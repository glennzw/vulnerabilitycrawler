commit eefdca043e8391dcd719711716492063030b55ac
Author: Roland McGrath <roland@redhat.com>
Date:   Tue Sep 14 12:22:58 2010 -0700

    x86-64, compat: Retruncate rax after ia32 syscall entry tracing
    
    In commit d4d6715, we reopened an old hole for a 64-bit ptracer touching a
    32-bit tracee in system call entry.  A %rax value set via ptrace at the
    entry tracing stop gets used whole as a 32-bit syscall number, while we
    only check the low 32 bits for validity.
    
    Fix it by truncating %rax back to 32 bits after syscall_trace_enter,
    in addition to testing the full 64 bits as has already been added.
    
    Reported-by: Ben Hawkes <hawkes@sota.gen.nz>
    Signed-off-by: Roland McGrath <roland@redhat.com>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/arch/x86/ia32/ia32entry.S b/arch/x86/ia32/ia32entry.S
index 84e3a4e..518bb99 100644
--- a/arch/x86/ia32/ia32entry.S
+++ b/arch/x86/ia32/ia32entry.S
@@ -1,77 +1,83 @@
 /*
  * Compatibility mode system call entry point for x86-64. 
  * 		
  * Copyright 2000-2002 Andi Kleen, SuSE Labs.
  */		 
 
 #include <asm/dwarf2.h>
 #include <asm/calling.h>
 #include <asm/asm-offsets.h>
 #include <asm/current.h>
 #include <asm/errno.h>
 #include <asm/ia32_unistd.h>	
 #include <asm/thread_info.h>	
 #include <asm/segment.h>
 #include <asm/irqflags.h>
 #include <linux/linkage.h>
 
 /* Avoid __ASSEMBLER__'ifying <linux/audit.h> just for this.  */
 #include <linux/elf-em.h>
 #define AUDIT_ARCH_I386		(EM_386|__AUDIT_ARCH_LE)
 #define __AUDIT_ARCH_LE	   0x40000000
 
 #ifndef CONFIG_AUDITSYSCALL
 #define sysexit_audit ia32_ret_from_sys_call
 #define sysretl_audit ia32_ret_from_sys_call
 #endif
 
 #define IA32_NR_syscalls ((ia32_syscall_end - ia32_sys_call_table)/8)
 
 	.macro IA32_ARG_FIXUP noebp=0
 	movl	%edi,%r8d
 	.if \noebp
 	.else
 	movl	%ebp,%r9d
 	.endif
 	xchg	%ecx,%esi
 	movl	%ebx,%edi
 	movl	%edx,%edx	/* zero extension */
 	.endm 
 
 	/* clobbers %eax */	
 	.macro  CLEAR_RREGS offset=0, _r9=rax
 	xorl 	%eax,%eax
 	movq	%rax,\offset+R11(%rsp)
 	movq	%rax,\offset+R10(%rsp)
 	movq	%\_r9,\offset+R9(%rsp)
 	movq	%rax,\offset+R8(%rsp)
 	.endm
 
 	/*
 	 * Reload arg registers from stack in case ptrace changed them.
 	 * We don't reload %eax because syscall_trace_enter() returned
-	 * the value it wants us to use in the table lookup.
+	 * the %rax value we should see.  Instead, we just truncate that
+	 * value to 32 bits again as we did on entry from user mode.
+	 * If it's a new value set by user_regset during entry tracing,
+	 * this matches the normal truncation of the user-mode value.
+	 * If it's -1 to make us punt the syscall, then (u32)-1 is still
+	 * an appropriately invalid value.
 	 */
 	.macro LOAD_ARGS32 offset, _r9=0
 	.if \_r9
 	movl \offset+16(%rsp),%r9d
 	.endif
 	movl \offset+40(%rsp),%ecx
 	movl \offset+48(%rsp),%edx
 	movl \offset+56(%rsp),%esi
 	movl \offset+64(%rsp),%edi
+	movl %eax,%eax			/* zero extension */
 	.endm
 	
 	.macro CFI_STARTPROC32 simple
 	CFI_STARTPROC	\simple
 	CFI_UNDEFINED	r8
 	CFI_UNDEFINED	r9
 	CFI_UNDEFINED	r10
 	CFI_UNDEFINED	r11
 	CFI_UNDEFINED	r12
 	CFI_UNDEFINED	r13
 	CFI_UNDEFINED	r14
 	CFI_UNDEFINED	r15
 	.endm
 
 #ifdef CONFIG_PARAVIRT
