commit e86a923d508c2aed371cdd958ce82489cf2ab615
Author: Scott James Remnant <scott@ubuntu.com>
Date:   Wed Apr 8 16:16:14 2009 -0700

    libudev: monitor - ignore messages from unusual sources
    
    For added protection, ignore any unicast message received on the
    netlink socket or any multicast message on the kernel group not
    received from the kernel.
    
    Signed-off-by: Scott James Remnant <scott@ubuntu.com>

diff --git a/udev/lib/libudev-monitor.c b/udev/lib/libudev-monitor.c
index 21bd19b..79627ed 100644
--- a/udev/lib/libudev-monitor.c
+++ b/udev/lib/libudev-monitor.c
@@ -256,164 +256,181 @@ int udev_monitor_get_fd(struct udev_monitor *udev_monitor)
 struct udev_device *udev_monitor_receive_device(struct udev_monitor *udev_monitor)
 {
 	struct udev_device *udev_device;
 	struct msghdr smsg;
 	struct iovec iov;
 	char cred_msg[CMSG_SPACE(sizeof(struct ucred))];
 	struct cmsghdr *cmsg;
+	struct sockaddr_nl snl;
 	struct ucred *cred;
 	char buf[4096];
 	size_t bufpos;
 	int devpath_set = 0;
 	int subsystem_set = 0;
 	int action_set = 0;
 	int maj = 0;
 	int min = 0;
 
 	if (udev_monitor == NULL)
 		return NULL;
 	memset(buf, 0x00, sizeof(buf));
 	iov.iov_base = &buf;
 	iov.iov_len = sizeof(buf);
 	memset (&smsg, 0x00, sizeof(struct msghdr));
 	smsg.msg_iov = &iov;
 	smsg.msg_iovlen = 1;
 	smsg.msg_control = cred_msg;
 	smsg.msg_controllen = sizeof(cred_msg);
 
+	if (udev_monitor->snl.nl_family != 0) {
+		smsg.msg_name = &snl;
+		smsg.msg_namelen = sizeof snl;
+	}
+
 	if (recvmsg(udev_monitor->sock, &smsg, 0) < 0) {
 		if (errno != EINTR)
-			info(udev_monitor->udev, "unable to receive message");
+			info(udev_monitor->udev, "unable to receive message\n");
 		return NULL;
 	}
 
+	if (udev_monitor->snl.nl_family != 0) {
+		if (snl.nl_groups == 0) {
+			info(udev_monitor->udev, "unicast netlink message ignored\n");
+			return NULL;
+		}
+		if ((snl.nl_groups == UDEV_MONITOR_KERNEL) && (snl.nl_pid > 0)) {
+			info(udev_monitor->udev, "multicast kernel netlink message from pid %d ignored\n", snl.nl_pid);
+			return NULL;
+		}
+	}
+
 	cmsg = CMSG_FIRSTHDR(&smsg);
 	if (cmsg == NULL || cmsg->cmsg_type != SCM_CREDENTIALS) {
-		info(udev_monitor->udev, "no sender credentials received, message ignored");
+		info(udev_monitor->udev, "no sender credentials received, message ignored\n");
 		return NULL;
 	}
 
 	cred = (struct ucred *)CMSG_DATA(cmsg);
 	if (cred->uid != 0) {
-		info(udev_monitor->udev, "sender uid=%d, message ignored", cred->uid);
+		info(udev_monitor->udev, "sender uid=%d, message ignored\n", cred->uid);
 		return NULL;
 	}
 
 	/* skip header */
 	bufpos = strlen(buf) + 1;
 	if (bufpos < sizeof("a@/d") || bufpos >= sizeof(buf)) {
-		info(udev_monitor->udev, "invalid message length");
+		info(udev_monitor->udev, "invalid message length\n");
 		return NULL;
 	}
 
 	/* check message header */
 	if (strstr(buf, "@/") == NULL) {
-		info(udev_monitor->udev, "unrecognized message header");
+		info(udev_monitor->udev, "unrecognized message header\n");
 		return NULL;
 	}
 
 	udev_device = device_new(udev_monitor->udev);
 	if (udev_device == NULL) {
 		return NULL;
 	}
 
 	while (bufpos < sizeof(buf)) {
 		char *key;
 		size_t keylen;
 
 		key = &buf[bufpos];
 		keylen = strlen(key);
 		if (keylen == 0)
 			break;
 		bufpos += keylen + 1;
 
 		if (strncmp(key, "DEVPATH=", 8) == 0) {
 			char path[UTIL_PATH_SIZE];
 
 			util_strlcpy(path, udev_get_sys_path(udev_monitor->udev), sizeof(path));
 			util_strlcat(path, &key[8], sizeof(path));
 			udev_device_set_syspath(udev_device, path);
 			devpath_set = 1;
 		} else if (strncmp(key, "SUBSYSTEM=", 10) == 0) {
 			udev_device_set_subsystem(udev_device, &key[10]);
 			subsystem_set = 1;
 		} else if (strncmp(key, "DEVTYPE=", 8) == 0) {
 			udev_device_set_devtype(udev_device, &key[8]);
 		} else if (strncmp(key, "DEVNAME=", 8) == 0) {
 			udev_device_set_devnode(udev_device, &key[8]);
 		} else if (strncmp(key, "DEVLINKS=", 9) == 0) {
 			char devlinks[UTIL_PATH_SIZE];
 			char *slink;
 			char *next;
 
 			util_strlcpy(devlinks, &key[9], sizeof(devlinks));
 			slink = devlinks;
 			next = strchr(slink, ' ');
 			while (next != NULL) {
 				next[0] = '\0';
 				udev_device_add_devlink(udev_device, slink);
 				slink = &next[1];
 				next = strchr(slink, ' ');
 			}
 			if (slink[0] != '\0')
 				udev_device_add_devlink(udev_device, slink);
 		} else if (strncmp(key, "DRIVER=", 7) == 0) {
 			udev_device_set_driver(udev_device, &key[7]);
 		} else if (strncmp(key, "ACTION=", 7) == 0) {
 			udev_device_set_action(udev_device, &key[7]);
 			action_set = 1;
 		} else if (strncmp(key, "MAJOR=", 6) == 0) {
 			maj = strtoull(&key[6], NULL, 10);
 		} else if (strncmp(key, "MINOR=", 6) == 0) {
 			min = strtoull(&key[6], NULL, 10);
 		} else if (strncmp(key, "DEVPATH_OLD=", 12) == 0) {
 			udev_device_set_devpath_old(udev_device, &key[12]);
 		} else if (strncmp(key, "PHYSDEVPATH=", 12) == 0) {
 			udev_device_set_physdevpath(udev_device, &key[12]);
 		} else if (strncmp(key, "SEQNUM=", 7) == 0) {
 			udev_device_set_seqnum(udev_device, strtoull(&key[7], NULL, 10));
 		} else if (strncmp(key, "TIMEOUT=", 8) == 0) {
 			udev_device_set_timeout(udev_device, strtoull(&key[8], NULL, 10));
 		} else if (strncmp(key, "PHYSDEV", 7) == 0) {
 			/* skip deprecated values */
 			continue;
 		} else {
 			udev_device_add_property_from_string(udev_device, key);
 		}
 	}
 	if (!devpath_set || !subsystem_set || !action_set) {
 		info(udev_monitor->udev, "missing values, skip\n");
 		udev_device_unref(udev_device);
 		return NULL;
 	}
 	if (maj > 0)
 		udev_device_set_devnum(udev_device, makedev(maj, min));
 	udev_device_set_info_loaded(udev_device);
 	return udev_device;
 }
 
 int udev_monitor_send_device(struct udev_monitor *udev_monitor, struct udev_device *udev_device)
 {
 	const char *buf;
 	ssize_t len;
 	ssize_t count;
 
 	len = udev_device_get_properties_monitor_buf(udev_device, &buf);
 	if (len < 32)
 		return -1;
 	if (udev_monitor->sun.sun_family != 0)
 		count = sendto(udev_monitor->sock,
 			       buf, len, 0,
 			       (struct sockaddr *)&udev_monitor->sun,
 			       udev_monitor->addrlen);
 	else if (udev_monitor->snl.nl_family != 0)
 		/* no destination besides the muticast group, we will always get ECONNREFUSED */
 		count = sendto(udev_monitor->sock,
 			       buf, len, 0,
 			       (struct sockaddr *)&udev_monitor->snl_peer,
 			       sizeof(struct sockaddr_nl));
 	else
 		return -1;
 
-	info(udev_monitor->udev, "passed %zi bytes to monitor %p, \n", count, udev_monitor);
+	info(udev_monitor->udev, "passed %zi bytes to monitor %p\n", count, udev_monitor);
 	return count;
 }
