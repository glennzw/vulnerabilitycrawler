commit 75e1c70fc31490ef8a373ea2a4bea2524099b478
Author: Jeff Moyer <jmoyer@redhat.com>
Date:   Fri Sep 10 14:16:00 2010 -0700

    aio: check for multiplication overflow in do_io_submit
    
    Tavis Ormandy pointed out that do_io_submit does not do proper bounds
    checking on the passed-in iocb array:
    
           if (unlikely(nr < 0))
                   return -EINVAL;
    
           if (unlikely(!access_ok(VERIFY_READ, iocbpp, (nr*sizeof(iocbpp)))))
                   return -EFAULT;                      ^^^^^^^^^^^^^^^^^^
    
    The attached patch checks for overflow, and if it is detected, the
    number of iocbs submitted is scaled down to a number that will fit in
    the long.  This is an ok thing to do, as sys_io_submit is documented as
    returning the number of iocbs submitted, so callers should handle a
    return value of less than the 'nr' argument passed in.
    
    Reported-by: Tavis Ormandy <taviso@cmpxchg8b.com>
    Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/aio.c b/fs/aio.c
index 3006b5b..1320b2a 100644
--- a/fs/aio.c
+++ b/fs/aio.c
@@ -1651,60 +1651,63 @@ out_put_req:
 long do_io_submit(aio_context_t ctx_id, long nr,
 		  struct iocb __user *__user *iocbpp, bool compat)
 {
 	struct kioctx *ctx;
 	long ret = 0;
 	int i;
 	struct hlist_head batch_hash[AIO_BATCH_HASH_SIZE] = { { 0, }, };
 
 	if (unlikely(nr < 0))
 		return -EINVAL;
 
+	if (unlikely(nr > LONG_MAX/sizeof(*iocbpp)))
+		nr = LONG_MAX/sizeof(*iocbpp);
+
 	if (unlikely(!access_ok(VERIFY_READ, iocbpp, (nr*sizeof(*iocbpp)))))
 		return -EFAULT;
 
 	ctx = lookup_ioctx(ctx_id);
 	if (unlikely(!ctx)) {
 		pr_debug("EINVAL: io_submit: invalid context id\n");
 		return -EINVAL;
 	}
 
 	/*
 	 * AKPM: should this return a partial result if some of the IOs were
 	 * successfully submitted?
 	 */
 	for (i=0; i<nr; i++) {
 		struct iocb __user *user_iocb;
 		struct iocb tmp;
 
 		if (unlikely(__get_user(user_iocb, iocbpp + i))) {
 			ret = -EFAULT;
 			break;
 		}
 
 		if (unlikely(copy_from_user(&tmp, user_iocb, sizeof(tmp)))) {
 			ret = -EFAULT;
 			break;
 		}
 
 		ret = io_submit_one(ctx, user_iocb, &tmp, batch_hash, compat);
 		if (ret)
 			break;
 	}
 	aio_batch_free(batch_hash);
 
 	put_ioctx(ctx);
 	return i ? i : ret;
 }
 
 /* sys_io_submit:
  *	Queue the nr iocbs pointed to by iocbpp for processing.  Returns
  *	the number of iocbs queued.  May return -EINVAL if the aio_context
  *	specified by ctx_id is invalid, if nr is < 0, if the iocb at
  *	*iocbpp[0] is not properly initialized, if the operation specified
  *	is invalid for the file descriptor in the iocb.  May fail with
  *	-EFAULT if any of the data structures point to invalid data.  May
  *	fail with -EBADF if the file descriptor specified in the first
  *	iocb is invalid.  May fail with -EAGAIN if insufficient resources
  *	are available to queue any iocbs.  Will return 0 if nr is 0.  Will
  *	fail with -ENOSYS if not implemented.
  */
