commit 51246bfd189064079c54421507236fd2723b18f3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 2 11:40:27 2010 +0100

    futex: Handle user space corruption gracefully
    
    If the owner of a PI futex dies we fix up the pi_state and set
    pi_state->owner to NULL. When a malicious or just sloppy programmed
    user space application sets the futex value to 0 e.g. by calling
    pthread_mutex_init(), then the futex can be acquired again. A new
    waiter manages to enqueue itself on the pi_state w/o damage, but on
    unlock the kernel dereferences pi_state->owner and oopses.
    
    Prevent this by checking pi_state->owner in the unlock path. If
    pi_state->owner is not current we know that user space manipulated the
    futex value. Ignore the mess and return -EINVAL.
    
    This catches the above case and also the case where a task hijacks the
    futex by setting the tid value and then tries to unlock it.
    
    Reported-by: Jermome Marchand <jmarchan@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Darren Hart <dvhltc@us.ibm.com>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: <stable@kernel.org>

diff --git a/kernel/futex.c b/kernel/futex.c
index 1782803..06e8240 100644
--- a/kernel/futex.c
+++ b/kernel/futex.c
@@ -752,60 +752,67 @@ static void wake_futex(struct futex_q *q)
 static int wake_futex_pi(u32 __user *uaddr, u32 uval, struct futex_q *this)
 {
 	struct task_struct *new_owner;
 	struct futex_pi_state *pi_state = this->pi_state;
 	u32 curval, newval;
 
 	if (!pi_state)
 		return -EINVAL;
 
+	/*
+	 * If current does not own the pi_state then the futex is
+	 * inconsistent and user space fiddled with the futex value.
+	 */
+	if (pi_state->owner != current)
+		return -EINVAL;
+
 	raw_spin_lock(&pi_state->pi_mutex.wait_lock);
 	new_owner = rt_mutex_next_owner(&pi_state->pi_mutex);
 
 	/*
 	 * This happens when we have stolen the lock and the original
 	 * pending owner did not enqueue itself back on the rt_mutex.
 	 * Thats not a tragedy. We know that way, that a lock waiter
 	 * is on the fly. We make the futex_q waiter the pending owner.
 	 */
 	if (!new_owner)
 		new_owner = this->task;
 
 	/*
 	 * We pass it to the next owner. (The WAITERS bit is always
 	 * kept enabled while there is PI state around. We must also
 	 * preserve the owner died bit.)
 	 */
 	if (!(uval & FUTEX_OWNER_DIED)) {
 		int ret = 0;
 
 		newval = FUTEX_WAITERS | task_pid_vnr(new_owner);
 
 		curval = cmpxchg_futex_value_locked(uaddr, uval, newval);
 
 		if (curval == -EFAULT)
 			ret = -EFAULT;
 		else if (curval != uval)
 			ret = -EINVAL;
 		if (ret) {
 			raw_spin_unlock(&pi_state->pi_mutex.wait_lock);
 			return ret;
 		}
 	}
 
 	raw_spin_lock_irq(&pi_state->owner->pi_lock);
 	WARN_ON(list_empty(&pi_state->list));
 	list_del_init(&pi_state->list);
 	raw_spin_unlock_irq(&pi_state->owner->pi_lock);
 
 	raw_spin_lock_irq(&new_owner->pi_lock);
 	WARN_ON(!list_empty(&pi_state->list));
 	list_add(&pi_state->list, &new_owner->pi_state_list);
 	pi_state->owner = new_owner;
 	raw_spin_unlock_irq(&new_owner->pi_lock);
 
 	raw_spin_unlock(&pi_state->pi_mutex.wait_lock);
 	rt_mutex_unlock(&pi_state->pi_mutex);
 
 	return 0;
 }
 
