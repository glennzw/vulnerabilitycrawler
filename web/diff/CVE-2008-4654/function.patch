commit 26d92b87bba99b5ea2e17b7eaa39c462d65e9133
Author: RÃ©mi Denis-Courmont <rdenis@simphalempin.com>
Date:   Sat Oct 18 22:19:49 2008 +0300

    Fix (yet another) TiVo demux overflow.
    
    Reported by Tobias Klein <tk@trapkit.de>

diff --git a/modules/demux/ty.c b/modules/demux/ty.c
index 754e235..65a408f 100644
--- a/modules/demux/ty.c
+++ b/modules/demux/ty.c
@@ -1615,61 +1615,63 @@ static int ty_stream_seek_time(demux_t *p_demux, uint64_t l_seek_time)
 static void parse_master(demux_t *p_demux)
 {
     demux_sys_t *p_sys = p_demux->p_sys;
     uint8_t mst_buf[32];
     int i, i_map_size;
     int64_t i_save_pos = stream_Tell(p_demux->s);
     int64_t i_pts_secs;
 
     /* Note that the entries in the SEQ table in the stream may have
        different sizes depending on the bits per entry.  We store them
        all in the same size structure, so we have to parse them out one
        by one.  If we had a dynamic structure, we could simply read the
        entire table directly from the stream into memory in place. */
 
     /* clear the SEQ table */
     free(p_sys->seq_table);
     
     /* parse header info */
     stream_Read(p_demux->s, mst_buf, 32);
     i_map_size = U32_AT(&mst_buf[20]);  /* size of bitmask, in bytes */
     p_sys->i_bits_per_seq_entry = i_map_size * 8;
     i = U32_AT(&mst_buf[28]);   /* size of SEQ table, in bytes */
     p_sys->i_seq_table_size = i / (8 + i_map_size);
 
     /* parse all the entries */
     p_sys->seq_table = malloc(p_sys->i_seq_table_size * sizeof(ty_seq_table_t));
     for (i=0; i<p_sys->i_seq_table_size; i++) {
-        stream_Read(p_demux->s, mst_buf, 8 + i_map_size);
+        stream_Read(p_demux->s, mst_buf, 8);
         p_sys->seq_table[i].l_timestamp = U64_AT(&mst_buf[0]);
         if (i_map_size > 8) {
             msg_Err(p_demux, "Unsupported SEQ bitmap size in master chunk");
+            stream_Read(p_demux->s, NULL, i_map_size);
             memset(p_sys->seq_table[i].chunk_bitmask, i_map_size, 0);
         } else {
+            stream_Read(p_demux->s, mst_buf + 8, i_map_size);
             memcpy(p_sys->seq_table[i].chunk_bitmask, &mst_buf[8], i_map_size);
         }
     }
 
     /* set up a few of our variables */
     p_sys->l_first_ty_pts = p_sys->seq_table[0].l_timestamp;
     p_sys->l_final_ty_pts =
         p_sys->seq_table[p_sys->i_seq_table_size - 1].l_timestamp;
     p_sys->b_have_master = true;
 
     i_pts_secs = p_sys->l_first_ty_pts / 1000000000;
     msg_Dbg( p_demux, "first TY pts in master is %02d:%02d:%02d",
              (int)(i_pts_secs / 3600), (int)((i_pts_secs / 60) % 60), (int)(i_pts_secs % 60) );
     i_pts_secs = p_sys->l_final_ty_pts / 1000000000;
     msg_Dbg( p_demux, "final TY pts in master is %02d:%02d:%02d",
              (int)(i_pts_secs / 3600), (int)((i_pts_secs / 60) % 60), (int)(i_pts_secs % 60) );
 
     /* seek past this chunk */
     stream_Seek(p_demux->s, i_save_pos + CHUNK_SIZE);
 }
 
 
 /* ======================================================================== */
 /* "Peek" at some chunks.  Skip over the Part header if we find it.
  * We parse the peeked data and determine audio type,
  * SA vs. DTivo, & Tivo Series.
  * Set global vars i_Pes_Length, i_Pts_Offset,
  * p_sys->tivo_series, p_sys->tivo_type, p_sys->audio_type */
