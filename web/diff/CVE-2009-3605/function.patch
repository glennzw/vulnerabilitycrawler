commit 9cf2325fb22f812b31858e519411f57747d39bd8
Author: Albert Astals Cid <aacid@kde.org>
Date:   Sat Apr 11 00:31:57 2009 +0200

    More gmalloc â†’ gmallocn

diff --git a/glib/poppler-page.cc b/glib/poppler-page.cc
index f1dd133..225c97b 100644
--- a/glib/poppler-page.cc
+++ b/glib/poppler-page.cc
@@ -293,43 +293,43 @@ static void
 poppler_page_prepare_output_dev (PopplerPage *page,
 				 double scale,
 				 int rotation,
 				 gboolean transparent,
 				 OutputDevData *output_dev_data)
 {
   CairoOutputDev *output_dev;
   cairo_surface_t *surface;
   double width, height;
   int cairo_width, cairo_height, cairo_rowstride, rotate;
   unsigned char *cairo_data;
 
   rotate = rotation + page->page->getRotate ();
   if (rotate == 90 || rotate == 270) {
     height = page->page->getCropWidth ();
     width = page->page->getCropHeight ();
   } else {
     width = page->page->getCropWidth ();
     height = page->page->getCropHeight ();
   }
 
   cairo_width = (int) ceil(width * scale);
   cairo_height = (int) ceil(height * scale);
 
   output_dev = page->document->output_dev;
   cairo_rowstride = cairo_width * 4;
-  cairo_data = (guchar *) gmalloc (cairo_height * cairo_rowstride);
+  cairo_data = (guchar *) gmallocn (cairo_height, cairo_rowstride);
   if (transparent)
       memset (cairo_data, 0x00, cairo_height * cairo_rowstride);
   else
       memset (cairo_data, 0xff, cairo_height * cairo_rowstride);
 
   surface = cairo_image_surface_create_for_data(cairo_data,
 						CAIRO_FORMAT_ARGB32,
 	  					cairo_width, cairo_height, 
 						cairo_rowstride);
 
   output_dev_data->cairo_data = cairo_data;
   output_dev_data->surface = surface;
   output_dev_data->cairo = cairo_create (surface);
   output_dev->setCairo (output_dev_data->cairo);
 }
 
diff --git a/splash/Splash.cc b/splash/Splash.cc
index c93ef40..a1deb85 100644
--- a/splash/Splash.cc
+++ b/splash/Splash.cc
@@ -1,51 +1,51 @@
 //========================================================================
 //
 // Splash.cc
 //
 //========================================================================
 
 //========================================================================
 //
 // Modified under the Poppler project - http://poppler.freedesktop.org
 //
 // All changes made under the Poppler project to this file are licensed
 // under GPL version 2 or later
 //
-// Copyright (C) 2005-2008 Albert Astals Cid <aacid@kde.org>
+// Copyright (C) 2005-2009 Albert Astals Cid <aacid@kde.org>
 // Copyright (C) 2005 Marco Pesenti Gritti <mpg@redhat.com>
 //
 // To see a description of the changes please see the Changelog file that
 // came with your tarball or type make ChangeLog if you are building from git
 //
 //========================================================================
 
 #include <config.h>
 
 #ifdef USE_GCC_PRAGMAS
 #pragma implementation
 #endif
 
 #include <stdlib.h>
 #include <string.h>
 #include "goo/gmem.h"
 #include "SplashErrorCodes.h"
 #include "SplashMath.h"
 #include "SplashBitmap.h"
 #include "SplashState.h"
 #include "SplashPath.h"
 #include "SplashXPath.h"
 #include "SplashXPathScanner.h"
 #include "SplashPattern.h"
 #include "SplashScreen.h"
 #include "SplashFont.h"
 #include "SplashGlyphBitmap.h"
 #include "Splash.h"
 
 //------------------------------------------------------------------------
 
 // distance of Bezier control point from center for circle approximation
 // = (4 * (sqrt(2) - 1) / 3) * r
 #define bezierCircle ((SplashCoord)0.55228475)
 #define bezierCircle2 ((SplashCoord)(0.5 * 0.55228475))
 
 // Divide a 16-bit value (in [0, 255*255]) by 255, returning an 8-bit result.
@@ -1859,1135 +1859,1135 @@ void Splash::fillGlyph2(int x0, int y0, SplashGlyphBitmap *glyph, GBool noClip)
 SplashError Splash::fillImageMask(SplashImageMaskSource src, void *srcData,
 				  int w, int h, SplashCoord *mat,
 				  GBool glyphMode) {
   SplashPipe pipe;
   GBool rot;
   SplashCoord xScale, yScale, xShear, yShear, yShear1;
   int tx, tx2, ty, ty2, scaledWidth, scaledHeight, xSign, ySign;
   int ulx, uly, llx, lly, urx, ury, lrx, lry;
   int ulx1, uly1, llx1, lly1, urx1, ury1, lrx1, lry1;
   int xMin, xMax, yMin, yMax;
   SplashClipResult clipRes, clipRes2;
   int yp, yq, yt, yStep, lastYStep;
   int xp, xq, xt, xStep, xSrc;
   int k1, spanXMin, spanXMax, spanY;
   SplashColorPtr pixBuf, p;
   int pixAcc;
   int x, y, x1, x2, y2;
   SplashCoord y1;
   int n, m, i, j;
 
   if (debugMode) {
     printf("fillImageMask: w=%d h=%d mat=[%.2f %.2f %.2f %.2f %.2f %.2f]\n",
 	   w, h, (double)mat[0], (double)mat[1], (double)mat[2],
 	   (double)mat[3], (double)mat[4], (double)mat[5]);
   }
 
   if (w == 0 && h == 0) return splashErrZeroImage;
 
   // check for singular matrix
   if (splashAbs(mat[0] * mat[3] - mat[1] * mat[2]) < 0.000001) {
     return splashErrSingularMatrix;
   }
 
   // compute scale, shear, rotation, translation parameters
   rot = splashAbs(mat[1]) > splashAbs(mat[0]);
   if (rot) {
     xScale = -mat[1];
     yScale = mat[2] - (mat[0] * mat[3]) / mat[1];
     xShear = -mat[3] / yScale;
     yShear = -mat[0] / mat[1];
   } else {
     xScale = mat[0];
     yScale = mat[3] - (mat[1] * mat[2]) / mat[0];
     xShear = mat[2] / yScale;
     yShear = mat[1] / mat[0];
   }
   // Note 1: The PDF spec says that all pixels whose *centers* lie
   // within the region get painted -- but that doesn't seem to match
   // up with what Acrobat actually does: it ends up leaving gaps
   // between image stripes.  So we use the same rule here as for
   // fills: any pixel that overlaps the region gets painted.
   // Note 2: The "glyphMode" flag is a kludge: it switches back to
   // "correct" behavior (matching the spec), for use in rendering Type
   // 3 fonts.
   // Note 3: The +/-0.01 in these computations is to avoid floating
   // point precision problems which can lead to gaps between image
   // stripes (it can cause image stripes to overlap, but that's a much
   // less visible problem).
   if (glyphMode) {
     if (xScale >= 0) {
       tx = splashRound(mat[4]);
       tx2 = splashRound(mat[4] + xScale) - 1;
     } else {
       tx = splashRound(mat[4]) - 1;
       tx2 = splashRound(mat[4] + xScale);
     }
   } else {
     if (xScale >= 0) {
       tx = splashFloor(mat[4] - 0.01);
       tx2 = splashFloor(mat[4] + xScale + 0.01);
     } else {
       tx = splashFloor(mat[4] + 0.01);
       tx2 = splashFloor(mat[4] + xScale - 0.01);
     }
   }
   scaledWidth = abs(tx2 - tx) + 1;
   if (glyphMode) {
     if (yScale >= 0) {
       ty = splashRound(mat[5]);
       ty2 = splashRound(mat[5] + yScale) - 1;
     } else {
       ty = splashRound(mat[5]) - 1;
       ty2 = splashRound(mat[5] + yScale);
     }
   } else {
     if (yScale >= 0) {
       ty = splashFloor(mat[5] - 0.01);
       ty2 = splashFloor(mat[5] + yScale + 0.01);
     } else {
       ty = splashFloor(mat[5] + 0.01);
       ty2 = splashFloor(mat[5] + yScale - 0.01);
     }
   }
   scaledHeight = abs(ty2 - ty) + 1;
   xSign = (xScale < 0) ? -1 : 1;
   ySign = (yScale < 0) ? -1 : 1;
   yShear1 = (SplashCoord)xSign * yShear;
 
   // clipping
   ulx1 = 0;
   uly1 = 0;
   urx1 = xSign * (scaledWidth - 1);
   ury1 = (int)(yShear * urx1);
   llx1 = splashRound(xShear * ySign * (scaledHeight - 1));
   lly1 = ySign * (scaledHeight - 1) + (int)(yShear * llx1);
   lrx1 = xSign * (scaledWidth - 1) +
            splashRound(xShear * ySign * (scaledHeight - 1));
   lry1 = ySign * (scaledHeight - 1) + (int)(yShear * lrx1);
   if (rot) {
     ulx = tx + uly1;    uly = ty - ulx1;
     urx = tx + ury1;    ury = ty - urx1;
     llx = tx + lly1;    lly = ty - llx1;
     lrx = tx + lry1;    lry = ty - lrx1;
   } else {
     ulx = tx + ulx1;    uly = ty + uly1;
     urx = tx + urx1;    ury = ty + ury1;
     llx = tx + llx1;    lly = ty + lly1;
     lrx = tx + lrx1;    lry = ty + lry1;
   }
   xMin = (ulx < urx) ? (ulx < llx) ? (ulx < lrx) ? ulx : lrx
                                    : (llx < lrx) ? llx : lrx
 		     : (urx < llx) ? (urx < lrx) ? urx : lrx
                                    : (llx < lrx) ? llx : lrx;
   xMax = (ulx > urx) ? (ulx > llx) ? (ulx > lrx) ? ulx : lrx
                                    : (llx > lrx) ? llx : lrx
 		     : (urx > llx) ? (urx > lrx) ? urx : lrx
                                    : (llx > lrx) ? llx : lrx;
   yMin = (uly < ury) ? (uly < lly) ? (uly < lry) ? uly : lry
                                    : (lly < lry) ? lly : lry
 		     : (ury < lly) ? (ury < lry) ? ury : lry
                                    : (lly < lry) ? lly : lry;
   yMax = (uly > ury) ? (uly > lly) ? (uly > lry) ? uly : lry
                                    : (lly > lry) ? lly : lry
 		     : (ury > lly) ? (ury > lry) ? ury : lry
                                    : (lly > lry) ? lly : lry;
   clipRes = state->clip->testRect(xMin, yMin, xMax, yMax);
   opClipRes = clipRes;
 
   // compute Bresenham parameters for x and y scaling
   yp = h / scaledHeight;
   yq = h % scaledHeight;
   xp = w / scaledWidth;
   xq = w % scaledWidth;
 
   // allocate pixel buffer
-  pixBuf = (SplashColorPtr)gmalloc((yp + 1) * w);
+  pixBuf = (SplashColorPtr)gmallocn((yp + 1), w);
 
   // initialize the pixel pipe
   pipeInit(&pipe, 0, 0, state->fillPattern, NULL, state->fillAlpha,
 	   gTrue, gFalse);
   if (vectorAntialias) {
     drawAAPixelInit();
   }
 
   // init y scale Bresenham
   yt = 0;
   lastYStep = 1;
 
   for (y = 0; y < scaledHeight; ++y) {
 
     // y scale Bresenham
     yStep = yp;
     yt += yq;
     if (yt >= scaledHeight) {
       yt -= scaledHeight;
       ++yStep;
     }
 
     // read row(s) from image
     n = (yp > 0) ? yStep : lastYStep;
     if (n > 0) {
       p = pixBuf;
       for (i = 0; i < n; ++i) {
 	(*src)(srcData, p);
 	p += w;
       }
     }
     lastYStep = yStep;
 
     // loop-invariant constants
     k1 = splashRound(xShear * ySign * y);
 
     // clipping test
     if (clipRes != splashClipAllInside &&
 	!rot &&
 	(int)(yShear * k1) ==
 	  (int)(yShear * (xSign * (scaledWidth - 1) + k1))) {
       if (xSign > 0) {
 	spanXMin = tx + k1;
 	spanXMax = spanXMin + (scaledWidth - 1);
       } else {
 	spanXMax = tx + k1;
 	spanXMin = spanXMax - (scaledWidth - 1);
       }
       spanY = ty + ySign * y + (int)(yShear * k1);
       clipRes2 = state->clip->testSpan(spanXMin, spanXMax, spanY);
       if (clipRes2 == splashClipAllOutside) {
 	continue;
       }
     } else {
       clipRes2 = clipRes;
     }
 
     // init x scale Bresenham
     xt = 0;
     xSrc = 0;
 
     // x shear
     x1 = k1;
 
     // y shear
     y1 = (SplashCoord)ySign * y + yShear * x1;
     // this is a kludge: if yShear1 is negative, then (int)y1 would
     // change immediately after the first pixel, which is not what we
     // want
     if (yShear1 < 0) {
       y1 += 0.999;
     }
 
     // loop-invariant constants
     n = yStep > 0 ? yStep : 1;
 
     for (x = 0; x < scaledWidth; ++x) {
 
       // x scale Bresenham
       xStep = xp;
       xt += xq;
       if (xt >= scaledWidth) {
 	xt -= scaledWidth;
 	++xStep;
       }
 
       // rotation
       if (rot) {
 	x2 = (int)y1;
 	y2 = -x1;
       } else {
 	x2 = x1;
 	y2 = (int)y1;
       }
 
       // compute the alpha value for (x,y) after the x and y scaling
       // operations
       m = xStep > 0 ? xStep : 1;
       p = pixBuf + xSrc;
       pixAcc = 0;
       for (i = 0; i < n; ++i) {
 	for (j = 0; j < m; ++j) {
 	  pixAcc += *p++;
 	}
 	p += w - m;
       }
 
       // blend fill color with background
       if (pixAcc != 0) {
 	pipe.shape = (pixAcc == n * m)
 	                 ? (SplashCoord)1
 	                 : (SplashCoord)pixAcc / (SplashCoord)(n * m);
 	if (vectorAntialias && clipRes2 != splashClipAllInside) {
 	  drawAAPixel(&pipe, tx + x2, ty + y2);
 	} else {
 	  drawPixel(&pipe, tx + x2, ty + y2, clipRes2 == splashClipAllInside);
 	}
       }
 
       // x scale Bresenham
       xSrc += xStep;
 
       // x shear
       x1 += xSign;
 
       // y shear
       y1 += yShear1;
     }
   }
 
   // free memory
   gfree(pixBuf);
 
   return splashOk;
 }
 
 SplashError Splash::drawImage(SplashImageSource src, void *srcData,
 			      SplashColorMode srcMode, GBool srcAlpha,
 			      int w, int h, SplashCoord *mat) {
   SplashPipe pipe;
   GBool ok, rot;
   SplashCoord xScale, yScale, xShear, yShear, yShear1;
   int tx, tx2, ty, ty2, scaledWidth, scaledHeight, xSign, ySign;
   int ulx, uly, llx, lly, urx, ury, lrx, lry;
   int ulx1, uly1, llx1, lly1, urx1, ury1, lrx1, lry1;
   int xMin, xMax, yMin, yMax;
   SplashClipResult clipRes, clipRes2;
   int yp, yq, yt, yStep, lastYStep;
   int xp, xq, xt, xStep, xSrc;
   int k1, spanXMin, spanXMax, spanY;
   SplashColorPtr colorBuf, p;
   SplashColor pix;
   Guchar *alphaBuf, *q;
 #if SPLASH_CMYK
   int pixAcc0, pixAcc1, pixAcc2, pixAcc3;
 #else
   int pixAcc0, pixAcc1, pixAcc2;
 #endif
   int alphaAcc;
   SplashCoord pixMul, alphaMul, alpha;
   int x, y, x1, x2, y2;
   SplashCoord y1;
   int nComps, n, m, i, j;
 
   if (debugMode) {
     printf("drawImage: srcMode=%d srcAlpha=%d w=%d h=%d mat=[%.2f %.2f %.2f %.2f %.2f %.2f]\n",
 	   srcMode, srcAlpha, w, h, (double)mat[0], (double)mat[1], (double)mat[2],
 	   (double)mat[3], (double)mat[4], (double)mat[5]);
   }
 
   // check color modes
   ok = gFalse; // make gcc happy
   nComps = 0; // make gcc happy
   switch (bitmap->mode) {
   case splashModeMono1:
   case splashModeMono8:
     ok = srcMode == splashModeMono8;
     nComps = 1;
     break;
   case splashModeRGB8:
     ok = srcMode == splashModeRGB8;
     nComps = 3;
     break;
   case splashModeXBGR8:
     ok = srcMode == splashModeXBGR8;
     nComps = 4;
     break;
   case splashModeBGR8:
     ok = srcMode == splashModeBGR8;
     nComps = 3;
     break;
 #if SPLASH_CMYK
   case splashModeCMYK8:
     ok = srcMode == splashModeCMYK8;
     nComps = 4;
     break;
 #endif
   }
   if (!ok) {
     return splashErrModeMismatch;
   }
 
   // check for singular matrix
   if (splashAbs(mat[0] * mat[3] - mat[1] * mat[2]) < 0.000001) {
     return splashErrSingularMatrix;
   }
 
   // compute scale, shear, rotation, translation parameters
   rot = splashAbs(mat[1]) > splashAbs(mat[0]);
   if (rot) {
     xScale = -mat[1];
     yScale = mat[2] - (mat[0] * mat[3]) / mat[1];
     xShear = -mat[3] / yScale;
     yShear = -mat[0] / mat[1];
   } else {
     xScale = mat[0];
     yScale = mat[3] - (mat[1] * mat[2]) / mat[0];
     xShear = mat[2] / yScale;
     yShear = mat[1] / mat[0];
   }
   // Note 1: The PDF spec says that all pixels whose *centers* lie
   // within the region get painted -- but that doesn't seem to match
   // up with what Acrobat actually does: it ends up leaving gaps
   // between image stripes.  So we use the same rule here as for
   // fills: any pixel that overlaps the region gets painted.
   // Note 2: The +/-0.01 in these computations is to avoid floating
   // point precision problems which can lead to gaps between image
   // stripes (it can cause image stripes to overlap, but that's a much
   // less visible problem).
   if (xScale >= 0) {
     tx = splashFloor(mat[4] - 0.01);
     tx2 = splashFloor(mat[4] + xScale + 0.01);
   } else {
     tx = splashFloor(mat[4] + 0.01);
     tx2 = splashFloor(mat[4] + xScale - 0.01);
   }
   scaledWidth = abs(tx2 - tx) + 1;
   if (yScale >= 0) {
     ty = splashFloor(mat[5] - 0.01);
     ty2 = splashFloor(mat[5] + yScale + 0.01);
   } else {
     ty = splashFloor(mat[5] + 0.01);
     ty2 = splashFloor(mat[5] + yScale - 0.01);
   }
   scaledHeight = abs(ty2 - ty) + 1;
   xSign = (xScale < 0) ? -1 : 1;
   ySign = (yScale < 0) ? -1 : 1;
   yShear1 = (SplashCoord)xSign * yShear;
 
   // clipping
   ulx1 = 0;
   uly1 = 0;
   urx1 = xSign * (scaledWidth - 1);
   ury1 = (int)(yShear * urx1);
   llx1 = splashRound(xShear * ySign * (scaledHeight - 1));
   lly1 = ySign * (scaledHeight - 1) + (int)(yShear * llx1);
   lrx1 = xSign * (scaledWidth - 1) +
            splashRound(xShear * ySign * (scaledHeight - 1));
   lry1 = ySign * (scaledHeight - 1) + (int)(yShear * lrx1);
   if (rot) {
     ulx = tx + uly1;    uly = ty - ulx1;
     urx = tx + ury1;    ury = ty - urx1;
     llx = tx + lly1;    lly = ty - llx1;
     lrx = tx + lry1;    lry = ty - lrx1;
   } else {
     ulx = tx + ulx1;    uly = ty + uly1;
     urx = tx + urx1;    ury = ty + ury1;
     llx = tx + llx1;    lly = ty + lly1;
     lrx = tx + lrx1;    lry = ty + lry1;
   }
   xMin = (ulx < urx) ? (ulx < llx) ? (ulx < lrx) ? ulx : lrx
                                    : (llx < lrx) ? llx : lrx
 		     : (urx < llx) ? (urx < lrx) ? urx : lrx
                                    : (llx < lrx) ? llx : lrx;
   xMax = (ulx > urx) ? (ulx > llx) ? (ulx > lrx) ? ulx : lrx
                                    : (llx > lrx) ? llx : lrx
 		     : (urx > llx) ? (urx > lrx) ? urx : lrx
                                    : (llx > lrx) ? llx : lrx;
   yMin = (uly < ury) ? (uly < lly) ? (uly < lry) ? uly : lry
                                    : (lly < lry) ? lly : lry
 		     : (ury < lly) ? (ury < lry) ? ury : lry
                                    : (lly < lry) ? lly : lry;
   yMax = (uly > ury) ? (uly > lly) ? (uly > lry) ? uly : lry
                                    : (lly > lry) ? lly : lry
 		     : (ury > lly) ? (ury > lry) ? ury : lry
                                    : (lly > lry) ? lly : lry;
   clipRes = state->clip->testRect(xMin, yMin, xMax, yMax);
   opClipRes = clipRes;
   if (clipRes == splashClipAllOutside) {
     return splashOk;
   }
 
   // compute Bresenham parameters for x and y scaling
   yp = h / scaledHeight;
   yq = h % scaledHeight;
   xp = w / scaledWidth;
   xq = w % scaledWidth;
 
   // allocate pixel buffers
-  colorBuf = (SplashColorPtr)gmalloc((yp + 1) * w * nComps);
+  colorBuf = (SplashColorPtr)gmallocn3((yp + 1), w, nComps);
   if (srcAlpha) {
-    alphaBuf = (Guchar *)gmalloc((yp + 1) * w);
+    alphaBuf = (Guchar *)gmallocn((yp + 1), w);
   } else {
     alphaBuf = NULL;
   }
 
   pixAcc0 = pixAcc1 = pixAcc2 = 0; // make gcc happy
 #if SPLASH_CMYK
   pixAcc3 = 0; // make gcc happy
 #endif
 
   // initialize the pixel pipe
   pipeInit(&pipe, 0, 0, NULL, pix, state->fillAlpha,
 	   srcAlpha || (vectorAntialias && clipRes != splashClipAllInside),
 	   gFalse);
   if (vectorAntialias) {
     drawAAPixelInit();
   }
 
   if (srcAlpha) {
 
     // init y scale Bresenham
     yt = 0;
     lastYStep = 1;
 
     for (y = 0; y < scaledHeight; ++y) {
 
       // y scale Bresenham
       yStep = yp;
       yt += yq;
       if (yt >= scaledHeight) {
 	yt -= scaledHeight;
 	++yStep;
       }
 
       // read row(s) from image
       n = (yp > 0) ? yStep : lastYStep;
       if (n > 0) {
 	p = colorBuf;
 	q = alphaBuf;
 	for (i = 0; i < n; ++i) {
 	  (*src)(srcData, p, q);
 	  p += w * nComps;
 	  q += w;
 	}
       }
       lastYStep = yStep;
 
       // loop-invariant constants
       k1 = splashRound(xShear * ySign * y);
   
       // clipping test
       if (clipRes != splashClipAllInside &&
 	  !rot &&
 	  (int)(yShear * k1) ==
 	    (int)(yShear * (xSign * (scaledWidth - 1) + k1))) {
 	if (xSign > 0) {
 	  spanXMin = tx + k1;
 	  spanXMax = spanXMin + (scaledWidth - 1);
 	} else {
 	  spanXMax = tx + k1;
 	  spanXMin = spanXMax - (scaledWidth - 1);
 	}
 	spanY = ty + ySign * y + (int)(yShear * k1);
 	clipRes2 = state->clip->testSpan(spanXMin, spanXMax, spanY);
 	if (clipRes2 == splashClipAllOutside) {
 	  continue;
 	}
       } else {
 	clipRes2 = clipRes;
       }
 
       // init x scale Bresenham
       xt = 0;
       xSrc = 0;
 
       // x shear
       x1 = k1;
 
       // y shear
       y1 = (SplashCoord)ySign * y + yShear * x1;
       // this is a kludge: if yShear1 is negative, then (int)y1 would
       // change immediately after the first pixel, which is not what
       // we want
       if (yShear1 < 0) {
 	y1 += 0.999;
       }
 
       // loop-invariant constants
       n = yStep > 0 ? yStep : 1;
 
       switch (srcMode) {
 
       case splashModeMono1:
       case splashModeMono8:
 	for (x = 0; x < scaledWidth; ++x) {
 
 	  // x scale Bresenham
 	  xStep = xp;
 	  xt += xq;
 	  if (xt >= scaledWidth) {
 	    xt -= scaledWidth;
 	    ++xStep;
 	  }
 
 	  // rotation
 	  if (rot) {
 	    x2 = (int)y1;
 	    y2 = -x1;
 	  } else {
 	    x2 = x1;
 	    y2 = (int)y1;
 	  }
 
 	  // compute the filtered pixel at (x,y) after the x and y scaling
 	  // operations
 	  m = xStep > 0 ? xStep : 1;
 	  alphaAcc = 0;
 	  p = colorBuf + xSrc;
 	  q = alphaBuf + xSrc;
 	  pixAcc0 = 0;
 	  for (i = 0; i < n; ++i) {
 	    for (j = 0; j < m; ++j) {
 	      pixAcc0 += *p++;
 	      alphaAcc += *q++;
 	    }
 	    p += w - m;
 	    q += w - m;
 	  }
 	  pixMul = (SplashCoord)1 / (SplashCoord)(n * m);
 	  alphaMul = pixMul * (1.0 / 255.0);
 	  alpha = (SplashCoord)alphaAcc * alphaMul;
 
 	  if (alpha > 0) {
 	    pix[0] = (int)((SplashCoord)pixAcc0 * pixMul);
 
 	    // set pixel
 	    pipe.shape = alpha;
 	    if (vectorAntialias && clipRes != splashClipAllInside) {
 	      drawAAPixel(&pipe, tx + x2, ty + y2);
 	    } else {
 	      drawPixel(&pipe, tx + x2, ty + y2,
 			clipRes2 == splashClipAllInside);
 	    }
 	  }
 
 	  // x scale Bresenham
 	  xSrc += xStep;
 
 	  // x shear
 	  x1 += xSign;
 
 	  // y shear
 	  y1 += yShear1;
 	}
 	break;
 
       case splashModeRGB8:
       case splashModeBGR8:
 	for (x = 0; x < scaledWidth; ++x) {
 
 	  // x scale Bresenham
 	  xStep = xp;
 	  xt += xq;
 	  if (xt >= scaledWidth) {
 	    xt -= scaledWidth;
 	    ++xStep;
 	  }
 
 	  // rotation
 	  if (rot) {
 	    x2 = (int)y1;
 	    y2 = -x1;
 	  } else {
 	    x2 = x1;
 	    y2 = (int)y1;
 	  }
 
 	  // compute the filtered pixel at (x,y) after the x and y scaling
 	  // operations
 	  m = xStep > 0 ? xStep : 1;
 	  alphaAcc = 0;
 	  p = colorBuf + xSrc * 3;
 	  q = alphaBuf + xSrc;
 	  pixAcc0 = pixAcc1 = pixAcc2 = 0;
 	  for (i = 0; i < n; ++i) {
 	    for (j = 0; j < m; ++j) {
 	      pixAcc0 += *p++;
 	      pixAcc1 += *p++;
 	      pixAcc2 += *p++;
 	      alphaAcc += *q++;
 	    }
 	    p += 3 * (w - m);
 	    q += w - m;
 	  }
 	  pixMul = (SplashCoord)1 / (SplashCoord)(n * m);
 	  alphaMul = pixMul * (1.0 / 255.0);
 	  alpha = (SplashCoord)alphaAcc * alphaMul;
 
 	  if (alpha > 0) {
 	    pix[0] = (int)((SplashCoord)pixAcc0 * pixMul);
 	    pix[1] = (int)((SplashCoord)pixAcc1 * pixMul);
 	    pix[2] = (int)((SplashCoord)pixAcc2 * pixMul);
 
 	    // set pixel
 	    pipe.shape = alpha;
 	    if (vectorAntialias && clipRes != splashClipAllInside) {
 	      drawAAPixel(&pipe, tx + x2, ty + y2);
 	    } else {
 	      drawPixel(&pipe, tx + x2, ty + y2,
 			clipRes2 == splashClipAllInside);
 	    }
 	  }
 
 	  // x scale Bresenham
 	  xSrc += xStep;
 
 	  // x shear
 	  x1 += xSign;
 
 	  // y shear
 	  y1 += yShear1;
 	}
 	break;
 
       case splashModeXBGR8:
 	for (x = 0; x < scaledWidth; ++x) {
 	  // x scale Bresenham
 	  xStep = xp;
 	  xt += xq;
 	  if (xt >= scaledWidth) {
 	    xt -= scaledWidth;
 	    ++xStep;
 	  }
 
 	  // rotation
 	  if (rot) {
 	    x2 = (int)y1;
 	    y2 = -x1;
 	  } else {
 	    x2 = x1;
 	    y2 = (int)y1;
 	  }
 
 	  // compute the filtered pixel at (x,y) after the x and y scaling
 	  // operations
 	  m = xStep > 0 ? xStep : 1;
 	  alphaAcc = 0;
 	  p = colorBuf + xSrc * 4;
 	  q = alphaBuf + xSrc;
 	  pixAcc0 = pixAcc1 = pixAcc2 = 0;
 	  for (i = 0; i < n; ++i) {
 	    for (j = 0; j < m; ++j) {
 	      pixAcc0 += *p++;
 	      pixAcc1 += *p++;
 	      pixAcc2 += *p++;
 	      *p++;
 	      alphaAcc += *q++;
 	    }
 	    p += 4 * (w - m);
 	    q += w - m;
 	  }
 	  pixMul = (SplashCoord)1 / (SplashCoord)(n * m);
 	  alphaMul = pixMul * (1.0 / 255.0);
 	  alpha = (SplashCoord)alphaAcc * alphaMul;
 
 	  if (alpha > 0) {
 	    pix[0] = (int)((SplashCoord)pixAcc0 * pixMul);
 	    pix[1] = (int)((SplashCoord)pixAcc1 * pixMul);
 	    pix[2] = (int)((SplashCoord)pixAcc2 * pixMul);
 	    pix[3] = 255;
 
 	    // set pixel
 	    pipe.shape = alpha;
 	    if (vectorAntialias && clipRes != splashClipAllInside) {
 	      drawAAPixel(&pipe, tx + x2, ty + y2);
 	    } else {
 	      drawPixel(&pipe, tx + x2, ty + y2,
 			clipRes2 == splashClipAllInside);
 	    }
 	  }
 
 	  // x scale Bresenham
 	  xSrc += xStep;
 
 	  // x shear
 	  x1 += xSign;
 
 	  // y shear
 	  y1 += yShear1;
 	}
 	break;
 
 
 #if SPLASH_CMYK
       case splashModeCMYK8:
 	for (x = 0; x < scaledWidth; ++x) {
 
 	  // x scale Bresenham
 	  xStep = xp;
 	  xt += xq;
 	  if (xt >= scaledWidth) {
 	    xt -= scaledWidth;
 	    ++xStep;
 	  }
 
 	  // rotation
 	  if (rot) {
 	    x2 = (int)y1;
 	    y2 = -x1;
 	  } else {
 	    x2 = x1;
 	    y2 = (int)y1;
 	  }
 
 	  // compute the filtered pixel at (x,y) after the x and y scaling
 	  // operations
 	  m = xStep > 0 ? xStep : 1;
 	  alphaAcc = 0;
 	  p = colorBuf + xSrc * 4;
 	  q = alphaBuf + xSrc;
 	  pixAcc0 = pixAcc1 = pixAcc2 = pixAcc3 = 0;
 	  for (i = 0; i < n; ++i) {
 	    for (j = 0; j < m; ++j) {
 	      pixAcc0 += *p++;
 	      pixAcc1 += *p++;
 	      pixAcc2 += *p++;
 	      pixAcc3 += *p++;
 	      alphaAcc += *q++;
 	    }
 	    p += 4 * (w - m);
 	    q += w - m;
 	  }
 	  pixMul = (SplashCoord)1 / (SplashCoord)(n * m);
 	  alphaMul = pixMul * (1.0 / 255.0);
 	  alpha = (SplashCoord)alphaAcc * alphaMul;
 
 	  if (alpha > 0) {
 	    pix[0] = (int)((SplashCoord)pixAcc0 * pixMul);
 	    pix[1] = (int)((SplashCoord)pixAcc1 * pixMul);
 	    pix[2] = (int)((SplashCoord)pixAcc2 * pixMul);
 	    pix[3] = (int)((SplashCoord)pixAcc3 * pixMul);
 
 	    // set pixel
 	    pipe.shape = alpha;
 	    if (vectorAntialias && clipRes != splashClipAllInside) {
 	      drawAAPixel(&pipe, tx + x2, ty + y2);
 	    } else {
 	      drawPixel(&pipe, tx + x2, ty + y2,
 			clipRes2 == splashClipAllInside);
 	    }
 	  }
 
 	  // x scale Bresenham
 	  xSrc += xStep;
 
 	  // x shear
 	  x1 += xSign;
 
 	  // y shear
 	  y1 += yShear1;
 	}
 	break;
 #endif // SPLASH_CMYK
       }
     }
 
   } else {
 
     // init y scale Bresenham
     yt = 0;
     lastYStep = 1;
 
     for (y = 0; y < scaledHeight; ++y) {
 
       // y scale Bresenham
       yStep = yp;
       yt += yq;
       if (yt >= scaledHeight) {
 	yt -= scaledHeight;
 	++yStep;
       }
 
       // read row(s) from image
       n = (yp > 0) ? yStep : lastYStep;
       if (n > 0) {
 	p = colorBuf;
 	for (i = 0; i < n; ++i) {
 	  (*src)(srcData, p, NULL);
 	  p += w * nComps;
 	}
       }
       lastYStep = yStep;
 
       // loop-invariant constants
       k1 = splashRound(xShear * ySign * y);
 
       // clipping test
       if (clipRes != splashClipAllInside &&
 	  !rot &&
 	  (int)(yShear * k1) ==
 	    (int)(yShear * (xSign * (scaledWidth - 1) + k1))) {
 	if (xSign > 0) {
 	  spanXMin = tx + k1;
 	  spanXMax = spanXMin + (scaledWidth - 1);
 	} else {
 	  spanXMax = tx + k1;
 	  spanXMin = spanXMax - (scaledWidth - 1);
 	}
 	spanY = ty + ySign * y + (int)(yShear * k1);
 	clipRes2 = state->clip->testSpan(spanXMin, spanXMax, spanY);
 	if (clipRes2 == splashClipAllOutside) {
 	  continue;
 	}
       } else {
 	clipRes2 = clipRes;
       }
 
       // init x scale Bresenham
       xt = 0;
       xSrc = 0;
 
       // x shear
       x1 = k1;
 
       // y shear
       y1 = (SplashCoord)ySign * y + yShear * x1;
       // this is a kludge: if yShear1 is negative, then (int)y1 would
       // change immediately after the first pixel, which is not what
       // we want
       if (yShear1 < 0) {
 	y1 += 0.999;
       }
 
       // loop-invariant constants
       n = yStep > 0 ? yStep : 1;
 
       switch (srcMode) {
 
       case splashModeMono1:
       case splashModeMono8:
 	for (x = 0; x < scaledWidth; ++x) {
 
 	  // x scale Bresenham
 	  xStep = xp;
 	  xt += xq;
 	  if (xt >= scaledWidth) {
 	    xt -= scaledWidth;
 	    ++xStep;
 	  }
 
 	  // rotation
 	  if (rot) {
 	    x2 = (int)y1;
 	    y2 = -x1;
 	  } else {
 	    x2 = x1;
 	    y2 = (int)y1;
 	  }
 
 	  // compute the filtered pixel at (x,y) after the x and y scaling
 	  // operations
 	  m = xStep > 0 ? xStep : 1;
 	  p = colorBuf + xSrc;
 	  pixAcc0 = 0;
 	  for (i = 0; i < n; ++i) {
 	    for (j = 0; j < m; ++j) {
 	      pixAcc0 += *p++;
 	    }
 	    p += w - m;
 	  }
 	  pixMul = (SplashCoord)1 / (SplashCoord)(n * m);
 
 	  pix[0] = (int)((SplashCoord)pixAcc0 * pixMul);
 
 	  // set pixel
 	  if (vectorAntialias && clipRes != splashClipAllInside) {
 	    pipe.shape = (SplashCoord)1;
 	    drawAAPixel(&pipe, tx + x2, ty + y2);
 	  } else {
 	    drawPixel(&pipe, tx + x2, ty + y2,
 		      clipRes2 == splashClipAllInside);
 	  }
 
 	  // x scale Bresenham
 	  xSrc += xStep;
 
 	  // x shear
 	  x1 += xSign;
 
 	  // y shear
 	  y1 += yShear1;
 	}
 	break;
 
       case splashModeRGB8:
       case splashModeBGR8:
 	for (x = 0; x < scaledWidth; ++x) {
 
 	  // x scale Bresenham
 	  xStep = xp;
 	  xt += xq;
 	  if (xt >= scaledWidth) {
 	    xt -= scaledWidth;
 	    ++xStep;
 	  }
 
 	  // rotation
 	  if (rot) {
 	    x2 = (int)y1;
 	    y2 = -x1;
 	  } else {
 	    x2 = x1;
 	    y2 = (int)y1;
 	  }
 
 	  // compute the filtered pixel at (x,y) after the x and y scaling
 	  // operations
 	  m = xStep > 0 ? xStep : 1;
 	  p = colorBuf + xSrc * 3;
 	  pixAcc0 = pixAcc1 = pixAcc2 = 0;
 	  for (i = 0; i < n; ++i) {
 	    for (j = 0; j < m; ++j) {
 	      pixAcc0 += *p++;
 	      pixAcc1 += *p++;
 	      pixAcc2 += *p++;
 	    }
 	    p += 3 * (w - m);
 	  }
 	  pixMul = (SplashCoord)1 / (SplashCoord)(n * m);
 
 	  pix[0] = (int)((SplashCoord)pixAcc0 * pixMul);
 	  pix[1] = (int)((SplashCoord)pixAcc1 * pixMul);
 	  pix[2] = (int)((SplashCoord)pixAcc2 * pixMul);
 
 	  // set pixel
 	  if (vectorAntialias && clipRes != splashClipAllInside) {
 	    pipe.shape = (SplashCoord)1;
 	    drawAAPixel(&pipe, tx + x2, ty + y2);
 	  } else {
 	    drawPixel(&pipe, tx + x2, ty + y2,
 		      clipRes2 == splashClipAllInside);
 	  }
 
 	  // x scale Bresenham
 	  xSrc += xStep;
 
 	  // x shear
 	  x1 += xSign;
 
 	  // y shear
 	  y1 += yShear1;
 	}
 	break;
 
       case splashModeXBGR8:
 	for (x = 0; x < scaledWidth; ++x) {
 
 	  // x scale Bresenham
 	  xStep = xp;
 	  xt += xq;
 	  if (xt >= scaledWidth) {
 	    xt -= scaledWidth;
 	    ++xStep;
 	  }
 
 	  // rotation
 	  if (rot) {
 	    x2 = (int)y1;
 	    y2 = -x1;
 	  } else {
 	    x2 = x1;
 	    y2 = (int)y1;
 	  }
 
 	  // compute the filtered pixel at (x,y) after the x and y scaling
 	  // operations
 	  m = xStep > 0 ? xStep : 1;
 	  p = colorBuf + xSrc * 4;
 	  pixAcc0 = pixAcc1 = pixAcc2 = 0;
 	  for (i = 0; i < n; ++i) {
 	    for (j = 0; j < m; ++j) {
 	      pixAcc0 += *p++;
 	      pixAcc1 += *p++;
 	      pixAcc2 += *p++;
 	      *p++;
 	    }
 	    p += 4 * (w - m);
 	  }
 	  pixMul = (SplashCoord)1 / (SplashCoord)(n * m);
 
 	  pix[0] = (int)((SplashCoord)pixAcc0 * pixMul);
 	  pix[1] = (int)((SplashCoord)pixAcc1 * pixMul);
 	  pix[2] = (int)((SplashCoord)pixAcc2 * pixMul);
 	  pix[3] = 255;
 
 	  // set pixel
 	  if (vectorAntialias && clipRes != splashClipAllInside) {
 	    pipe.shape = (SplashCoord)1;
 	    drawAAPixel(&pipe, tx + x2, ty + y2);
 	  } else {
 	    drawPixel(&pipe, tx + x2, ty + y2,
 		      clipRes2 == splashClipAllInside);
 	  }
 
 	  // x scale Bresenham
 	  xSrc += xStep;
 
 	  // x shear
 	  x1 += xSign;
 
 	  // y shear
 	  y1 += yShear1;
 	}
 	break;
 
 #if SPLASH_CMYK
       case splashModeCMYK8:
 	for (x = 0; x < scaledWidth; ++x) {
 
 	  // x scale Bresenham
 	  xStep = xp;
 	  xt += xq;
 	  if (xt >= scaledWidth) {
 	    xt -= scaledWidth;
 	    ++xStep;
 	  }
 
 	  // rotation
 	  if (rot) {
 	    x2 = (int)y1;
 	    y2 = -x1;
 	  } else {
 	    x2 = x1;
 	    y2 = (int)y1;
 	  }
 
 	  // compute the filtered pixel at (x,y) after the x and y scaling
 	  // operations
 	  m = xStep > 0 ? xStep : 1;
 	  p = colorBuf + xSrc * 4;
 	  pixAcc0 = pixAcc1 = pixAcc2 = pixAcc3 = 0;
 	  for (i = 0; i < n; ++i) {
 	    for (j = 0; j < m; ++j) {
 	      pixAcc0 += *p++;
 	      pixAcc1 += *p++;
 	      pixAcc2 += *p++;
 	      pixAcc3 += *p++;
 	    }
 	    p += 4 * (w - m);
 	  }
 	  pixMul = (SplashCoord)1 / (SplashCoord)(n * m);
 
 	  pix[0] = (int)((SplashCoord)pixAcc0 * pixMul);
 	  pix[1] = (int)((SplashCoord)pixAcc1 * pixMul);
 	  pix[2] = (int)((SplashCoord)pixAcc2 * pixMul);
 	  pix[3] = (int)((SplashCoord)pixAcc3 * pixMul);
 
 	  // set pixel
 	  if (vectorAntialias && clipRes != splashClipAllInside) {
 	    pipe.shape = (SplashCoord)1;
 	    drawAAPixel(&pipe, tx + x2, ty + y2);
 	  } else {
 	    drawPixel(&pipe, tx + x2, ty + y2,
 		      clipRes2 == splashClipAllInside);
 	  }
 
 	  // x scale Bresenham
 	  xSrc += xStep;
 
 	  // x shear
 	  x1 += xSign;
 
 	  // y shear
 	  y1 += yShear1;
 	}
 	break;
 #endif // SPLASH_CMYK
       }
     }
 
   }
 
   gfree(colorBuf);
   gfree(alphaBuf);
 
   return splashOk;
 }
 
diff --git a/splash/SplashBitmap.cc b/splash/SplashBitmap.cc
index 97d622c..6cf2aea 100644
--- a/splash/SplashBitmap.cc
+++ b/splash/SplashBitmap.cc
@@ -1,77 +1,77 @@
 //========================================================================
 //
 // SplashBitmap.cc
 //
 //========================================================================
 
 //========================================================================
 //
 // Modified under the Poppler project - http://poppler.freedesktop.org
 //
 // All changes made under the Poppler project to this file are licensed
 // under GPL version 2 or later
 //
-// Copyright (C) 2006 Albert Astals Cid <aacid@kde.org>
+// Copyright (C) 2006, 2009 Albert Astals Cid <aacid@kde.org>
 // Copyright (C) 2007 Ilmari Heikkinen <ilmari.heikkinen@gmail.com>
 //
 // To see a description of the changes please see the Changelog file that
 // came with your tarball or type make ChangeLog if you are building from git
 //
 //========================================================================
 
 #include <config.h>
 
 #ifdef USE_GCC_PRAGMAS
 #pragma implementation
 #endif
 
 #include <stdio.h>
 #include "goo/gmem.h"
 #include "SplashErrorCodes.h"
 #include "SplashBitmap.h"
 
 //------------------------------------------------------------------------
 // SplashBitmap
 //------------------------------------------------------------------------
 
 SplashBitmap::SplashBitmap(int widthA, int heightA, int rowPad,
 			   SplashColorMode modeA, GBool alphaA,
 			   GBool topDown) {
   width = widthA;
   height = heightA;
   mode = modeA;
   switch (mode) {
   case splashModeMono1:
     rowSize = (width + 7) >> 3;
     break;
   case splashModeMono8:
     rowSize = width;
     break;
   case splashModeRGB8:
   case splashModeBGR8:
     rowSize = width * 3;
     break;
   case splashModeXBGR8:
     rowSize = width * 4;
     break;
 #if SPLASH_CMYK
   case splashModeCMYK8:
     rowSize = width * 4;
     break;
 #endif
   }
   rowSize += rowPad - 1;
   rowSize -= rowSize % rowPad;
-  data = (SplashColorPtr)gmalloc(rowSize * height);
+  data = (SplashColorPtr)gmallocn(rowSize, height);
   if (!topDown) {
     data += (height - 1) * rowSize;
     rowSize = -rowSize;
   }
   if (alphaA) {
-    alpha = (Guchar *)gmalloc(width * height);
+    alpha = (Guchar *)gmallocn(width, height);
   } else {
     alpha = NULL;
   }
 }
 
 
diff --git a/splash/SplashFTFont.cc b/splash/SplashFTFont.cc
index 0039feb..c3b298a 100644
--- a/splash/SplashFTFont.cc
+++ b/splash/SplashFTFont.cc
@@ -169,88 +169,88 @@ GBool SplashFTFont::getGlyph(int c, int xFrac, int yFrac,
 GBool SplashFTFont::makeGlyph(int c, int xFrac, int yFrac,
 			      SplashGlyphBitmap *bitmap, int x0, int y0, SplashClip *clip, SplashClipResult *clipRes) {
   SplashFTFontFile *ff;
   FT_Vector offset;
   FT_GlyphSlot slot;
   FT_UInt gid;
   int rowSize;
   Guchar *p, *q;
   int i;
 
   ff = (SplashFTFontFile *)fontFile;
 
   ff->face->size = sizeObj;
   offset.x = (FT_Pos)(int)((SplashCoord)xFrac * splashFontFractionMul * 64);
   offset.y = 0;
   FT_Set_Transform(ff->face, &matrix, &offset);
   slot = ff->face->glyph;
 
   if (ff->codeToGID && c < ff->codeToGIDLen) {
     gid = (FT_UInt)ff->codeToGID[c];
   } else {
     gid = (FT_UInt)c;
   }
   if (ff->trueType && gid == 0) {
     // skip the TrueType notdef glyph
     return gFalse;
   }
 
   // if we have the FT2 bytecode interpreter, autohinting won't be used
 #ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
   if (FT_Load_Glyph(ff->face, gid,
 		    aa ? FT_LOAD_NO_BITMAP : FT_LOAD_DEFAULT)) {
     return gFalse;
   }
 #else
   // FT2's autohinting doesn't always work very well (especially with
   // font subsets), so turn it off if anti-aliasing is enabled; if
   // anti-aliasing is disabled, this seems to be a tossup - some fonts
   // look better with hinting, some without, so leave hinting on
   if (FT_Load_Glyph(ff->face, gid,
 		    aa ? FT_LOAD_NO_HINTING | FT_LOAD_NO_BITMAP
                        : FT_LOAD_DEFAULT)) {
     return gFalse;
   }
 #endif
 
   FT_Glyph_Metrics *glyphMetrics = &(ff->face->glyph->metrics);
   // prelimirary values from FT_Glyph_Metrics
   bitmap->x = splashRound(-glyphMetrics->horiBearingX / 64.0);
   bitmap->y = splashRound(glyphMetrics->horiBearingY / 64.0);
   bitmap->w = splashRound(glyphMetrics->width / 64.0);
   bitmap->h = splashRound(glyphMetrics->height / 64.0);
 
   *clipRes = clip->testRect(x0 - bitmap->x,
                             y0 - bitmap->y,
                             x0 - bitmap->x + bitmap->w,
                             y0 - bitmap->y + bitmap->h);
   if (*clipRes == splashClipAllOutside) {
     bitmap->freeData = gFalse;
     return gTrue;
   }
 
   if (FT_Render_Glyph(slot, aa ? ft_render_mode_normal
 		               : ft_render_mode_mono)) {
     return gFalse;
   }
 
   bitmap->x = -slot->bitmap_left;
   bitmap->y = slot->bitmap_top;
   bitmap->w = slot->bitmap.width;
   bitmap->h = slot->bitmap.rows;
   bitmap->aa = aa;
   if (aa) {
     rowSize = bitmap->w;
   } else {
     rowSize = (bitmap->w + 7) >> 3;
   }
-  bitmap->data = (Guchar *)gmalloc(rowSize * bitmap->h);
+  bitmap->data = (Guchar *)gmallocn(rowSize, bitmap->h);
   bitmap->freeData = gTrue;
   for (i = 0, p = bitmap->data, q = slot->bitmap.buffer;
        i < bitmap->h;
        ++i, p += rowSize, q += slot->bitmap.pitch) {
     memcpy(p, q, rowSize);
   }
 
   return gTrue;
 }
 
