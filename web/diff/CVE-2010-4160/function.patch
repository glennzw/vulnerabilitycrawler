commit 8acfe468b0384e834a303f08ebc4953d72fb690a
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Oct 28 11:41:55 2010 -0700

    net: Limit socket I/O iovec total length to INT_MAX.
    
    This helps protect us from overflow issues down in the
    individual protocol sendmsg/recvmsg handlers.  Once
    we hit INT_MAX we truncate out the rest of the iovec
    by setting the iov_len members to zero.
    
    This works because:
    
    1) For SOCK_STREAM and SOCK_SEQPACKET sockets, partial
       writes are allowed and the application will just continue
       with another write to send the rest of the data.
    
    2) For datagram oriented sockets, where there must be a
       one-to-one correspondance between write() calls and
       packets on the wire, INT_MAX is going to be far larger
       than the packet size limit the protocol is going to
       check for and signal with -EMSGSIZE.
    
    Based upon a patch by Linus Torvalds.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/socket.h b/include/linux/socket.h
index 5146b50..86b652f 100644
--- a/include/linux/socket.h
+++ b/include/linux/socket.h
@@ -322,7 +322,7 @@ extern int csum_partial_copy_fromiovecend(unsigned char *kdata,
 					  int offset, 
 					  unsigned int len, __wsum *csump);
 
-extern long verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr *address, int mode);
+extern int verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr *address, int mode);
 extern int memcpy_toiovec(struct iovec *v, unsigned char *kdata, int len);
 extern int memcpy_toiovecend(const struct iovec *v, unsigned char *kdata,
 			     int offset, int len);
diff --git a/net/compat.c b/net/compat.c
index 63d260e..3649d58 100644
--- a/net/compat.c
+++ b/net/compat.c
@@ -33,25 +33,27 @@
 static inline int iov_from_user_compat_to_kern(struct iovec *kiov,
 					  struct compat_iovec __user *uiov32,
 					  int niov)
 {
 	int tot_len = 0;
 
 	while (niov > 0) {
 		compat_uptr_t buf;
 		compat_size_t len;
 
 		if (get_user(len, &uiov32->iov_len) ||
-		   get_user(buf, &uiov32->iov_base)) {
-			tot_len = -EFAULT;
-			break;
-		}
+		    get_user(buf, &uiov32->iov_base))
+			return -EFAULT;
+
+		if (len > INT_MAX - tot_len)
+			len = INT_MAX - tot_len;
+
 		tot_len += len;
 		kiov->iov_base = compat_ptr(buf);
 		kiov->iov_len = (__kernel_size_t) len;
 		uiov32++;
 		kiov++;
 		niov--;
 	}
 	return tot_len;
 }
 
diff --git a/net/core/iovec.c b/net/core/iovec.c
index 72aceb1..c40f27e 100644
--- a/net/core/iovec.c
+++ b/net/core/iovec.c
@@ -35,49 +35,47 @@
  *	in any case.
  */
 
-long verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr *address, int mode)
+int verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr *address, int mode)
 {
-	int size, ct;
-	long err;
+	int size, ct, err;
 
 	if (m->msg_namelen) {
 		if (mode == VERIFY_READ) {
 			void __user *namep;
 			namep = (void __user __force *) m->msg_name;
 			err = move_addr_to_kernel(namep, m->msg_namelen,
 						  address);
 			if (err < 0)
 				return err;
 		}
 		m->msg_name = address;
 	} else {
 		m->msg_name = NULL;
 	}
 
 	size = m->msg_iovlen * sizeof(struct iovec);
 	if (copy_from_user(iov, (void __user __force *) m->msg_iov, size))
 		return -EFAULT;
 
 	m->msg_iov = iov;
 	err = 0;
 
 	for (ct = 0; ct < m->msg_iovlen; ct++) {
-		err += iov[ct].iov_len;
-		/*
-		 * Goal is not to verify user data, but to prevent returning
-		 * negative value, which is interpreted as errno.
-		 * Overflow is still possible, but it is harmless.
-		 */
-		if (err < 0)
-			return -EMSGSIZE;
+		size_t len = iov[ct].iov_len;
+
+		if (len > INT_MAX - err) {
+			len = INT_MAX - err;
+			iov[ct].iov_len = len;
+		}
+		err += len;
 	}
 
 	return err;
 }
 
 /*
  *	Copy kernel to iovec. Returns -EFAULT on error.
  *
  *	Note: this modifies the original iovec.
  */
 
