   net: Limit socket I/O iovec total length to INT_MAX.
   
   This helps protect us from overflow issues down in the
   individual protocol sendmsg/recvmsg handlers.  Once
   we hit INT_MAX we truncate out the rest of the iovec
   by setting the iov_len members to zero.
   
   This works because:
   
   1) For SOCK_STREAM and SOCK_SEQPACKET sockets, partial
      writes are allowed and the application will just continue
      with another write to send the rest of the data.
   
   2) For datagram oriented sockets, where there must be a
      one-to-one correspondance between write() calls and
      packets on the wire, INT_MAX is going to be far larger
      than the packet size limit the protocol is going to
      check for and signal with -EMSGSIZE.
   
   Based upon a patch by Linus Torvalds.
   
   Signed-off-by: David S. Miller <davem@davemloft.net>
					  int offset, 
					  unsigned int len, __wsum *csump);

extern long verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr *address, int mode);
extern int memcpy_toiovec(struct iovec *v, unsigned char *kdata, int len);
extern int memcpy_toiovecend(const struct iovec *v, unsigned char *kdata,
			     int offset, int len);
		compat_size_t len;

		if (get_user(len, &uiov32->iov_len) ||
		   get_user(buf, &uiov32->iov_base)) {
			tot_len = -EFAULT;
			break;
		}
		tot_len += len;
		kiov->iov_base = compat_ptr(buf);
		kiov->iov_len = (__kernel_size_t) len;
 *	in any case.
 */

long verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr *address, int mode)
{
	int size, ct;
	long err;

	if (m->msg_namelen) {
		if (mode == VERIFY_READ) {
	err = 0;

	for (ct = 0; ct < m->msg_iovlen; ct++) {
		err += iov[ct].iov_len;
		/*
		 * Goal is not to verify user data, but to prevent returning
		 * negative value, which is interpreted as errno.
		 * Overflow is still possible, but it is harmless.
		 */
		if (err < 0)
			return -EMSGSIZE;
	}

	return err;
