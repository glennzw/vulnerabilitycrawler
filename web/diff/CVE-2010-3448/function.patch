commit b525c06cdbd8a3963f0173ccd23f9147d4c384b5
Author: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
Date:   Thu Feb 25 22:22:22 2010 -0300

    thinkpad-acpi: lock down video output state access
    
    Given the right combination of ThinkPad and X.org, just reading the
    video output control state is enough to hard-crash X.org.
    
    Until the day I somehow find out a model or BIOS cut date to not
    provide this feature to ThinkPads that can do video switching through
    X RandR, change permissions so that only processes with CAP_SYS_ADMIN
    can access any sort of video output control state.
    
    This bug could be considered a local DoS I suppose, as it allows any
    non-privledged local user to cause some versions of X.org to
    hard-crash some ThinkPads.
    
    Reported-by: Jidanni <jidanni@jidanni.org>
    Signed-off-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Cc: stable@kernel.org

diff --git a/Documentation/laptops/thinkpad-acpi.txt b/Documentation/laptops/thinkpad-acpi.txt
index 75afa12..39c0a09 100644
--- a/Documentation/laptops/thinkpad-acpi.txt
+++ b/Documentation/laptops/thinkpad-acpi.txt
@@ -650,6 +650,10 @@ LCD, CRT or DVI (if available). The following commands are available:
 	echo expand_toggle > /proc/acpi/ibm/video
 	echo video_switch > /proc/acpi/ibm/video
 
+NOTE: Access to this feature is restricted to processes owning the
+CAP_SYS_ADMIN capability for safety reasons, as it can interact badly
+enough with some versions of X.org to crash it.
+
 Each video output device can be enabled or disabled individually.
 Reading /proc/acpi/ibm/video shows the status of each device.
 
diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
index f526e73..11fce79 100644
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -309,19 +309,25 @@ config THINKPAD_ACPI_UNSAFE_LEDS
 config THINKPAD_ACPI_VIDEO
 	bool "Video output control support"
 	depends on THINKPAD_ACPI
 	default y
 	---help---
 	  Allows the thinkpad_acpi driver to provide an interface to control
 	  the various video output ports.
 
 	  This feature often won't work well, depending on ThinkPad model,
 	  display state, video output devices in use, whether there is a X
 	  server running, phase of the moon, and the current mood of
 	  Schroedinger's cat.  If you can use X.org's RandR to control
 	  your ThinkPad's video output ports instead of this feature,
-	  don't think twice: do it and say N here to save some memory.
+	  don't think twice: do it and say N here to save memory and avoid
+	  bad interactions with X.org.
 
-	  If you are not sure, say Y here.
+	  NOTE: access to this feature is limited to processes with the
+	  CAP_SYS_ADMIN capability, to avoid local DoS issues in platforms
+	  where it interacts badly with X.org.
+
+	  If you are not sure, say Y here but do try to check if you could
+	  be using X.org RandR instead.
 
 config THINKPAD_ACPI_HOTKEY_POLL
 	bool "Support NVRAM polling for hot keys"
diff --git a/drivers/platform/x86/thinkpad_acpi.c b/drivers/platform/x86/thinkpad_acpi.c
index 3af4628..5d02cc0 100644
--- a/drivers/platform/x86/thinkpad_acpi.c
+++ b/drivers/platform/x86/thinkpad_acpi.c
@@ -285,7 +285,8 @@ struct ibm_struct {
 struct ibm_init_struct {
 	char param[32];
 
 	int (*init) (struct ibm_init_struct *);
+	mode_t base_procfs_mode;
 	struct ibm_struct *data;
 };
 
@@ -4623,92 +4624,100 @@ static int video_expand_toggle(void)
 static int video_read(struct seq_file *m)
 {
 	int status, autosw;
 
 	if (video_supported == TPACPI_VIDEO_NONE) {
 		seq_printf(m, "status:\t\tnot supported\n");
 		return 0;
 	}
 
+	/* Even reads can crash X.org, so... */
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
 	status = video_outputsw_get();
 	if (status < 0)
 		return status;
 
 	autosw = video_autosw_get();
 	if (autosw < 0)
 		return autosw;
 
 	seq_printf(m, "status:\t\tsupported\n");
 	seq_printf(m, "lcd:\t\t%s\n", enabled(status, 0));
 	seq_printf(m, "crt:\t\t%s\n", enabled(status, 1));
 	if (video_supported == TPACPI_VIDEO_NEW)
 		seq_printf(m, "dvi:\t\t%s\n", enabled(status, 3));
 	seq_printf(m, "auto:\t\t%s\n", enabled(autosw, 0));
 	seq_printf(m, "commands:\tlcd_enable, lcd_disable\n");
 	seq_printf(m, "commands:\tcrt_enable, crt_disable\n");
 	if (video_supported == TPACPI_VIDEO_NEW)
 		seq_printf(m, "commands:\tdvi_enable, dvi_disable\n");
 	seq_printf(m, "commands:\tauto_enable, auto_disable\n");
 	seq_printf(m, "commands:\tvideo_switch, expand_toggle\n");
 
 	return 0;
 }
 
 static int video_write(char *buf)
 {
 	char *cmd;
 	int enable, disable, status;
 	int res;
 
 	if (video_supported == TPACPI_VIDEO_NONE)
 		return -ENODEV;
 
+	/* Even reads can crash X.org, let alone writes... */
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
 	enable = 0;
 	disable = 0;
 
 	while ((cmd = next_cmd(&buf))) {
 		if (strlencmp(cmd, "lcd_enable") == 0) {
 			enable |= TP_ACPI_VIDEO_S_LCD;
 		} else if (strlencmp(cmd, "lcd_disable") == 0) {
 			disable |= TP_ACPI_VIDEO_S_LCD;
 		} else if (strlencmp(cmd, "crt_enable") == 0) {
 			enable |= TP_ACPI_VIDEO_S_CRT;
 		} else if (strlencmp(cmd, "crt_disable") == 0) {
 			disable |= TP_ACPI_VIDEO_S_CRT;
 		} else if (video_supported == TPACPI_VIDEO_NEW &&
 			   strlencmp(cmd, "dvi_enable") == 0) {
 			enable |= TP_ACPI_VIDEO_S_DVI;
 		} else if (video_supported == TPACPI_VIDEO_NEW &&
 			   strlencmp(cmd, "dvi_disable") == 0) {
 			disable |= TP_ACPI_VIDEO_S_DVI;
 		} else if (strlencmp(cmd, "auto_enable") == 0) {
 			res = video_autosw_set(1);
 			if (res)
 				return res;
 		} else if (strlencmp(cmd, "auto_disable") == 0) {
 			res = video_autosw_set(0);
 			if (res)
 				return res;
 		} else if (strlencmp(cmd, "video_switch") == 0) {
 			res = video_outputsw_cycle();
 			if (res)
 				return res;
 		} else if (strlencmp(cmd, "expand_toggle") == 0) {
 			res = video_expand_toggle();
 			if (res)
 				return res;
 		} else
 			return -EINVAL;
 	}
 
 	if (enable || disable) {
 		status = video_outputsw_get();
 		if (status < 0)
 			return status;
 		res = video_outputsw_set((status & ~disable) | enable);
 		if (res)
 			return res;
 	}
 
 	return 0;
 }
 
@@ -8440,70 +8449,71 @@ static void ibm_exit(struct ibm_struct *ibm)
 static int __init ibm_init(struct ibm_init_struct *iibm)
 {
 	int ret;
 	struct ibm_struct *ibm = iibm->data;
 	struct proc_dir_entry *entry;
 
 	BUG_ON(ibm == NULL);
 
 	INIT_LIST_HEAD(&ibm->all_drivers);
 
 	if (ibm->flags.experimental && !experimental)
 		return 0;
 
 	dbg_printk(TPACPI_DBG_INIT,
 		"probing for %s\n", ibm->name);
 
 	if (iibm->init) {
 		ret = iibm->init(iibm);
 		if (ret > 0)
 			return 0;	/* probe failed */
 		if (ret)
 			return ret;
 
 		ibm->flags.init_called = 1;
 	}
 
 	if (ibm->acpi) {
 		if (ibm->acpi->hid) {
 			ret = register_tpacpi_subdriver(ibm);
 			if (ret)
 				goto err_out;
 		}
 
 		if (ibm->acpi->notify) {
 			ret = setup_acpi_notify(ibm);
 			if (ret == -ENODEV) {
 				printk(TPACPI_NOTICE "disabling subdriver %s\n",
 					ibm->name);
 				ret = 0;
 				goto err_out;
 			}
 			if (ret < 0)
 				goto err_out;
 		}
 	}
 
 	dbg_printk(TPACPI_DBG_INIT,
 		"%s installed\n", ibm->name);
 
 	if (ibm->read) {
-		mode_t mode;
+		mode_t mode = iibm->base_procfs_mode;
 
-		mode = S_IRUGO;
+		if (!mode)
+			mode = S_IRUGO;
 		if (ibm->write)
 			mode |= S_IWUSR;
 		entry = proc_create_data(ibm->name, mode, proc_dir,
 					 &dispatch_proc_fops, ibm);
 		if (!entry) {
 			printk(TPACPI_ERR "unable to create proc entry %s\n",
 			       ibm->name);
 			ret = -ENODEV;
 			goto err_out;
 		}
 		ibm->flags.proc_created = 1;
 	}
 
 	list_add_tail(&ibm->all_drivers, &tpacpi_all_drivers);
 
 	return 0;
 
@@ -8659,64 +8669,65 @@ static int __init probe_for_thinkpad(void)
 static struct ibm_init_struct ibms_init[] __initdata = {
 	{
 		.init = thinkpad_acpi_driver_init,
 		.data = &thinkpad_acpi_driver_data,
 	},
 	{
 		.init = hotkey_init,
 		.data = &hotkey_driver_data,
 	},
 	{
 		.init = bluetooth_init,
 		.data = &bluetooth_driver_data,
 	},
 	{
 		.init = wan_init,
 		.data = &wan_driver_data,
 	},
 	{
 		.init = uwb_init,
 		.data = &uwb_driver_data,
 	},
 #ifdef CONFIG_THINKPAD_ACPI_VIDEO
 	{
 		.init = video_init,
+		.base_procfs_mode = S_IRUSR,
 		.data = &video_driver_data,
 	},
 #endif
 	{
 		.init = light_init,
 		.data = &light_driver_data,
 	},
 	{
 		.init = cmos_init,
 		.data = &cmos_driver_data,
 	},
 	{
 		.init = led_init,
 		.data = &led_driver_data,
 	},
 	{
 		.init = beep_init,
 		.data = &beep_driver_data,
 	},
 	{
 		.init = thermal_init,
 		.data = &thermal_driver_data,
 	},
 	{
 		.data = &ecdump_driver_data,
 	},
 	{
 		.init = brightness_init,
 		.data = &brightness_driver_data,
 	},
 	{
 		.init = volume_init,
 		.data = &volume_driver_data,
 	},
 	{
 		.init = fan_init,
 		.data = &fan_driver_data,
 	},
 };
 
