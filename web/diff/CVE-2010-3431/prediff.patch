   Relevant BUGIDs:
   
   Purpose of commit: bugfix
   
   Commit summary:
   ---------------
   2010-10-04  Dmitry V. Levin  <ldv@altlinux.org>
   
   	* libpam/pam_modutil_priv.c: New file.
   	* libpam/Makefile.am (libpam_la_SOURCES): Add it.
   	* libpam/include/security/pam_modutil.h (struct pam_modutil_privs,
   	PAM_MODUTIL_DEF_PRIVS, pam_modutil_drop_priv,
   	pam_modutil_regain_priv): New declarations.
   	* libpam/libpam.map (LIBPAM_MODUTIL_1.1.3): New interface.
   	* modules/pam_env/pam_env.c (handle_env): Use new pam_modutil interface.
   	* modules/pam_mail/pam_mail.c (_do_mail): Likewise.
   	* modules/pam_xauth/pam_xauth.c (check_acl, pam_sm_open_session,
   	pam_sm_close_session): Likewise.
   	(pam_sm_open_session): Remove redundant fchown call.
   	Fixes CVE-2010-3430, CVE-2010-3431.
2010-10-01  Thorsten Kukuk  <kukuk@thkukuk.de>

	* configure.in: Extend cross compiling check.
	pam_vprompt.c pam_syslog.c pam_dynamic.c pam_audit.c \
	pam_modutil_cleanup.c pam_modutil_getpwnam.c pam_modutil_ioloop.c \
	pam_modutil_getgrgid.c pam_modutil_getpwuid.c pam_modutil_getgrnam.c \
	pam_modutil_getspnam.c pam_modutil_getlogin.c  pam_modutil_ingroup.c
extern int PAM_NONNULL((1,3))
pam_modutil_audit_write(pam_handle_t *pamh, int type,
			const char *message, int retval);
#ifdef __cplusplus
}
#endif
  global:
    pam_modutil_audit_write;
} LIBPAM_MODUTIL_1.0;
#include <string.h>
#include <syslog.h>
#include <sys/stat.h>
#include <sys/fsuid.h>
#include <sys/types.h>
#include <unistd.h>

	  return PAM_BUF_ERR;
	}
      if (stat(envpath, &statbuf) == 0) {
	uid_t fsuid = setfsuid(user_entry->pw_uid);
        retval = _parse_config_file(pamh, envpath);
	setfsuid(fsuid);
        if (retval == PAM_IGNORE)
          retval = PAM_SUCCESS;
      }
#include <syslog.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/fsuid.h>
#include <unistd.h>
#include <dirent.h>
#include <errno.h>

    if ((est && !(ctrl & PAM_NO_LOGIN))
	|| (!est && (ctrl & PAM_LOGOUT_TOO))) {
	uid_t fsuid = setfsuid(pwd->pw_uid);
	type = get_mail_status(pamh, ctrl, folder);
	setfsuid(fsuid);

	if (type != 0) {
	    retval = report_mail(pamh, ctrl, type, folder);

#include "config.h"
#include <sys/types.h>
#include <sys/fsuid.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>
	struct passwd *pwd;
	FILE *fp = NULL;
	int i, fd = -1, save_errno;
	uid_t fsuid;
	struct stat st;
	/* Check this user's <sense> file. */
	pwd = pam_modutil_getpwnam(pamh, this_user);
	if (pwd == NULL) {
			   "name of user's home directory is too long");
		return PAM_SESSION_ERR;
	}
	fsuid = setfsuid(pwd->pw_uid);
	if (!stat(path, &st)) {
		if (!S_ISREG(st.st_mode))
			errno = EINVAL;
			fd = open(path, O_RDONLY | O_NOCTTY);
	}
	save_errno = errno;
	setfsuid(fsuid);
	if (fd >= 0) {
		if (!fstat(fd, &st)) {
			if (!S_ISREG(st.st_mode))
	struct passwd *tpwd, *rpwd;
	int fd, i, debug = 0;
	int retval = PAM_SUCCESS;
	uid_t systemuser = 499, targetuser = 0, fsuid;

	/* Parse arguments.  We don't understand many, so no sense in breaking
	 * this into a separate function. */
			  getuid(), getgid(),
			  xauth, "-f", cookiefile, "nlist", display,
			  NULL) == 0) {
		int save_errno;
#ifdef WITH_SELINUX
		security_context_t context = NULL;
#endif
		/* Check that we got a cookie.  If not, we get creative. */
		if (((cookie == NULL) || (strlen(cookie) == 0)) &&
		    ((strncmp(display, "localhost:", 10) == 0) ||
		}

		/* Generate a new file to hold the data. */
		fsuid = setfsuid(tpwd->pw_uid);

#ifdef WITH_SELINUX
		if (is_selinux_enabled() > 0) {
			struct selabel_handle *ctx = selabel_open(SELABEL_CTX_FILE, NULL, 0);
				}
			}
		}
		fd = mkstemp(xauthority + sizeof(XAUTHENV));
		save_errno = errno;
		if (context != NULL) {
			free(context);
			setfscreatecon(NULL);
		}
#else
		fd = mkstemp(xauthority + sizeof(XAUTHENV));
		save_errno = errno;
#endif

		setfsuid(fsuid);
		if (fd == -1) {
			errno = save_errno;
			pam_syslog(pamh, LOG_ERR,
				   "error creating temporary file `%s': %m",
				   xauthority + sizeof(XAUTHENV));
			retval = PAM_SESSION_ERR;
			goto cleanup;
		}
		/* Set permissions on the new file and dispose of the
		 * descriptor. */
		setfsuid(tpwd->pw_uid);
		if (fchown(fd, tpwd->pw_uid, tpwd->pw_gid) < 0)
		  pam_syslog (pamh, LOG_ERR, "fchown: %m");
		setfsuid(fsuid);
		close(fd);

		/* Get a copy of the filename to save as a data item for
		 * removal at session-close time. */
	const void *data;
	const char *cookiefile;
	struct passwd *tpwd;
	uid_t fsuid;

	/* Try to retrieve the name of a file we created when
	 * the session was opened. */

	if (debug)
		pam_syslog(pamh, LOG_DEBUG, "removing `%s'", cookiefile);
	fsuid = setfsuid(tpwd->pw_uid);
	if (unlink(cookiefile) == -1 && errno != ENOENT)
	  pam_syslog(pamh, LOG_WARNING, "Couldn't remove `%s': %m", cookiefile);
	setfsuid(fsuid);

	return PAM_SUCCESS;
}
