commit 888cd1843e935fe675cf2ac303116d4ed5b9d54b
Author: Werner Lemberg <wl@gnu.org>
Date:   Thu Jul 8 07:29:42 2010 +0200

    Fix Savannah bug #30361.
    
    * src/truetype/ttinterp.c (Ins_IUP): Fix bounds check.

diff --git a/ChangeLog b/ChangeLog
index 19fe6bd..5dfcd86 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8564 +1,8570 @@
+2010-07-08  Werner Lemberg  <wl@gnu.org>
+
+	Fix Savannah bug #30361.
+
+	* src/truetype/ttinterp.c (Ins_IUP): Fix bounds check.
+
 2010-07-06  Werner Lemberg  <wl@gnu.org>
 
 	Pacify compiler.
 
 	* src/cff/cffload.c (cff_index_get_pointers): Initialize
 	`new_bytes'.
 
 2010-07-05  Eugene A. Shatokhin  <spectre@ispras.ru>
 
 	Fix Savannah bug #27648.
 
 	* src/base/ftobjs.c (ft_remove_renderer, FT_Add_Module): Call
 	`raster_done' only if we have an outline glyph format.
 
 2010-07-05  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30030.
 
 	* builds/win32/*/freetype.vcproj: Add ftxf86.c.
 
 2010-07-05  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Next try to fix `hintmask' and `cntrmask' limit check.
 
 	Problem reported by malc <av1474@comtv.ru>.
 
 	* src/cff/cffgload.c (cff_decoder_parse_charstrings)
 	<cff_op_hintmask>: It is possible that there is just a single byte
 	after the `hintmask' or `cntrmask', e.g., a `return' instruction.
 
 2010-07-04  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Restrict the number of the charmaps in a rogue-compatible mode.
 	Fix for Savannah bug #30059.
 
 	* src/cache/ftccmap.c (FTC_CMapCache_Lookup): Replace `16' the
 	minimum character code passed by a legacy rogue client by...
 	* include/freetype/config/ftoption.h (FT_MAX_CHARMAP_CACHEABLE):
 	This.  It is undefined when FT_CONFIG_OPTION_OLD_INTERNALS is
 	undefined (thus the rogue client compatibility is not required).
 
 	* src/cff/cffobjs.c (cff_face_init): Abort the automatic
 	selection or synthesis of Unicode cmap subtable when the charmap
 	index exceeds FT_MAX_CHARMAP_CACHEABLE.
 	* src/sfnt/ttcmap.c (tt_face_build_cmaps): Issue error message
 	when the charmap index exceeds FT_MAX_CHARMAP_CACHEABLE.
 
 	* src/base/ftobjs.c (find_unicode_charmap): When Unicode charmap
 	is found after FT_MAX_CHARMAP_CACHEABLE, ignore it and search
 	earlier one.
 	(find_variant_selector_charmap): When UVS charmap is found after
 	FT_MAX_CHARMAP_CACHEABLE, ignore it and search earlier one.
 	(FT_Select_Charmap): When a charmap matching with requested
 	encoding but after FT_MAX_CHARMAP_CACHEABLE, ignore and search
 	earlier one.
 	(FT_Set_Charmap): When a charmap matching with requested
 	charmap but after FT_MAX_CHARMAP_CACHEABLE, ignore and search
 	earlier one.
 	(FT_Get_Charmap_Index): When a requested charmap is found
 	after FT_MAX_CHARMAP_CACHEABLE, return the inverted charmap
 	index.
 
 2010-07-04  Werner Lemberg  <wl@gnu.org>
 
 	TrueType hinting is no longer patented.
 
 	* include/freetype/config/ftoption.h, devel/ftoption.h
 	(TT_CONFIG_OPTION_BYTECODE_INTERPRETER): Define.
 	(TT_CONFIG_OPTION_UNPATENTED_HINTING): Undefine.
 
 	* docs/CHANGES, docs/INSTALL, include/freetype/freetype.h: Updated.
 	* docs/TRUETYPE, docs/PATENTS: Removed.
 
 2010-07-04  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Check error value by `FT_CMap_New'.
 
 	* src/cff/cffobjs.c (cff_face_init): Check error value by
 	`FT_CMap_New'.
 	* src/pfr/pfrobjs.c (pfr_face_init): Ditto.
 	* src/type1/t1jobjs.c (T1_Face_Init): Ditto.
 	* src/type42/t42jobjs.c (T42_Face_Init): Ditto.
 
 2010-07-03  Werner Lemberg  <wl@gnu.org>
 
 	Make ftgrays.c compile stand-alone again.
 
 	* src/smooth/ftgrays.c [_STANDALONE_]: Include `stddef.h'.
 	(FT_INT_MAX, FT_PtrDist)[_STANDALONE_]: Define.
 
 2010-07-02  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Additional fix for Savannah bug #30306.
 
 	* src/base/ftobjs.c (Mac_Read_POST_Resource): If the type of the
 	POST fragment is 0, the segment is completely ignored.  The declared
 	length of the segment is not cared at all.  According to Adobe
 	Technical Note 5040, type 0 segment is a comment only and should not
 	be loaded for the interpreter.  Reported by Robert Święcki.
 
 2010-07-01  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Protect against code range underflow.
 
 	* src/truetype/ttinterp.c (DO_JROT, DO_JMPR, DO_JROF): Don't allow
 	negative IP values.
 
 2010-07-01  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Add rudimentary tracing for bytecode instructions.
 
 	* src/truetype/ttinterp.c (opcode_name) [FT_DEBUG_LEVEL_TRACE]: New
 	array.
 	(TT_RunIns): Trace opcodes.
 
 2010-06-30  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30263.
 
 	* src/smooth/ftgrays.c (gray_render_span): Use cast to `unsigned
 	int' to avoid integer overflow.
 
 	* src/smooth/ftsmooth.c (ft_smooth_render_generic): Use smaller
 	threshold values for `width' and `height'.  This is not directly
 	related to the bug fix but makes sense anyway.
 
 2010-07-01  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Initial fix for Savannah bug #30306.
 
 	* src/base/ftobjs.c (Mac_Read_POST_Resource): Check `rlen', the
 	length of fragment declared in the POST fragment header, and prevent
 	an underflow in length calculation.  Some fonts set the length to
 	zero in spite of the existence of a following 16bit `type'. 
 	Reported by Robert Święcki.
 
 2010-07-01  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Additional fix for Savannah bug #30248 and #30249.
 
 	* src/base/ftobjs.c (Mac_Read_POST_Resource): Check the buffer size
 	during gathering PFB fragments embedded in LaserWriter PS font for
 	Macintosh.  Reported by Robert Święcki.
 
 2010-06-30  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	Minor optimizations by avoiding divisions.
 
 	* src/sfnt/ttkern.c (tt_face_load_kern, tt_face_get_kerning):
 	Replace divisions with multiplication in comparisons.
 
 2010-06-29  Werner Lemberg  <wl@gnu.org>
 
 	Fix minor tracing issues.
 
 	* src/cff/cffgload.c, src/truetype/ttgload.c: Adjust tracing levels.
 
 2010-06-27  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Really fix `hintmask' and `cntrmask' limit check.
 
 	* src/cff/cffgload.c (cff_decoder_parse_charstrings)
 	<cff_op_hintmask>: Fix thinko and handle tracing also.
 
 2010-06-27  Werner Lemberg  <wl@gnu.org>
 
 	Fix valgrind warning.
 
 	* src/base/ftoutln.c (FT_Outline_Get_Orientation): Initialize
 	`result' array.
 
 2010-06-27  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Fix memory leak.
 
 	* src/cff/cffgload.c (cff_operator_seac): Free charstrings even in
 	case of errors.
 
 2010-06-27  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Protect against invalid `hintmask' and `cntrmask' operators.
 
 	* src/cff/cffgload.c (cff_decoder_parse_charstrings)
 	<cff_op_hintmask>: Ensure that we don't exceed `limit' while parsing
 	the bit masks of the `hintmask' and `cntrmask' operators.
 
 2010-06-26  Werner Lemberg  <wl@gnu.org>
 
 	Fix PFR change 2010-06-24.
 
 	* src/pfr/pfrgload.c (pfr_glyph_load_simple): Really protect against
 	invalid indices.
 
 2010-06-26  Werner Lemberg  <wl@gnu.org>
 
 	Improve PFR tracing messages.
 
 	* src/pfr/pfrgload.c (pfr_glyph_load_rec): Emit tracing messages for
 	simple and compound glyph offsets.
 
 2010-06-26  Werner Lemberg  <wl@gnu.org>
 
 	Fix last PFR change.
 
 	* src/pfr/pfrobjs.c (pfr_face_init): Fix rejection logic.
 
 2010-06-26  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30262.
 
 	* src/sfnt/ttload.c (tt_face_load_maxp): Limit `maxComponentDepth'
 	arbitrarily to 100 to avoid stack exhaustion.
 
 2010-06-26  Werner Lemberg  <wl@gnu.org>
 
 	Add some memory checks (mainly for debugging).
 
 	* src/base/ftstream.c (FT_Stream_EnterFrame): Exit with error
 	if the frame size is larger than the stream size.
 
 	* src/base/ftsystem.c (ft_ansi_stream_io): Exit with error if
 	seeking a position larger than the stream size.
 
 2010-06-25  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30261.
 
 	* src/pfr/pfrobjs.c (pfr_face_init): Reject fonts which contain
 	neither outline nor bitmap glyphs.
 
 2010-06-25  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30254.
 
 	* src/cff/cffload.c (cff_index_get_pointers): Do sanity check for
 	first offset also.
 
 2010-06-25  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Initial fix for Savannah bug #30248 and #30249.
 
 	* src/base/ftobjs.c (Mac_Read_POST_Resource): Check the error during
 	reading a PFB fragment embedded in LaserWriter PS font for Macintosh.
 	Reported by Robert Święcki.
 
 2010-06-24  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30247.
 
 	* src/pcf/pcfread.c (pcf_get_metrics): Disallow (invalid) fonts with
 	zero metrics.
 
 2010-06-24  Graham Asher  <graham.asher@btinternet.com>
 
 	* src/smooth/ftgrays.c (gray_render_cubic): Fix algorithm.
 	The previous version was too aggressive, as demonstrated in
 	http://lists.gnu.org/archive/html/freetype-devel/2010-06/msg00020.html.
 
 2010-06-24  Werner Lemberg  <wl@gnu.org>
 
 	*/*: Use module specific error names where appropriate.
 
 2010-06-24  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30236.
 
 	* src/sfnt/ttcmap.c (tt_face_build_cmaps): Improve check for pointer
 	to `cmap_table'.
 
 2010-06-24  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30235.
 
 	* src/pfr/pfrgload.c (pfr_glyph_load_simple): Protect against
 	invalid indices if there aren't any coordinates for indexing.
 
 2010-06-24  Werner Lemberg  <wl@gnu.org>
 
 	[bdf]: Font properties are optional.
 
 	* src/bdf/bdflib.c (_bdf_readstream): Use special error code to
 	indicate a redo operation.
 	(_bdf_parse_start): Handle `CHARS' keyword here too and pass current
 	input line to `_bdf_parse_glyph'.
 
 2010-06-23  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30220.
 
 	* include/freetype/fterrdef.h
 	(BDF_Err_Missing_Fontboundingbox_Field): New error code.
 
 	* src/bdf/bdflib.c (_bdf_parse_start): Check for missing
 	`FONTBOUNDINGBOX' field.
 	Avoid memory leak if there are multiple `FONT' lines (which is
 	invalid but doesn't hurt).
 
 2010-06-21  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30168.
 
 	* src/pfr/pfrgload.c (pfr_glyph_load_compound): Limit the number of
 	subglyphs to avoid endless recursion.
 
 2010-06-20  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30145.
 
 	* src/psaux/psobjs.c (t1_builder_add_contour): Protect against
 	`outline == NULL' which might happen in invalid fonts.
 
 2010-06-19  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30135.
 
 	* src/bdf/bdflib.c (_bdf_list_join): Don't modify value in static
 	string `empty'.
 	(_bdf_parse_glyph): Avoid memory leak in case of error.
 
 2010-06-15  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30108.
 
 	* src/autofit/afglobal.c (af_face_globals_compute_script_coverage):
 	Properly mask AF_DIGIT bit in comparison.
 
 2010-06-11  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30106.
 
 	Point numbers for FreeType's implementation of hinting masks are
 	collected before the final number of points of a glyph has been
 	determined; in particular, the code for handling the `endchar'
 	opcode can reduce the number of points.
 
 	* src/pshinter/pshalgo.c (psh_glyph_find_strong_points): Assure that
 	`end_point' is not larger than `glyph->num_points'.
 
 2010-06-11  Werner Lemberg  <wl@gnu.org>
 
 	[cff]: Improve debugging output.
 
 	* src/cff/cffgload.c (cff_decoder_parse_charstrings)
 	<cff_op_hintmask>: Implement it.
 
 2010-06-10  Graham Asher  <graham.asher@btinternet.com>
 
 	ftgrays: Speed up rendering of small cubic splines.
 
 	* src/smooth/ftgrays.c (gray_render_cubic): Implement new,
 	simplified algorithm to find out whether the spline can be replaced
 	with two straight lines.  See this thread for more:
 
 	  http://lists.gnu.org/archive/html/freetype-devel/2010-06/msg00000.html
 
 2010-06-09  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30082.
 
 	* src/cff/cffgload.c (cff_decoder_parse_charstrings)
 	<cff_op_callothersubr>: Protect against stack underflow.
 
 2010-06-08  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30053.
 
 	* src/cff/cffparse.c (cff_parse_real): Handle border case where
 	`fraction_length' has value 10.
 
 2010-06-07  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30052.
 	This bug has been introduced with commit 2415cbf3.
 
 	* src/base/ftobjs.c (FT_Get_First_Char, FT_Get_Next_Char): Protect
 	against endless loop in case of corrupted font header data.
 
 2010-05-26  Werner Lemberg  <wl@gnu.org>
 
 	Remove unused variable.
 	Found by Graham.
 
 	* src/autofit/afhints.c (af_glyph_hints_reload): Remove unused
 	variable `first' in first block.
 
 2010-05-22  Werner Lemberg  <wl@gnu.org>
 
 	Fix various memory problems found by linuxtesting.org.
 
 	* src/base/ftgxval.c (FT_TrueTypeGX_Free, FT_ClassicKern_Free),
 	src/base/ftotval.c (FT_OpenType_Free), src/base/ftpfr.c
 	(ft_pfr_check): Check `face'.
 
 	* src/base/ftobjs.c (FT_Get_Charmap_Index): Check `charmap' and
 	`charmap->face'.
 	(FT_Render_Glyph): Check `slot->face'.
 	(FT_Get_SubGlyph_Info): Check `glyph->subglyphs'.
 
 2010-05-22  Werner Lemberg  <wl@gnu.org>
 
 	autofit: Remove dead code.
 	Suggested by Graham.
 
 	* src/autofit/afhints.c (af_glyph_hints_compute_inflections):
 	Removed.
 	(af_glyph_hints_reload): Remove third argument.
 	Update all callers.
 
 2010-05-21  Bram Tassyns  <bramt@enfocus.be>
 
 	Fix Savannah bug #27987.
 
 	* src/cff/cffobjs.c (remove_subset_prefix): New function.
 	(cff_face_init): Use it to adjust `cffface->family_name'.
 
 2010-05-20  Werner Lemberg  <wl@gnu.org>
 
 	TrueType: Make FreeType ignore maxSizeOfInstructions in `maxp'.
 
 	Acroread does the same.
 
 	* src/truetype/ttgload.c (TT_Process_Composite_Glyph): Call
 	`Update_Max' to adjust size of instructions array if necessary and
 	add a rough safety check.
 
 	(load_truetype_glyph): Save `loader->byte_len' before recursive
 	call.
 
 	* src/truetype/ttinterp.h, src/truetype/ttinterp.c (Update_Max):
 	Declare it as FT_LOCAL.
 
 2010-05-18  Hongbo Ni  <hongbo@njstar.com>
 
 	Apply Savannah patch #7196.
 
 	* src/cff/cffgload.c (cff_slot_load): Prevent crash if CFF subfont
 	index is out of range.
 
 2010-05-11  Werner Lemberg  <wl@gnu.org>
 
 	* docs/formats.txt: Give pointer to PCF documentation.
 	Information provided by Alan Coopersmith
 	<alan.coopersmith@oracle.com>.
 
 2010-05-10  Ken Sharp  <ken.sharp@artifex.com>
 
 	Fix Savannah bug #29846.
 
 	Previously we discovered fonts which used `setcurrentpoint' to set
 	the initial point of a contour to 0,0.  This caused FreeType to
 	raise an error, because the `setcurrentpoint' operator is only
 	supposed to be used with the results from an OtherSubr subroutine.
 
 	This was fixed by simply ignoring the error and carrying on.
 
 	Now we have found a font which uses setcurrentpoint to actually
 	establish a non-zero point for a contour during the course of a
 	glyph program.  FWIW, these files may be produced by an application
 	called `Intaglio' on the Mac, when converting TrueType fonts to
 	Type 1.
 
 	The fix allows the new invalid behaviour, the old invalid behaviour
 	and real proper usage of the operator to work the same way as Adobe
 	interpreters apparently do.
 
 	(t1_decoder_parse_charstrings): Make `setcurrentpoint' use the top
 	two elements of the stack to establish unconditionally the current x
 	and y coordinates.
 
 	Make the `flex' subroutine handling (OtherSubr 0) put the current
 	x,y coordinates onto the stack, instead of two dummy uninitialised
 	values.
 
 2010-04-14  Ken Sharp  <ken.sharp@artifex.com>
 
 	Fix Savannah bug #29444.
 
 	* src/psaux/psobjs.c (t1_builder_start_point): Accept (invalid)
 	`lineto' immediately after `hsbw', in accordance with Acrobat, GS,
 	and others.
 
 2010-04-14  Michał Cichoń  <thedmd@artifexmundi.com>
 
 	Fix Savannah bug #27999.
 
 	* src/cache/ftcmanag.c (FTC_Manager_RemoveFaceID): Only remove
 	selected entry, not all.
 
 2010-04-06  Jonathan Kew  <jfkthame@gmail.com>
 
 	Add overflow check to `fvar' table.
 
 	* src/truetype/ttgxvar.c (TT_Get_MM_Var): Check axis and instance
 	count.
 
 2010-04-05  Ken Sharp  <ken.sharp@artifex.com>
 
 	Fix Savannah bug #29335.
 
 	* src/raster/ftraster.c (Line_Up): Use slow multiplication to
 	prevent overflow.  This shouldn't have any serious impact on speed,
 	however.
 
 2010-04-05  Werner Lemberg  <wl@gnu.org>
 
 	Add new function `FT_Library_SetLcdFilterWeights'.
 
 	This is based on code written by Lifter
 	<http://unixforum.org/index.php?showuser=11691>.  It fixes
 	FreeDesktop bug #27386.
 
 	* src/base/ftlcdfil.c (FT_Library_SetLcdFilterWeights): New
 	function.
 
 	* include/freetype/ftlcdfil.h: Updated.
 
 	* docs/CHANGES: Updated.
 
 2010-04-01  John Tytgat  <John.Tytgat@esko.com>
 
 	Fix Savannah bug #29404.
 
 	* src/truetype/ttgload.c: Revert change 2752bd1a (check on bit 1
 	of `head' table of TrueType fonts).
 
 2010-03-14  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Fix `multi build' for Tytgat's CFF driver improvement.
 
 	* src/base/cffload.h (cff_index_get_name): Added.
 
 2010-03-12  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Remove duplicated inclusion of `FT_OUTLINE_H' in ftobjs.c.
 
 	* src/base/ftobjs.c: Remove 2nd inclusion of `FT_OUTLINE_H'.
 
 2010-03-11  Chris Liddell  <chris.liddell@artifex.com>
 
 	Fix Savannah bug #27442.
 
 	* src/raster/ftraster.c (ft_black_reset): Fix `buffer_size'.
 
 2010-03-09  Werner Lemberg  <wl@gnu.org>
 
 	Remove unused variable.
 	Reported by Graham.
 
 	* src/cff/cffparse.c (cff_parse_real): Remove `rest'.
 
 2010-03-02  John Tytgat  <John.Tytgat@esko.com>
 
 	Improve CFF string (especially glyphname) lookup performance.
 
 	We do this by avoiding memory allocation and file I/O.  This is
 	Savannah patch #7104.
 
 	* src/cff/cfftypes.h: Include PS cmaps service and
 	FT_INTERNAL_POSTSCRIPT_HINTS_H.
 	(CFF_SubFontRec): Remove `num_local_subrs'.
 	(CFF_FontRec): Add `num_strings', `strings', and `string_pool'
 	fields.
 	Remove `string_index' and `num_global_subrs' fields.
 	Use real types instead of `void' for `pshinter' and `psnames' fields.
 
 	* src/cff/cffload.c: Don't include PS cmaps service.
 	(cff_index_get_pointers): Add `pool' parameter which allows to
 	insert an extra NUL character for each String INDEX entry.
 	(cff_index_get_name): Make it a local function.
 	(cff_index_get_string): New function.
 	(cff_subfont_load): Updated.
 	(cff_font_load): Initialize `num_strings', `strings', and
 	`string_pool' fields in the `CFF_FontRec' structure.
 	(cff_index_get_sid_string): Use `cff_index_get_string' instead of
 	`cff_index_get_name'.
 	(cff_font_done): Updated.
 
 	* src/cff/cffload.h: Don't include PS cmaps service.
 	(cff_index_get_string): Added.
 	(cff_index_get_sid_string): Updated.
 
 	* src/cff/cffobjs.c: Don't include PS cmaps service and
 	FT_INTERNAL_POSTSCRIPT_HINTS_H.
 	(cff_size_get_globals_funcs, cff_slot_init): Updated.
 	(cff_face_init): Follow `cff_index_get_name',
 	`cff_index_get_string', and `cff_index_get_sid_string' changes.
 
 	* src/cff/cffcmap.c (cff_sid_free_glyph_name): Removed.
 	(cff_sid_to_glyph_name): Use `cff_index_get_cid_string'.
 	(cff_cmap_unicode_init): Updated.
 
 	* src/cff/cffdrivr.c: Don't include PS cmap service.
 	(cff_get_glyph_name): Avoid unnecessary lookup for POSTSCRIPT_CMAPS
 	service.
 	(cff_get_glyph_name, cff_ps_get_font_info, cff_get_ros): Follow API
 	`cff_index_get_sid_string' change.
 	(cff_get_name_index): Use `cff_index_get_string' instead of
 	`cff_index_get_name'.
 
 	* src/cff/cffgload.c: Don't include FT_INTERNAL_POSTSCRIPT_HINTS_H.
 	(cff_decoder_init, cff_decoder_prepare): Updated.
 
 2010-02-27  Werner Lemberg  <wl@gnu.org>
 
 	Simplify code.
 	Suggested by Behdad.
 
 	* src/base/ftobjs.c (FT_Get_First_Char): Don't use a loop since we
 	call FT_Get_Next_Char anyway if necessary.
 
 2010-02-26  Behdad Esfahbod  <behdad@behdad.org>
 
 	Improve handling of invalid glyph indices in char->index functions.
 
 	* src/base/ftobjs.c (FT_Get_First_Char, FT_Get_Next_Char): Use a
 	loop.
 
 2010-02-18  Chris Liddell  <chris.liddell@artifex.com>
 
 	Fix Savannah bug #28905.
 
 	Initialize phantom points before calling the incremental interface
 	to update glyph metrics.
 
 	* src/truetype/ttgload.c (tt_get_metrics_incr_overrides)
 	[FT_CONFIG_OPTION_INCREMENTAL]: New function, split off from...
 	(tt_get_metrics): This.
 	Updated.
 	(load_truetype_glyph): Use tt_get_metrics_incr_overrides.
 
 2010-02-13  Werner Lemberg  <wl@gnu.org>
 
 	* Version 2.3.12 released.
 	==========================
 
 
 	Tag sources with `VER-2-3-12'.
 
 	* docs/CHANGES: Updated.
 
 	* docs/VERSION.DLL: Update documentation and bump version number to
 	2.3.12.
 
 	* README, Jamfile (RefDoc),
 	builds/win32/vc2005/freetype.vcproj, builds/win32/vc2005/index.html,
 	builds/win32/vc2008/freetype.vcproj, builds/win32/vc2008/index.html,
 	builds/win32/visualc/freetype.dsp,
 	builds/win32/visualc/freetype.vcproj,
 	builds/win32/visualc/index.html, builds/win32/visualce/freetype.dsp,
 	builds/win32/visualce/freetype.vcproj,
 	builds/win32/visualce/index.html,
 	builds/wince/vc2005-ce/freetype.vcproj,
 	builds/wince/vc2005-ce/index.html,
 	builds/wince/vc2008-ce/freetype.vcproj,
 	builds/wince/vc2008-ce/index.html: s/2.3.11/2.3.12/, s/2311/2312/.
 
 	* include/freetype/freetype.h (FREETYPE_PATCH): Set to 12.
 
 	* builds/unix/configure.raw (version_info): Set to 10:0:4.
 
 2010-02-12  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Improve autotool version checking to work with beta releases.
 
 	* autogen.sh (check_tool_version): Improve the extraction of version
 	number from "tool --version" output.  Some beta releases of
 	autotools have extra strings before version number.
 
 2010-02-12  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Fix overallocating bug in FT_Outline_New_Internal().
 
 	* src/base/ftoutln.c (FT_Outline_New_Internal): The length of
 	FT_Outline->points[] should be numPoints, not 2 * numPoints.
 	Found by Paul Messmer, see
 	http://lists.gnu.org/archive/html/freetype-devel/2010-02/msg00003.html
 
 2010-02-10  Ken Sharp  <ken.sharp@artifex.com>
 
 	Really fix Savannah bug #28678 (part 2).
 
 	Since we consider `sbw' for the horizontal direction only, we still have
 	to synthesize vertical metrics if the user wants to use the vertical
 	writing direction.
 
 	* src/cff/cffgload.c (cff_slot_load), src/cid/cidgload.c
 	(cid_slot_load_glyph), src/type1/t1gload.c (T1_Load_Glyph):
 	Synthesize vertical metrics (only) if FT_LOAD_VERTICAL_LAYOUT is
 	set.
 
 2010-02-10  Ken Sharp  <ken.sharp@artifex.com>
 
 	Really fix Savannah bug #28678 (part 1).
 
 	After long discussion, we now consider the character width vector
 	(wx,wy) returned by the `sbw' Type 1 operator as being part of *one*
 	direction only.  For example, if you are using the horizontal
 	writing direction, you get the horizontal and vertical components of
 	the advance width for this direction.  Note that OpenType and CFF fonts
 	don't have such a vertical component; instead, the GPOS table can be
 	used to generate two-dimensional advance widths (but this isn't
 	handled by FreeType).
 
 	* include/freetype/ftincrem.h (FT_Incremental_MetricsRec): Add
 	`advance_v' field to hold the vertical component of the advance
 	value.
 
 	* src/truetype/ttgload.c (tt_get_metrics), src/cff/cffgload.c
 	(cff_slot_load), src/type1/t1gload.c
 	(T1_Parse_Glyph_And_Get_Char_String), src/cid/cidgload.c
 	(cid_load_glyph): Use it.
 
 2010-02-08  Werner Lemberg  <wl@gnu.org>
 
 	* devel/ftoption.h [FT_CONFIG_OPTION_PIC]: Define.
 
 2010-02-04  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Prevent NULL pointer dereference passed to FT_Module_Requester.
 
 	* src/sfnt/sfdriver.c (sfnt_get_interface): Don't use `module'.
 	* src/psnames/psmodule.c (psnames_get_interface): Ditto.
 
 	* src/cff/cffdrivr.c (cff_get_interface): Check NULL `driver'.
 	* src/truetype/ttdriver.c (tt_get_interface): Ditto.
 
 2010-01-29  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Fix memory leaks in previous patch.
 
 	* src/sfnt/sfobjs.c (sfnt_load_face): Don't overwrite the strings
 	allocated for face->root.family_name and style_name.
 
 2010-01-29  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	New parameters for FT_Open_Face() to ignore preferred family names.
 
 	Preferred family names should be used for legacy systems that
 	can hold only a few faces (<= 4) for a family name. Suggested by
 	Andreas Heinrich.
 	http://lists.gnu.org/archive/html/freetype/2010-01/msg00001.html
 
 	* include/freetype/ftsnames.h (FT_PARAM_TAG_IGNORE_PREFERRED_FAMILY,
 	FT_PARAM_TAG_IGNORE_PREFERRED_SUBFAMILY): Define.
 
 	* src/sfnt/sfobjs.h (sfnt_load_face): Check the arguments and
 	ignore preferred family and subfamily names if requested.
 
 2010-01-27  Ken Sharp  <ken.sharp@artifex.com>
 
 	Fix Savannah bug #28678.
 
 	* src/cff/cffgload.c (cff_slot_load), src/cid/cidgload.c
 	(cid_load_glyph): Handle vertical metrics correctly.
 
 	* src/type1/t1gload.c (T1_Parse_Glyph_And_Get_Char_String): Handle
 	vertical metrics correctly.
 	(T1_Load_Glyph): Don't synthesize vertical metrics.
 
 2010-01-14  Werner Lemberg  <wl@gnu.org>
 
 	Make FT_Set_Transform work if no renderer is available.
 
 	* src/base/ftobjs.c (FT_Load_Glyph): Apply `standard' transformation
 	if no renderer is compiled into the library.
 
 2010-01-14  Werner Lemberg  <wl@gnu.org>
 
 	Fix compilation warning.
 
 	* src/base/ftbase.h: s/LOCAL_DEF/LOCAL/.
 	* src/base/ftobjc.s: Include ftbase.h conditionally.
 
 2010-01-11  Kwang Yul Seo  <skyul@company100.net>
 
 	Provide inline assembly code for RVCT compiler.
 	This is Savannah patch #7059.
 
 	* include/freetype/config/ftconfig.h (FT_MULFIX_ASSEMBLER,
 	FT_MulFix_arm) [__CC_ARM || __ARM_CC]: Define.
 
 2010-01-08  Ken Sharp  <ken.sharp@artifex.com>
 
 	Fix Savannah bug #28521.
 
 	Issue #28226 involved a work-around for a font which used the
 	`setcurrentpoint' operator in an invalid way; this operator is only
 	supposed to be used with the result of OtherSubrs, and the font used
 	it directly.  The supplied patch removed the block of code which
 	checked this usage entirely.
 
 	This turns out to be a Bad Thing.  If `setcurrentpoint' is being
 	used correctly it should reset the flex flag in the decoder.  If we
 	don't do this then the flag never gets reset and we omit any further
 	contours from the glyph (at least until we close the path or
 	similar).
 
 	* src/psaux/t1decode.c (t1_decoder_parse_charstrings)
 	<op_setcurrentpoint>: Handle `flex_state' correctly.
 
 2010-01-05  Werner Lemberg  <wl@gnu.org>
 
 	Apply reports from clang static analyzer.
 
 	* src/lzw/ftlzw.c (ft_lzw_file_init), src/base/ftstroke.c
 	(FT_Stroker_ParseOutline), src/base/ftsynth.c
 	(FT_GlyphSlot_Embolden): Remove dead code.
 
 	* src/base/ftpatent.c (_tt_check_patents_in_table): Initialize
 	`offset_i' and `length_i'.
 
 2010-01-05  Ralph Giles  <giles@ghostscript.com>
 
 	Enable the incremental font interface by default.
 
 	Ghostscript requires the incremental font interface for handling
 	some Postscript documents.  It is moving to using FreeType as its
 	primary renderer; supporting this in the default build makes it
 	Ghostscript to be linked against the system FreeType when one is
 	available.
 
 	* include/freetype/config/ftoption.h (FT_CONFIG_OPTION_INCREMENTAL):
 	Uncomment.
 
 2010-01-05  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #28395.
 
 	* src/truetype/ttdriver.c (Load_Glyph), src/type1/t1gload.c
 	(T1_Loada_Glyph): Don't check `num_glyphs' if incremental interface
 	is used.
 
 2010-01-05  Ken Sharp  <ken.sharp@artifex.com>
 
 	Make Type 1 `seac' operator work with incremental interface.
 	This fixes Savannah bug #28480.
 
 	* src/psaux/t1decode.c (t1operator_seac): Don't check `glyph_names'
 	if incremental interface is used.
 
 2010-01-04  Ken Sharp  <ken.sharp@artifex.com>
 
 	Make incremental interface work with TrueType fonts.
 	This fixes Savannah bug #28478.
 
 	* src/truetype/ttgload.c (load_truetype_glyph): Don't check
 	`glyf_offset' if incremental interface is used.
 
 2009-12-31  Lars Abrahamsson  <wonko@opera.com>
 
 	Make compilation with FT_CONFIG_OPTION_PIC work again.
 
 	* src/base/ftglyph.c (FT_Glyph_To_Bitmap) [FT_CONFIG_OPTION_PIC]:
 	Declare `library' for FT_BITMAP_GLYPH_CLASS_GET.
 
 	* src/base/ftinit.c (ft_destroy_default_module_classes,
 	ft_create_default_module_classes): Use proper casts (needed for C++
 	compilation).
 
 	* src/sfnt/ttcmap.c (tt_cmap13_class_rec): Use FT_DEFINE_TT_CMAP.
 
 2009-12-22  Marc Kleine-Budde  <mkl@pengutronix.de>
 
 	Make freetype-config aware of $SYSROOT.
 	This is Savannah patch #7040.
 
 	* builds/unix/freetype-config.in: Decorate with ${SYSROOT} where
 	appropriate.
 
 2009-12-20  Werner Lemberg  <wl@gnu.org>
 
 	Fix compiler warning.
 	Reported by Sean.
 
 	* src/base/ftdbgmem.c [!FT_DEBUG_MEMORY]: ANSI C doesn't like empty
 	source files; however, some compilers warn about an unused variable
 	declaration.  This is now replaced with a typedef.
 
 2009-12-18  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #28320.
 
 	There exist corrupt, subsetted fonts (embedded in PDF files) which
 	contain a private dict that ends with an unterminated floating point
 	number (no operator following).  We now ignore this error (as
 	acrobat does).
 
 	* src/cff/cffparse.c (cff_parser_run): Don't emit a syntax error for
 	unterminated floating point numbers.
 
 2009-12-16  Werner Lemberg  <wl@gnu.org>
 
 	Really fix compiler warnings.
 	Reported by Sean.
 
 	* src/truetype/ttgxvar.c (GX_PT_POINTS_ARE_WORDS,
 	GX_PT_POINT_RUN_COUNT_MASK): Convert enum values to macros.
 
 2009-12-16  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Improve configure.raw to copy some options from CFLAGS to LDFLAGS.
 	The linker of Mac OS X 10.6 is sensitive to the architecture.  If
 	the architectures are specified explicitly for the C compiler, the
 	linker requires the architecture specifications too.
 
 	* builds/unix/configure.raw: Replace `-isysroot' option parser by
 	more generic argument parser.
 
 2009-12-15  Werner Lemberg  <wl@gnu.org>
 
 	Fix compiler warnings.
 	Reported by Sean.
 
 	* src/truetype/ttgxvar.c (ft_var_readpackeddeltas): Fix counter data
 	type.
 
 2009-12-14  Ken Sharp  <ken.sharp@artifex.com>
 
 	Ignore invalid `setcurrentpoint' operations in Type 1 fonts.
 	This fixes Savannah bug #28226.
 
 	At least two wild PostScript files of unknown provenance contain
 	Type 1 fonts, apparently converted from TrueType fonts in earlier
 	PDF versions of the files, which use the `setcurrentpoint' operator
 	inappropriately.
 
 	FreeType currently throws an error in this case, but Ghostscript and
 	Adobe Distiller both accept the fonts and ignore the problem.  This
 	commit #ifdefs out the check so PostScript interpreters using
 	FreeType can render these files.
 
 	The specification says `setcurrentpoint' should only be used to set
 	the point after a `Subr' call, but these fonts use it to set the
 	initial point to (0,0).  Unnecessarily so, as they correctly use an
 	`hsbw' operation which implicitly sets the initial point.
 
 	* src/psaux/t1decode.c (t1_decoder_parse_charstrings)
 	<op_setcurrentpoint>: Comment out code.
 
 2009-12-14  Bram Tassyns  <bramt@enfocus.be>
 
 	Fix parsing of /CIDFontVersion.
 	This fixes Savannah bug #28287.
 
 	* src/cid/cidtoken.h: `cid_version' in CID_FaceInfoRec (in
 	t1tables.h) is of type FT_Fixed.
 
 2009-12-14  Werner Lemberg  <wl@gnu.org>
 
 	Trace glyph index in CID module.
 	Suggested in Savannah patch #7023.
 
 	* src/cid/cidgload.c (cid_load_glyph): Add tracing message.
 
 2009-12-03  Werner Lemberg  <wl@gnu.org>
 
 	Fix compiler warnings.
 
 	* src/truetype/ttgload.c (tt_get_metrics): Put `Exit' label into the
 	proper preprocessor conditional.
 	* src/pfr/pfrobjs.c (pfr_slot_load): Pacify gcc.
 
 2009-11-25  John Tytgat  <John.Tytgat@esko.com>
 
 	Better handling of start of `eexec' section.
 	This fixes Savannah bug #28090.
 
 	* src/type1/t1parse.c (T1_Get_Private_Dict): Skip all whitespace
 	characters before start of `eexec' section.
 
 2009-11-20  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #27742.
 
 	* src/base/ftstroke.c (ft_stroker_outside): Avoid silent division by
 	zero, using a threshold for `theta'.
 
 2009-11-20  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #28036.
 
 	* src/type1/t1afm.c (t1_get_index): Fix comparison.
 
 2009-11-16  Werner Lemberg  <wl@gnu.org>
 
 	Fix compiler warnings.
 	Reported by Kevin Blenkinsopp <arqon@promode.org>.
 
 	* src/sfnt/ttload.c (check_table_dir): Use proper data type.
 
 2009-11-15  Werner Lemberg  <wl@gnu.org>
 
 	Really fix FreeDesktop bug #21197.
 	This also fixes Savannah bug #28021.
 
 	* src/autofit/aflatin.c (af_latin_metrics_check_digits),
 	src/autofit/aflatin2.c (af_latin2_metrics_check_digits): Fix loop.
 
 2009-11-15  Werner Lemberg  <wl@gnu.org>
 
 	Add tracing messages for advance values.
 
 	* src/base/ftobjs.c (FT_Load_Glyph), src/truetype/ttgload.c
 	(TT_Get_HMetrics, TT_Get_VMetrics): Do it.
 
 2009-11-08  Werner Lemberg  <wl@gnu.org>
 
 	Fix compiler warning.
 	Reported by Jeremy Manson <jeremy.manson@gmail.com>.
 
 	* src/truetype/ttgload.c (load_truetype_glyph): Initialize `error'.
 
 2009-11-04  Werner Lemberg  <wl@gnu.org>
 
 	Remove compiler warning.
 	Reported by Sean McBride <sean@rogue-research.com>.
 
 	* src/tools/apinames.c (read_header_file)<STATE_TYPE>: Use a cast to
 	`int', as specified in the printf(3) man page.
 
 2009-11-04  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #27921.
 
 	* src/cff/cffobjs.c (cff_face_init), src/cid/cidobjs.c
 	(cid_face_init), src/type1/t1afm.c (T1_Read_Metrics),
 	src/type1/t1objs.c (T1_Face_Init): Don't use unsigned constant
 	values for rounding if the argument can be negative.
 
 2009-11-03  Bram Tassyns  <bramt@enfocus.be>
 
 	Add basic support for Type1 charstrings in CFF.
 	This fixes Savannah bug #27922.
 
 	* src/cff/cffgload.c (CFF_Operator, cff_argument_counts): Handle
 	`seac', `sbw', and `setcurrentpoint' opcodes.
 	(cff_compute_bias): Add parameter to indicate the charstring type.
 	Update all callers.
 	(cff_operator_seac): Add parameter for side bearing.
 	(cff_decoder_parse_charstrings): Updated for more Type1 support.
 
 2009-11-03  Werner Lemberg  <wl@gnu.org>
 
 	Return correct `linearHoriAdvance' value for embedded TT bitmaps too.
 	Reported by Jeremy Manson <jeremy.manson@gmail.com>.
 
 	src/truetype/ttgload.c (load_truetype_glyph): Add parameter to
 	quickly load the glyph header only.
 	Update all callers.
 	(tt_loader_init): Add parameter to quickly load the `glyf' table
 	only.
 	Update all callers.
 	(TT_Load_Glyph): Compute linear advance values for embedded bitmap
 	glyphs too.
 
 2009-11-03  Werner Lemberg  <wl@gnu.org>
 
 	Improve code readability.
 
 	* src/ttgload.c (load_truetype_glyph): Move metrics calculation
 	to...
 	(tt_get_metrics): This new function.
 
 2009-10-26  Bram Tassyns  <bramt@enfocus.be>
 
 	Fix Savannah bug #27811.
 
 	* src/truetype/ttxgvar.c (ft_var_readpackeddeltas): Fix
 	signed/unsigned mismatch.
 
 2009-10-19  Ning Dong  <flintning@163.com>
 
 	Fix handling of `get' and `put' CFF instructions.
 
 	* src/cff/cffgload.c (cff_decoder_parse_charstrings) <cff_op_get,
 	cff_op_put>: Appendix B of Adobe Technote #5177 limits the number of
 	elements for the `get' and `put' operators to 32.
 	* src/cff/cffgload.h (CFF_MAX_TRANS_ELEMENTS): Define.
 	(CFF_Decoder): Use it for `buildchar' and remove `len_buildchar'.
 
 2009-10-18  Werner Lemberg  <wl@gnu.org>
 
 	Fix handling of `dup' CFF instruction.
 	Problem and solution reported by Ning Dong <flintning@163.com>.
 
 	* src/cff/cffgload.c (cff_decoder_parse_charstrings) <cff_op_dup>:
 	Increase `args' by 2, not 1.
 
 2009-10-10  Werner Lemberg  <wl@gnu.org>
 
 	* Version 2.3.11 released.
 	==========================
 
 
 	Tag sources with `VER-2-3-11'.
 
 	* docs/VERSION.DLL: Update documentation and bump version number to
 	2.3.11.
 
 	* README, Jamfile (RefDoc), builds/win32/visualc/index.html,
 	builds/win32/visualc/freetype.dsp,
 	builds/win32/visualc/freetype.vcproj,
 	builds/win32/visualce/index.html,
 	builds/win32/visualce/freetype.dsp,
 	builds/win32/visualce/freetype.vcproj: s/2.3.10/2.3.11/, s/2310/2311/.
 
 	* include/freetype/freetype.h (FREETYPE_PATCH): Set to 11.
 
 	* builds/unix/configure.raw (version_info): Set to 9:22:3.
 
 2009-10-10  Werner Lemberg  <wl@gnu.org>
 
 	* docs/CHANGES, docs/release: Updated.
 
 2009-10-10  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/pcf/pcfread.c (pcf_get_properties): Fix a bug in the nprops
 	truncation.  Reported by Martin von Gagern and Peter Volkov.
 	https://bugs.gentoo.org/288357 and https://bugs.gentoo.org/288256
 
 2009-10-06  Werner Lemberg  <wl@gnu.org>
 
 	* Version 2.3.10 released.
 	==========================
 
 
 	Tag sources with `VER-2-3-10'.
 
 	* builds/toplevel.mk (major, minor, patch): Fix regexp to allow more
 	than a single digit.
 	(dist): We now use git.
 
 	* docs/VERSION.DLL: Update documentation and bump version number to
 	2.3.10.
 
 	* README, Jamfile (RefDoc), builds/win32/visualc/index.html,
 	builds/win32/visualc/freetype.dsp,
 	builds/win32/visualc/freetype.vcproj,
 	builds/win32/visualce/index.html,
 	builds/win32/visualce/freetype.dsp,
 	builds/win32/visualce/freetype.vcproj: s/2.3.9/2.3.10/, s/239/2310/.
 
 	* include/freetype/freetype.h (FREETYPE_PATCH): Set to 10.
 
 	* builds/unix/configure.raw (version_info): Set to 9:21:3.
 
 2009-10-06  Werner Lemberg  <wl@gnu.org>
 
 	Fix `make multi'.
 
 	* src/cache/ftccache.c, src/cache/ftcsbits.c (FT_COMPONENT): Define.
 
 	* src/sfnt/sfdriver.c: Include FT_INTERNAL_DEBUG_H.
 
 2009-09-27  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	[cache] Fix Savannah bug #27441, clean up Redhat bugzilla #513582.
 	Tricky casts in FTC_{CACHE,GCACHE,MRULIST}_LOOKUP_CMP() are removed.
 	Now these functions should be called with FTC_Node or FTC_MruNode
 	variable, and the caller should cast them to appropriate pointers to
 	concrete data.  These tricky casts can GCC-4.4 optimizer (-O2)
 	confused and the crashing binaries are generated.
 
 	* src/cache/ftcmru.h (FTC_MRULIST_LOOKUP_CMP): Drop tricky cast.
 	Now the 4th argument `node' of this function should be typed as
 	FTC_MruNode.
 
 	* src/cache/ftcglyph.h (FTC_GCACHE_LOOKUP_CMP): For inline
 	implementation, new temporal variable FTC_MruNode `_mrunode' to take
 	the pointer from FTC_MRULIST_LOOKUP_CMP().  For non-inline
 	implementation, tricky cast is dropped.
 
 	* src/cache/ftcmanag.c (FTC_SIZE_NODE): New macro casting
 	to FTC_SizeNode.
 	(FTC_Manager_LookupSize): Replace FTC_SizeNode `node' by FTC_MruNode
 	`mrunode', and FTC_SIZE_NODE() is inserted.
 	(FTC_FACE_NODE): New macro casting to FTC_FaceNode.
 	(FTC_Manager_LookupFace) Replace FTC_FaceNode `node' by FTC_MruNode
 	`mrunode', and FTC_FACE_NODE() is inserted.
 
 	* src/cache/ftcbasic.c (FTC_ImageCache_Lookup): Change the type of
 	`node' from FTC_INode to FTC_Node.  Extra casting macro FTC_NODE()
 	is dropped.
 	(FTC_ImageCache_LookupScaler): Ditto.
 	(FTC_SBitCache_Lookup): Change the type of `node' from FTC_SNode to
 	FTC_Node.  Extra casting macro FTC_NODE() is dropped.  FTC_SNODE()
 	is inserted.
 	(FTC_SBitCache_LookupScaler): Ditto.
 
 	* src/cache/ftccmap.c (FTC_CMapCache_Lookup): Change the type of
 	`node' from FTC_CMapNode to FTC_Node.  Extra casting macro
 	FTC_NODE() is dropped, FTC_CMAP_NODE() is inserted.
 
 2009-09-25  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	[cache, psaux, type1] Fix for multi build.
 	In multi build, some cpp functions are left as unresolved symbols.
 
 	* src/cache/ftcbasic.c: Include FT_INTERNAL_DEBUG_H for FT_TRACE1().
 
 	* src/psaux/t1decode.c: Include FT_INTERNAL_CALC_H for
 	FIXED_TO_INT().
 	* src/type1/t1gload.c: Ditto.
 	* src/type1/t1objs.c: Ditto.
 
 2009-09-25  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	[autofit] Fix for multi build.
 
 	* src/autofit/afmodule.h: Include FT_INTERNAL_OBJECTS_H to use
 	FT_DECLARE_MODULE() macro in multi build.
 
 	* src/autofit/aflatin.c: Include <ft2build.h> to handle
 	FT_ADVANCES_H correctly in multi build.
 
 2009-09-24  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	[cache] Check the face filled by FTC_Manager_LookupFace().
 
 	* src/cache/ftcbasic.c (ftc_basic_family_get_count): Return
 	immediately if FTC_Manager_LookupFace() fills face by NULL.  Such
 	case can occur when the code is optimized by GCC-4.2.x.
 
 2009-09-23  Werner Lemberg  <wl@gnu.org>
 
 	* docs/CHANGES: Updated.
 
 2009-09-12  Werner Lemberg  <wl@gnu.org>
 
 	[raster] Fix 5-levels grayscale output.
 	This was broken since version 2.3.0.
 
 	* src/raster/ftraster.c (count_table): Use pre-2.3.0 values (which
 	were then computed dynamically).
 	(Vertical_Gray_Sweep_Step): Updated.
 
 	(ft_black_render): Initialize `worker->gray_lines' (problem found by
 	valgrind).
 
 	(FT_RASTER_OPTION_ANTI_ALIASING, DEBUG_RASTER): Dont' #undef, just
 	comment out.
 
 2009-09-12  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Improve configure.raw for cross build.
 
 	* builds/unix/configure.raw: Remove temporal files created by the
 	suffix checking for CC_BUILD.  Set XX_ANSIFLAGS and XX_CFLAGS when
 	cross compiler is GCC.  AC_PROG_CC checks whether the cross compiler
 	is GCC, its result is stored in GCC.
 
 2009-09-12  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	[BDF] Modify hash API to take size_t value instead of void *.
 
 	The hash API in BDF driver is designed to be generic, it takes
 	void * typed data.  But BDF driver always gives an unsigned long
 	integer (the index to a property).  To reduce non-essential
 	casts from unsigned long to void* and from void* to unsigned
 	long, the hash API is changed to take size_t integer.
 	The issue of incompatible cast between unsigned long and void*
 	on LLP64 platform is reported by NightStrike from MinGW-Win64
 	project.  See
 	http://lists.gnu.org/archive/html/freetype/2009-09/msg00000.html
 
 	* src/bdf/bdf.h: The type of hashnode->data is changed from
 	void* to size_t.
 
 	* src/bdf/bdflib.c (hash_insert): Get size_t data, instead of
 	void* data.
 	(bdf_create_property): Get the name length of new property by
 	size_t variable, with a cut-off at FT_ULONG_MAX.
 	(_bdf_set_default_spacing): Get the name length of the face by
 	size_t variable, with a cut-off at 256.
 	(bdf_get_property): Get the property id by size_t variable to
 	reduce the casts between 32-bit prop ID & hashnode->data during
 	simple copying.
 	(_bdf_add_property): Ditto.
 	(_bdf_parse_start): Calculate the index to the property array
 	by size_t variable.
 	(bdf_get_font_property): Drop a cast to unsigned long.
 
 2009-09-10  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	[Win64] Improve the computation of random seed from stack address.
 
 	On LLP64 platform, the conversion from pointer to FT_Fixed need
 	to drop higher 32-bit.  Explict casts are required. Reported by
 	NightStrike from MinGW-w64 project.  See
 	http://lists.gnu.org/archive/html/freetype/2009-09/msg00000.html
 
 	* src/cff/cffgload.c: Convert the pointers to FT_Fixed explicitly.
 
 	* src/psaux/t1decode.c: Ditto.
 
 
 2009-09-03  Werner Lemberg  <wl@gnu.org>
 
 	[raster] Improvements for stand-alone mode.
 
 	* src/raster/rules.mk: Don't handle ftmisc.h.  It is needed for
 	stand-alone mode only.
 
 	* src/raster/ftmisc.h (FT_MemoryRec , FT_Alloc_Func, FT_Free_Func,
 	FT_Realloc_Func): Copy declarations from ftsystem.h.
 
 2009-09-02  Bram Tassyns  <bramt@enfocus.be>
 
 	Improve vertical metrics calculation (Savannah bug #27364).
 
 	The calculation of `vertBearingX' is not defined in the OTF font
 	spec so FreeType does a `best effort' attempt.  However, this value
 	is defined in the PDF and PostScript specs, and that algorithm is
 	better than the one FreeType currently uses:
 
 	  FreeType: Use the middle of the bounding box as the X coordinate
 	            of the vertical origin.
 
 	  Adobe PDF spec: Use the middle of the horizontal advance vector as
 	                  the X coordinate of the vertical origin.
 
 	FreeType's algorithm goes wrong if you have a really small glyph
 	(like the full-width, circle-like dot at the end of the sentence, as
 	used in CJK scripts) with large bearings.  With the FreeType
 	algorithm this dot gets centered on the baseline; with the PDF
 	algorithm it gets the correct location (in the top right).  Note
 	that this is a serious issue, it's like printing the dot at the end
 	of a Roman sentence at the center of the textline instead of on the
 	baseline like it should. So i believe the PDF spec's algorithm
 	should be used in FreeType as well.
 
 	The `vertBearingY' value for such small glyphs is also very strange
 	if no `vmtx' information is present, since the height of the bbox is
 	not representable for the height of the glyph visually (the
 	whitespace up to the baseline is part of the glyph).  The fix also
 	includes some code for a better estimate of `vertBearingY'.
 
 	* src/base/ftobjs.c (ft_synthesize_vertical_metrics): `vertBearingX'
 	is now calculated as described by the Adobe PDF Spec.  Estimate for
 	`vertBearingY' now works better for small glyphs completely above or
 	below the baseline into account.
 
 	* src/cff/cffgload.c (cff_slot_load): `vertBearingX' is now
 	calculated as described by the Adobe PDF Spec.  Vertical metrics
 	information was always ignored when FT_CONFIG_OPTION_OLD_INTERNALS
 	was not defined.
 
 	* src/truetype/ttgload.c (compute_glyph_metrics): `vertBearingX' is
 	now calculated as described by the Adobe PDF Spec.
 
 2009-09-01  John Tytgat  <John.Tytgat@esko.com>
 
 	Fix custom cmap for empty Type 1 font (Savannah bug #27294).
 
 	* include/freetype/internal/t1types.h (T1_EncodingRecRec_): Update
 	comment to reflect revised code_last meaning.
 	* src/type1/t1load.c (T1_Open_Face), src/type42/t42objs.c
 	(T42_Open_Face): Assign max_char as highest character code + 1 and
 	use this for T1_EncodingRecRec_::code_last.
 	* src/psaux/t1cmap.c (t1_cmap_custom_init): Follow revised
 	T1_EncodingRecRec_::code_last meaning.
 
 2009-08-25  Werner Lemberg  <wl@gnu.org>
 
 	Fix rendering of horizontally compressed CFFs.
 	Bug reported by Ivan Nincic <inincic@pdftron.com>.
 
 	* src/cff/cffgload.c (cff_slot_load): Thinko: Check `xx' element of
 	`font_matrix' also.
 
 	* docs/CHANGES: Updated.
 
 2009-08-03  suyu0925@gmail.com
 
 	Don't call `ft_fseek' every time when executing `ft_fread'.
 
 	* src/base/ftstream.c (FT_Stream_Seek), src/base/ftsystem.c
 	(ft_ansi_stream_io): Implement it.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	sfnt: Cast a charcode to 32-bit in cmap format 14 parser.
 	
 	* src/sfnt/ttcmap.c (tt_cmap14_char_var_index,
 	tt_cmap14_char_var_isdefault, tt_cmap14_char_variants,
 	tt_cmap14_variant_chars): Correct mismatches from
 	FT_CMap_CharVarIndexFunc prototype, FT_ULong arguments
 	are replaced by FT_UInt32 arguments.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	sfnt: Cast a charcode to 32-bit in cmap format 12 parser.
 
 	* src/sfnt/ttcmap.c (tt_cmap12_char_next):
 	Insert explicit cast from FT_UFast to FT_UInt32
 	for return value.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	psaux: Fix a few casts to FT_Int32 value.
 
 	* src/psaux/t1decode.c (t1_decoder_parse_charstrings):
 	Fix a few casts setting `value' from FT_Long to FT_Int32,
 	because `value' is typed as FT_Int32 since 2009-06-22.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	sfnt: Fix a data type mismatching with its source.
 
 	* src/sfnt/ttcmap.c (tt_cmap13_char_next): Fix the
 	type of `gindex' from FT_ULong to FT_UInt because
 	it is set by FT_UInt tt_cmap13_char_map_binary() or
 	TT_CMap13->cur_gindex.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	sfnt: Extend a few local variables to load 32-bit values.
 
 	* src/sfnt/ttkern.c (tt_face_load_kern): Extend `count'
 	and `kern' to load 32-bit values.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	pfr: Extend `num_aux' to take 32-bit value.
 
 	* src/pfr/pfrload.c (pfr_phy_font_load): Extend
 	`num_aux' to load 32-bit value.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	pcf: Truncate FT_ULong `nprops' to fit to int PCF_Face->nprops.
 
 	* src/pcf/pcfread.c (pcf_get_properties): Load `nprops'
 	as FT_ULong value from PCF file, but truncate it as
 	int to fit PCF_Face->nprops.  The number of truncated
 	properties is shown in the trace message.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	gxvalid: Extend a few local variables to reduce the casts.
 
 	* src/gxvalid/gxvmorx.c (gxv_morx_subtables_validate):
 	Extend `type' and `rest' to take FT_ULong values.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	gxvalid: Extend `settingTable' to take 32-bit offset.
 
 	* src/gxvalid/gxvfeat.c (gxv_feat_name_validate):
 	Extend `settingTable' to take 32-bit offset.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	autofit: Cast FT_Long glyph_count to compare with FT_UInt GID.
 
 	* src/autofit/afglobal.c (af_face_globals_is_digit,
 	af_face_globals_compute_script_coverage): Cast FT_Long
 	globals->glyph_count to FT_ULong, to compare with FT_UInt
 	gindex.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	smooth: Exclude 16-bit system in invalid pitch/height check.
 
 	* src/smooth/ftsmooth.c (ft_smooth_render_generic):
 	pitch and height are typed as FT_UInt but checked to fit
 	16-bit range, to avoid the overflows.  On 16-bit system,
 	this checking inserts a conditional that never occurs.
 
 2009-07-03  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	cff: Type large constants > 0x7FFF as long for 16-bit systems.
 
 	* src/cff/cffload.c (cff_charset_load): Type large
 	constants > 0x7FFF as long, because normal constants
 	are typed signed integer that is less than 0x8000 on
 	16-bit systems.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	base: Remove an unused variable.
 
 	* src/base/ftglyph.c (FT_Glyph_To_Bitmap): Remove an
 	unused variable `library'.  glyph->library is used.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	cache: Check higher bits in flags for non ILP32 systems.
 
 	4 public functions ought to take FT_ULong flags, but take
 	FT_UInt flags. To keep binary compatibility, we drop higher
 	bits on non ILP32 platforms,
 		ILP64 systems: No drop occurs.
 		LP64 systems: Higher bits are not used.
 		16-bit systems: Drop can occur.
 	See
 	http://lists.gnu.org/archive/html/freetype-devel/2008-12/msg00065.html
 	These functions will be refined to take FT_ULong flags in
 	next bump with incompatible API change.
 
 	* src/cache/ftcbasic.c (FTC_ImageCache_Lookup):
 	Check `flags' in `type', the 2nd argument.
 	(FTC_SBitCache_Lookup): Ditto.
 	(FTC_ImageCache_LookupScaler): Check `load_flags',
 	the 3rd argument.
 	(FTC_SBitCache_LookupScaler): Ditto.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	sfnt: Ignore invalid GIDs in glyph name lookup.
 
 	* include/freetype/internal/fttrace.h:
 	New trace module for sfdriver.c is added.
 
 	* src/sfnt/sfdriver.c (sfnt_get_name_index):
 	Restrict glyph name lookup to FT_UInt GID.
 	Genuine TrueType can hold 16-bit glyphs.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	pcf: Fix a comparison between FT_Long and FT_ULong.
 
 	* src/pcf/pcfread.c (pcf_get_bitmaps): Return an error
 	if PCF_Face->nemetrics is negative.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	gxvalid: Guarantee `nFeatureFlags' size up to 32-bit.
 
 	* src/gxvalid/gxvmort.c (gxv_mort_featurearray_validate):
 	Extend the 3rd argument `nFeatureFlags' to FT_ULong.
 	* src/gxvalid/gxvmort.h: Ditto.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	sfnt: Insert explicit cast for LP64 system.
 
 	* src/sfnt/ttkern.c (tt_face_load_kern): Insert
 	cast from unsigned long to FT_UInt32.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	gxvalid: Guarantee `just' table size upto 32-bit.
 
 	* src/gxvalid/gxvjust.c (gxv_just_validate):
 	The type of `offset' is changed from FT_UInt to
 	FT_Offset, for 16-bit platforms.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	gxvalid: Guarantee `trak' table size upto 32-bit.
 
 	* src/gxvalid/gxvtrak.c (gxv_trak_validate):
 	The type of `offset' is changed from FT_UInt to
 	FT_Offset, for 16-bit platforms.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	type1: Fix a data type mismatching with its source.
 
 	* include/freetype/internal/t1types.h: The type of
 	T1_Face->buildchar is matched with T1_Decorder->top.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	pfr: Fix a data type mismatching with its source.
 
 	* src/pfr/pfrtypes.h: The type of PFR_KernItem->offset
 	is extended from FT_UInt32 to FT_Offset, because it is
 	calculated with the pointer difference, in
 	pfr_extra_item_load_kerning_pairs().
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	pfr: Fix a data type mismatching with its source.
 
 	* src/pfr/pfrtypes.h: The type of PFR_PhysFont->chars_offset
 	is extended from FT_UInt32 to FT_Offset, because it is
 	calculated with the pointer difference in pfr_phy_font_load().
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	pfr: Fix a data type mismatching with its source.
 
 	* src/pfr/pfrtypes.h: The type of PFR_PhyFont->bct_offset
 	is extended from FT_UInt32 to FT_Long, because it is
 	loaded by FT_STREAM_POS() in pfr_phy_font_load().
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	smooth: Improve the format in debug message.
 
 	* src/smooth/ftgrays.c (gray_dump_cells): Improve the
 	format specifications to dump variables.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	sfnt: Fix a data type mismatching with its source.
 
 	* src/sfnt/sfobjs.c (sfnt_load_face): The type of
 	local `flags' is matched with FT_Face->face_flags.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	psaux: Fix a data type mismatching with its source.
 
 	* include/freetype/internal/psaux.h: The type of
 	T1_DecorderRec.buildchar is matched with
 	T1_DecorderRec.top.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	truetype: Extend TrueType GX packed deltas to FT_Offset.
 
 	* src/truetype/ttgxvar.c (ft_var_readpackeddeltas):
 	The type of 2nd argument `delta_cnt' is changed from
 	FT_Int to FT_Offset, because its source can be cvt
 	table size calculated from stream position.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	truetype: Extend mmvar_len to hold size_t values.
 
 	* src/truetype/ttgxvar.h: The type of
 	GX_BlendRec.mmvar_len is changed from FT_Int to
 	FT_Offset, because TT_Get_MM_Var() calculates it
 	by sizeof() results.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	truetype: Check invalid function number in IDEF instruction.
 
 	* src/truetype/ttinterp.c (Ins_IDEF): Check
 	if the operand fits to 8-bit opcode limitation.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	truetype: Check invalid function number in FDEF instruction.
 
 	* src/truetype/ttinterp.c (Ins_FDEF): Check
 	if the operand fits 16-bit function number.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	truetype: Truncate the deltas of composite glyph at 16-bit values.
 
 	* src/truetype/ttgload.c (load_truetype_glyph):
 	Insert cast from FT_Long (deltas[i].{x,y}) to
 	FT_Int16 in the summation of deltas[] for composite
 	glyphs.  Because deltas[i] is typed as FT_Pos,
 	its component x, y are typed as FT_Long, but
 	their sources are always FT_Int16 when they are
 	loaded by ft_var_readpackeddeltas().  However,
 	the limitation about the summed deltas is unclear.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	truetype: Truncate the instructions upto 16-bit per a glyph.
 
 	* src/truetype/ttgload.c (TT_Hint_Glyph): Truncate
 	the instructions upto 16-bit length per a glyph.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	truetype: Cast the numerical operands to 32-bit for LP64 systems.
 
 	* src/truetype/ttinterp.c (Ins_SPHIX, INS_MIAP,
 	Ins_MIRP): Insert cast from long (args[], the
 	operands passed to TrueType operator) to FT_Int32
 	(the argument of TT_MulFix14()).
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	truetype: Cast the project vector to 32-bit for LP64 system.
 
 	* src/truetype/ttinterp.c (Project, DualProject):
 	Insert casts from FT_Pos (the arguments `dx', `dy')
 	to FT_UInt32 (the argument to TT_DotFix14()).
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	truetype: Cast the scaling params to 32-bit for LP64 system.
 
 	* src/truetype/ttgload.c (TT_Process_Composite_Component):
 	Insert casts from long (return value of FT_MulFix()) to
 	FT_Int32 (the argument to FT_SqrtFixed()).
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	sfnt: Cast a character code to FT_UInt32 for LP64 system.
 
 	* src/sfnt/ttcmap.c (tt_cmap14_char_map_nondef_binary,
 	tt_cmap14_variants, tt_cmap14_char_variants,
 	tt_cmap14_def_char_count, tt_cmap14_get_def_chars,
 	tt_cmap14_get_nondef_chars, tt_cmap14_variant_chars)
 	Insert casts when FT_UInt32 variable is loaded by
 	TT_NEXT_{UINT24|ULONG}.  Because most of them are
 	compared with FT_UInt32 values in public API, replacing
 	FT_UFast is not recommended.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	sfnt: Cast a character code to FT_UInt32 for LP64 system.
 
 	* src/sfnt/ttcmap.c (tt_cmap4_init, tt_cmap4_next):
 	Insert the casts from unsigned long constant to
 	FT_UInt32.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	sfnt: Extend TT_BDF->strings_size to FT_ULong for huge BDF.
 
 	* include/freetype/internal/tttypes.h: The type
 	of TT_BDF->string_size is extended from FT_UInt32
 	to FT_ULong, because BDF specification does not
 	restrict the length of string.
 	* src/sfnt/ttbdf.c: The scratch variable `strings'
 	to load TT_BDF->string_size is matched with
 	TT_BDF->string_size.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	psaux: Handle the string length by FT_Offset variables.
 
 	* src/psaux/afmparse.c (afm_parser_next_key,
 	afm_tokenize, afm_parse_track_kern,
 	afm_parse_kern_pairs, afm_parse_kern_data,
 	afm_parser_skip_section, afm_parser_parse):
 	The length of key is handled by FT_Offset,
 	instead of FT_UInt.  Although the length of
 	PostScript strings or name object is 16-bit,
 	AFM_STREAM_KEY_LEN() calculates the length
 	from the pointer difference.
 
 	* src/psaux/afmparse.h (afm_parser_next_key):
 	Ditto.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	pcf: Fix some data types mismatching with their sources.
 
 	* src/pcf/pcfread.c (pcf_get_bitmaps): The types
 	of `nbitmaps', `i', `sizebitmaps' are matched with
 	the type of area FT_Bitmap.pitch * FT_Bitmap.rows.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	pcf: Handle the string length by size_t variables.
 
 	* src/pcf/pcfread.c (pcf_interpret_style): The types
 	of nn, len, lengths[4] are changed to size_t, because
 	they are loaded by (or compared with) ft_strlen().
 
 	* src/pcf/pcfutil.c (BitOrderInvert, TwoByteSwap,
 	FourByteSwap): The type of the 2nd argument `nbytes'
 	is changed to size_t, for similarity with ANSI C
 	string functions.
 
 	* src/pcf/pcfdrivr.c (PCF_Glyph_Load): The type of
 	`bytes' is changed to FT_Offset, because it is passed
 	to FT_ALLOC(), via ft_glyphslot_alloc_bitmap().  At
 	least, using unsigned type is better.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	pcf: Fix some data types mismatching with their sources.
 
 	* src/pcf/pcfread.c (pcf_seek_to_table_type,
 	pcf_has_table_type): The type of 3rd argument
 	`ntables' is matched with PCF_Toc->count.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	otvalid: Truncate the glyph index to 16-bit.
 
 	* src/otvalid/otvalid.c (otv_validate): Checks
 	face->num_glyphs does not exceed 16-bit limit,
 	pass FT_UInt num_glyphs to backend functions
 	otv_{GPOS|GSUB|GDEF|JSTF|MATH}_validate().
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	cache: Insert explict casts for LP64 systems.
 
 	* src/cache/ftcbasic.c (FTC_ImageCache_Lookup,
 	FTC_SBitCache_Lookup): The type of FTC_ImageType->width
 	is FT_Int, so the cast to unsigned larger type FT_ULong
 	is introduced for the comparisons with 0x10000L for
 	LP64 platform.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	cache: Fix some data types mismatching with their sources.
 
 	* src/cache/ftccache.h: The type of return value
 	by FTC_Node_WeightFunc function is changed to
 	FT_Offset.  The type of FTC_CacheClass->cache_size
 	is changed to FT_Offset, too.
 
 	* src/cache/ftccback.h (ft_inode_weight,
 	ftc_snode_weight): Ditto.
 
 	* src/cache/ftccmap.c (ftc_cmap_node_weight): Ditto.
 
 	* src/cache/ftcimage.c (ftc_inode_weight,
 	FTC_INode_Weight): Ditto.
 
 	* src/cache/ftcsbits.c (ftc_snode_weight,
 	FTC_SNode_Weight): Ditto.
 
 	* src/cache/ftcmru.h: The type of
 	FTC_MruListClass->node_size is changed to FT_Offset,
 	because it is passed to FT_ALLOC() to specify the
 	size of buffer.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	XXX_cmap_encoding_char_next() return FT_UInt32 values.
 
 	* include/freetype/internal/services/svpscmap.h:
 	The size of the charcode value returned by
 	the function typed PS_Unicodes_CharNextFunc is
 	matched with its input charcode value.
 
 	* src/cff/cffmap.c (cff_cmap_encoding_char_next,
 	cff_cmap_unicode_char_next): Ditto.
 
 	* src/pfr/pfrmap.c (pfr_cmap_encoding_char_next):
 	Ditto.
 
 	* src/psaux/t1cmap.c (t1_cmap_std_char_next,
 	t1_cmap_custom_char_next, t1_cmap_unicode_char_next):
 	Ditto.
 
 	* src/psnames/psmodule.c (ps_unicodes_char_next):
 	Ditto.
 
 	* src/winfonts/winfnt.c (fnt_cmap_char_next):
 	Ditto.
 
 	* src/sfnt/ttcmap.c (tt_cmap0_char_next,
 	tt_cmap2_char_next, tt_cmap4_char_next,
 	tt_cmap6_char_next, tt_cmap10_char_next,
 	tt_cmap12_char_next, tt_cmap13_char_next): Ditto.
 	(tt_cmap14_char_variants): Handle base unicode
 	codepoint by FT_UInt32 variable to avoid overflow
 	on 16-bit platforms.
 	(tt_cmap14_ensure): The type of `num_results' is
 	extend to FT_UInt32, to cover unsigned 32-bit
 	`numVarSelectorRecords' in cmap14 table header.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	truetype: Extend TT_Face->num_locations for broken TTFs.
 
 	* include/freetype/internal/tttypes.h:
 	TT_Face->num_locations are extended from FT_UInt
 	to FT_ULong, to stand with broken huge loca table.
 	Some people insists there are broken TTF including
 	the glyphs over 16-bit limitation, in PRC market.
 	* src/truetype/ttpload.c (tt_face_load_loca):
 	Remove unrequired 16-bit truncation for FT_UInt
 	TT_Face->num_locations.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	smooth: Fix some data types mismatching with their sources.
 
 	* src/smooth/ftgrays.c: The type of `TCoord' is
 	matched to `TPos', because they are mixed in
 	gray_set_cell().  The type of TCell->x is extended
 	to `TPos', because gray_find_cell() sets it by
 	TWorker.ex.  The type of TCell->cover is extended
 	to `TCoord', because gray_render_scanline() adds
 	TCoord value to it.  The type of TWork.cover is matched
 	with TCell->cover.  The types of
 	TWork.{max_cells,num_cells} are changed to FT_PtrDist,
 	because they are calculated from the memory addresses.
 	The type of TWork.ycount is changed to TPos, because
 	it is calculated from TPos variables.
 	(gray_find_cell): The type of `x' is matched with
 	its initial value ras.ex.
 	(gray_render_scanline): The types of `mod', `lift'
 	and `rem' are changed to TCoord, because their values
 	are set with explicit casts to TCoord.  When ras.area
 	is updated by the differential values including
 	`delta', they are explicitly cast to TArea, because
 	the type of `delta' is not TArea but TCoord.
 	(gray_render_line): The type of `mod' is extended
 	from int to TCoord, because (TCoord)dy is added to mod.
 	(gray_hline): The argument `acount' is extended to
 	TCoord, to match with the parameters in the callers.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	cff: Fix some data types mismatching with their sources.
 
 	* src/cff/cffobjs.c (cff_face_init): The type of
 	`scaling' is matched with the scaling parameter
 	in FT_Matrix_Multiply_Scaled() and
 	FT_Vector_Transform_Scaled().
 
 	* src/cff/cffparse.c (cff_parse_real): The type of
 	`power_ten', `scaling', `exponent_add',
 	`integer_length', `fraction_length',
 	`new_fraction_length' and `shift' are matched with
 	the type of `exponent' to avoid unexpected truncation.
 	(cff_parse_fixed_scaled): The type of `scaling' is
 	matched with the `scaling' argument to
 	cff_parse_real().
 	(cff_parse_fixed_dynamic): Ditto.
 	(cff_parse_font_matrix): The type of `scaling' is
 	matched with the `scaling' argument to
 	cff_parse_dynamic().
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	autofit: Fix some data types mismatching with their sources.
 
 	* src/autofit/afglobal.c: Correct the type of
 	AF_FaceGlobalsRec.glyph_count to match with
 	FT_Face->num_glyphs.
 	(af_face_globals_compute_script_coverage):
 	Insert explicit cast to compare
 	FT_Long AF_FaceGlobalsRec.glyph_count versus
 	FT_UInt gindex.  The type of `nn' is changed
 	to scan glyph index upto AF_FaceGlobalsRec.glyph_count.
 	(af_face_globals_get_metrics): The type of `script_max'
 	is changed to cover size_t value.  Insert explicit cast
 	to compare FT_Long AF_FaceGlobalsRec.glyph_count versus
 	FT_UInt gindex.
 
 	* src/autofit/afhints.c (af_axis_hints_new_segment):
 	Insert explicit cast to calculate `big_max' from
 	integer and size_t values.
 	(af_axis_hints_new_edge): Ditto.
 
 	* src/autofit/aflatin.c (af_latin_metrics_init_blues):
 	The type of `best_y' is matched to FT_Vector.y.
 	(af_latin_compute_stem_width): The type of `delta' is
 	matched to `dist' and `org_dist'.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	autofit: Count the size of the memory object by ptrdiff_t.
 
 	* src/autofit/afcjk.c (af_cjk_hint_edges): The
 	number of edges `n_edges' should be counted by
 	FT_PtrDist variable instead of FT_Int.
 
 	* src/autofit/aflatin.c (af_latin_hint_edges):
 	Ditto.
 
 	* src/autofit/aftypes.h: In AF_ScriptClassRec,
 	the size of metric `script_metrics_size' should
 	be counted by FT_Offset variable instead of FT_UInt.
 
 	* src/autofit/afhints.c
 	(af_glyph_hints_align_strong_points): The cursors
 	for the edges `min', `max', `mid' in the memory
 	buffer should be typed FT_PtrDist.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	autofit: Fix for unused variable `first'.
 
 	* src/autofit/afhints.c (af_glyph_hints_reload): Insert
 	FT_UNUSED() to hide the unused variable warning.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Improve bitmap size or pixel variables for 16-bit systems.
 
 	* include/freetype/config/ftstdlib.h: Introduce
 	FT_INT_MIN, to use in signed integer overflow in
 	16-bit and 64-bit platforms.
 	
 	* include/freetype/internal/fttrace.h: Add a tracer
 	to ftsynth.c.
 	
 	* src/base/ftbitmap.c (FT_Bitmap_Embolden): Check
 	invalid strength causing integer overflow on 16-bit
 	platform.
 	
 	* src/base/ftcalc.c (ft_corner_orientation): Change
 	the internal calculation from FT_Int to FT_Long, to
 	avoid an overflow on 16-bit platforms.  The caller of
 	this function should use only the sign of result,
 	so the cast to FT_Int is acceptable.
 	
 	* src/base/ftsynth.c: Introduce a tracer for synth module.
 	(FT_GlyphSlot_Embolden): Check invalid strength causing
 	integer overflow on 16-bit platform.
 	
 	* src/bdf/bdfdrivr.c (BDF_Face_Init): The glyph index
 	in FT2 API is typed as FT_UInt, although BDF driver
 	can handle unsigned long glyph index internally.  To
 	avoid integer overflow on 16-bit platform, too large
 	glyph index should be excluded.
 	(BDF_Glyph_Load): The glyph pitch in FT2 is typed as
 	FT_UInt, although BDF driver can handle unsigned long
 	glyph pitch internally.  To avoid integer overflow on
 	16-bit platform, too large glyph pitch should not be
 	returned.
 	
 	* src/pfr/pfrsbit.c (pfr_slot_load_bitmap): The glyph
 	pitch in FT2 is typed as FT_UInt, although PFR font
 	format can include huge bitmap glyph with 24-bit pitch
 	(however, a glyph spends 16.7 pixel, it's not realistic).
 	To avoid integer overflow on 16-bit platform, huge
 	bitmap glyph should be excluded.
 	
 	* src/smooth/ftgrays.c (gray_hline): As FT_Span.x is
 	truncated to fit its type (16-bit short), FT_Span.y
 	should be truncated to fit its type (FT_Int).
 	
 	* src/cff/cffdrivr.c (cff_get_ros): CFF specification
 	defines the supplement in ROS as a real number.
 	Truncate it to fit public FT2 API.
 	
 	* src/cff/cffparse.c (cff_parse_cid_ros): Warn the
 	supplement if it is truncated or rounded in cff_get_ros().
 	
 	* src/cff/cfftypes.h: Change the type of internal variable
 	`supplement' from FT_Long to FT_ULong to fit the signedness
 	to the type in public API.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	psaux: Prevent invalid arguments to afm_parser_read_vals().
 
 	* src/psaux/afmparse.c (afm_parser_read_vals): Change
 	the type of `n' to prevent negative number how many
 	arguments should be parsed.
 
 	* src/psaux/afmparse.h (afm_parser_read_vals): Ditto.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	base: Prevent some overflows on LP64 systems.
 
 	* src/base/ftadvance.c (FT_Get_Advances): Cast the
 	unsigned long constant FT_LOAD_ADVANCE_ONLY to FT_UInt32
 	for LP64 platforms.
 
 	* src/base/ftcalc.c (FT_Sqrt32): All internal variables
 	are changed to FT_UInt32 from FT_ULong.
 	(FT_MulDiv): Insert casts to FT_Int32 for LP64 platforms.
 	This function is designed for 32-bit integer, although
 	their arguments and return value are FT_Long.
 
 	* src/base/ftobjs.c (FT_Get_Char_Index): Check `charcode'
 	is within unsigned 32-bit integer for LP64 platforms.
 	(FT_Face_GetCharVariantIndex): Check `charcode' and
 	`variantSelector' are within 32-bit integer for LP64
 	platforms.
 	(FT_Face_GetCharsOfVariant): Check `variantSelector' is
 	within unsigned 32-bit integer for LP64 platforms.
 
 	* src/base/fttrigon.c (ft_trig_downscale): The FT_Fixed
 	variable `val' and unsigned long constant FT_TRIG_SCALE
 	are cast to FT_UInt32, when calculates FT_UInt32.
 	(FT_Vector_Rotate): The long constant 1L is cast to
 	FT_Int32 to calculate FT_Int32 `half'.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	cff: Cast the long variables to 32-bit for LP64 systems.
 
 	* src/cff/cffdrivr.c (cff_get_advances): Insert
 	explicit cast to modify a 32-bit flag by unsigned
 	long constant.
 
 	* src/cff/cffobjs.c (cff_face_init): Ditto.
 
 	* src/cff/cffgload.c (cff_decoder_parse_charstrings):
 	Replace the casts to FT_Long by the casts to FT_Int32
 	for LP64 platforms.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	pcf: Improve PCF_PropertyRec.value names on LP64 platforms.
 
 	* src/pcf/pcf.h: In PCF_PropertyRec.value, the member
 	`integer' is replaced by `l', `cardinal' is replaced
 	by `ul', to fix the difference between the name and
 	the types on LP64 platforms.
 
 	* src/pcf/pcfdrivr.c (pcf_get_bdf_property): Reflect
 	PCF_PropertyRec.value change, with appropriate casts
 	to FT_Int32/FT_UInt32.  Their destinations
 	BDF_PropertyRec.{integer|cardinal} are public and
 	explicitly defined as FT_Int32/FT_UInt32.
 
 	* src/pcf/pcfread.c (pcf_get_properties, pcf_load_font):
 	Reflect PCF_PropertyRec.value change.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	pcf: Fix some data types mismatching with their sources.
 
 	* src/pcf/pcfdrivr.c (pcf_cmap_char_index): The type of
 	`code' is matched to PCF_Encoding->enc.
 	(pcf_cmap_char_next): The type of `charcode' is matched
 	to PCF_Encoding->enc.  When *acharcode is set by charcode,
 	an overflow is checked and cast to unsigned 32-bit
 	integer.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	bdf: Improve bdf_property_t.value names for LP64 platforms.
 
 	* src/bdf/bdf.h: In bdf_property_t.value, the member
 	`int32' is replaced by `l', `card32' is replaced by
 	`ul', to fix the difference between the name and the
 	types on LP64 platforms.
 
 	* src/bdf/bdfdrivr.c (BDF_Face_Init): Reflect
 	bdf_property_t.value change.
 	(bdf_get_bdf_property): Reflect bdf_property_t.value
 	change, with appropriate casts to FT_Int32/FT_UInt32.
 	Their destinations BDF_PropertyRec.{integer|cardinal}
 	are public and explicitly defined as FT_Int32/FT_UInt32.
 
 	* src/bdf/bdflib.c (_bdf_add_property): Reflect
 	bdf_property_t.value change.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	bdf: Fix some data types mismatching with their sources.
 
 	* src/bdf/bdrdrivr.c (bdf_cmap_char_index): The type
 	of `code' is matched with BDF_encoding_el->enc.
 	(bdf_cmap_char_next): The type of `charcode' is
 	matched with BDF_encoding_el->enc.  When *acharcode
 	is set by charcode, an overflow is checked and
 	cast to unsigned 32-bit integer.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	autofit: Improve Unicode range definitions.
 
 	* src/autofit/aftypes.h (AF_UNIRANGE_REC): New macro
 	to declare a range by two unsigned 32-bit integer,
 	to avoid 64-bit range definition on LP64 platforms.
 
 	* src/autofit/aflatin.c (af_latin_uniranges): Ditto.
 
 	* src/autofit/aflatin2.c (af_latin2_uniranges): Ditto.
 
 	* src/autofit/afindic.c (af_indic_uniranges): Ditto.
 
 	* src/autofit/afcjk.c (af_cjk_uniranges): Declare
 	the ranges by AF_UNIRANGE_REC.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	smooth: Fix a data type mismatching with its source.
 
 	* src/smooth/ftgrays.c (gray_sweep): The type of
 	`area' is matched with the 3rd argument `area'
 	of gray_hline().
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	smooth: Fix a data type mismatching with its source.
 
 	* src/smooth/ftgrays.c (gray_render_line): The type
 	of `area' is matched with TWorker.area.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	cache: Disable the legacy compatibility if 16-bit system.
 
 	* src/cache/ftcbasic.c (FTC_ImageCache_Lookup): Exclude
 	the legacy behaviour from 16-bit platform, because the
 	current hack cannot detect the caller uses this function
 	via legacy convension.
 	(FTC_SBitCache_Lookup): Ditto.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	cache: Check 32-bit glyph index on 16-bit systems.
 
 	* src/cache/ftcbasic.c (ftc_basic_family_get_count):
 	Check overflow caused by the face including large
 	number of glyphs > 64k.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	cache: Fix some data types mismatching with their sources.
 
 	* src/cache/ftccache.c (ftc_cache_resize): The types of
 	`p', `mask', `count' are matched with FTC_Cache->{p,mask}.
 	(FTC_Cache_Clear): The type of `old_index' is matched to
 	FTC_Cache->{p,mask}.
 
 	* src/cache/ftccache.h (FTC_CACHE_LOOKUP_CMP): The type
 	of `_idx' is matched with FTC_Cache->{p,mask}.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	cache: Fix some data types mismatching with their sources.
 
 	* src/cache/ftcsbits.c (ftc_snode_load): The types
 	of `xadvance' and `yadvance' are matched with
 	FT_GlyphSlot->advance.{x|y}.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	cache: Cast NULL to a required function type explicitly.
 
 	* src/cache/ftcmanag.c (FTC_Manager_RemoveFaceID):
 	Insert explicit cast from NULL to function type.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	fttypes.h: Cast FT_MAKE_TAG output to FT_Tag exlicitly.
 
 	* include/freetype/fttypes.h (FT_MAKE_TAG):
 	Cast the result to FT_Tag.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	psnames: Handle Unicode codepoints by FT_UInt32 variables.
 
 	* src/psnames/psmodule.c (BASE_GLYPH): Cast the result
 	to unsigned 32-bit integer for LP64 platform.
 	(ps_unicode_value): Return the value by unsigned 32-bit
 	integer instead of unsigned long.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	psaux: Use size_t variable to pass the buffer size.
 
 	* src/psaux/psaux.h (to_bytes): The type of `max_bytes'
 	(the argument to pass the buffer size) is changed to
 	size_t, to match with ANSI C string functions.
 
 	* src/psaux/psconv.h (PS_Conv_StringDecode,
 	PS_Conv_ASCIIHexDecode, PS_Conv_EexecDecode): Ditto.
 
 	* src/psaux/psconv.c (PS_Conv_StringDecode,
 	PS_Conv_ASCIIHexDecode, PS_Conv_EexecDecode): Ditto.
 
 	* src/psaux/psobjs.h (ps_parser_to_bytes): Ditto.
 
 	* src/psaux/psobjs.c (ps_parser_to_bytes): Ditto.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	type1: Use size_t variable to pass the string length.
 
 	* psaux.h: The type of `len' (the argument to pass
 	the buffer size to the function in AFM_ParserRec)
 	is changed to size_t, to match with ANSI C string
 	functions.
 
 	* t1afm.c (t1_get_index): Ditto.
 
 	* test_afm.c (dummy_get_index): Ditto.
 
 	* afmparse.c (afm_parser_read_vals): To call
 	AFM_ParserRec.get_index, the length of token
 	`len' is cast to size_t.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	cid: Fix some data types mismatching with their sources.
 
 	* src/cid/cidparse.c (cid_parser_new): The types of
 	`read_len' and `stream_len' are matched to
 	FT_Stream->size.  Unrequired cast is removed.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	cff: Fix for unused variable `rest'.
 
 	* src/cff/cffparse.c (cff_parse_real): Insert
 	FT_UNUSED() to hide the unused variable warning.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	cff: Fix some data types mismatching with their sources.
 
 	* src/cff/cffgload.c (cff_slot_load): The types of	
 	`top_upm' and `sub_upm' are matched with
 	CFF_FontRecDict->units_per_em.
 
 	* src/cff/cffobjs.c (cff_size_select): Ditto.
 	(cff_size_request): Ditto.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	bdf: Fix some data types mismatching with their sources.
 
 	* bdflib.c (_bdf_list_ensure): The type of `num_items'
 	is matched with _bdf_list_t.used.  Also the types of
 	`oldsize', `newsize', `bigsize' are matched too.
 	(_bdf_readstream): `cursor' is used as an offset to
 	the pointer, it should be typed as FT_Offset.  Also
 	the types of `bytes', `start', `end', `avail' are matched.
 
 	* bdfdrivr.c: The type of BDF_CMap->num_encodings is
 	matched with FT_CMap->clazz->size.
 	(bdf_cmap_char_index): The types of `min', `max', `mid'
 	are matched with BDF_CMap->num_encodings.  The type of
 	`result' is matched with encoding->glyph.
 	(bdf_cmap_char_next): Ditto, the type of `code' is
 	matched with BDF_encoding_el.enc.
 	(bdf_interpret_style): The type of `lengths' is changed
 	to size_t, to take the value by ft_strlen().  Also the
 	types of `len', `nn', `mm' are matched.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	sfnt: Count the size of the memory object by ptrdiff_t.
 
 	* src/sfnt/ttbdf.c (tt_face_find_bdf_prop): The type of
 	`peroperty_len' is changed from FT_UInt to FT_Offset,
 	to match with size_t, which is appropriate type for the
 	object in the memory buffer.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	lzw: Count the size of the memory object by ptrdiff_t.
 
 	* src/lzw/ftzopen.h: The types of FT_LzwState->{buf_total,
 	stack_size} are changed from FT_UInt to FT_Offset, to match
 	with size_t, which is appropriate type for the object in
 	the memory buffer.
 
 	* src/lzw/ftzopen.c (ft_lzwstate_stack_grow): The types of
 	`old_size' and `new_size' are changed from FT_UInt to
 	FT_Offset, to match with size_t, which is appropriate type
 	for the object in the memory buffer.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	otvalid: Count the table size on memory by ptrdiff_t.
 
 	* src/otvalid/otvgpos.c (otv_ValueRecord_validate):
 	Change the type of table size from FT_UInt to
 	FT_PtrDist because it is calculated by the memory
 	addresses.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	otvalid: Prevent an overflow by GPOS/GSUB 32b-bit offset.
 
 	* src/otvalid/otvgpos.c (otv_ExtensionPos_validate):
 	Extend ExtensionOffset from FT_UInt to FT_ULong, to
 	cover 32-bit offset on 16-bit platform.
 
 	* src/otvalid/otvgsub.c (otv_ExtensionSubst_validate):
 	Ditto.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	ftobjs.c: Prevent an overflow in glyph index handling.
 
 	* src/base/ftobjs.c (FT_Face_GetCharsOfVariant):
 	Improve the cast in comparison to avoid the truncation.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Improve the variable types in raccess_make_file_name().
 
 	* src/base/ftrfork.c (raccess_make_file_name):
 	Change the type of cursor variable `tmp' to const char*,
 	to prevent the unexpected modification of original pathname.
 	(raccess_make_file_name): Change the type of new_length
 	to size_t.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	ftpatent.c: Fix for unused variable `error'.
 
 	* src/base/ftpatent.c (_tt_check_patents_in_range):
 	Fix warning for unused variable `error'.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	type1: Check invalid string longer than PostScript limit.
 
 	* src/type1/t1afm.c (t1_get_index): Check invalid string
 	which exceeds the limit of PostScript string/name objects.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	gzip: Use FT2 zcalloc() & zfree() in ftgzip.c by default.
 
 	* src/gzip/ftgzip.c (zcalloc, zcfree): Disable all
 	zcalloc() & zfree() by zlib in zutil.c, those in
 	ftgzip.c by FT2 are enabled by default.  To use
 	zlib zcalloc() & zfree(), define USE_ZLIB_ZCALLOC.
 	See discussion:
 	http://lists.gnu.org/archive/html/freetype-devel/2009-02/msg00000.html
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	gzip: Distinguish PureC from TurboC on MSDOS.
 
 	* src/gzip/zutil.c (zcalloc, zcfree): Enable only for
 	MSDOS platform.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	gxvalid: Insert PureC pragma to allow unevaluated variables.
 
 	* builds/atari/ATARI.H: Insert PureC pragma not to
 	warn against set-but-unevaluated variable in gxvalid
 	module.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	gxvalid: Pass the union by the pointer instead of the value.
 
 	* src/gxvalid/gxvcommn.h:
 	  - Declare new type `GXV_LookupValueCPtr'.
 	  - Update the type of the 2nd argument to pass GXV_LookupValueDesc
 	    data to the function prototyped as GXV_Lookup_Value_Validate_Func,
 	    from GXV_LookupValueDesc to GXV_LookupValueCPtr.
 	  - Likewise for the function prototyped as
 	    GXV_Lookup_Fmt4_Transit_Func.
 
 	  - Declare new type `GXV_StateTable_GlyphOffsetCPtr'.
 	  - Update the type of the 3rd argument to pass
 	    GXV_StateTable_GlyphOffsetDesc data to the function prototyped
 	    as GXV_StateTable_Entry_Validate_Func, from
 	    GXV_StateTable_GlyphOffsetDesc to GXV_StateTable_GlyphOffsetCPtr.
 
 	  - Declare new type `GXV_XStateTable_GlyphOffsetCPtr'.
 	  - Update the type of the 3rd argument to pass
 	    GXV_XStateTable_GlyphOffsetDesc data to the function prototyped
 	    as GXV_XStateTable_Entry_Validate_Func,
 	    from GXV_XStateTable_GlyphOffsetDesc
 	    to GXV_XStateTable_GlyphOffsetCPtr.
 
 	* src/gxvalid/gxvcommn.c (gxv_LookupTable_fmt0_validate,
 	gxv_XClassTable_lookupval_validate,
 	gxv_XClassTable_lookupfmt4_transit):
 	Update from GXV_LookupValueDesc to GXV_LookupValueCPtr.
 	
 	* src/gxvalid/gxvbsln.c (gxv_bsln_LookupValue_validate,
 	gxv_bsln_LookupFmt4_transit): Ditto.
 	
 	* src/gxvalid/gxvjust.c
 	(gxv_just_pcTable_LookupValue_entry_validate,
 	gxv_just_classTable_entry_validate,
 	gxv_just_wdcTable_LookupValue_validate): Ditto.
 	
 	* src/gxvalid/gxvkern.c
 	(gxv_kern_subtable_fmt1_entry_validate): Ditto.
 	
 	* src/gxvalid/gxvlcar.c (gxv_lcar_LookupValue_validate,
 	gxv_lcar_LookupFmt4_transit): Ditto.
 	
 	* src/gxvalid/gxvopbd.c (gxv_opbd_LookupValue_validate,
 	gxv_opbd_LookupFmt4_transit): Ditto.
 	
 	* src/gxvalid/gxvprop.c (gxv_prop_LookupValue_validate,
 	gxv_prop_LookupFmt4_transit): Ditto.
 	
 	* src/gxvalid/gxvmort4.c
 	(gxv_mort_subtable_type4_lookupval_validate): Ditto.
 	
 	* src/gxvalid/gxvmort0.c
 	(gxv_mort_subtable_type0_entry_validate): Update
 	from GXV_StateTable_GlyphOffsetDesc
 	to GXV_StateTable_GlyphOffsetCPtr.
 	
 	* src/gxvalid/gxvmort1.c
 	(gxv_mort_subtable_type1_entry_validate): Ditto.
 	
 	* src/gxvalid/gxvmort2.c
 	(gxv_mort_subtable_type2_entry_validate): Ditto.
 	
 	* src/gxvalid/gxvmort5.c
 	(gxv_mort_subtable_type5_entry_validate): Ditto.
 	
 	* src/gxvalid/gxvmorx2.c
 	(gxv_morx_subtable_type2_entry_validate): Ditto.
 	
 	* src/gxvalid/gxvmorx5.c
 	(gxv_morx_subtable_type5_entry_validate): Ditto.
 	
 	* src/gxvalid/gxvmorx1.c
 	(gxv_morx_subtable_type1_entry_validate): Ditto.
 	(gxv_morx_subtable_type1_LookupValue_validate,
 	gxv_morx_subtable_type1_LookupFmt4_transit):
 	Update from GXV_LookupValueDesc to GXV_LookupValueCPtr.
 	
 	* src/gxvalid/gxvmorx0.c
 	(gxv_morx_subtable_type0_entry_validate): Update
 	from GXV_XStateTable_GlyphOffsetDesc
 	to GXV_XStateTable_GlyphOffsetCPtr.
 
 2009-07-29  Fabrice Bellet  <fabrice@bellet.info>
 
 	Fix Redhat bugzilla #513582 and Savannah bug #26849.
 
 	* src/cache/ftccache.h (FTC_CACHE_LOOKUP_CMP) <FTC_INLINE>: Fix
 	aliasing bug.
 
 2009-07-19  Werner Lemberg  <wl@gnu.org>
 
 	Document recent library changes.
 
 	* docs/CHANGES: Do it.
 
 2009-07-17  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #23786.
 
 	* src/truetype/ttobjs.c (tt_size_init_bytecode): Don't reset x_ppem
 	and y_ppem.  Otherwise the `*_CVT_Stretched' functions in ttinterp.c
 	get never called.
 	An anonymous guy suggested this change on Savannah, and it seems to
 	be the right solution.
 
 2009-07-15  Werner Lemberg  <wl@gnu.org>
 
 	* docs/release: Updated.
 
 2009-07-15  Werner Lemberg  <wl@gnu.org>
 
 	README.CVS -> README.git
 
 	* README.CVS: Renamed to...
 	* README.git: This.
 	Updated.
 
 2009-07-15  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Borland C++ compiler patch proposed by Mirco Babin.
 	http://lists.gnu.org/archive/html/freetype/2009-07/msg00016.html.
 
 	* builds/exports.mk: Delete unused flags, CCexe_{CFLAGS,LDFLAGS}.
 	Fix APINAMES_C and APINAMES_EXE pathnames to reflect the platform
 	specific pathname syntax.
 	* builds/compiler/bcc.mk: Remove unused flag, CCexe_LDFLAGS.
 	Define TE = `-e' separately (bcc32 cannot specify the pathname of
 	binary executable by T = `-o').
 	Extend the large page size in linking freetype.lib.
 	Add extra CLEAN target to delete bcc specific temporary files.
 	* builds/compiler/bcc-dev.mk: Ditto.
 
 2009-07-14  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #27026.
 
 	* builds/win32/vc2005/freetype.sln: Use correct version number.
 
 2009-07-12  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Add a script to check the undefined and unused trace macros.
 
 	* src/tools/chktrcmp.py: A script to check trace_XXXX macros
 	that are used in C source but undefined in fttrace.h, or
 	defined in fttrace.h but unused in C sources.  See
 	http://lists.gnu.org/archive/html/freetype-devel/2009-07/msg00013.html.
 	* docs/DEBUG: Mention on chktrcmp.py.
 	* docs/release: Ditto.
 
 2009-07-09  Werner Lemberg  <wl@gnu.org>
 
 	[ftraster] Make it compile again with -D_STANDALONE_.
 
 	* src/raster/ftraster.c [_STANDALONE_]: Define
 	FT_CONFIG_STANDARD_LIBRARY_H.
 	Include `string.h'.
 	Don't include `rastpic.h'.
 	Define FT_DEFINE_RASTER_FUNCS.
 
 2009-07-09  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	smooth: Check glyph size by width/height, instead of pitch/height.
 	Suggested by der Mouse <mouse@Rodents-Montreal.ORG>.
 
 	* src/smooth/ftsmooth.c (ft_smooth_render_generic): Improve
 	the check for too large glyph.  Replace the pair of `pitch' and
 	`height' by the pair of `width' and `height'.  `pitch' cannot
 	be greater than `height'.  The required is checking the product
 	`pitch' * `height' <= FT_ULONG_MAX, but we use cheap checks for
 	the realistic case only.
 
 2009-07-09  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Register 2 missing trace components, t1afm and ttbdf.
 
 	* include/freetype/internal/fttrace.h: Add FT_TRACE_DEF( t1afm )
 	and FT_TRACE_DEF( ttbdf ).  See
 	http://lists.gnu.org/archive/html/freetype-devel/2009-07/msg00013.html
 
 2009-07-09  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Register a trace component for ftgloadr.c.
 
 	* include/freetype/internal/fttrace.h: Add FT_TRACE_DEF( gloader ).
 	The macro `trace_gloader' was already used in the initial version
 	on 2002-02-24.
 
 2009-07-08  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Prevent the overflows by a glyph with too many points or contours.
 	The bug is reported by Boris Letocha <b.letocha@gmc.net>.  See
 	http://lists.gnu.org/archive/html/freetype-devel/2009-06/msg00031.html
 	http://lists.gnu.org/archive/html/freetype-devel/2009-07/msg00002.html	
 
 	* include/freetype/ftimage.h (FT_OUTLINE_CONTOURS_MAX,
 	FT_OUTLINE_POINTS_MAX): New macros to declare the maximum
 	values of FT_Outline.{n_contours,n_points}.
 	* src/base/ftgloadr.c (FT_GlyphLoader_CheckPoints): Check the
 	total numbers of points and contours cause no overflows in
 	FT_Outline.{n_contours,n_points}.
 
 	* include/freetype/internal/ftgloadr.h (FT_GLYPHLOADER_CHECK_P,
 	FT_GLYPHLOADER_CHECK_C): Compare the numbers of points and
 	contours as unsigned long number, instead of signed int, to
 	prevent the overflows on 16-bit systems.
 
 2009-07-05  Bram Tassyns  <bramt@enfocus.be>
 
 	Improve compatibility to Acroread.
 	This fixes Savannah bug #26944.
 
 	* src/cff/cffload.c (cff_charset_compute_cids): For multiple GID to
 	single CID mappings, make the lowest value win.
 
 2009-06-28  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	ftpatent: Fix a bug by wrong usage of service->table_info().
 	http://lists.gnu.org/archive/html/freetype-devel/2008-12/msg00039.html
 
 	* include/freetype/internal/services/svsfnt.h: Extend
 	FT_SFNT_TableInfoFunc() to take new argument to obtain the offset
 	to the specified table.
 	* src/sfnt/sfdriver.c (sfnt_table_info): Extend to return the
 	table-offset to the caller function.
 	* src/base/ftpatent.c (_tt_check_patents_in_table): Use new
 	service->table_info().
 	* src/base/ftobjs.c (FT_Sfnt_Table_Info): Synchronize to new
 	service->table_info().
 
 2009-06-28  Werner Lemberg  <wl@gnu.org>
 
 	[psaux, cff] Protect against nested `seac' calls.
 
 	* include/freetype/internal/psaux.h (T1_Decoder), src/cff/cffgload.h
 	(CFF_Decoder): Add `seac' boolean variable.
 
 	* src/cff/cffgload.c (cff_operator_seac), src/psaux/t1decode.c
 	(t1operator_seac): Use it.
 
 2009-06-28  Werner Lemberg  <wl@gnu.org>
 
 	Thinko.
 
 	* src/psaux/t1decode.c (t1operator_seac)
 	[FT_CONFIG_OPTION_INCREMENTAL]: Test for existence of incremental
 	interface.
 
 2009-06-28  Werner Lemberg  <wl@gnu.org>
 
 	* devel/ftoption.h [FT_CONFIG_OPTION_INCREMENTAL]: Define.
 
 2009-06-27  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Add tools to preprocess the source files for AtariST PureC.
 
 	* builds/atari/deflinejoiner.awk: New file to filter C source files
 	for broken C preprocessor of PureC compiler.
 
 	* builds/atari/gen-purec-patch.sh: New file to generate a patch set
 	for PureC, by using deflinejoiner.awk.
 
 2009-06-27  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Keep existing modules.cfg in the building tree.
 
 	* configure: If `configure' is executed outside of the source tree,
 	an existing `modules.cfg' file in the build directory should be
 	kept, not overwritten by the version in the source tree.
 
 2009-06-27  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Filter --srcdir= option before invoking builds/unix/configure.
 
 	* configure: If builds/unix/configure is invoked with --srcdir
 	option, the option should take `builds/unix' directory instead of
 	the top source directory.  Thus the configure script in the top
 	directory should modify the --srcdir= option if
 	`builds/unix/configure' is invoked.
 
 2009-06-27  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Improve configure.raw for cross-building on exe-suffixed systems.
 
 	* builds/unix/configure.raw: Fix a bug in sed script to extract
 	native suffix for binary executables, patch by Peter Breitenlohner.
 	http://lists.gnu.org/archive/html/freetype-devel/2009-04/msg00036.html
 
 2009-06-26  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Remove TT_SubGlyphRec.
 
 	* src/truetype/ttobjs.h (TT_SubGlyphRec): Removed, unused.
 
 2009-06-26  Werner Lemberg  <wl@gnu.org>
 
 	* */*: For warning messages, replace FT_ERROR with FT_TRACE0.
 
 	FT_ERROR is now used only if a function produces a non-zero `error'
 	value.
 
 	Formatting, improving and harmonizing debug strings.
 
 2009-06-25  Werner Lemberg  <wl@gnu.org>
 
 	Provide version information better.
 
 	* src/base/ftinit.c (FT_Init_FreeType): Don't set version here
 	but...
 	* src/base/ftobjs.c (FT_New_Library): Here.
 
 2009-06-22  Werner Lemberg  <wl@gnu.org>
 
 	Use 16.16 format while parsing Type 1 charstrings.
 	This fixes Savannah bug #26867.
 
 	Previously, only integers have been used which can lead to serious
 	rounding errors.
 
 	However, fractional values are only used internally; after the
 	charstrings (of either Type 1 or 2) have been processed, the
 	resulting coordinates get rounded to integers currently -- before
 	applying scaling.  This should be fixed; at the same time a new load
 	flag should be introduced, to be used in combination with
 	FT_LOAD_NO_SCALE, which indicates that font units are returned in
 	16.16 format.  Similarly, the incremental interface should be
 	extended to allow fractional values for metrics.
 
 	* include/freetype/internal/psaux.h (T1_BuilderRec): Remove `shift'
 	field.
 	* include/freetype/internal/pshints.h (T1_Hints_SetStemFunc,
 	T1_Hints_SetStem3Func): Use FT_Fixed for coordinates.
 
 	* src/psaux/psobjs.c: Include FT_INTERNAL_CALC_H.
 	(t1_build_add_point): Always convert fixed to integer.
 	* src/psaux/t1decode.c (t1_decoder_parse_charstrings):
 	Use 16.16 format everywhere (except for large integers followed by a
 	`div').
 	[CAN_HANDLE_NON_INTEGRAL_T1_OPERANDS]: Remove #ifdef and activate
 	code uncoditionally.
 	Add support for random numbers and update remaining code
 	accordingly; this should work now.
 	(t1_operator_seac): Updated.
 	* src/psaux/pshrec.c: Include FT_INTERNAL_CALC_H.
 	(ps_hints_t1stem3, t1_hints_stem): Updated.
 
 	* src/cid/cidgload.c: Include FT_INTERNAL_CALC_H.
 	(cid_load_glyph) [FT_CONFIG_OPTION_INCREMENTAL],
 	(cid_face_compute_max_advance, cid_slot_load_glyph): Updated.
 
 	* src/type1/t1gload.c (T1_Parse_Glyph_And_Get_Char_String)
 	[FT_CONFIG_OPTION_INCREMENTAL], (T1_Get_Advances, T1_Load_Glyph):
 	Updated.
 	* src/type1/t1load.c: Include FT_INTERNAL_CALC_H.
 	* src/type1/t1objs.c (T1_Face_Init): Updated.
 
 2009-06-21  Werner Lemberg  <wl@gnu.org>
 
 	* src/pshinter/pshrec.c: Use PSH_Err_Ok.
 
 2009-06-21  Werner Lemberg  <wl@gnu.org>
 
 	Code beautification.
 
 	* src/type1/t1load.c (FT_INT_TO_FIXED): Removed.
 	Replace everywhere with INT_TO_FIXED.
 	(FT_FIXED_TO_INT): Move to ...
 	* include/freetype/internal/ftcalc.h (FIXED_TO_INT): Here.
 	Update all users.
 
 2009-06-20  Werner Lemberg  <wl@gnu.org>
 
 	Remove unused variables.
 
 	* include/freetype/internal/psaux.h (T1_BuilderRec),
 	src/cff/cffgload.h (CFF_Builder): Remove `last'.
 	Update all users.
 
 2009-06-20  Werner Lemberg  <wl@gnu.org>
 
 	[psaux] Check large integers while parsing charstrings.
 
 	* src/psaux/t1decode.c (t1_decoder_parse_charstrings): Large
 	integers must be followed by a `div' operator.
 
 2009-06-20  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Revert last change.
 
 	* src/cff/cffgload.c (cff_decoder_parse_charstrings): Do it.
 	Next time, don't confuse Type 2 charstring opcodes with TOP DICT
 	values...
 
 2009-06-20  Werner Lemberg  <wl@gnu.org>
 
 	* src/autofit/aflatin.c (af_latin_metrics_check_digits): Fix
 	compiler warning.
 
 2009-06-20  Werner Lemberg  <wl@gnu.org>
 
 	* builds/compiler/gcc.mk (CFLAGS): Use -O3, not -O6.
 
 2009-06-19  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Fix handling of reserved byte 0xFF.
 
 	* src/cff/cffgload.c (cff_decoder_parse_charstrings): Abort if byte
 	0xFF is encountered.
 
 2009-06-19  Werner Lemberg  <wl@gnu.org>
 
 	Improve debug messages for Type1 charstrings.
 
 	* src/psaux/t1decode.c (t1_decoder_parse_charstrings): Emit newlines
 	after instructions.
 	Prettify output.
 
 2009-06-19  Werner Lemberg  <wl@gnu.org>
 
 	More ftgray fixes for FT_STATIC_RASTER.
 	Problems reported by suyu@cooee.cn.
 
 	* src/smooth/ftgrays.c (gray_move_to, gray_raster_render): Use
 	RAS_VAR.
 
 2009-06-18  Werner Lemberg  <wl@gnu.org>
 
 	* docs/CHANGES: Updated.
 
 2009-06-18  Werner Lemberg  <wl@gnu.org>
 
 	Fix B/W rasterization of subglyphs with different drop-out modes.
 
 	Normally, the SCANMODE instruction (if present) to set the drop-out
 	mode in a TrueType font is located in the `prep' table only and thus
 	valid for all glyphs.  However, there are fonts like `pala.ttf'
 	which additionally contain this instruction in the hinting code of
 	some glyphs (but not all).  As a result it can happen that a
 	composite glyph needs multiple drop-out modes for its subglyphs
 	since the rendering state gets reset for each subglyph.
 
 	FreeType collects the hinted outlines from all subglyphs, then it
 	sends the data to the rasterizer.  It also sends the drop-out mode
 	-- after hinting has been applied -- and here is the error: It sends
 	the drop-out mode of the last subglyph only; drop-out modes of all
 	other subglyphs are lost.
 
 	This patch fixes the problem; it adds a second, alternative
 	mechanism to pass the drop-out mode: For each contour, the
 	rasterizer now checks the first `tags' array element.  If bit 2 is
 	set, bits 5-7 contain the contour's drop-out mode, overriding the
 	global drop-out mode.
 
 	* include/freetype/ftimage.h (FT_CURVE_TAG_HAS_SCANMODE): New macro.
 
 	* src/truetype/ttgload.c (TT_Hint_Glyph): Store drop-out mode in
 	`tags[0]'.
 
 	* src/raster/ftraster.c (Flow_Up, Overshoot_Top, Overshoot_Bottom):
 	Use bits 3-5 instead of 0-2.
 	(New_Profile): Set the drop-out mode in the profile's `flags' field.
 	(Decompose_Curve): Check `tags[0]' and set `dropOutControl' if
 	necessary.
 	(Vertical_Sweep_Drop, Horizontal_Sweep_Drop,
 	Horizontal_Gray_Sweep_Drop, Draw_Sweep): Use the profile's drop-out
 	mode.
 
 2009-06-16  Werner Lemberg  <wl@gnu.org>
 
 	Improve scan conversion rules 4 and 6.
 
 	Two new constraints are introduced to better identify a `stub' -- a
 	concept which is only vaguely described in the OpenType
 	specification.  The old code was too rigorous and suppressed more
 	pixel than it should.
 
 	  . The intersection of the two profiles with the scanline is less
 	    than a half pixel.  Code related to this was already present in
 	    the sources but has been commented out.
 
 	  . The endpoint of the original contour forming a profile has a
 	    distance (`overshoot') less than half a pixel to the scanline.
 
 	Note that the two additional conditions fix almost all differences
 	to the Windows rasterizer, but some problematic cases remain.
 
 	* src/raster/ftraster.c (Overshoot_Top, Overshoot_Bottom): New
 	macros for the `flags' field in the `TProfile' structure.
 	(IS_BOTTOM_OVERSHOOT, IS_TOP_OVERSHOOT): New macros.
 	(New_Profile, End_Profile): Pass overshoot flag as an argument and
 	set it accordingly.
 	Update callers.
 	(Vertical_Sweep_Drop, Horizontal_Sweep_Drop): Implement the two new
 	constraints.
 
 2009-06-11  Werner Lemberg  <wl@gnu.org>
 
 	Increase precision for B/W rasterizer.
 
 	* src/raster/ftraster.c (Set_High_Precision): Add two more bits to
 	the precision.  This corrects rendering of some small glyphs, for
 	example, glyph `xi' in verdana.ttf at 13 ppem.  Testing with ftbench
 	on my GNU/Linux box I don't see a performance degradation.
 
 2009-06-08  Michael Zucchi  <notzed@gmail.com>
 
 	Handle FT_STROKER_LINECAP_BUTT.
 	This fixes Savannah bug #26757.
 
 	* src/base/ftstroke.c (ft_stroker_cap): Implement it.
 
 2009-06-07  Harald Fernengel  <harry@kdevelop.org>
 
 	Fix some potential out-of-memory crashes.
 
 	* src/base/ftobjs.c (ft_glyphslot_done): Check `slot->internal'.
 	* src/base/ftstream.c (FT_Stream_ReleaseFrame): Check `stream'.
 	* src/truetype/ttinterp.c (TT_New_Context): Avoid double-free of
 	`exec' in case of failure.
 
 2009-06-07  Werner Lemberg  <wl@gnu.org>
 
 	Simplify math.
 	Suggested by Alexei Podtelezhnikov <apodtele@gmail.com>.
 
 	* src/raster/ftraster.c (Vertical_Sweep_Drop, Horizontal_Sweep_Drop,
 	Horizontal_Gray_Sweep_Drop): Do it.
 
 2009-06-04  Werner Lemberg  <wl@gnu.org>
 
 	Preparation for fixing scan conversion rules 4 and 6.
 
 	* src/raster/ftraster.c (TFlow): Replace enumeration with...
 	(Flow_Up): This macro.
 	(TProfile): Replace `flow' member with `flags' bit field.
 	Update all affected code.
 
 2009-05-29  James Cloos  <cloos@jhcloos.com>
 
 	Enable autohinting for glyphs rotated by multiples of 90°.
 
 	* src/base/ftobjs.c (FT_Load_Glyph): Alter check for permitted
 	matrices to allow rotations by multiples of 90°, not only unrotated,
 	possibly slanted matrices.
 
 2009-05-28  Werner Lemberg  <wl@gnu.org>
 
 	Remove compiler warning.
 	Reported by Krzysztof Kowalczyk <kkowalczyk@gmail.com>.
 
 	* src/autofit/aflatin2.c (af_latin2_hint_edges): Move declaration of
 	`n_edges' into `#if' block.
 
 2009-05-28  Werner Lemberg  <wl@gnu.org>
 
 	Make compilation work with FT_CONFIG_OPTION_USE_ZLIB not defined.
 	Reported by Krzysztof Kowalczyk <kkowalczyk@gmail.com>.
 
 	* src/pcf/pcfdrivr.c (PCF_Face_Init) [!FT_CONFIG_OPTION_USE_ZLIB]:
 	Make it work.
 	Simplify #ifdef logic.
 
 2009-05-22  Werner Lemberg  <wl@gnu.org>
 
 	Improve b/w rasterizer.
 	Problem reported by Krzysztof Kotlenga <pocek@users.sf.net>.
 
 	* src/raster/raster.c (Vertical_Sweep_Drop, Horizontal_Sweep_Drop,
 	Horizontal_Gray_Sweep_Drop): For smart drop-out mode, if
 	intersections are equally distant relative to next pixel center,
 	select the left pixel, not the right one.
 
 2009-05-19  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #26600.
 
 	* src/type42/t42parse.c (t42_load_keyword): Handle
 	T1_FIELD_LOCATION_FONT_EXTRA.
 
 2009-04-30  Werner Lemberg  <wl@gnu.org>
 
 	Document recent changes to ftview.
 
 	* docs/CHANGES: Do it.
 
 2009-04-27  Werner Lemberg  <wl@gnu.org>
 
 	autohinter: Don't change digit widths if all widths are the same.
 	This fixes FreeDesktop bug #21197.
 
 	* src/autofit/afglobal.c (AF_DIGIT): New macro.
 	(af_face_globals_compute_script_coverage): Mark ASCII digits in
 	`glyph_scripts' array.
 	(af_face_globals_get_metrics): Updated.
 	(af_face_globals_is_digit): New function.
 	* src/autofit/afglobal.h: Updated.
 	(AF_ScriptMetricsRec): Add `digits_have_same_width' flag.
 
 	* src/autofit/aflatin.c: Include FT_ADVANCES_H.
 	(af_latin_metrics_check_digits): New function.
 	(af_latin_metrics_init): Use it.
 	* src/autofit/aflatin.h: Updated.
 	* src/autofit/afcjk.c (af_cjk_metrics_init): Updated.
 
 	* src/autofit/aflatin2.c: Similar changes as with aflatin.c.
 
 	* src/autofit/afloader.c (af_loader_load_g): Test digit width.
 
 	* docs/CHANGES: Document it.
 
 2009-04-26  Werner Lemberg  <wl@gnu.org>
 
 	Make ftgrays compile with _STANDALONE_ and FT_STATIC_RASTER again.
 	Problems reported by suyu@cooee.cn.
 
 	* src/smooth/ftgrays.c (FT_DEFINE_OUTLINE_FUNCS,
 	FT_DEFINE_RASTER_FUNCS) [_STANDALONE_]: Define.
 	[!_STANDALONE_]: Include ftspic.h only here.
 	(ras): Define/declare after definition of `TWorker'.
 	Use `RAS_VAR_' where necessary.
 
 2009-04-21  Karl Berry  <karl@gnu.org>
 
 	Fix AC_CHECK_FT2.
 
 	* builds/unix/freetype2.m4: Only check PATH for freetype-config if
 	we did not already find it from a prefix option.
 
 2009-04-05  Oran Agra  <oran@monfort.co.il>
 
 	Add #error to modules and files that do not support PIC yet.
 
 	When FT_CONFIG_OPTION_PIC is defined the following files will
 	create #error:
 	* src/bdf/bdfdrivr.h
 	* src/cache/ftcmanag.c
 	* src/cid/cidriver.h
 	* src/gxvalid/gxvmod.h
 	* src/gzip/ftgzip.c
 	* src/lzw/ftlzw.c
 	* src/otvalid/otvmod.h
 	* src/pcf/pcfdrivr.h
 	* src/pfr/pfrdrivr.h
 	* src/psaux/psauxmod.h
 	* src/type1/t1driver.h
 	* src/type42/t42drivr.h
 	* src/winfonts/winfnt.h
 
 2009-04-05  Oran Agra  <oran@monfort.co.il>
 
 	Position Independent Code (PIC) support in autofit module.
 
 	* include/freetype/internal/autohint.h add macros to init
 	instances of FT_AutoHinter_ServiceRec.
 
 	* src/autofit/afmodule.h declare autofit_module_class
 	using macros from ftmodapi.h,
 	when FT_CONFIG_OPTION_PIC is defined create and destroy
 	functions will be declared.
 	* src/autofit/afmodule.c when FT_CONFIG_OPTION_PIC is defined
 	af_autofitter_service and autofit_module_class structs
 	will have functions to init or create and destroy them
 	instead of being allocated in the global scope.
 	And macros will be used from afpic.h in order to access them.
 
 	* src/autofit/aftypes.h add macros to init and declare
 	instances of AF_ScriptClassRec.
 
 	* src/autofit/afcjk.h declare af_cjk_script_class
 	using macros from aftypes.h,
 	when FT_CONFIG_OPTION_PIC is defined init function will be declared.
 	* src/autofit/afcjk.c when FT_CONFIG_OPTION_PIC is defined
 	af_cjk_script_class struct will have function to init it instead of
 	being allocated in the global scope.
 
 	* src/autofit/afdummy.h declare af_dummy_script_class
 	using macros from aftypes.h,
 	when FT_CONFIG_OPTION_PIC is defined init function will be declared.
 	* src/autofit/afdummy.c when FT_CONFIG_OPTION_PIC is defined
 	af_dummy_script_class struct will have function to init it instead of
 	being allocated in the global scope.
 
 	* src/autofit/afindic.h declare af_indic_script_class
 	using macros from aftypes.h,
 	when FT_CONFIG_OPTION_PIC is defined init function will be declared.
 	* src/autofit/afindic.c when FT_CONFIG_OPTION_PIC is defined
 	af_indic_script_class struct will have function to init it instead of
 	being allocated in the global scope.
 
 	* src/autofit/aflatin.h declare af_latin_script_class
 	using macros from aftypes.h,
 	when FT_CONFIG_OPTION_PIC is defined init function will be declared.
 	* src/autofit/aflatin.c when FT_CONFIG_OPTION_PIC is defined
 	af_latin_script_class struct will have function to init it instead of
 	being allocated in the global scope.
 	Change af_latin_blue_chars to be PIC-compatible by being a two
 	dimentional array rather than array of pointers.
 
 
 	* src/autofit/aflatin2.h declare af_latin2_script_class
 	using macros from aftypes.h,
 	when FT_CONFIG_OPTION_PIC is defined init function will be declared.
 	* src/autofit/aflatin2.c when FT_CONFIG_OPTION_PIC is defined
 	af_latin2_script_class struct will have function to init it instead of
 	being allocated in the global scope.
 	Change af_latin2_blue_chars to be PIC-compatible by being a two
 	dimentional array rather than array of pointers.
 
 	* src/autofit/afglobal.c when FT_CONFIG_OPTION_PIC is defined
 	af_script_classes array initialization was moved to afpic.c and
 	is later refered using macros defeined in afpic.h.
 
 	New Files:
 	* src/autofit/afpic.h declare struct to hold PIC globals for autofit
 	module and macros to access them.
 	* src/autofit/afpic.c implement functions to allocate, destroy and
 	initialize PIC globals for autofit module.
 
 	* src/autofit/autofit.c add new file to build: afpic.c.
 	* src/autofit/jamfile add new files to FT2_MULTI build: afpic.c.
 
 2009-04-05  Oran Agra  <oran@monfort.co.il>
 
 	Position Independent Code (PIC) support in pshinter module.
 
 	* include/freetype/internal/pshints.h add macros to init
 	instances of PSHinter_Interface.
 
 	* src/pshinter/pshmod.h declare pshinter_module_class
 	using macros from ftmodapi.h,
 	when FT_CONFIG_OPTION_PIC is defined create and destroy
 	functions will be declared.
 	* src/pshinter/pshmod.c when FT_CONFIG_OPTION_PIC is defined
 	pshinter_interface and pshinter_module_class structs
 	will have functions to init or create and destroy them
 	instead of being allocated in the global scope.
 	And macros will be used from pshpic.h in order to access them.
 
 	New Files:
 	* src/pshinter/pshpic.h declare struct to hold PIC globals for pshinter
 	module and macros to access them.
 	* src/pshinter/pshpic.c implement functions to allocate, destroy and
 	initialize PIC globals for pshinter module.
 
 	* src/pshinter/pshinter.c add new file to build: pshpic.c.
 	* src/pshinter/jamfile add new files to FT2_MULTI build: pshpic.c.
 
 2009-04-05  Oran Agra  <oran@monfort.co.il>
 
 	Position Independent Code (PIC) support in psnames module.
 
 	* include/freetype/internal/services/svpscmap.h add macros to init
 	instances of FT_Service_PsCMapsRec.
 
 	* src/psnames/psmodule.h declare psnames_module_class
 	using macros from ftmodapi.h,
 	when FT_CONFIG_OPTION_PIC is defined create and destroy
 	functions will be declared.
 	* src/psnames/psmodule.c when FT_CONFIG_OPTION_PIC is defined
 	pscmaps_interface and pscmaps_services structs
 	and psnames_module_class array
 	will have functions to init or create and destroy them
 	instead of being allocated in the global scope.
 	And macros will be used from pspic.h in order to access them.
 
 	New Files:
 	* src/psnames/pspic.h declare struct to hold PIC globals for psnames
 	module and macros to access them.
 	* src/psnames/pspic.c implement functions to allocate, destroy and
 	initialize PIC globals for psnames module.
 
 	* src/psnames/psnames.c add new file to build: pspic.c.
 	* src/psnames/jamfile add new files to FT2_MULTI build: pspic.c.
 
 2009-04-05  Oran Agra  <oran@monfort.co.il>
 
 	Position Independent Code (PIC) support in raster renderer.
 
 	* src/raster/ftrend1.h declare ft_raster1_renderer_class
 	and ft_raster5_renderer_class
 	using macros from ftrender.h,
 	when FT_CONFIG_OPTION_PIC is defined create and destroy
 	functions will be declared.
 	* src/smooth/ftrend1.c when FT_CONFIG_OPTION_PIC is defined
 	ft_raster1_renderer_class and ft_raster5_renderer_class structs
 	will have functions to init or create and destroy them
 	instead of being allocated in the global scope.
 	Macros will be used from rastpic.h in order to access
 	ft_standard_raster from the pic_container (allocated in ftraster.c).
 	In ft_raster1_render when PIC is enabled, the last letter of
 	module_name is used to verfy the renderer class rather than the
 	class pointer.
 
 	* src/raster/ftraster.c when FT_CONFIG_OPTION_PIC is defined
 	ft_standard_raster struct will have function to init it
 	instead of being allocated in the global scope.
 
 	New Files:
 	* src/raster/rastpic.h declare struct to hold PIC globals for raster
 	renderer and macros to access them.
 	* src/raster/rastpic.c implement functions to allocate, destroy and
 	initialize PIC globals for raster renderer.
 
 	* src/raster/raster.c add new file to build: rastpic.c.
 	* src/raster/jamfile add new files to FT2_MULTI build: rastpic.c.
 
 2009-04-05  Oran Agra  <oran@monfort.co.il>
 
 	Position Independent Code (PIC) support in smooth renderer.
 
 	* src/smooth/ftsmooth.h declare ft_smooth_renderer_class,
 	ft_smooth_lcd_renderer_class and ft_smooth_lcd_v_renderer_class
 	using macros from ftrender.h,
 	when FT_CONFIG_OPTION_PIC is defined create and destroy
 	functions will be declared.
 	* src/smooth/ftsmooth.c when FT_CONFIG_OPTION_PIC is defined
 	the following structs:
 	ft_smooth_renderer_class, ft_smooth_lcd_renderer_class
 	and ft_smooth_lcd_v_renderer_class
 	will have functions to init or create and destroy them
 	instead of being allocated in the global scope.
 	And macros will be used from ftspic.h in order to access
 	ft_grays_raster from the pic_container (allocated in ftgrays.c).
 
 	* src/smooth/ftgrays.h include FT_CONFIG_CONFIG_H
 	* src/smooth/ftgrays.c when FT_CONFIG_OPTION_PIC is NOT defined
 	func_interface was moved from gray_convert_glyph_inner function
 	to the global scope.
 	When FT_CONFIG_OPTION_PIC is defined
 	func_interface and ft_grays_raster structs
 	will have functions to init them
 	instead of being allocated in the global scope.
 	And func_interface will be allocated on the stack of
 	gray_convert_glyph_inner.
 
 	New Files:
 	* src/smooth/ftspic.h declare struct to hold PIC globals for smooth
 	renderer and macros to access them.
 	* src/smooth/ftspic.c implement functions to allocate, destroy and
 	initialize PIC globals for smooth renderer.
 
 	* src/smooth/smooth.c add new file to build: ftspic.c.
 	* src/smooth/jamfile add new files to FT2_MULTI build: ftspic.c.
 
 2009-04-05  Oran Agra  <oran@monfort.co.il>
 
 	Position Independent Code (PIC) support in cff driver.
 
 	* include/freetype/internal/services/svcid.h add macros to init
 	instances of FT_Service_CIDRec.
 	* include/freetype/internal/services/svpsinfo.h add macros to init
 	instances of FT_Service_PsInfoRec.
 
 	* src/cff/cffcmap.h declare cff_cmap_encoding_class_rec
 	and cff_cmap_unicode_class_rec using macros from
 	ftobjs.h, when FT_CONFIG_OPTION_PIC is defined create and destroy
 	functions will be declared.
 	* src/cff/cffcmap.c when FT_CONFIG_OPTION_PIC is defined
 	the following structs:
 	cff_cmap_encoding_class_rec and cff_cmap_unicode_class_rec
 	will have functions to init or create and destroy them
 	instead of being allocated in the global scope.
 
 	* src/cff/cffdrivr.h declare cff_driver_class using macros from
 	ftdriver.h, when FT_CONFIG_OPTION_PIC is defined create and destroy
 	functions will be declared.
 	* src/cff/cffdrivr.c when FT_CONFIG_OPTION_PIC is defined
 	the following structs:
 	cff_service_glyph_dict, cff_service_ps_info, cff_service_ps_name
 	cff_service_get_cmap_info, cff_service_cid_info, cff_driver_class,
 	and cff_services array
 	will have functions to init or create and destroy them
 	instead of being allocated in the global scope.
 	And macros will be used from cffpic.h in order to access them
 	from the pic_container.
 	Use macros from cffpic.h in order to access the
 	structs allocated in cffcmap.c
 
 	* src/cff/cffobjs.c Use macros from cffpic.h in order to access the
 	structs allocated in cffcmap.c
 
 	* src/cff/parser.c when FT_CONFIG_OPTION_PIC is defined
 	implement functions to create and destroy cff_field_handlers array
 	instead of being allocated in the global scope.
 	And macros will be used from cffpic.h in order to access it
 	from the pic_container.
 
 	New Files:
 	* src/cff/cffpic.h declare struct to hold PIC globals for cff
 	driver and macros to access them.
 	* src/cff/cffpic.c implement functions to allocate, destroy and
 	initialize PIC globals for cff driver.
 
 	* src/cff/cff.c add new file to build: cffpic.c.
 	* src/cff/jamfile add new files to FT2_MULTI build: cffpic.c.
 
 2009-04-05  Oran Agra  <oran@monfort.co.il>
 
 	Position Independent Code (PIC) support in sfnt driver.
 
 	* include/freetype/internal/services/svbdf.h add macros to init
 	instances of FT_Service_BDFRec.
 	* include/freetype/internal/services/svgldict.h add macros to init
 	instances of FT_Service_GlyphDictRec.
 	* include/freetype/internal/services/svpostnm.h add macros to init
 	instances of FT_Service_PsFontNameRec.
 	* include/freetype/internal/services/svsfnt.h add macros to init
 	instances of FT_Service_SFNT_TableRec.
 	* include/freetype/internal/services/svttcmap.h add macros to init
 	instances of FT_Service_TTCMapsRec.
 	* include/freetype/internal/sfnt.h add macros to init
 	instances of SFNT_Interface.
 
 	* src/sfnt/sfdriver.h declare sfnt_module_class using macros from
 	ftmodapi.h, when FT_CONFIG_OPTION_PIC is defined create and destroy
 	functions will be declared.
 	* src/sfnt/sfdriver.c when FT_CONFIG_OPTION_PIC is defined
 	the following structs:
 	sfnt_service_sfnt_table, sfnt_service_glyph_dict, sfnt_service_ps_name
 	tt_service_get_cmap_info, sfnt_service_bdf, sfnt_interface,
 	sfnt_module_class, and sfnt_services array
 	will have functions to init or create and destroy them
 	instead of being allocated in the global scope.
 	And macros will be used from sfntpic.h in order to access them
 	from the pic_container.
 
 	* src/sfnt/ttcmap.h add macros to init
 	instances of TT_CMap_ClassRec.
 	* src/sfnt/ttcmap.c when FT_CONFIG_OPTION_PIC is defined
 	the following structs:
 	tt_cmap0_class_rec, tt_cmap2_class_rec, tt_cmap4_class_rec
 	tt_cmap6_class_rec, tt_cmap8_class_rec, tt_cmap10_class_rec,
 	tt_cmap12_class_rec, tt_cmap14_class_rec and tt_cmap_classes array
 	will have functions to init or create and destroy them
 	instead of being allocated in the global scope.
 	And macros will be used from sfntpic.h in order to access them
 	from the pic_container.
 	The content of tt_cmap_classes is now described in the
 	new file 'ttcmapc.h'.
 
 	New Files:
 	* src/sfnt/sfntpic.h declare struct to hold PIC globals for sfnt
 	driver and macros to access them.
 	* src/sfnt/sfntpic.c implement functions to allocate, destroy and
 	initialize PIC globals for sfnt driver.
 	* src/sfnt/ttcmapc.h describing the content of
 	tt_cmap_classes allocated in ttcmap.c
 
 	* src/sfnt/sfnt.c add new file to build: sfntpic.c.
 	* src/sfnt/jamfile add new files to FT2_MULTI build: sfntpic.c.
 
 2009-04-05  Oran Agra  <oran@monfort.co.il>
 
 	Position Independent Code (PIC) support in truetype driver.
 
 	* include/freetype/internal/services/svmm.h add macros to init
 	instances of FT_Service_MultiMastersRec.
 	* include/freetype/internal/services/svttglyf.h add macros to init
 	instances of FT_Service_TTGlyfRec.
 
 	* src/truetype/ttdriver.h declare tt_driver_class using macros from
 	ftdriver.h, when FT_CONFIG_OPTION_PIC is defined create and destroy
 	functions will be declared.
 	* src/truetype/ttdriver.c when FT_CONFIG_OPTION_PIC is defined
 	the following structs:
 	tt_service_gx_multi_masters, tt_service_truetype_glyf, tt_driver_class
 	and tt_services array,
 	will have functions to init or create and destroy them
 	instead of being allocated in the global scope.
 	And macros will be used from ttpic.h in order to access them
 	from the pic_container.
 	* src/truetype/ttobjs.c change trick_names array to be
 	PIC-compatible by being a two dimentional array rather than array
 	of pointers.
 
 	New Files:
 	* src/truetype/ttpic.h declare struct to hold PIC globals for truetype
 	driver and macros to access them.
 	* src/truetype/ttpic.c implement functions to allocate, destroy and
 	initialize PIC globals for truetype driver.
 
 	* src/truetype/truetype.c add new file to build: ttpic.c.
 	* src/truetype/jamfile add new files to FT2_MULTI build: ttpic.c.
 
 2009-04-05  Oran Agra  <oran@monfort.co.il>
 
 	Position Independent Code (PIC) support and infrastructure in base.
 
 	* include/freetype/config/ftoption.h add FT_CONFIG_OPTION_PIC
 	* include/freetype/internal/ftobjs.h Add pic_container member to
 	FT_LibraryRec.
 	Add macros to declare and init instances of FT_CMap_ClassRec.
 	Add macros to init instances of FT_Outline_Funcs and FT_Raster_Funcs.
 	Add macros to declare, allocate and initialize modules
 	(FT_Module_Class).
 	Add macros to declare, allocate and initialize renderers
 	(FT_Renderer_Class).
 	Add macro to init instances of FT_Glyph_Class.
 	Add macros to declare, allocate and initialize drivers
 	(FT_Driver_ClassRec).
 	* include/freetype/internal/ftpic.h new file to declare the
 	FT_PIC_Container struct and the functions to allocate and detroy it.
 	* include/freetype/internal/ftserv.h add macros to allocate and
 	destory arrays of FT_ServiceDescRec.
 	* include/freetype/internal/internal.h define macro to include
 	ftpic.h.
 
 	New Files:
 	* src/base/ftpic.c implement functions to allocate and destory the
 	global pic_container.
 	* src/base/basepic.h declare struct to hold PIC globals for base and
 	macros to access them.
 	* src/base/basepic.c implement functions to allocate, destroy and
 	initialize PIC globals for base.
 
 	* src/base/ftinit.c when FT_CONFIG_OPTION_PIC is defined implement
 	functions that allocate and destroy ft_default_modules according to
 	FT_CONFIG_MODULES_H in the pic_container instead of the global scope
 	and use macro from basepic.h to access it.
 	* src/base/ftobjs.c add calls to the functions that allocate and
 	destroy the global pic_container when the library is created and
 	destroyed.
 
 	* src/base/jamfile add new files to FT2_MULTI build:
 	ftpic.c and basepic.c.
 	* src/base/ftbase.c add new files to build:
 	ftpic.c and basepic.c.
 
 	* src/base/ftglyph.c when FT_CONFIG_OPTION_PIC is defined
 	ft_bitmap_glyph_class and ft_outline_glyph_class will be allocated
 	in the pic_container instead of the global scope and use macros from
  	basepic.h to access them.
 	* src/base/ftbbox.c allocate bbox_interface stract on the stack
 	instead of the global scope when FT_CONFIG_OPTION_PIC is defined.
 	* src/base/ftstroke.c access ft_outline_glyph_class allocated in
 	ftglyph.c via macros from basepic.h
 
 2009-04-05  Oran Agra  <oran@monfort.co.il>
 
 	Preparing changes in cff parser later needed for PIC version.
 
 	* src/cff/cffload.c, src/cff/cffload.h, src/cff/cffobjs.c,
 	src/cff/cffparse.c, src/cff/cffparse.h: Add library pointer to
 	'CFF_ParserRec' set by `cff_parser_init'.
 	Route library pointer from 'cff_face_init' to 'cff_subfont_load'
 	for `cff_parser_init'.
 
 	* src/cff/cffparse.c (CFF_Field_Handler): Move it to...
 	* src/cff/cffparse.h: This file, to be used by other C files.
 
 2009-04-05  Oran Agra  <oran@monfort.co.il>
 
 	Minor change in ftstroke.c.
 
 	* src/base/ftstroke.c (FT_StrokerRec): Replace `memory' member with
 	`library' needed for PIC version.
 	Update all callers.
 
 2009-04-04  Werner Lemberg  <wl@gnu.org>
 
 	ftnames.c -> ftsnames.c
 
 	* src/base/ftnames.c: Rename to...
 	* src/base/ftsnames.c: This.
 	* src/base/Jamfile, src/base/rules.mk, src/base/ftbase.c: Updated.
 
 2009-04-04  Werner Lemberg  <wl@gnu.org>
 
 	Add support for cmap type 13.
 
 	* devel/ftoption.h, include/freetype/config/ftoption.h
 	(TT_CONFIG_CMAP_FORMAT_13): New macro.
 
 	* src/sfnt/ttcmap.c (TT_CMap13Rec, tt_cmap13_init,
 	tt_cmap13_validate, tt_cmap13_char_index, tt_cmap13_char_next,
 	tt_cmap13_get_info, tt_cmap13_char_map_def_binary,
 	tt_cmap14_class_rec): New functions and structures for cmap 13
 	support.
 	(tt_cmap_classes): Register tt_cmap13_class_rec.
 
 	* docs/CHANGES: Mention cmap 13 support.
 
 2009-04-01  Werner Lemberg  <wl@gnu.org>
 
 	Ignore empty contours in CFF glyphs.
 
 	Problem reported by Albert Astals Cid <aacid@kde.org>.
 
 	* src/cff/cffgload.c (cff_builder_close_contour): Synchronize with
 	t1_builder_close_contour.
 
 2009-03-21  Werner Lemberg  <wl@gnu.org>
 
 	Another redundant header inclusion.
 
 	* src/truetype/ttgxvar.c: Fix Ghostscript Coverity issue #4041.
 
 2009-03-21  Werner Lemberg  <wl@gnu.org>
 
 	Remove redundant header inclusions.
 
 	This covers many Ghostscript Coverity issues.
 
 	* src/*: Do it.
 
 2009-03-21  Werner Lemberg  <wl@gnu.org>
 
 	Fix Ghostscript Coverity issue #3904.
 
 	* src/truetype/ttgxvar.c (ft_var_readpackedpoints): Protect against
 	invalid values of `runcnt'.
 
 2009-03-20  Werner Lemberg  <wl@gnu.org>
 
 	Fix `make multi' run.
 
 	* src/smooth/ftsmooth.h: Include FT_INTERNAL_DEBUG_H.
 
 2009-03-20  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #25923.
 
 	* src/cache/ftccmap.c (FTC_CMAP_HASH): Fix typo.
 
 2009-03-20  Werner Lemberg  <wl@gnu.org>
 
 	Protect against too large glyphs.
 
 	Problem reported by Tavis Ormandy <taviso@google.com>.
 
 	* src/smooth/ftsmooth.c (ft_smooth_render_generic): Don't allow
 	`pitch' or `height' to be larger than 0xFFFF.
 
 2009-03-20  Werner Lemberg  <wl@gnu.org>
 	    Tavis Ormandy  <taviso@google.com>
 
 	Fix validation for various cmap table formats.
 
 	* src/sfnt/ttcmap.c (tt_cmap8_validate, tt_cmap10_validate,
 	tt_cmap12_validate): Check `length' correctly.
 	(tt_cmap_14_validate): Check `length' and `numMappings' correctly.
 
 2009-03-20  Werner Lemberg  <wl@gnu.org>
 
 	Protect against malformed compressed data.
 
 	* src/lzw/ftzopen.c (ft_lzwstate_io): Test whether `state->prefix' is
 	zero.
 
 2009-03-20  Werner Lemberg  <wl@gnu.org>
 
 	Protect against invalid SID values in CFFs.
 
 	Problem reported by Tavis Ormandy <taviso@google.com>.
 
 	* src/cff/cffload.c (cff_charset_load): Reject SID values larger
 	than 64999.
 
 2009-03-19  Vincent Richomme  <richom.v@free.fr>
 
 	Update WinCE Visual C project files.
 
 	* builds/wince/vc2005-ce/freetype.vcproj,
 	builds/wince/vc2008-ce/freetype.vcproj: Add missing base extension
 	files.
 
 2009-03-19  Werner Lemberg  <wl@gnu.org>
 
 	Remove unused Win32 code.
 
 	* builds/wince/ftdebug.c: Remove code guarded with `!_WIN32_WCE'.
 	Since Win32 is handled separately this is no longer needed.
 
 2009-03-19  Vincent Richomme  <richom.v@free.fr>
 
 	Make `gzip' module compile on WinCE.
 
 	* src/gzip/zconf.h [_WIN32_WCE]: Define NO_ERRNO_H.
 
 2009-03-19  Werner Lemberg  <wl@gnu.org>
 
 	Remove unused WinCE code.
 
 	* builds/win32/ftdebug.c: Remove code guarded with `_WIN32_WCE'.
 	Since WinCE is handled separately this is no longer needed.
 
 2009-03-16  Werner Lemberg  <wl@gnu.org>
 
 	docmaker: Don't ignore single-line code blocks.
 
 	* src/tools/docmaker/content.py (DocBlock::_init__): Fix change from
 	2009-01-31.
 
 2009-03-15  Steve Langasek  <steve.langasek@canonical.com>
 
 	Use __asm__ for declaring assembly instead of asm.
 
 	* builds/unix/ftconfig.in (FT_MulFix_arm): Use __asm__ instead of
 	asm on arm, fixing a build failure on armel with -pedantic.
 
 2009-03-14  Werner Lemberg  <wl@gnu.org>
 
 	Fix valgrind warning.
 
 	* src/sfnt/ttsbit0.c (tt_sbit_decoder_load_bit_aligned): Don't read
 	past the end of the frame.
 
 2009-03-12  Werner Lemberg  <wl@gnu.org>
 
 	* Version 2.3.9 released.
 	=========================
 
 
 	Tag sources with `VER-2-3-9'.
 
 2009-03-12  Werner Lemberg  <wl@gnu.org>
 
 	* builds/unix/freetype2.in: Move @FT2_EXTRA_LIBS@ to `Libs.private'.
 
 2009-03-12  Werner Lemberg  <wl@gnu.org>
 
 	Fix some FreeType Coverity issues as reported for Ghostscript.
 
 	* src/base/ftobjs.c (FT_New_Face, FT_New_Memory_Face): Initialize
 	`args.stream' (#3874, #3875).
 	(open_face_PS_from_sfnt_stream): Improve error management (#3786).
 	* src/base/ftmm.c (ft_face_get_mm_service): Fix check of `aservice'
 	(#3870).
 	* src/base/ftstroke.c (ft_stroke_border_get_counts): Remove dead
 	code (#3790).
 	* src/base/ftrfork.c (raccess_guess_apple_generic): Check error
 	value of `FT_Stream_Skip' (#3784).
 
 	* src/type1/t1gload.c (T1_Load_Glyph): Check `size' before accessing
 	it (#3872)
 
 	* src/pcf/pcfdrivr.c (PCF_Glyph_Load): Check `face' before accessing
 	it (#3871).
 	* src/pcf/pcfread.c (pcf_get_metrics): Handle return value of
 	`pcf_get_metric' (#3789, #3782).
 	(pcf_get_properties): Use FT_STREAM_SKIP (#3783).
 
 	* src/cache/ftcmanag.c (FTC_Manager_RegisterCache): Fix check of
 	`acache' (#3797)
 
 	* src/cff/cffdrivr.c (cff_ps_get_font_info): Fix check of `cff'
 	(#3796).
 	* src/cff/cffgload.c (cff_decoder_prepare): Check `size' (#3795).
 	* src/cff/cffload.c (cff_index_get_pointers): Add comment (#3794).
 
 	* src/bdf/bdflib.c (_bdf_add_property): Check `fp->value.atom'
 	(#3793).
 	(_bdf_parse_start): Add comment (#3792).
 
 	* src/raster/ftraster.c (Finalize_Profile_Table): Check
 	`ras.fProfile' (#3791).
 
 	* src/sfnt/ttsbit.c (Load_SBit_Image): Use FT_STREAM_SKIP (#3785).
 
 	* src/gzip/ftgzip.c (ft_gzip_get_uncompressed_size): Properly ignore
 	seek error (#3781).
 
 2009-03-11  Michael Toftdal  <toftdal@gmail.com>
 
 	Extend CID service functions to handle CID-keyed CFFs as CID fonts.
 
 	* include/freetype/ftcid.h (FT_Get_CID_Is_Internally_CID_keyed,
 	FT_Get_CID_From_Glyph_Index): New functions.
 
 	* include/freetype/internal/services/svcid.h
 	(FT_CID_GetIsInternallyCIDKeyedFunc,
 	FT_CID_GetCIDFromGlyphIndexFunc): New function typedefs.
 	(CID Service): Use them.
 
 	* src/base/ftcid.c: Include FT_CID_H.
 	(FT_Get_CID_Is_Internally_CID_keyed, FT_Get_CID_From_Glyph_Index):
 	New functions.
 
 	* src/cff/cffdrivr.c (cff_get_is_cid, cff_get_cid_from_glyph_index):
 	New functions.
 	(cff_service_cid_info): Add them.
 	* src/cff/cffload.c (cff_font_load): Don't free `font->charset.sids'
 	-- it is needed for access as a CID-keyed font.  It gets deleted
 	later on.
 
 	* src/cid/cidriver.c (cid_get_is_cid, cid_get_cid_from_glyph_index):
 	New functions.
 	(cid_service_cid_info): Add them.
 
 	* docs/CHANGES: Updated.
 
 2009-03-11  Bram Tassyns  <bramt@enfocus.be>
 
 	Fix Savannah bug #25597.
 
 	* src/cff/cffparse.c (cff_parse_real): Don't allow fraction_length
 	to become larger than 9.
 
 2009-03-11  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #25814.
 
 	* builds/unix/freetype2.in: As suggested in the bug report, move
 	@LIBZ@ to `Libs.private'.
 
 2009-03-11  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #25781.
 	We now simply check for a valid `offset', no longer handling `delta
 	= 1' specially.
 
 	* src/sfnt/ttcmap.c (tt_cmap4_validate): Don't check `delta' for
 	last segment.
 	(tt_cmap4_set_range, tt_cmap4_char_map_linear,
 	tt_cmap4_char_map_binary): Check offset.
 
 2009-03-11  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/Jamfile: Fix handling of ftadvanc.c.
 	Reported by Oran Agra <oran@monfort.co.il>.
 
 2009-03-10  Vincent Richomme  <richom.v@free.fr>
 
 	Restructure Win32 and Wince compiler support.
 
 	* src/builds/win32: Remove files for WinCE.
 	Move VC 2005 support to a separate directory.
 	Add directory for VC 2008 support.
 
 	* src/builds/wince: New directory hierarchy for WinCE compilers
 	(VC 2005 and VC 2008).
 
 2009-03-09  Werner Lemberg  <wl@gnu.org>
 
 	More preparations for 2.3.9 release.
 
 	* docs/CHANGES: Updated.
 
 	* Jamfile, README: s/2.3.8/2.3.9/, s/238/239/.
 
 2009-03-09  Werner Lemberg  <wl@gnu.org>
 
 	* src/sfnt/rules.mk (SFNT_DRV_H): Add ttsbit0.c.
 
 2009-03-09  Alexey Kryukov  <anagnost@yandex.ru>
 
 	Fix handling of EBDT formats 8 and 9 (part 2).
 
 	This patch fixes the following problems in ttsbit0.c:
 
 	. Bitmaps for compound glyphs were never allocated.
 
 	. `SBitDecoder' refused to load metrics if some other metrics have
 	  already been loaded.  This condition certainly makes no sense for
 	  recursive calls, so I've just disabled it.  Another possibility
 	  would be resetting `decoder->metrics_loaded' to false before
 	  loading each composite component.  However, we must restore the
 	  original metrics after finishing the recursion; otherwise we can
 	  get a misaligned glyph.
 
 	. `tt_sbit_decoder_load_bit_aligned' incorrectly handled `x_pos',
 	  causing some glyph components to be shifted too far to the right
 	  (especially noticeable for small sizes).
 
 	Note that support for grayscale bitmaps (not necessarily compound) is
 	completely broken in ttsbit0.c.
 
 	* src/sfnt/tt_sbit_decoder_load_metrics: Always load metrics.
 	(tt_sbit_decoder_load_bit_aligned): Handle `x_pos' correctly in case
 	of `h == height'.
 	(tt_sbit_decoder_load_compound): Reset metrics after loading
 	components.
 	Allocate bitmap.
 
 2009-03-09  Werner Lemberg  <wl@gnu.org>
 
 	* builds/unix/configure.raw (version_info): Set to 9:20:3.
 
 2009-03-03  David Turner  <david@freetype.org>
 
 	Protect SFNT kerning table parser against malformed tables.
 
 	This closes Savannah BUG #25750.
 
 	* src/sfnt/ttkern.c (tt_face_load_kern, tt_face_get_kerning): Fix a
 	bug where a malformed table would be successfully loaded but later
 	crash the engine during parsing.
 
 2009-03-03  David Turner  <david@freetype.org>
 
 	Update documentation and bump version number to 2.3.9.
 
 	* include/freetype/freetype.h: Bump patch version to 9.
 	* docs/CHANGES: Document the ABI break in 2.3.8.
 	* docs/VERSION.DLL: Update version numbers table for 2.3.9.
 
 2009-03-03  David Turner  <david@freetype.org>
 
 	Remove ABI-breaking field in public PS_InfoFontRec definition.
 
 	Instead, we define a new internal PS_FontExtraRec structure to
 	hold the additional field, then place it in various internal
 	positions of the corresponding FT_Face derived objects.
 
 	* include/freetype/t1tables.h (PS_FontInfoRec): Remove the
 	`fs_type' field from the public structure.
 	* include/freetype/internal/psaux.h (T1_FieldLocation): New
 	enumeration `T1_FIELD_LOCATION_FONT_EXTRA'.
 	* include/freetype/internal/t1types.h (PS_FontExtraRec): New
 	structure.
 	(T1_FontRec, CID_FaceRec): Add it.
 
 	* src/cid/cidload.c (cid_load_keyword): Handle
 	T1_FIELD_LOCATION_FONT_EXTRA.
 	* src/cid/cidtoken.h, src/type1/t1tokens.h, src/type42/t42parse.c:
 	Adjust FT_STRUCTURE and T1CODE properly to handle `FSType'.
 	* src/type1/t1load.c (t1_load_keyword): Handle
 	T1_FIELD_LOCATION_FONT_EXTRA.
 
 	* include/freetype/internal/services/svpsinfo.h (PsInfo service):
 	Add `PS_GetFontExtraFunc' function typedef.
 
 	* src/base/ftfstype.c: Include FT_INTERNAL_SERVICE_H and
 	FT_SERVICE_POSTSCRIPT_INFO_H.
 	(FT_Get_FSType_Flags): Use POSTSCRIPT_INFO service.
 
 	* src/cff/cffdrivr.c (cff_service_ps_info): Updated.
 	* src/cid/cidriver.c (cid_ps_get_font_extra): New function.
 	(cid_service_ps_info): Updated.
 	* src/type1/t1driver.c (t1_ps_get_font_extra): New function.
 	(t1_service_ps_info): Updated.
 	* src/type42/t42drivr.c (t42_ps_get_font_extra): New function.
 	(t42_service_ps_info): Updated.
 
 2009-03-02  Alexey Kryukov  <anagnost@yandex.ru>
 
 	Fix handling of EBDT formats 8 and 9.
 
 	The main cycle in `blit_sbit' makes too many iterations: it actually
 	needs the count of lines in the source bitmap rather than in the
 	target image.
 
 	* src/sfnt/ttsbit.c (blit_sbit) [FT_CONFIG_OPTION_OLD_INTERNALS]:
 	Add parameter `source_height' and use it for main loop.
 	(Load_SBit_Single) [FT_CONFIG_OPTION_OLD_INTERNALS]: Updated.
 
 2009-02-23  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #25669.
 
 	* src/base/ftadvanc.h (FT_Get_Advances): Fix serious typo.
 
 	* src/base/ftobjs.c (FT_Select_Metrics, FT_Request_Metrics): Fix
 	scaling factor for non-scalable fonts.
 
 	* src/cff/cffdrivr.c (cff_get_advances): Use correct advance width
 	value to prevent incorrect scaling.
 
 	* docs/CHANGES: Document it.
 
 2009-02-15  Matt Godbolt  <matt@godbolt.org>
 
 	Fix Savannah bug #25588.
 
 	* builds/unix/ftconfig.in (FT_MulFix_arm): Use correct syntax for
 	`orr' instruction.
 
 2009-02-11  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttobjs.c (tt_check_trickyness): Add `DFKaiShu'.
 	Reported by David Bevan <dbevan@emtex.com>.
 
 2009-02-09  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #25495.
 
 	* src/sfnt/sfobjs.c (sfnt_load_face): Test for bitmap strikes before
 	setting metrics and bbox values.  This ensures that the check for a
 	font with neither a `glyf' table nor bitmap strikes can be performed
 	early enough to set metrics and bbox values too.
 
 2009-02-04  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #25480.
 
 	* builds/unix/freetype-config.in: For --ftversion, don't use $prefix
 	but $includedir.
 
 2009-01-31  Werner Lemberg  <wl@gnu.org>
 
 	Minor docmaker improvements.
 
 	* src/tools/docmaker/content.py (DocBlock::__init__): Ignore empty
 	code blocks.
 
 2009-01-25  Werner Lemberg  <wl@gnu.org>
 
 	Fix SCANCTRL handling in TTFs.
 	Problem reported by Alexey Kryukov <anagnost@yandex.ru>.
 
 	* src/truetype/ttinterp.c (Ins_SCANCTRL): Fix threshold handling.
 
 2009-01-23  Werner Lemberg  <wl@gnu.org>
 
 	Move FT_Get_FSType_Flags to a separate file.
 	Problem reported by Mickey Gabel <mickey@monfort.co.il>.
 
 	* src/base/ftobjs.c (FT_Get_FSType_Flags): Move to...
 	* src/base/ftfstype.c: This new file.
 
 	* modules.cfg (BASE_EXTENSION): Add ftfstype.c.
 
 	* docs/INSTALL.ANY: Updated.
 
 	* builds/mac/*.txt, builds/amiga/*makefile*,
 	builds/win32/{visualc,visualce}/freetype.*, builds/symbian/*:
 	Updated.
 
 2009-01-22  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* builds/unix/ftsystem.c (FT_Stream_Open): Fix 2 error
 	messages ending without "\n".
 
 2009-01-22  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Fix Savannah bug #25347.
 
 	* src/base/ftobjs.c (open_face_PS_from_sfnt_stream): Rewind
 	the stream to the original position passed to this function,
 	when ft_lookup_PS_in_sfnt_stream() failed.
 	(Mac_Read_sfnt_Resource): Rewind the stream to the head of
 	sfnt resource body, when open_face_PS_from_sfnt_stream()
 	failed.
 
 2009-01-19  Michael Lotz  <mmlr@mlotz.ch>
 
 	Fix Savannah bug #25355.
 
 	* include/freetype/config/ftconfig.h (FT_MulFix_i386): Make
 	assembler code work with gcc 2.95.3 (as used by the Haiku project).
 	Add `cc' register to the clobber list.
 
 2009-01-18  Werner Lemberg  <wl@gnu.org>
 
 	Protect FT_Get_Next_Char.
 
 	* src/sfnt/ttcmap.c (tt_cmap4_set_range): Apply fix similar to
 	change from 2008-07-22.
 
 	Patch from Ronen Ghoshal <rghoshal@emtex.com>.
 
 2009-01-18  Werner Lemberg  <wl@gnu.org>
 
 	Implement FT_Get_Name_Index for SFNT driver.
 
 	* src/sfnt/sfdriver.c (sfnt_get_name_index): New function.
 	(sfnt_service_glyph_dict): Use it.
 
 	Problem reported by Truc Truong <tructv@necsv.com>.
 
 2009-01-18  Werner Lemberg  <wl@gnu.org>
 
 	* include/freetype/ftstroke.h (FT_Outline_GetInsideBorder): Fix
 	documentation.  Problem reported by Truc Truong <tructv@necsv.com>.
 
 	* docs/CHANGES: Updated.
 
 2009-01-14  Werner Lemberg  <wl@gnu.org>
 
 	* Version 2.3.8 released.
 	=========================
 
 
 	Tag sources with `VER-2-3-8'.
 
 	* docs/VERSION.DLL: Update documentation and bump version number to
 	2.3.8.
 
 	* README, Jamfile (RefDoc), builds/win32/visualc/index.html,
 	builds/win32/visualc/freetype.dsp,
 	builds/win32/visualc/freetype.vcproj,
 	builds/win32/visualce/index.html,
 	builds/win32/visualce/freetype.dsp,
 	builds/win32/visualce/freetype.vcproj: s/2.3.7/2.3.8/, s/237/238/.
 
 	* include/freetype/freetype.h (FREETYPE_PATCH): Set to 8.
 
 	* builds/unix/configure.raw (version_info): Set to 9:19:3.
 
 	* docs/release: Updated.
 
 2009-01-14  Werner Lemberg  <wl@gnu.org>
 
 	* builds/toplevel.mk (dist): Compress better.
 
 2009-01-13  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftobjs.c (FT_Get_FSType_Flags): Cast for compilation
 	with C++.
 
 2009-01-13  Werner Lemberg  <wl@gnu.org>
 
 	Don't use stdlib.h and friends directly.
 	Reported by Mickey Gabel <mickey@monfort.co.il>.
 
 	* src/base/ftdbgmem.c: s/<stdlib.h>/FT_CONFIG_STANDARD_LIBRARY_H/.
 
 	* src/gzip/ftgzip.c, src/lzw/ftlzw.c, src/raster/ftmisc.h:
 	s/<string.h>/FT_CONFIG_STANDARD_LIBRARY_H/.
 
 	* src/autofit/aftypes.h, src/autofit/afhints.c,
 	src/pshinter/pshalgo.c: s/<stdio.h>/FT_CONFIG_STANDARD_LIBRARY_H/
 
 	* src/lzw/ftlzw.c, src/base/ftdbgmem.c: Don't include stdio.h.
 
 2009-01-12  Werner Lemberg  <wl@gnu.org>
 
 	Avoid compiler warnings.
 
 	* */*: s/do ; while ( 0 )/do { } while ( 0 )/.
 	Reported by Sean McBride <sean@rogue-research.com>.
 
 2009-01-12  Werner Lemberg  <wl@gnu.org>
 
 	Fix stdlib dependencies.
 
 	Problem reported by Mickey Gabel <mickey@monfort.co.il>.
 
 	* include/freetype/config/ftstdlib.h (ft_exit): Removed.  Unused.
 
 	* src/autofit/afhints.c, src/base/ftlcdfil.c, src/smooth/ftsmooth.c:
 	s/memcpy/ft_memcpy/.
 	* src/psaux/t1decode.c: s/memset/ft_memset/, s/memcpy/ft_memcpy/.
 
 2009-01-11  Werner Lemberg  <wl@gnu.org>
 
 	* docs/formats.txt: Add link to PCF specification.
 
 	* include/freetype/ftbdf.h (FT_Get_BDF_Property): Improve
 	documentation.
 
 2009-01-09  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftadvanc.c (_ft_face_scale_advances, FT_Get_Advance,
 	FT_Get_Advances): Change the type of load_flags from FT_UInt32 to
 	FT_Int32, to match with the flags for FT_Load_Glyph().
 	* src/cff/cffdrivr.c (cff_get_advances): Ditto.
 	* src/truetype/ttdriver.c (tt_get_advances): Ditto.
 	* include/freetype/ftadvanc.h (FT_Get_Advance, FT_Get_Advances):
 	Ditto.
 	* include/freetype/internal/ftdriver.h (FT_Face_GetAdvancesFunc):
 	Ditto.
 
 2009-01-09  Daniel Zimmermann  <netzimme@aol.com>
 
 	* src/gxvalid/gxvmort.c (gxv_mort_feature_validate): Fix wrong
 	length check.  From Savannah patch #6682.
 
 2009-01-09  Werner Lemberg  <wl@gnu.org>
 
 	Fix problem with T1_FIELD_{NUM,FIXED}_TABLE2.
 
 	* src/psaux/psobjs.c (ps_parser_load_field_table): Don't handle
 	`count_offset' if it is zero (i.e., unused).  Otherwise, the first
 	element of the structure which holds the data is erroneously
 	modified.  Problem reported by Chi Nguyen <chint@necsv.com>.
 
 2009-01-09  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftadvanc.c (_ft_face_scale_advances, FT_Get_Advance,
 	FT_Get_Advances): Extend the type of load_flags from FT_UInt to
 	FT_UInt32, to pass 32-bit flags on 16bit platforms.
 	* src/cff/cffdrivr.c (cff_get_advances): Ditto.
 	* src/truetype/ttdriver.c (tt_get_advances): Ditto.
 	* include/freetype/ftadvanc.h (FT_Get_Advance, FT_Get_Advances):
 	Ditto.
 	* include/freetype/internal/ftdriver.h (FT_Face_GetAdvancesFunc):
 	Ditto.
 
 2009-01-09  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftobjs.c (FT_Done_Library): Issue an error message when
 	FT_Done_Face() cannot free all faces. If the list of the opened
 	faces includes broken face which FT_Done_Face() cannot free,
 	FT_Done_Library() retries FT_Done_Face() and it can fall into
 	an endless loop. See the discussion:
 	http://lists.gnu.org/archive/html/freetype-devel/2008-09/msg00047.html
 	http://lists.gnu.org/archive/html/freetype-devel/2008-10/msg00000.html
 
 2009-01-07  Werner Lemberg  <wl@gnu.org>
 
 	* docs/CHANGES: Document new key `a' in ftdiff.
 
 2009-01-06  Werner Lemberg  <wl@gnu.org>
 
 	* autogen.sh: Don't use GNUisms while calling sed.  Problem reported
 	by Sean McBride.
 
 2009-01-06  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftbitmap.c (FT_Bitmap_Convert): Handle FT_PIXEL_MODE_LCD
 	and FT_PIXEL_MODE_LCD_V.  Problem reported by Chi Nguyen
 	<chint@necsv.com>.
 
 2009-01-06  Diego Pettenò  <flameeyes@gmail.com>
 
 	* builds/unix/configure.raw: Don't call AC_CANONICAL_BUILD and
 	AC_CANONICAL_TARGET and use $host_os only.  A nice explanation for
 	this change can be found at
 	http://blog.flameeyes.eu/s/canonical-target.
 
 	From Savannah patch #6712.
 
 2009-01-06  Sean McBride  <sean@rogue-research.com>
 
 	* src/base/ftdbgmem.c (_debug_mem_dummy): Make it static.
 
 	* src/base/ftmac.c: Remove some #undefs.
 
 2008-12-26  Werner Lemberg  <wl@gnu.org>
 
 	Set `face_index' field in FT_Face for all font formats.
 
 	* cff/cffobjs.c (cff_face_init), winfonts/winfnt.c (FNT_Face_Init),
 	sfnt/sfobjs.c (sfnt_init_face): Do it.
 
 	* docs/CHANGES: Document it.
 
 2008-12-22  Steve Grubb
 
 	* builds/unix/ftsystem.c (FT_Stream_Open): Reject zero-length files.
 	Patch from Savannah bug #25151.
 
 2008-12-21  Werner Lemberg  <wl@gnu.org>
 
 	* src/pfr/pfrdrivr.c, src/winfonts/winfnt.c, src/cache/ftcmanag.c,
 	src/smooth/ftgrays.c, src/base/ftobjc.s, src/sfobjs.c:
 	s/_Err_Bad_Argument/_Err_Invalid_Argument/.  The former is for
 	errors in the bytecode interpreter only.
 
 2008-12-21  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftpfr.c (FT_Get_PFR_Metrics): Protect against NULL
 	arguments.
 	Fix return value for non-PFR fonts.  Both problems reported by Chi
 	Nguyen <chint@necsv.com>.
 
 2008-12-21  anonymous
 
 	FT_USE_MODULE declares things as:
 
 	  extern const FT_Module_Class
 
 	(or similar for C++).  However, the actual types of the variables
 	being declared are often different, e.g., FT_Driver_ClassRec or
 	FT_Renderer_Class.  (Some are, indeed, FT_Module_Class.)
 
 	This works with most C compilers (since those structs begin with an
 	FT_Module_Class struct), but technically it's undefined behavior.
 
 	To quote the ISO/IEC 9899:TC2 final committee draft, section 6.2.7
 	paragraph 2:
 
 	  All declarations that refer to the same object or function shall
 	  have compatible type; otherwise, the behavior is undefined.
 
 	(And they are not compatible types.)
 
 	Most C compilers don't reject (or even detect!) code which has this
 	issue, but the GCC LTO development branch compiler does.  (It
 	outputs the types of the objects while generating .o files, along
 	with a bunch of other information, then compares them when doing the
 	final link-time code generation pass.)
 
 	Patch from Savannah bug #25133.
 
 	* src/base/ftinit.c (FT_USE_MODULE): Include variable type.
 
 	* builds/amiga/include/freetype/config/ftmodule.h,
 	include/freetype/config/ftmodule.h, */module.mk: Updated to declare
 	pass correct types to FT_USE_MODULE.
 
 2008-12-21  Hongbo Ni  <hongbo@njstar.com>
 
 	* src/autofit/aflatin.c (af_latin_hint_edges),
 	src/autofit/aflatin2.c (af_latin2_hint_edges), src/autofit/afcjk.c
 	(af_cjk_hint_edges): Protect against division by zero.  This fixes
 	Savannah bug #25124.
 
 2008-12-18  Werner Lemberg  <wl@gnu.org>
 
 	* docs/CHANGES: Updated.
 
 2008-12-18  Bevan, David  <dbevan@emtex.com>
 
 	Provide API for accessing embedding and subsetting restriction
 	information.
 
 	* include/freetype.h (FT_FSTYPE_INSTALLABLE_EMBEDDING,
 	FT_FSTYPE_RESTRICTED_LICENSE_EMBEDDING,
 	FT_FSTYPE_PREVIEW_AND_PRINT_EMBEDDING, FT_FSTYPE_EDITABLE_EMBEDDING,
 	FT_FSTYPE_NO_SUBSETTING, FT_FSTYPE_BITMAP_EMBEDDING_ONLY): New
 	macros.
 	(FT_Get_FSType_Flags): New function declaration.
 
 	* src/base/ftobjs.c (FT_Get_FSType_Flags): New function.
 
 	* src/cid/cidtoken.h, src/type1/t1tokens.h, src/type42/t42parse.c
 	(t42_keywords): Handle `FSType'.
 
 	* include/freetype/t1tables.h (PS_FontInfoRec): Add `fs_type' field.
 
 2008-12-17  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftsynth.c (FT_GlyphSlot_Embolden): Don't use internal
 	macros so that copying the source code into an application works
 	out of the box.
 
 2008-12-17  Werner Lemberg  <wl@gnu.org>
 
 	* include/freetype/ftsynth.h, src/base/ftsynth.c: Move
 	FT_GlyphSlot_Own_Bitmap to...
 	* include/freetype/ftbitmap.h, src/base/ftbitmap.c: These files.
 
 	* docs/CHANGES: Document it.
 
 2008-12-10  Werner Lemberg  <wl@gnu.org>
 
 	Generalize the concept of `tricky' fonts by introducing
 	FT_FACE_FLAG_TRICKY to indicate that the font format's hinting
 	engine is necessary for correct rendering.
 
 	At the same time, slightly modify the behaviour of tricky fonts:
 	FT_LOAD_NO_HINTING is now ignored.  To really force raw loading
 	of tricky fonts (without hinting), both FT_LOAD_NO_HINTING and
 	FT_LOAD_NO_AUTOHINT must be used.
 
 	Finally, tricky TrueType fonts always use the bytecode interpreter
 	even if the patented code is used.
 
 	* include/freetype/freetype.h (FT_FACE_FLAG_TRICKY, FT_IS_TRICKY):
 	New macros.
 
 	* src/truetype/ttdriver.c (Load_Glyph): Handle new load flags
 	semantics as described above.
 
 	* src/truetype/ttobjs.c (tt_check_trickyness): New function, using
 	code of ...
 	(tt_face_init): This function, now simplified and updated to new
 	semantics.
 
 	* src/base/ftobjs.c (FT_Load_Glyph): Don't use autohinter for tricky
 	fonts.
 
 	* docs/CHANGES: Document it.
 
 2008-12-09  Werner Lemberg  <wl@gnu.org>
 
 	Really fix Savannah bug #25010: An SFNT font with neither outlines
 	nor bitmaps can be considered as containing space `glyphs' only.
 
 	* src/truetype/ttpload.c (tt_face_load_loca): Handle the case where
 	a `glyf' table is missing.
 
 	* src/truetype/ttgload.c (load_truetype_glyph): Abort if we have no
 	`glyf' table but a non-zero `loca' entry.
 	(tt_loader_init): Handle missing `glyf' table.
 
 	* src/base/ftobjs.c (FT_Load_Glyph): Undo change 2008-12-05.
 
 	* src/sfnt/sfobjs.c (sfnt_load_face): A font with neither outlines
 	nor bitmaps is scalable.
 
 2008-12-05  Werner Lemberg  <wl@nu.org>
 
 	* src/autofit/aflatin.c (af_latin_uniranges): Add more ranges.  This
 	fixes Savannah bug #21190 which also provides a basic patch.
 
 2008-12-05  Werner Lemberg  <wl@nu.org>
 
 	* include/freetype/freetype.h (FT_LOAD_ADVANCE_ONLY): Use value
 	0x100 instead of 0x10000; the latter value is already occupied by
 	FT_LOAD_TARGET_LIGHT.  Bug reported by James Cloos.
 
 
 	Handle SFNT with neither outlines nor bitmaps.  This fixes Savannah
 	bug #25010.
 
 	* src/base/ftobjs.c (FT_Load_Glyph): Reject fonts with neither
 	outlines nor bitmaps.
 
 	* src/sfnt/sfobjs.c (sfnt_load_face): Don't return an error if there
 	is no table with glyphs.
 
 
 	* src/sfnt/ttload.c (tt_face_lookup_table): Improve debugging
 	message.
 
 2008-12-01  Werner Lemberg  <wl@gnu.org>
 
 	GDEF tables need `glyph_count' too for validation.  Problem reported
 	by Chi Nguyen <chint@necsv.com>.
 
 	* src/otvalid/otvgdef.c (otv_GDEF_validate), src/otvalid/otvalid.h
 	(otv_GDEF_validate), src/otvalid/otvmod.c (otv_validate): Pass
 	`glyph_count'.
 
 2008-11-29  Werner Lemberg  <wl@gnu.org>
 
 	* src/autofit/afcjk.c, src/base/ftoutln.c, src/base/ftrfork.c,
 	src/bdf/bdfdrivr.c, src/gxvalid/gxvmorx.c, src/otvalid/otvmath.c,
 	src/pcf/pcfdrivr.c, src/psnames/pstables.h, src/smooth/ftgrays.c,
 	src/tools/glnames.py, src/truetype/ttinterp.c, src/type1/t1load.c,
 	src/type42/t42objs.c, src/winfonts/winfnt.c: Fix compiler warnings
 	(Atari PureC).
 
 2008-11-29  James Cloos  <cloos@jhcloos.com>
 
 	* src/type/t1load.c (mm_axis_unmap): Revert previous patch and fix
 	it correctly by using FT_INT_TO_FIXED (FreeType expects 16.16 values
 	in the /BlendDesignMap space).
 
 2008-11-29  James Cloos  <cloos@jhcloos.com>
 
 	* src/type1/t1load.c (mm_axis_unmap): `blend_points' is FT_Fixed*,
 	whereas `design_points' is FT_Long*.  Therefore, return blend rather
 	than design points.
 
 2008-11-27  Werner Lemberg  <wl@gnu.org>
 
 	* src/cff/cffparse.c (cff_parse_real): Handle more than nine
 	significant digits correctly.  This fixes Savannah bug #24953.
 
 2008-11-25  Daniel Zimmermann  <netzimme@aol.com>
 
 	* src/base/ftstream.c (FT_Stream_ReadFields): Don't access stream
 	before the NULL check.  From Savannah patch #6681.
 
 2008-11-24  Werner Lemberg  <wl@gnu.org>
 
 	Fixes from the gnuwin32 port.
 
 	* src/base/ftlcdfil.c: s/EXPORT/EXPORT_DEF/.
 
 	* src/base/ftotval.c: Include FT_OPENTYPE_VALIDATE_H.
 
 	* src/psaux/psobjs.c (ps_table_add): Check `length'.
 
 2008-11-15  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttinterp.c (tt_default_graphics_state): The default
 	value for `scan_type' is zero, as confirmed by Greg Hitchcock from
 	Microsoft.  Problem reported by Michal Nowakowski
 	<miszka@limes.com.pl>.
 
 2008-11-12  Tor Andersson  <tor.andersson@gmail.com>
 
 	* src/cff/cffdrivr.c (cff_get_cmap_info): Initialize `format' field.
 	This fixes Savannah bug #24819.
 
 2008-11-08  Werner Lemberg  <wl@gnu.org>
 
 	* src/sfnt/sfobjs.c (sfnt_load_face): Remove #if 0/#endif guards
 	since OpenType version 1.5 has been released.
 
 	* include/ttnameid.h (TT_NAME_ID_WWS_FAMILY,
 	TT_NAME_ID_WWS_SUBFAMILY): New macros for OpenType 1.5.
 	(TT_URC_COPTIC, TT_URC_VAI, TT_URC_NKO, TT_URC_BALINESE,
 	TT_URC_PHAGSPA, TT_URC_NON_PLANE_0, TT_URC_PHOENICIAN,
 	TT_URC_TAI_LE, TT_URC_NEW_TAI_LUE, TT_URC_BUGINESE,
 	TT_URC_GLAGOLITIC, TT_URC_YIJING, TT_URC_SYLOTI_NAGRI,
 	TT_URC_LINEAR_B, TT_URC_ANCIENT_GREEK_NUMBERS, TT_URC_UGARITIC,
 	TT_URC_OLD_PERSIAN, TT_URC_SHAVIAN, TT_URC_OSMANYA,
 	TT_URC_CYPRIOT_SYLLABARY, TT_URC_KHAROSHTHI, TT_URC_TAI_XUAN_JING,
 	TT_URC_CUNEIFORM, TT_URC_COUNTING_ROD_NUMERALS, TT_URC_SUNDANESE,
 	TT_URC_LEPCHA, TT_URC_OL_CHIKI, TT_URC_SAURASHTRA, TT_URC_KAYAH_LI,
 	TT_URC_REJANG, TT_URC_CHAM, TT_URC_ANCIENT_SYMBOLS,
 	TT_URC_PHAISTOS_DISC, TT_URC_OLD_ANATOLIAN, TT_URC_GAME_TILES): New
 	macros for OpenType 1.5.
 
 2008-11-08  Wenlin Institute  <wenlin@wenlin.com>
 
 	* src/base/ftobjs.c (ft_glyphslot_free_bitmap): Protect against
 	slot->internal == NULL.  Reported by Graham Asher.
 
 2008-11-08  Werner Lemberg  <wl@gnu.org>
 
 	* src/sfnt/sfobjs.c (tt_face_get_name): Modified to return an error
 	code so that memory allocation problems can be distinguished from
 	missing table entries.  Reported by Graham Asher.
 	(GET_NAME): New macro.
 	(sfnt_load_face): Use it.
 
 2008-11-05  Werner Lemberg  <wl@gnu.org>
 
 	* devel/ftoption.h, include/freetype/config/ftoption.h
 	[TT_CONFIG_OPTION_BYTECODE_INTERPRETER]: Undefine
 	TT_CONFIG_OPTION_UNPATENTED_HINTING.  This fixes the return value of
 	`FT_Get_TrueType_Engine_Type' (and makes it work as documented).
 	Reported in bug #441638 of bugzilla.novell.com.
 
 	* docs/CHANGES: Document it.
 
 2008-11-03  Werner Lemberg  <wl@gnu.org>
 
 	* src/type1/t1load.c (parse_subrs): Use an endless loop.  There are
 	fonts (like HELVI.PFB version 003.001, used on OS/2) which define
 	some `subrs' elements more than once.  Problem reported by Peter
 	Weilbacher <mozilla@weilbacher.org>.
 
 2008-10-15  Graham Asher  <graham.asher@btinternet.com>
 
 	* src/sfnt/ttpost.c (tt_post_default_names): Add `const'.
 
 2008-10-15  David Turner  <david@freetype.org>
 
 	* src/truetype/ttgxvar.c (TT_Set_MM_Blend): Disambiguate for
 	meddlesome compilers' warning against `for ( ...; ...; ...) ;'.
 
 2008-10-14  Werner Lemberg  <wl@gnu.org>
 
 	* src/cff/cffobjs.c (cff_face_init): Remove compiler warning.
 	Suggested by Bram Tassyns in Savannah patch #6651.
 
 2008-10-12  Graham Asher  <graham.asher@btinternet.com>
 
 	* src/sfnt/sfobjs.c (sfnt_load_face): Fix computation of
 	`underline_position'.
 
 2008-10-12  Werner Lemberg  <wl@gnu.org>
 
 	* docs/CHANGES: Updated.
 
 2008-10-09  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Fix Savannah bug #24468.
 
 	According to include/freetype/internal/ftobjs.h, the appropriate
 	type to interchange single character codepoint is FT_UInt32. It
 	should be distinguished from FT_UInt which can be 16bit integer.
 
 	* src/sfnt/ttcmap.c (tt_cmap4_char_map_linear): Change the type
 	of the second argument `pcharcode' from FT_UInt* to FT_UInt32*.
 	(tt_cmap4_char_map_binary): Ditto.
 	(tt_cmap14_get_nondef_chars): Change the type of return value
 	from FT_UInt* to FT_UInt32*.
 
 2008-10-08  John Tytgat  <John.Tytgat@esko.com>
 
 	Fix Savannah bug #24485.
 
 	* src/type1/t1load.c (parse_charstrings): Assure that we always have
 	a .notdef glyph.
 
 2008-10-05  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftmac.c: Include FT_TRUETYPE_TAGS_H for multi build.
 	* builds/mac/ftmac.c: Ditto.
 
 2008-10-05  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* include/freetype/tttags.h (TTAG_TYP1, TTAG_typ1): Fix definitions.
 	* src/base/ftobjs.c: Include FT_TRUETYPE_TAGS_H.
 
 2008-10-05  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/sfnt/sfobjs.c (sfnt_open_font): Allow `typ1' version tag in
 	the beginning of sfnt container.
 	* src/sfnt/ttload.c (check_table_dir): Return
 	`SFNT_Err_Table_Missing' when sfnt table directory structure is
 	correct but essential tables for TrueType fonts (`head', `bhed' or
 	`SING') are missing.  Other errors are returned by
 	SFNT_Err_Unknown_File_Format.
 
 	* src/base/ftobjs.c (FT_Open_Face): When TrueType driver returns
 	`FT_Err_Table_Missing', try `open_face_PS_from_sfnt_stream'.  It is
 	enabled only when old mac font support is configured.
 
 2008-10-04  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* include/freetype/tttags.h (TTAG_CID, TTAG_FOND, TTAG_LWFN,
 	TTAG_POST, TTAG_sfnt, TTAG_TYP1, TTAG_typ1): New tags to simplify
 	the repeated calculations of these values in ftobjs.c and ftmac.c.
 	* src/base/ftobjs.c: Replace all FT_MAKE_TAG by new tags.
 	* src/base/ftmac.c: Ditto.
 	* builds/mac/ftmac.c: Ditto.
 
 2008-10-04  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftobjs.c (ft_lookup_PS_in_sfnt_stream): Remove wrong
 	initialization of *is_sfnt_cid.
 
 2008-10-04  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftobjs.c (open_face_PS_from_sfnt_stream): Remove compiler
 	warnings.
 
 2008-10-04  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftobjs.c (ft_lookup_PS_in_sfnt): Replaced by...
 	(ft_lookup_PS_in_sfnt_stream): This.
 	(open_face_PS_from_sfnt_stream): New function.  It checks whether
 	the stream is sfnt-wrapped Type1 PS font or sfnt-wrapped CID-keyed
 	font, then try to open a face for given face_index.
 	(Mac_Read_sfnt_Resource): Replace the combination of
 	`ft_lookup_PS_in_sfnt' and `open_face_from_buffer' by
 	`open_face_PS_from_sfnt_stream'.
 	* src/base/ftmac.c (FT_New_Face_From_SFNT): Ditto.
 	* builds/mac/ftmac.c (FT_New_Face_From_SFNT): Ditto.
 	* src/base/ftbase.h: Remove `ft_lookup_PS_in_sfnt' and add
 	`open_face_PS_from_sfnt_stream'.
 
 2008-10-03  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftobjs.c (ft_lookup_PS_in_sfnt): Set *is_sfnt_cid to
 	FALSE if neither `CID ' nor `TYP1' is found in the sfnt container.
 
 2008-10-03  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* include/freetype/config/ftconfig.h: Define FT_MACINTOSH when SC or
 	MrC compiler of MPW is used.  These compilers do not define the
 	macro __APPLE__ by themselves.
 	* builds/unix/ftconfig.in: Ditto.
 	* builds/vms/ftconfig.h: Ditto.
 	* src/base/ftbase.c: Use FT_MACINTOSH instead of __APPLE__, to
 	include ftmac.c if FreeType 2 is built by MPW.
 	* src/base/ftobjs.c: Use FT_MACINTOSH instead of __APPLE__, to
 	enable shared functions for ftmac.c if FreeType 2 is built by MPW.
 
 	* builds/mac/ftmac.c: Include ftbase.h.
 	(memory_stream_close): Removed.
 	(new_memory_stream): Ditto.
 	(open_face_from_buffer): Removed.  Use the implementation in
 	ftobjs.c.
 	(ft_lookup_PS_in_sfnt): Ditto.
 
 	* builds/mac/FreeType.m68k_far.make.txt: Build ftmac.c as an
 	included part of ftbase.c, to share the functions in ftobjs.c.  The
 	rule compiling ftmac.c separately is removed and the rule copying
 	ftbase.c from src/base/ftbase.c to builds/mac/ftbase.c is added.
 	* builds/mac/FreeType.m68k_cfm.make.txt: Ditto.
 	* builds/mac/FreeType.ppc_classic.make.txt: Ditto.
 	* builds/mac/FreeType.ppc_carbon.make.txt: Ditto.
 
 2008-10-02  Bram Tassyns  <bramt@enfocus.be>
 
 	* src/cff/cffgload.c (cff_slot_load): Map CID 0 to GID 0.  This
 	fixes Savannah bug #24430.
 
 2008-10-02  Werner Lemberg  <wl@gnu.org>
 
 	* builds/freetype.mk (BASE_H): Rename to...
 	(INTERNAL_H): This.
 	(FREETYPE_H): Updated.
 	* src/base/rules.mk: (BASE_OBJ_S, OBJ_DIR/%.$O): Add BASE_H.
 	* src/bdf/rules.mk (BDF_DRV_H): Add bdferror.h.
 	* src/cache/rules.mk (CACHE_DRV_H): Add ftccache.h and ftcsbits.h.
 	* src/pcf/rules.mk (PCF_DRV_H): Add pcfread.h.
 	* src/raster/rules.mk (RASTER_DRV_H): Add ftmisc.h.
 	* src/type42/rules.mk (T42_DRV_H): Add t42types.h.
 
 2008-10-02  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftbase.h: New file to declare the private utility
 	functions shared by the sources of base modules.  Currently,
 	`ft_lookup_PS_in_sfnt' and `open_face_from_buffer' are declared to
 	share between ftobjs.c and ftmac.c.
 
 	* src/base/rule.mk: Add ftbase.h.
 
 	* src/base/ftobjs.c: Include ftbase.h.
 	(memory_stream_close): Build on any platform when old MacOS font
 	support is enabled.
 	(new_memory_stream): Ditto.
 	(open_face_from_buffer): Build on any platform when old MacOS font
 	support is enabled.  The counting of the face in a font file is
 	slightly different between Carbon-dependent parser and Carbon-free
 	parser.  They are merged with the platform-specific conditional.
 	(ft_lookup_PS_in_sfnt): Ditto.
 
 	* src/base/ftmac.c: Include ftbase.h.
 	(memory_stream_close): Removed.
 	(new_memory_stream): Ditto.
 	(open_face_from_buffer): Removed.  Use the implementation in
 	ftobjs.c.
 	(ft_lookup_PS_in_sfnt): Ditto.
 
 2008-10-02  Werner Lemberg  <wl@gnu.org>
 
 	* src/sfnt/sfobjs.c (sfnt_load_face): `psnames_error' is only needed
 	if TT_CONFIG_OPTION_POSTSCRIPT_NAMES is defined.
 
 2008-10-01  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttobjs.c (tt_face_done), src/cff/cffobjs.c
 	(cff_face_done), src/pfr/pfrobjs.c (pfr_face_done),
 	src/pcf/pcfdrivr.c (PCF_Face_Done), src/cid/cidobjs.c
 	(cid_face_done), src/bdf/bdfdrivr. (BDF_Face_Done),
 	src/sfnt/sfobjs.c (sfnt_face_done): Protect against face == 0.
 	Reported by Graham Asher.
 
 2008-09-30  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/rules.mk: Add conditional source to BASE_SRC, for `make
 	multi' on Mac OS X.  If the macro $(ftmac_c) is defined,
 	$(BASE_DIR)/$(ftmac_c) is added to BASE_SRC.  In a normal build, the
 	lack of ftmac.c in BASE_SRC is not serious because ftbase.c includes
 	ftmac.c.
 	* builds/unix/unix-def.in: Add a macro definition of $(ftmac_c).
 	* builds/unix/configure.raw: Add procedure to set up appropriate
 	value of $(ftmac_c) with the consideration of the availability of
 	Carbon framework.
 
 2008-09-30  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/Jamfile: Add target for multi build by jam on Mac OS X.
 	* src/base/ftobjs.c (FT_New_Face): Fix the condition to include this
 	function for MPW building.  It is synchronized the condition to
 	include ftmac.c source into ftbase.c.
 
 2008-09-22  Werner Lemberg  <wl@gnu.org>
 
 	* src/cff/cffgload.c (CFF_Operator, cff_argument_counts,
 	cff_decoder_parse_charstrings): Handle (invalid)
 	`callothersubr' and `pop' instructions.
 
 2008-09-22  John Tytgat  <John.Tytgat@esko.com>
 
 	Fix Savannah bug #24307.
 
 	* include/freetype/internal/t1types.h (CID_FaceRec),
 	src/type42/t42types.h (T42_FaceRec): Comment out `afm_data'.
 
 2008-09-21  Werner Lemberg  <wl@gnu.org>
 
 	* src/smooth/ftgrays.c (gray_raster_render): Don't dereference
 	`target_map' if FT_RASTER_FLAG_DIRECT is set.  Problem reported by
 	Stephan T. Lavavej <stl@nuwen.net>.
 
 2008-09-21  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/otvalid/Jamfile: Add missing target `otvmath' for multi build
 	by jam.
 	* src/sfnt/Jamfile: Add missing target `ttmtx' for multi build by
 	jam.
 
 2008-09-20  Werner Lemberg  <wl@gnu.org>
 
 	* src/smooth/ftgrays.c (gray_find_cell): Fix threshold.  The values
 	passed to this function are already `normalized'.  Problem reported
 	by Stephan T. Lavavej <stl@nuwen.net>.
 
 	* docs/CHANGES: Document it.
 
 2008-09-20  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftoutln.c: Include FT_INTERNAL_DEBUG_H.
 	(FT_Outline_Decompose): Decorate with tracing messages.
 
 	* src/smooth/ftgrays.c [DEBUG_GRAYS]: Replace with
 	FT_DEBUG_LEVEL_TRACE.
 	[_STANDALONE_ && FT_DEBUG_LEVEL_TRACE]: Include stdio.h and
 	stdarg.h.
 
 	(FT_TRACE) [_STANDALONE_]: Remove.
 	(FT_Message) [_STANDALONE_ && FT_DEBUG_LEVEL_TRACE]: New function.
 	(FT_TRACE5, FT_TRACE7) [_STANDALONE_]: New macros.
 	(FT_ERROR) [_STANDALONE_]: Updated.
 
 	(gray_hline) [FT_DEBUG_LEVEL_TRACE]: Fix condition.
 	Use FT_TRACE7.
 	(gray_dump_cells): Make it `static void'.
 	(gray_convert_glyph): Use FT_TRACE7.
 
 	(FT_Outline_Decompose) [_STANDALONE_]: Synchronize with version in
 	ftoutln.c.
 
 	* src/base/ftadvanc.c (FT_Get_Advance, FT_Get_Advances): Use
 	FT_ERROR_BASE.
 
 	* docs/formats.txt: Updated.
 
 2008-09-19  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftmac.c: Import sfnt-wrapped Type1 and sfnt-wrapped
 	CID-keyed font support.
 	* builds/mac/ftmac.c: Ditto.
 
 2008-09-19  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftobjs.c (Mac_Read_sfnt_Resource): Fix double free bug in
 	sfnt-wrapped Type1 and sfnt-wrapped CID-keyed font support code.
 	`open_face_from_buffer' frees the passed buffer if it cannot open a
 	face from the buffer, so the caller must not free it.
 
 2008-09-19  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftobjs.c (Mac_Read_sfnt_Resource): Add initial support
 	for sfnt-wrapped Type1 and sfnt-wrapped CID-keyed font.
 	(ft_lookup_PS_in_sfnt): New function to look up `TYP1' or `CID '
 	table in sfnt table directory.  It is used before loading TrueType
 	font driver.
 
 	* docs/CHANGES: Add note about the current status of sfnt-wrapped
 	Type1 and sfnt-wrapped CID-keyed font support.
 
 2008-09-18  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftsystem.c (FT_Done_Memory): Use ft_sfree directly for
 	orthogonality (ft_free and ft_sfree could belong to different memory
 	pools).  This fixes Savannah bug #24297.
 
 2008-09-18  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/cff/cffobjs.c (cff_face_init): Use TTAG_OTTO defined
 	in ttags.h instead of numerical value 0x4F54544FL.
 
 2008-09-16  Werner Lemberg  <wl@gnu.org>
 
 	* src/cff/cffgload.h, src/cff/cffgload.c
 	(cff_decoder_set_width_only): Eliminate function call.
 
 2008-09-15  George Williams  <gww@silcom.com>
 
 	Fix Savannah bug #24179, reported by Bram Tassyns.
 
 	* src/type1/t1load.c (mm_axis_unmap, T1_Get_MM_Var): Fix computation
 	of default values.
 
 2008-09-15  Werner Lemberg  <wl@gnu.org>
 
 	* src/tools/glnames.py (main): Surround `ft_get_adobe_glyph_index'
 	and `ft_adobe_glyph_list' with FT_CONFIG_OPTION_ADOBE_GLYPH_LIST to
 	prevent unconditional definition.  This fixes Savannah bug #24241.
 
 	* src/psnames/pstables.h: Regenerated.
 
 2008-09-13  Werner Lemberg  <wl@gnu.org>
 
 	* autogen.sh, builds/unix/configure.raw,
 	include/freetype/config/ftconfig.h, builds/unix/ftconfig.in: Minor
 	beautifying.
 
 	* include/freetype/ftadvanc.h, include/freetype/ftgasp.h,
 	include/freetype/ftlcdfil.h: Protect against FreeType 1.
 	Some other minor fixes.
 
 	* devel/ftoption.h: Synchronize with
 	include/freetype/config/ftoption.h.
 
 2008-09-11  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftbase.c: Include ftadvanc.c.
 
 2008-09-11  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* builds/unix/ftconfig.in: Duplicate the cpp computation of
 	FT_SIZEOF_{INT|LONG} from include/freetype/config/ftconfig.h.
 	(FT_USE_AUTOCONF_SIZEOF_TYPES): New macro.  If defined, the cpp
 	computation is disabled and the statically configured sizes are
 	used.  This fixes Savannah bug #21250.
 
 	* builds/unix/configure.raw: Add the checks to compare the cpp
 	computation results of the bit length of int and long versus the
 	sizes detected by running `configure'.  If the results are
 	different, FT_USE_AUTOCONF_SIZEOF_TYPES is defined to prioritize the
 	results.
 	New option --{enable|disable}-biarch-config is added to define or
 	undefine FT_USE_AUTOCONF_SIZEOF_TYPES manually.
 
 2008-09-05  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* builds/unix/configure.raw: Clear FT2_EXTRA_LIBS when Carbon or
 	ApplicationService framework is missing.  Although this value is not
 	used in building of FreeType2, it is written in `freetype2.pc' and
 	`freetype-config'.
 
 2008-09-01  david turner  <david@freetype.org>
 
 	* src/cache/ftccmap.c (FTC_CMapCache_Lookup): Accept a negative cmap
 	index to mean `use default cached FT_Face's charmap'.  This fixes
 	Savannah bug #22625.
 	* include/freetype/ftcache.h: Document it.
 
 
 	Make FT_MulFix an inlined function.  This is done to speed up
 	FreeType a little (on x86 3% when loading+hinting, 10% when
 	rendering, ARM savings are more important though).  Disable this by
 	undefining FT_CONFIG_OPTION_INLINE_MULFIX.
 
 	Use of assembler code can now be controlled with
 	FT_CONFIG_OPTION_NO_ASSEMBLER.
 
 	* include/freetype/config/ftconfig.h, builds/unix/ftconfig.in
 	[!FT_CONFIG_OPTION_NO_ASSEMBLER] (FT_MulFix_arm): New assembler
 	implementation.
 	[!FT_CONFIG_OPTION_NO_ASSEMBLER] (FT_MulFix_i386): Assembler
 	implementation taken from `ftcalc.c'.
 	[!FT_CONFIG_OPTION_NO_ASSEMBLER] (FT_MULFIX_ASSEMBLER): New macro
 	which is defined to the platform-specific assembler implementation
 	of FT_MulFix.
 	[FT_CONFIG_OPTION_INLINE_MULFIX && FT_MULFIX_ASSEMBLER]
 	(FT_MULFIX_INLINED): New macro.
 
 	* include/freetype/config/ftoption.h (FT_CONFIG_OPTION_NO_ASSEMBLER,
 	FT_CONFIG_OPTION_INLINE_MULFIX): New macros.
 
 	* include/freetype/freetype.h: Updated to handle FT_MULFIX_INLINED.
 
 	* src/base/ftcalc.c: Updated to use FT_MULFIX_ASSEMBLER and
 	FT_MULFIX_INLINED.
 
 
 	Add a new header named FT_ADVANCES_H declaring some new APIs to
 	extract the advances of one or more glyphs without necessarily
 	loading their outlines.  Also provide `fast loaders' for the
 	TrueType, Type1, and CFF font drivers (more to come later).
 
 	* src/base/ftadvanc.c, include/freetype/ftadvanc.h: New files.
 
 	* include/freetype/config/ftheader.h (FT_ADVANCES_H): New macro.
 	* include/freetype/freetype.h (FT_LOAD_ADVANCE_ONLY): New macro.
 
 	* include/freetype/internal/ftdriver.h (FT_Face_GetAdvancesFunc):
 	`flags' and `advances' are now of type `FT_UInt' and `FT_Fixed',
 	respectively.
 
 	* src/base/Jamfile (_sources), src/base/rules.mk (BASE_SRC): Add
 	ftadvanc.c.
 
 	* src/cff/cffdrivr.c (cff_get_advances): New function.
 	(cff_driver_class): Register it.
 
 	* src/cff/cffgload.c (cff_decoder_set_width_only): New function.
 	(cff_decoder_parse_charstrings): Handle `width_only'.
 	(cff_slot_load): Handle FT_LOAD_ADVANCE_ONLY.
 
 	* src/cff/cffgload.h (cff_decoder): New element `width_only'.
 	(cff_decoder_set_width_only): New declaration.
 
 	* src/truetype/ttdriver.c (tt_get_advances): New function.
 	(tt_driver_class): Register it.
 
 	* src/truetype/ttgload.c (Get_HMetrics, Get_VMetrics): Renamed to...
 	(TT_Get_HMetrics, TT_Get_VMetrics): This.
 	Update callers.
 	* src/truetype/ttgload.h: Declare them.
 
 	* src/type1/t1gload.h, src/type1/t1gload.c (T1_Get_Advances): New
 	function.
 	* src/type1/t1driver.c (t1_driver_class): Register T1_Get_Advances.
 
 
 	Add checks for minimum version of the `autotools' stuff.
 
 	* autogen.sh: Implement it.
 	(get_major_version, get_minor_version, get_patch_version,
 	compare_to_minimum_version, check_tool_version): New auxiliary
 	functions.
 
 	* README.CVS: Document it.
 
 2008-08-29  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/sfnt/sfobjs.c (sfnt_open_font): Use TTAG_OTTO defined in
 	ttags.h instead of FT_MAKE_TAG( 'O', 'T', 'T', 'O' ).
 
 2008-08-28  Werner Lemberg  <wl@gnu.org>
 
 	* src/type1/t1load.c (parse_encoding): Protect against infinite
 	loop.  This fixes Savannah bug #24150 (where a patch has been posted
 	too).
 
 2008-08-23  Werner Lemberg  <wl@gnu.org>
 
 	* src/type/t1afm.c (compare_kern_pairs), src/pxaux/afmparse.c
 	(afm_compare_kern_pairs): Fix comparison.  This fixes Savannah bug
 	#24119.
 
 2008-08-19  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftobjs.c (FT_Stream_New): Initialize *astream always,
 	even if passed library or arguments are invalid.  This fixes a bug
 	that an uninitialized stream is freed when an invalid library handle
 	is passed.  Originally proposed by Mike Fabian, 2008/08/18 on
 	freetype-devel.
 	(FT_Open_Face): Ditto (stream).
 	(load_face_in_embedded_rfork): Ditto (stream2).
 
 2008-08-18  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftmac.c: Add a fallback to guess the availability of the
 	`ResourceIndex' type.  It is used when built without configure
 	(e.g., a build with Jam).
 	* builds/mac/ftmac.c: Ditto.
 	* builds/unix/configure.raw: Set HAVE_TYPE_RESOURCE_INDEX to 1 or 0
 	explicitly, even if `ResourceIndex' is unavailable.
 
 2008-08-18  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* builds/unix/configure.raw: In checking of Mac OS X features,
 	all-in-one header file `Carbon.h' is replaced by the minimum
 	header file `CoreServices.h', similar to current src/base/ftmac.c.
 
 2008-08-18  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/sfnt/ttcmap.c (tt_cmap2_validate): Skip the validation of
 	sub-header when its code_count is 0.  Many Japanese Dynalab fonts
 	include such an empty sub-header (code_count == 0, first_code == 0
 	delta == 0, but offset != 0) as the second sub-header in SJIS cmap.
 
 2008-08-04  Werner Lemberg  <wl@gnu.org>
 
 	* src/type1/t1tokens.h: Handle `ForceBold' keyword.  This fixes
 	Savannah bug #23995.
 
 	* src/cid/cidload.c (parse_expansion_factor): New callback function.
 	(cid_field_records): Use it for `ExpansionFactor'.
 	* src/cod/cidtoken.h: Handle `ForceBold' keyword.
 	Don't handle `ExpansionFactor'.
 
 2008-08-04  Bram Tassyns  <bramt@enfocus.be>
 
 	* src/cff/cffparse.c (cff_parse_fixed_scaled): Fix thinko which
 	resulted in incorrect scaling.  This fixes Savannah bug #23973.
 
 2008-08-04  Werner Lemberg  <wl@gnu.org>
 
 	Be more tolerant w.r.t. invalid entries in SFNT table directory.
 
 	* src/sfnt/ttload.c (check_table_dir): Ignore invalid entries and
 	adjust table count.
 	Add more trace messages.
 	(tt_face_load_font_dir): Updated.
 
 2008-07-30  Werner Lemberg  <wl@gnu.org>
 
 	* src/cff/cffgload.c (cff_decoder_parse_charstrings): No longer
 	assume that the first argument on the stack is the bottom-most
 	element.  Two reasons:
 
 	  o According to people from Adobe it is missing in the Type 2
 	    specification that pushing of additional, superfluous arguments
 	    on the stack is prohibited.
 
 	  o Acroread in general handles fonts differently, namely by popping
 	    the number of arguments needed for a particular operand (as a PS
 	    interpreter would do).  In case of buggy fonts this causes a
 	    different interpretation which of the elements on the stack are
 	    superfluous and which not.
 
 	Since there are CFF subfonts (embedded in PDFs) which rely on
 	Acroread's behaviour, FreeType now does the same.
 
 2008-07-27  Werner Lemberg  <wl@gnu.org>
 
 	Add extra mappings for `Tcommaaccent' and `tcommaaccent'.  This
 	fixes Savannah bug #23940.
 
 	* src/psnames/psmodule.c (WGL_EXTRA_LIST_SIZE): Rename to...
 	(EXTRA_GLYPH_LIST_SIZE): This.
 	Increase by 2.
 	(ft_wgl_extra_unicodes): Rename to...
 	(ft_extra_glyph_unicodes): This.
 	Add two code values.
 	(ft_wgl_extra_glyph_names): Rename to...
 	(ft_extra_glyph_names): This.
 	Add two glyphs.
 	(ft_wgl_extra_glyph_name_offsets): Rename to...
 	(ft_extra_glyph_name_offsets): This.
 	Add two offsets.
 
 	(ps_check_wgl_name, ps_check_wgl_unicode): Rename to...
 	(ps_check_extra_glyph_name, ps_check_extra_glyph_unicode): This.
 	Updated.
 	(ps_unicodes_init): Updated.
 
 2008-07-26  Werner Lemberg  <wl@gnu.org>
 
 	* src/cff/cffgload.c (cff_decoder_prepare,
 	cff_decoder_parse_charstrings): Improve debug output.
 
 2008-07-22  Martin McBride  <mmcbride@emtex.com>
 
 	* src/sfnt/ttcmap.c (tt_cmap4_validate, tt_cmap4_char_map_linear,
 	tt_cmap4_char_map_binary): Handle fonts which treat the last segment
 	specially.  According to the specification, such fonts would be
 	invalid but acroread accepts them.
 
 2008-07-16  Jon Foster  <Jon.Foster@cabot.co.uk>
 
 	* src/pfr/pfrdrivr.c (pfr_get_advance): Fix off-by-one error.
 
 	* src/base/ftcalc.c (FT_MulFix): Fix portability issue.
 
 	* src/sfnt/ttpost.c (MAC_NAME) [!FT_CONFIG_OPTION_POSTSCRIPT_NAMES]:
 	Fix compiler warning.
 
 2008-07-16  Werner Lemberg  <wl@gnu.org>
 
 	Handle CID-keyed fonts wrapped in an SFNT (with cmaps) correctly.
 
 	* src/cff/cffload.c (cff_font_load): Pass `pure_cff'.
 	Invert sids table only if `pure_cff' is set.
 	* src/cff/cffload.h: Udpated.
 
 	* src/cff/cffobjs.c (cff_face_init): Updated.
 	Set FT_FACE_FLAG_CID_KEYED only if pure_cff is set.
 
 	* docs/CHANGES: Updated.
 
 2008-07-09  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttpload.c (tt_face_load_loca): Handle buggy fonts
 	where num_locations < num_glyphs.  Problem reported by Ding Li.
 
 2008-07-05  Werner Lemberg  <wl@gnu.org>
 
 	Since FreeType uses `$(value ...)', we now need GNU make 3.80 or
 	newer.  This fixes Savannah bug #23648.
 
 	* configure: zsh doesn't like ${1+"$@"}.
 	Update needed GNU make version.
 	* builds/toplevel.mk: Check for `$(eval ...)'.
 	* docs/INSTALL.GNU, docs/INSTALL.CROSS, docs/INSTALL.UNIX: Document
 	it.
 
 2008-07-04  Werner Lemberg  <wl@gnu.org>
 
 	* src/raster/ftraster.c (Draw_Sweep): If span is smaller than one
 	pixel, only check for dropouts if neither start nor end point lies
 	on a pixel center.  This fixes Savannah bug #23762.
 
 2008-06-29  Werner Lemberg  <wl@gnu.org>
 
 	* Version 2.3.7 released.
 	=========================
 
 
 	Tag sources with `VER-2-3-7'.
 
 	* docs/CHANGES, docs/VERSION.DLL: Update documentation and bump
 	version number to 2.3.7.
 
 	* README, Jamfile (RefDoc), builds/win32/visualc/index.html,
 	builds/win32/visualc/freetype.dsp,
 	builds/win32/visualc/freetype.vcproj,
 	builds/win32/visualce/index.html,
 	builds/win32/visualce/freetype.dsp,
 	builds/win32/visualce/freetype.vcproj: s/2.3.6/2.3.7/, s/236/237/.
 
 	* include/freetype/freetype.h (FREETYPE_PATCH): Set to 7.
 
 	* builds/unix/configure.raw (version_info): Set to 9:18:3.
 
 	* docs/release: Updated.
 
 2008-06-28  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftglyph.c (FT_Matrix_Multiply, FT_Matrix_Invert): Move to...
 	* src/ftcalc.c: Here.  This fixes Savannah bug #23729.
 
 2008-06-27  Werner Lemberg  <wl@gnu.org>
 
 	* src/raster/ftraster.c (Vertical_Sweep_Drop, Horizontal_Sweep_Drop,
 	Horizontal_Gray_Sweep_Drop): Test for intersections which
 	degenerate to a single point can be ignored; this has been confirmed
 	by Greg Hitchcock from Microsoft.  (This was commented out code.)
 
 2008-06-26  Werner Lemberg  <wl@gnu.org>
 
 	Improve navigation in API reference.
 
 	* src/tools/docmaker/tohtml.py (html_header_3): Renamed to...
 	(html_header_6): This.
 	(html_header_3, html_header_3i, html_header_4, html_header_5,
 	html_header_5t): New strings.
 	(toc_footer_start, toc_footer_end): New strings.
 	(HtmlFormatter::html_header): Updated.
 	(HtmlFormatter::html_index_header, HtmlFormatter::html_toc_header):
 	New strings.
 	(HtmlFormatter::index_enter): Use `html_index_header'.
 	(HtmlFormatter::index_exit): Print `html_footer'.
 	(HtmlFormatter::toc_enter): Use `html_toc_header'.
 	(HtmlFormatter::toc_exit): Print proper footer.
 
 	Convert ~ to non-breakable space.
 
 	* src/tools/docmaker/tohtml.py (make_html_para): Implement it.
 	Update header files accordingly.
 
 2008-06-24  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* builds/unix/configure.raw: Check type `ResourceIndex' explicitly
 	and define HAVE_TYPE_RESOURCE_INDEX if it is defined.  Mac OS X 10.5
 	bundles 10.4u SDK with MAC_OS_X_VERSION_10_5 macro but without
 	ResourceIndex type definition.  The macro does not inform the type
 	availability.
 	* src/base/ftmac.c: More parentheses are inserted to clarify the
 	conditionals to disable legacy APIs in `10.5 and later' cases.  If
 	HAVE_TYPE_RESOURCE_INDEX is not defined, ResourceIndex is defined.
 
 2008-06-24  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttinterp.c (Ins_SCANTYPE): Don't check rendering
 	mode.
 
 	* src/raster/ftraster.c (Render_Glyph, Render_Gray_Glyph,
 	Draw_Sweep): No-dropout mode is value 2, not value 0.
 	(Draw_Sweep): Really skip dropout handling for no-dropout mode.
 
 2008-06-24  Werner Lemberg  <wl@gnu.org>
 
 	* src/psaux/psobjs.c (t1_builder_close_contour): Don't add contour
 	if it consists of one point only.  Based on a patch from Savannah
 	bug #23683 (from John Tytgat).
 
 2008-06-22  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgload.c (TT_Load_Glyph): Protect bytecode stuff
 	with IS_HINTED.
 
 	* docs/CHANGES: Updated.
 
 2008-06-22  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* builds/unix/configure.raw: If CFLAGS has `-isysroot XXX' option
 	but LDFLAGS does not, import it to LDFLAGS.  The option is used to
 	specify non-default SDK on Mac OS X (e.g., universal binary SDK for
 	Mac OS X 10.4 on PowerPC platform).  Although Apple TechNote 2137
 	recommends to add the option only to CFLAGS, LDFLAGS should include
 	it because libfreetype.la is built with -no-undefined.  This fixes a
 	bug reported by Ryan Schmidt in MacPorts,
 	http://trac.macports.org/ticket/15331.
 
 2008-06-21  Werner Lemberg  <wl@gnu.org>
 
 	Enable access to the various dropout rules of the B&W rasterizer.
 	Pass dropout rules from the TT bytecode interpreter to the
 	rasterizer.
 
 	* include/freetype/ftimage.h (FT_OUTLINE_SMART_DROPOUTS,
 	FT_OUTLINE_EXCLUDE_STUBS): New flags for for FT_Outline.
 
 	* src/raster/ftraster.c (Vertical_Sweep_Drop, Horizontal_Sweep_Drop,
 	Horizontal_Gray_Sweep_Drop): Use same mode numbers as given in the
 	OpenType specification.
 	Fix mode 4 computation.
 	(Render_Glyph, Render_Gray_Glyph): Handle new outline flags.
 
 	* src/truetype/ttgload.c (TT_Load_Glyph) Convert scan conversion
 	mode to FT_OUTLINE_XXX flags.
 
 	* src/truetype/ttinterp.c (Ins_SCANCTRL): Enable ppem check.
 
 2008-06-19  Werner Lemberg  <wl@gnu.org>
 
 	* src/cff/cffobjs.c (cff_face_init): Compute final
 	`dict->units_per_em' value before assigning it to
 	`cffface->units_per_EM'.  Otherwise, CFFs without subfonts are
 	scaled incorrectly if the font matrix is non-standard.  This fixes
 	Savannah bug #23630.
 
 	* docs/CHANGES: Updated.
 
 2008-06-19  Werner Lemberg  <wl@gnu.org>
 
 	* src/type/t1objs.c (T1_Face_Init): Slightly improve algorithm fix
 	from 2008-06-19.
 
 2008-06-18  Werner Lemberg  <wl@gnu.org>
 
 	* src/type/t1objs.c (T1_Face_Init): Fix change from 2008-03-21.
 	Reported by Peter Weilbacher <mozilla@weilbacher.org>.
 
 	* docs/CHANGES: Updated.
 
 2008-06-15  George Williams  <gww@silcom.com>
 
 	* src/otvalid/otvgpos.c (otv_MarkBasePos_validate): Set
 	`valid->extra2' to 1.  This is undocumented in the OpenType 1.5
 	specification.
 
 2008-06-15  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftcalc.c (FT_MulFix) <asm>: Protect registers correctly
 	from clobbering.  Patch from Savannah bug report #23556.
 
 	* docs/CHANGES: Document it.
 
 2008-06-10  Werner Lemberg  <wl@gnu.org>
 
 	* autogen.sh: Add option `--install' to libtoolize.
 
 2008-06-10  Werner Lemberg  <wl@gnu.org>
 
 	* Version 2.3.6 released.
 	=========================
 
 
 	Tag sources with `VER-2-3-6'.
 
 	* docs/CHANGES, docs/VERSION.DLL: Update documentation and bump
 	version number to 2.3.6.
 
 	* README, Jamfile (RefDoc), builds/win32/visualc/index.html,
 	builds/win32/visualc/freetype.dsp,
 	builds/win32/visualc/freetype.vcproj,
 	builds/win32/visualce/index.html,
 	builds/win32/visualce/freetype.dsp,
 	builds/win32/visualce/freetype.vcproj: s/2.3.5/2.3.6/, s/235/236/.
 
 	* include/freetype/freetype.h (FREETYPE_PATCH): Set to 6.
 
 	* builds/unix/configure.raw (version_info): Set to 9:17:3.
 
 
 	* include/freetype/internal/psaux.h (T1_BuilderRec): Remove `scale_x'
 	and `scale_y'.
 	* src/cff/cffgload.h (CFF_Builder): Remove `scale_x' and `scale_y'.
 
 
 	* src/cff/cffparse.c: Include FT_INTERNAL_DEBUG_H.
 	* src/cff/cffobjs.h: Include FT_INTERNAL_POSTSCRIPT_HINTS_H.
 
 2008-06-10  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftobjs.c (open_face): Check `clazz->init_face' and
 	`clazz->done_face'.
 
 2008-06-09  VaDiM  <s_sliva@rambler.ru>
 
 	Support debugging on WinCE.  From Savannah patch #6536; this fixes
 	bug #23497.
 
 	* builds/win32/ftdebug.c (OutputDebugStringEx): New function/macro
 	as a replacement for OutputDebugStringA (which WinCE doesn't have).
 	Update all callers.
 	(ft_debug_init) [_WIN32_CE]: WinCE apparently doesn't have
 	environment variables.
 
 2008-06-09  Werner Lemberg  <wl@gnu.org>
 
 	* README.CVS: Updated.
 
 	* builds/unix/configure.raw, builds/unix/freetype-config.in: Updated
 	for newer versions of autoconf and friends.
 
 2008-06-08  Werner Lemberg  <wl@gnu.org>
 
 	* src/type1/t1parse.h (T1_ParserRec): Make `base_len' and
 	`private_len' unsigned.
 
 	* src/type1/t1parse.c (read_pfb_tag): Make `asize' unsigned and read
 	it as such.
 	(T1_New_Parser, T1_Get_Private_Dict): Make `size' unsigned.
 
 
 	* src/base/ftstream.c (FT_Stream_Skip): Reject negative values.
 
 
 	* src/type1/t1load.c (parse_blend_design_positions): Check `n_axis'
 	for sane value.
 	Fix typo.
 
 
 	* src/psaux/psobjs.c (ps_table_add): Check `idx' correctly.
 
 
 	* src/truetype/ttinterp (Ins_SHC): Use BOUNDS() to check
 	`last_point'.
 
 
 	* src/sfnt/ttload.c (tt_face_load_max_profile): Limit
 	`maxTwilightPoints'.
 
 2008-06-06  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttinterp.c (Ins_IP): Handle case `org_dist == 0'
 	correctly.  This fixes glyphs `t' and `h' of Arial Narrow at 12ppem.
 
 2008-06-03  Werner Lemberg  <wl@gnu.org>
 
 	* include/freetype/ftcache.h (FTC_FaceID): Change type back to
 	FT_Pointer.  Reported by Ian Britten <britten@caris.com>.
 
 2008-06-02  Werner Lemberg  <wl@gnu.org>
 
 	Emit header info for defined FreeType objects in reference.
 
 	* src/tools/docmaker/content.py (re_header_macro): New regexp.
 	(ContentProcessor::__init__): Initialize new dictionary `headers'.
 	(DocBlock::__init__): Collect macro header definitions.
 
 	* src/tools/docmaker/tohtml.py (header_location_header,
 	header_location_footer): New strings.
 	(HtmlFormatter::__init__): Pass `headers' dictionary.
 	(HtmlFormatter::print_html_field): Don't emit paragraph tags.
 	(HtmlFormatter::print_html_field_list): Emit empty paragraph.
 	(HtmlFormatter::block_enter): Emit header info.
 
 2008-06-01  Werner Lemberg  <wl@gnu.org>
 
 	* include/freetype/config/ftheader.h (FT_UNPATENTED_HINTING_H,
 	FT_INCREMENTAL_H): Added.
 
 2008-05-28  Werner Lemberg  <wl@gnu.org>
 
 	* src/tools/docmaker/sources.py (SourceBlock::__init__): While
 	looking for markup tags, return immediately as soon a single one is
 	found.
 
 2008-05-28  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttinterp.c (Ins_MD): The MD instruction also uses
 	original, unscaled input values.  Confirmed by Greg Hitchcock from
 	Microsoft.
 
 2008-05-27  Werner Lemberg  <wl@gnu.org>
 
 	* src/tools/docmaker/tohtml.py (block_footer_start,
 	block_footer_middle): Beautify output.
 
 2008-05-25  Werner Lemberg  <wl@gnu.org>
 
 	* src/raster/ftraster.c (fc_black_render): Return 0 when we are
 	trying to render into a zero-width/height bitmap, not an error code.
 
 	* src/truetype/ttgload.c (load_truetype_glyph): Move initialization
 	of the graphics state for subglyphs to...
 	(TT_Hint_Glyph): This function.
 	Hinting instructions for a composite glyph apparently refer to the
 	just hinted subglyphs, not the unhinted, unscaled outline.  This
 	seems to fix Savannah bugs #20973 and (at least partially) #23310.
 
 2008-05-20  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftmac.c (FT_New_Face_From_Suitcase): Check if valid
 	`aface' is returned by FT_New_Face_From_FOND().  The patch was
 	proposed by an anonymous reporter of Savannah bug #23204.
 
 2008-05-18  Werner Lemberg  <wl@gnu.org>
 
 	* src/pshinter/pshalgo.c (ps_hints_apply): Reset scale values after
 	correction for pixel boundary.  Without this patch, the effect can
 	be cumulative under certain circumstances, making glyphs taller and
 	taller after each call.  This fixes Savannah bug #19976.
 
 2008-05-18  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftdebug.c (FT_Message, FT_Panic): Send output to stderr.
 	This fixes Savannah bug #23280.
 
 	* docs/CHANGES: Updated.
 
 2008-05-18  David Turner  <david@freetype.org>
 
 	* src/psnames/psmodule.c (ft_wgl_extra_unicodes,
 	ft_wgl_extra_glyph_names, ft_wgl_extra_glyph_name_offsets,
 	ps_check_wgl_name, ps_check_wgl_unicode): Use `static' to make
 	declarations non-global.
 
 	* src/type1/t1load.c: Add missing comment.
 
 2008-05-17  Sam Hocevar  <samh>
 
 	* src/truetype/ttgload.c (TT_Load_Simple_Glyph): Handle zero-contour
 	glyphs correctly.  Patch from Savannah bug #23277.
 
 2008-05-16  Werner Lemberg  <wl@gnu.org>
 
 	* docs/CHANGES: Updated.
 
 2008-05-16  Sergey Tolstov  <stolstov@esri.com>
 
 	Improve support for WGL4 encoded fonts.
 
 	* src/psnames/psmodule.c (WGL_EXTRA_LIST_SIZE): New macro.
 	(ft_wgl_extra_unicodes, ft_wgl_extra_glyph_names,
 	ft_wgl_extra_glyph_name_offsets): New arrays.
 	(ps_check_wgl_name, ps_check_wgl_unicode): New functions.
 	(ps_unicodes_init): Use them to add additional Unicode mappings.
 
 2008-05-15  Werner Lemberg  <wl@gnu.org>
 
 	* src/psaux/t1decode.c (t1_decoder_parse_charstrings)
 	<op_closepath>: `closepath' without a path is a no-op, not an error
 	(cf. the PS reference manual).
 
 	Reported by Martin McBride.
 
 2008-05-15  Werner Lemberg  <wl@gnu.org>
 
 	* builds/toplevel.mk (CONFIG_GUESS, CONFIG_SUB): Updated.
 
 2008-05-15  Werner Lemberg  <wl@gnu.org>
 
 	* src/type1/t1load.c (parse_subrs): Accept fonts with a subrs array
 	which contains a single but empty entry.  This is technically
 	invalid (since it must end with `return'), but...
 
 	Reported by Martin McBride.
 
 2008-05-14  Werner Lemberg  <wl@gnu.org>
 
 	Finish fix of scaling bug of CID-keyed CFF subfonts.
 
 	* include/freetype/internal/ftcalc.h, src/base/ftcalc.c
 	(FT_Matrix_Multiply_Scaled, FT_Vector_Transform_Scaled): New
 	functions.
 
 	* src/cff/cffobjs.h (CFF_Internal): New struct.  It is used to
 	provide global hinting data for both the top-font and all subfonts
 	(with proper scaling).
 
 	* src/cff/cffobjs.c (cff_make_private_dict): New function, using
 	code from `cff_size_init'.
 	(cff_size_init, cff_size_done, cff_size_select, cff_size_request):
 	Use CFF_Internal and handle subfonts.
 	(cff_face_init): Handle top-dict and subfont matrices correctly;
 	apply some heuristic in case of unlikely matrix concatenation
 	results.  This has been discussed with people from Adobe (thanks
 	goes mainly to David Lemon) who confirm that the CFF specs are fuzzy
 	and not correct.
 
 	* src/cff/cffgload.h (cff_decoder_prepare): Add `size' argument.
 
 	* src/cff/cffgload.c (cff_builder_init): Updated.
 	(cff_decoder_prepare): Handle hints globals for subfonts.
 	Update all callers.
 	(cff_slot_load): Handling scaling of subfonts properly.
 
 	* src/cff/cffparse.c (cff_parse_fixed_dynamic): New function.
 	(cff_parse_font_matrix): Use it.
 
 	* src/cff/cfftypes.h (CFF_FontDictRec): Make `units_per_em'
 	FT_ULong.
 
 	* docs/CHANGES: Document it.
 
 2008-05-13  Werner Lemberg  <wl@gnu.org>
 
 	* src/winfonts/winfnt.c (fnt_face_get_dll_font, FNT_Face_Init):
 	Handle case `face_index < 0'.
 	* docs/CHANGES: Document it.
 
 2008-05-04  Werner Lemberg  <wl@gnu.org>
 
 	First steps to fix the scaling bug of CID-keyed CFF subfonts,
 	reported by Ding Li on 2008/03/28 on freetype-devel.
 
 	* src/base/cff/cffparse.c (power_tens): New array.
 	(cff_parse_real): Rewritten to introduce a fourth parameter which
 	returns the `scaling' of the real number so that we have no
 	precision loss.  This is not used yet.
 	Update all callers.
 	(cff_parse_fixed_thousand): Replace with...
 	(cff_parse_fixed_scaled): This function.  Update all callers.
 
 2008-05-03  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftobjs.c (FT_Load_Glyph): Call the auto-hinter without
 	transformation since it recursively calls FT_Load_Glyph.  This fixes
 	Savannah bug #23143.
 
 2008-04-26  Werner Lemberg  <wl@gnu.org>
 
 	* include/freetype/internal/psaux.h (T1_BuilderRec): Mark `scale_x'
 	and `scale_y' as obsolete since they aren't used.
 	* src/psaux/psobjs.c (t1_builder_init): Updated.
 
 	* src/cff/cffgload.h (CFF_Builder): Mark `scale_x' and `scale_y' as
 	obsolete since they aren't used.
 	* src/cff/cffgload.c (cff_builder_init): Updated.
 
 2008-04-14  Werner Lemberg  <wl@gnu.org>
 
 	* src/pcf/pcfdrivr.c (PCF_Face_Init): Protect call to
 	`FT_Stream_OpenLZW' with `FT_CONFIG_OPTION_USE_LZ'.  From Savannah
 	bug #22909.
 
 2008-04-13  Werner Lemberg  <wl@gnu.org>
 
 	* src/psaux/psconv.c (PS_Conv_ToFixed): Increase precision if
 	integer part is zero.
 
 2008-04-01  Werner Lemberg  <wl@gnu.org>
 
 	Fix compilation with g++ 4.1 (with both `single' and `multi'
 	targets).
 
 	* src/base/ftobjs.c (FT_Open_Face): Don't define a variable in block
 	which is crossed by a `goto'.
 
 	* src/otvalid/otvalid.h (otv_MATH_validate): Add prototype.
 
 2008-03-31  Werner Lemberg  <wl@gnu.org>
 
 	Fix support for subsetted CID-keyed CFFs.
 
 	* include/freetype/freetype.h (FT_FACE_FLAG_CID_KEYED,
 	FT_IS_CID_KEYED): New macros.
 
 	* src/cff/cffobjs.c (cff_face_init): Set number of glyphs to the
 	maximum CID value in CID-keyed CFFs.
 	Handle FT_FACE_FLAG_CID_KEYED flag.
 
 	* docs/CHANGES: Document it.
 
 
 	Fix CFF font matrix calculation and improve precision.
 
 	* src/cff/cffparse.c (cff_parse_real): Increase precision if integer
 	part is zero.
 	(cff_parse_font_matrix): Simplify computation of `units_per_em';
 	this prevents overflow also.
 
 
 	Support FT_Get_CID_Registry_Ordering_Supplement for PS CID fonts.
 
 	* src/cid/cidriver.c: Include FT_SERVICE_CID_H.
 	(cid_get_ros): New function.
 	(cid_service_cid_info): New service structure.
 	(cid_services): Register it.
 
 2008-03-23  Werner Lemberg  <wl@gnu.org>
 
 	Adjustments for Visual C++ 8.0, as reported by Rainer Deyke.
 
 	* builds/compiler/visualc.mk (CFLAGS): Remove /W5.
 	(ANSIFLAGS): Add _CRT_SECURE_NO_DEPRECATE.
 
 2008-03-21  Laurence Darby  <ldarby>
 
 	* src/type1/t1objs.c (T1_Face_Init): Use `/Weight'.  Patch from
 	Savannah bug #22675.
 
 2008-03-13  Derek Clegg  <dclegg@apple.com>
 
 	* src/truetype/ttgxvar.c (TT_Get_MM_Var): Fix named style loop.
 	Patch from Savannah bug #22541.
 
 2008-03-03  Masatoshi Kimura  <VYV03354@nifty.ne.jp>
 
 	* src/sfnt/ttcmap.c (tt_cmap14_char_map_nondef_binary,
 	tt_cmap14_find_variant): Return correct value.
 	(tt_cmap14_variant_chars): Fix check for `di'.
 
 2008-02-29  Wermer Lemberg  <wl@gnu.org>
 
 	* docs/CHANGES: Updated.
 
 2008-02-29  Wolf
 
 	Add build support for symbian platform.  From Savannah bug #22440.
 
 	* builds/symbian/*: New files.
 
 2008-02-21  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftmac.c (parse_fond): Fix a bug of PostScript font name
 	synthesis.  For any face of a specified FOND, always the name for
 	the first face was used.  Except of a FOND that refers multiple
 	Type1 font files, wrong synthesized font names are not used at all,
 	so this is an invisible bug.  A few limit checks are added too.
 
 	* builds/mac/ftmac.c: Ditto.
 
 2008-02-21  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* builds/unix/configure.raw: Split compiler option to link Carbon
 	frameworks to one option for CoreServices framework and another
 	option for ApplicationServices framework.  The split options can be
 	managed by GNU libtool to avoid unrequired duplication when FreeType
 	is linked with other applications.  Suggested by Daniel Macks,
 	Savannah bug #22366.
 
 2008-02-18  Victor Stinner  <victor.stinner@haypocalc.com>
 
 	* src/truetype/ttinterp.c (Ins_IUP): Check number of points.  Fix
 	from Savannah bug #22356.
 
 2008-02-17  Jonathan Blow  <jon@number-none.com>
 
 	* src/autofit/afloader.c (af_loader_load_g, af_loader_load_glyph):
 	Check for valid callback pointers.
 
 2008-02-15  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftmac.c (FT_New_Face_From_SFNT): Check the sfnt resource
 	handle by its value instead of ResError(), fix provided by Deron
 	Kazmaier.  According to the Resource Manager Reference,
 	GetResource(), Get1Resource(), GetNamedResource(),
 	Get1NamedResource() and RGetResource() set noErr but return NULL
 	handle when they can not find the requested resource.  These
 	functions never return undefined values, so it is sufficient to
 	check if the handle is not NULL.
 
 	* builds/mac/ftmac.c (FT_New_Face_From_SFNT): Ditto.
 
 2008-02-14  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftbase.c: <ftmac.c> is replaced by "ftmac.c" as other
 	inclusion styles.  Now it always includes src/base/ftmac.c;
 	builds/mac/ftmac.c is never included in any configuration.
 
 	* builds/unix/configure.raw: Print warning if configure is executed
 	with options to specify Carbon functionalities explicitly.
 
 	* docs/INSTALL.MAC: Note that legacy builds/mac/ftmac.c is not
 	included automatically and manual replacement is required.
 
 2008-02-11  Werner Lemberg  <wl@gnu.org>
 
 	* builds/modules.mk (CLOSE_MODULE, REMOVE_MODULE), builds/detect.mk
 	(dos_setup), builds/freetype.mk (clean_project_dos,
 	distclean_project_dos): Don't use \ but $(SEP).  Reported by Duncan
 	Murdoch.
 
 2008-01-18  Sylvain Pasche  <sylvain.pasche@gmail.com>
 
 	* src/base/ftlcdfil.c (_ft_lcd_filter_legacy): Updated comment to
 	mention intra-pixel algorithm.
 
 	* include/freetype/freetype.h (FT_Render_Mode): Mention that
 	FT_Library_SetLcdFilter can be used to reduce fringes.
 
 2008-01-16  Werner Lemberg  <wl@gnu.org>
 
 	* src/raster/ftraster.c (ft_black_render): Check `outline' before
 	using it.  Reported by Allan Yang.
 
 2008-01-12  Werner Lemberg  <wl@gnu.org>
 
 	* src/raster/ftraster.c (FT_CONFIG_OPTION_5_GRAY_LEVELS): Remove.
 
 2008-01-12  Allan Yang, Jian Hua - SH  <Allan.Yang@fmc.fujitsu.com>
 
 	* src/raster/ftraster.c (ft_black_init)
 	[FT_RASTER_OPTION_ANTI_ALIASING]: Fix compilation.
 
 2008-01-10  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgload.c (load_truetype_glyph): Handle the case
 	where the number of contours in a simple glyph is zero (and which
 	does contain an entry in the `glyf' table).  This fixes Savannah bug
 	#21990.
 
 2008-01-04  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Formatting suggested by Sean McBride.
 
 	* builds/mac/ftmac.c: Formatting (tab expanded).
 	* src/autofit/afindic.c: Ditto.
 	* src/base/ftcid.c: Ditto.
 	* src/base/ftmac.c: Ditto.
 
 2007-12-30  Werner Lemberg  <wl@gnu.org>
 
 	* src/smooth/ftgrays.c (gray_raster_render): Check `outline'
 	correctly.
 
 2007-12-21  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Improvement of POSIX resource-fork accessor to load unsorted
 	references in a resource.  In HelveLTMM (resource-fork PostScript
 	Type1 font bundled with Mac OS X since 10.3.x), the appearance order
 	of PFB chunks is not sorted; sorting the chunks by reference IDs is
 	required.
 
 	* include/freetype/internal/ftrfork.h (FT_RFork_Ref): New structure
 	type to store a pair of reference ID and offset to the chunk.
 
 	* src/base/ftrfork.c (ft_raccess_sort_ref_by_id): New function to
 	sort FT_RFork_Ref by their reference IDs.
 
 	(FT_Raccess_Get_DataOffsets): Returns an array of offsets that is
 	sorted by reference ID.
 
 2007-12-14  Werner Lemberg  <wl@gnu.org>
 
 	* src/cff/cffparse.c (cff_parse_real): Don't apply `power_ten'
 	division too early; otherwise the most significant digit(s) of the
 	final result are lost as the value is truncated to an integer.  This
 	fixes Savannah bug #21794 (where the patch has been posted too).
 
 2007-12-06  Fix  <4d876b82@gmail.com>
 
 	Pass options from one configure script to another as-is (not
 	expanded).  This is needed for options like
 	--includedir='${prefix}/include'.
 
 	* builds/unix/detect.mk, configure: Prevent argument expansion in
 	call to the (real) `configure' script.
 
 2007-12-06  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgload.c (load_truetype_glyph): Fix compilation if
 	TT_USE_BYTECODE_INTERPRETER isn't defined.
 
 2007-12-06  Werner Lemberg  <wl@gnu.org>
 
 	There exist CFFs which contain opcodes for the Type 1 operators
 	`hsbw' and `closepath' which are both invalid in Type 2 charstrings.
 	However, it doesn't harm to support them.
 
 	* src/cff/cffgload.c (CFF_Operator): Add `cff_op_hsbw' and
 	`cff_op_closepath.'
 	(cff_argument_counts): Ditto.
 
 	(cff_decoder_parse_charstrings): Handle Type 1 opcodes 9 (closepath)
 	and 13 (hsbw) which are invalid in Type 2 charstrings.
 
 2007-12-06  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftrfork.c (raccess_guess_darwin_newvfs): New function to
 	support new pathname syntax `..namedfork/rsrc' to access a resource
 	fork on Mac OS X.  The legacy syntax `/rsrc' does not work on
 	case-sensitive HFS+.
 	(raccess_guess_darwin_hfsplus): Fix a bug in the calculation of
 	buffer size to store a pathname.
 	* include/freetype/internal/ftrfork.h: Increment the number of
 	resource fork guessing rule.
 
 2007-12-06  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* builds/unix/configure.raw: Improve the compile tests to search
 	Carbon functions.
 	* builds/mac/ftmac.c: Import fixes for Carbon incompatibilities
 	proposed by Sean McBride from src/base/ftmac.c (see 2007-11-16).
 
 2007-12-06  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	The documents and comments for Mac OS X are improved by Sean
 	McBride.
 
 	* src/base/ftmac.c: Fix a comment.
 	* include/freetype/ftmac.h: Ditto.
 	* docs/INSTALL.MAC: Improve English and add comment on lowest
 	system version specified by MACOSX_DEPLOYMENT_TARGET.
 
 2007-12-04  Werner Lemberg  <wl@gnu.org>
 
 	* src/cff/cffload.c (cff_subfont_load): Don't use logical OR to
 	concatenate error codes.
 	* src/sfnt/ttsbit.c (Load_SBit_Range): Ditto.
 
 2007-12-04  Graham Asher  <graham.asher@btinternet.com>
 
 	* src/truetype/ttobjs.c (tt_face_init): Don't use logical OR to
 	concatenate error codes.
 
 2007-12-04  Sean McBride  <sean@rogue-research.com>
 
 	* src/pfr/pfrgload.c (pfr_glyph_load_compound): Remove compiler
 	warning.
 
 2007-11-20  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Fix MacOS legacy font support by Masatake Yamato on Mac OS X.  It is
 	not working since 2.3.5.  In FT_Open_New(), if FT_New_Stream()
 	cannot mmap() the specified file and cannot seek to head of the
 	specified file, it returns NULL stream and FT_Open_New() returns the
 	error immediately.  On MacOS, most legacy MacOS fonts fall into such
 	a scenario because their data forks are zero-sized and cannot be
 	sought.  To proceed to guessing of resource fork fonts, the
 	functions for legacy MacOS font must properly handle the NULL stream
 	returned by FT_New_Stream().
 
 	* src/base/ftobjs.c (IsMacBinary): Return error
 	FT_Err_Invalid_Stream_Operation immediately when NULL stream is
 	passed.
 	(FT_Open_Face): Even when FT_New_Stream() returns an error, proceed
 	to fallback.  Originally, legacy MacOS font is tested in the cases
 	of FT_Err_Invalid_Stream_Operation (occurs when data fork is empty)
 	or FT_Err_Unknown_File_Format (occurs when AppleSingle header or
 	.dfont header is combined).  Now the case of
 	FT_Err_Cannot_Open_Stream is included.
 
 	* src/base/ftrfork.c (FT_Raccess_Guess): When passed stream is NULL,
 	skip FT_Stream_Seek(), which seeks to the head of stream, and
 	proceed to unit testing of raccess_guess_XXX().  FT_Stream_Seek()
 	for a NULL stream causes a Bus error on Mac OS X.
 	(raccess_guess_apple_double): Return FT_Err_Cannot_Open_Stream
 	immediately if passed stream is NULL.
 	(raccess_guess_apple_single): Ditto.
 
 2007-11-16  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Fix for Carbon incompatibilities since Mac OS X 10.5,
 	proposed by Sean McBride.
 
 	* doc/INSTALL.MAC: Comment on MACOSX_DEPLOYMENT_TARGET.
 
 	* include/freetype/ftmac.h: Deprecate FT_New_Face_From_FOND and
 	FT_GetFilePath_From_Mac_ATS_Name.  Since Mac OS X 10.5, calling
 	Carbon functions from a forked process is classified as unsafe
 	by Apple.  All Carbon-dependent functions should be deprecated.
 
 	* src/base/ftmac.c: Use essential header files
 	<CoreServices/CoreServices.h> and
 	<ApplicationServices/ApplicationServices.h> instead of
 	all-in-one header file <Carbon/Carbon.h>.
 
 	Include <sys/syslimits.h> and replace HFS_MAXPATHLEN by Apple
 	genuine macro PATH_MAX.
 
 	Add fallback macro for kATSOptionFlagsUnRestrictedScope which
 	is not found in Mac OS X 10.0.
 
 	Multi-character constants ('POST', 'sfnt' etc) are replaced by
 	64bit constants calculated by FT_MAKE_TAG() macro.
 
 	For the index in the segment of resource fork, new portable
 	type ResourceIndex is introduced for better compatibility.
 	This type is since Mac OS X 10.5, so it is defined as short
 	when built on older platforms.
 
 	(FT_ATSFontGetFileReference): If build target is only the systems
 	10.5 and newer, it calls Apple genuine ATSFontGetFileReference().
 
 	(FT_GetFile_From_Mac_ATS_Name): Return an error if system is 10.5
 	and newer or 64bit platform, because legacy type FSSpec type is
 	removed completely.
 
 	(FT_New_Face_From_FSSpec): Ditto.
 
 2007-11-01  Werner Lemberg  <wl@gnu.org>
 
 	* src/sfnt/sfobjs.c (sfnt_done_face): Check `sfnt' everywhere.  This
 	fixes Savannah bug #21485.
 
 2007-10-29  Daniel Svoboda  <dasvo@planeta@cz>
 
 	* src/winfonts/winfnt.c (FNT_Face_Init): Check first that the driver
 	can handle the font at all, then check `face_index'.  Otherwise, the
 	driver might return the wrong error code.  This fixes Savannah bug
 	#21468.
 
 2007-10-21  Werner Lemberg  <wl@gnu.org>
 
 	* src/sfnt/sfobjs.c (sfnt_load_face): Support bit 9 and prepare
 	support for bit 8 of the `fsSelection' field in the `OS/2' table.
 	MS is already using this; hopefully, this becomes part of OpenType
 	1.5.
 	Prepare also support for `name' IDs 21 (WWS_FAMILY) and 22
 	(WWS_SUBFAMILY).
 
 2007-10-20  Werner Lemberg  <wl@gnu.org>
 
 	* src/tools/docmaker/tohtml.py (html_header_2): Fix typo.
 	Add `td.left' element to CSS.
 	(toc_section_enter): Use it.
 
 2007-10-18  David Turner  <david@freetype.org>
 
 	* include/freetype/freetype.h, src/base/ftobjs.c: Rename API
 	functions related to cmap type 14 support to the
 	`FT_Object_ActionName' scheme:
 
 	  FT_Get_Char_Variant_index     -> FT_Face_GetCharVariantIndex
 	  FT_Get_Char_Variant_IsDefault -> FT_Face_GetCharVariantIsDefault
 	  FT_Get_Variant_Selectors      -> FT_Face_GetVariantSelectors
 	  FT_Get_Variants_Of_Char       -> FT_Face_GetVariantsOfChar
 	  FT_Get_Chars_Of_Variant       -> FT_Face_GetCharsOfVariant
 
 	Update documentation accordingly.
 
 	* src/sfnt/ttcmap.c: Stronger cmap 14 validation.
 	Make the code a little more consistent with FreeType coding
 	conventions and modify the cmap14 functions that returned a newly
 	allocated array to use a persistent vector from the TT_CMap14 object
 	instead.
 
 	(TT_CMap14Rec): Provide array and auxiliary data for result.
 	(tt_cmap14_done, tt_cmap14_ensure): New functions.
 
 	(tt_cmap14_init, tt_cmap14_validate, tt_cmap14_char_map_def_binary,
 	tt_cmap14_char_map_nondef_binary, tt_cmap14_find_variant,
 	tt_cmap14_char_var_index, tt_cmap14_variants,
 	tt_cmap14_char_variants, tt_cmap14_def_char_count,
 	tt_cmap14_get_def_chars, tt_cmap14_get_nondef_chars,
 	tt_cmap14_variant_chars, tt_cmap14_class_rec): Updated and improved.
 
 2007-10-15  George Williams  <gww@silcom.com>
 
 	Add support for cmap type 14.
 
 	* devel/ftoption.h, include/freetype/config/ftoption.h
 	(TT_CONFIG_CMAP_FORMAT_14): New macro.
 
 	* include/freetype/internal/ftobjs.h (FT_CMap_CharVarIndexFunc,
 	FT_CMap_CharVarIsDefaultFunc, FT_CMap_VariantListFunc,
 	FT_CMap_CharVariantListFunc, FT_CMap_VariantCharListFunc): New
 	support function prototypes.
 	(FT_CMap_ClassRec): Add them.
 	Update all users.
 
 	* include/freetype/ttnameid.h (TT_APPLE_ID_VARIANT_SELECTOR): New
 	macro.
 
 	* include/freetype/freetype.h (FT_Get_Char_Variant_Index,
 	FT_Get_Char_Variant_IsDefault, FT_Get_Variant_Selectors,
 	FT_Get_Variants_Of_Char, FT_Get_Chars_Of_Variant): New API
 	functions.
 
 	* src/base/ftobjs.c (find_variant_selector_charmap): New auxiliary
 	function.
 	(FT_Set_Charmap): Disallow cmaps of type 14.
 	(FT_Get_Char_Variant_Index, FT_Get_Char_Variant_IsDefault,
 	FT_Get_Variant_Selectors, FT_Get_Variants_Of_Char,
 	FT_Get_Chars_Of_Variant): New API functions.
 
 	* src/sfnt/ttcmap.c (TT_PEEK_UINT24, TT_NEXT_UINT24): New macros.
 
 	(TT_CMap14Rec, tt_cmap14_init, tt_cmap14_validate,
 	tt_cmap14_char_index, tt_cmap14_char_next, tt_cmap14_get_info,
 	tt_cmap14_char_map_def_binary, tt_cmap14_char_map_nondef_binary,
 	tt_cmap14_find_variant, tt_cmap14_char_var_index,
 	tt_cmap14_char_var_isdefault, tt_cmap14_variants,
 	tt_cmap14_char_variants, tt_cmap14_def_char_count,
 	tt_cmap14_get_def_chars, tt_cmap14_get_nondef_chars,
 	tt_cmap14_variant_chars, tt_cmap14_class_rec): New functions and
 	structures for cmap 14 support.
 	(tt_cmap_classes): Register tt_cmap14_class_rec.
 	(tt_face_build_cmaps): One more error message.
 
 	* docs/CHANGES: Mention cmap 14 support.
 
 2007-10-01  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftobjs.c (find_unicode_charmap): If search for a UCS-4
 	charmap fails, do the loop again while searching a UCS-2 charmap.
 	This favours MS charmaps over Apple ones.
 
 2007-08-29  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftmac.c: Introduction of abstract `short' data types,
 	ResFileRefNum and ResID.  These types were introduced for Copland,
 	then backported to MPW.  The variables exchanged with FileManager
 	QuickDraw frameworks are redefined by these data types.  Patch was
 	proposed by Sean McBride.
 	* builds/mac/ftmac.c: Ditto.
 
 2007-08-18  Werner Lemberg  <wl@gnu.org>
 
 	* src/otvalid/otvcmmn.c (otv_x_y_ux_sy): Skip context glyphs.  Found
 	by Imran Yousaf.  Fixes Savannah bug #20773.
 
 	(otv_Lookup_validate): Correct handling of LookupType.  Found by
 	Imran Yousaf.  Fixes Savannah bug #20782.
 
 2007-08-17  George Williams  <gww@silcom.com>
 
 	* src/otvalid/otvgsub.c (otv_SingleSubst_validate): Fix handling of
 	SingleSubstFormat1.
 
 2007-08-11  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* builds/unix/configure.raw: Fix a bug which sets CC_BUILD by
 	${build-gcc} (unchecked) instead of by ${build}-gcc (checked).
 	Found by Ryan Hill.
 
 2007-08-11  George Williams  <gww@silcom.com>
 
 	* src/otvalid/otvcommn.c, src/otvalid/otvcommn.h
 	(otv_Coverage_validate): Add fourth argument to pass an expected
 	count value.  Update all users.
 	Check glyph IDs.
 	(otv_ClassDef_validate): Check `StartGlyph'.
 
 	* src/otvalid/otvgsub.c (otv_SingleSubst_validate): More glyph ID
 	checks.
 
 	* src/otvalid/otvmath.c (otv_MathConstants_validate): There are only
 	56 constants.
 	(otv_GlyphAssembly_validate, otv_MathGlyphConstruction_validate):
 	Check glyph IDs.
 
 2007-08-08  Werner Lemberg  <wl@gnu.org>
 
 	* src/otvalid/otvbase.c, src/otvalid/otvcommn.c,
 	src/otvalid/otvgdef.c, src/otvalid/otvgpos.c, src/otvalid/otvgsub.c,
 	src/otvalid/otvjstf.c: s/FT_INVALID_DATA/FT_INVALID_FORMAT/ where
 	appropriate.  Reported by George.
 
 	* include/freetype/internal/fttrace.h: Define `trace_otvmath'.
 
 	* src/otvalid/rules.mk (OTV_DRV_SRC): Add otvmath.c.
 
 	* docs/CHANGES: Updated.
 
 2007-08-08  George Williams  <gww@silcom.com>
 
 	Add `MATH' validating support to otvalid module.
 
 	* include/freetype/tttags.h (TTAG_MATH): New macro.
 	* include/freetype/ftotval.h (FT_VALIDATE_MATH): New macro.
 	(FT_VALIDATE_OT): Updated.
 
 	* src/otvalid/otmath.c: New file.
 
 	* src/otvalid/otvalid.c: Include otvmath.c.
 	* src/otvalid/otvmod.c (otv_validate): Handle `MATH' table.
 
 2007-08-04  Werner Lemberg  <wl@gnu.org>
 
 	* builds/unix/configure.raw: Add call to AC_LIBTOOL_WIN32_DLL.
 	Fixes Savannah bug #20686.
 
 2007-08-03  Werner Lemberg  <wl@gnu.org>
 
 	* src/psnames/psmodule.c: Fix usage of
 	FT_CONFIG_OPTION_POSTSCRIPT_NAMES macro.  Reported by Graham Asher.
 
 2007-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftmac.c (open_face_from_buffer): The argument
 	`driver_name' is typed as `const char*' to match with the
 	callers in FT_New_Face_From_LWFN and FT_New_Face_From_SFNT.
 	This is same with open_face_from_buffer in src/base/ftobjs.c.
 	Found and fixed by Sean McBride.
 
 2007-07-28  Werner Lemberg  <wl@gnu.org>
 
 	* src/raster/ftraster.c (count_table): Make it conditional.
 	* src/base/ftobjs.c (FT_New_Library): Check FT_RENDER_POOL_SIZE with
 	a preprocessor statement.
 
 2007-07-27  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftoutln.c (FT_Outline_Translate): Check `outline' before
 	first usage.  From Savannah patch #6115.
 
 2007-07-16  Werner Lemberg  <wl@gnu.org>
 
 	* docs/CHANGES: Updated.
 
 2007-07-16  Derek Clegg  <dclegg@apple.com>
 
 	Add new service for getting the ROS from a CID font.
 
 	* include/freetype/config/ftheader.h (FT_CID_H): New macro.
 	* include/freetype/ftcid.h: New file.
 
 	* include/freetype/internal/ftserv.h (FT_SERVIVE_CID_H): New macro.
 	* include/freetype/internal/services/svcid.h: New file.
 
 	* src/base/ftcid.c: New file.
 
 	* src/cff/cffdrivr.c: Include FT_SERVICE_CID_H.
 	(cff_get_ros): New function.
 	(cff_service_cid_info): New service structure.
 	(cff_services): Register it.
 
 	* src/cff/cffload.c (cff_font_done): Free registry and ordering.
 
 	* src/cff/cfftypes.h (CFF_FontRec): Add `registry' and `ordering'.
 
 	* modules.cfg (BASE_EXTENSIONS): Add ftcid.c.
 
 2007-07-11  Derek Clegg  <dclegg@apple.com>
 
 	Add support for postscript name service to CFF driver.
 
 	* src/cff/cffdrivr.c: Include FT_SERVICE_POSTSCRIPT_NAME_H.
 	(cff_get_ps_name): New function.
 	(cff_service_ps_name): New service structure.
 	(cff_services): Register it.
 
 2007-07-07  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftglyph.c (FT_Glyph_Copy): Fix initialization of
 	`target'.  Reported by Sean McBride.
 
 2007-07-06  Werner Lemberg  <wl@gnu.org>
 
 	* src/pfr/pfrcmap.c: Include pfrerror.h.
 
 	* src/autofit/afindic.c: Add some external declarations to pacify
 	`make multi' compilation.
 
 	* src/cid/cidgload.c (cid_load_glyph): Pacify compiler.
 
 	* src/cff/cffdrivr.c (cff_ps_get_font_info), src/cff/cffobjs.c
 	(cff_strcpy), include/freetype/internal/ftmemory.h (FT_MEM_STRDUP),
 	src/autofit/aflatin.c (af_latin_hints_compute_edges),
 	src/autofit/afcjk.c (af_cjk_hints_compute_edges), src/sfnt/ttmtx.c
 	(tt_face_get_metrics), src/base/ftobjs.c (open_face)
 	[FT_CONFIG_OPTION_INCREMENTAL]: Fix compilation with C++ compiler.
 
 	* docs/release: Mention test compilation targets.
 
 2007-07-04  Werner Lemberg  <wl@gnu.org>
 
 	* docs/PROBLEMS: Mention that some PS based fonts can't be
 	handled correctly by FreeType.
 
 	* src/truetype/ttgload.c (load_truetype_glyph): Always allow a
 	recursion depth of 1.  This was the maximum value in TrueType 1.0,
 	and some older fonts don't set this field correctly.
 
 	* src/gxvalid/gxvmort1.c
 	(gxv_mort_subtable_type1_substTable_validate): Fix tracing message.
 
 2007-07-03  Werner Lemberg  <wl@gnu.org>
 
 	* src/autofit/aflatin.c (af_latin_metrics_init_blues): Initialize
 	`round' to pacify compiler.
 
 2007-07-02  Werner Lemberg  <wl@gnu.org>
 
 
 	* Version 2.3.5 released.
 	=========================
 
 
 	Tag sources with `VER-2-3-5'.
 
 	* docs/CHANGES, docs/VERSION.DLL: Update documentation and bump
 	version number to 2.3.5.
 
 	* README, Jamfile (RefDoc), builds/win32/visualc/index.html,
 	builds/win32/visualc/freetype.dsp,
 	builds/win32/visualc/freetype.vcproj,
 	builds/win32/visualce/index.html,
 	builds/win32/visualce/freetype.dsp,
 	builds/win32/visualce/freetype.vcproj: s/2.3.4/2.3.5/, s/234/235/.
 
 	* include/freetype/freetype.h (FREETYPE_PATCH): Set to 5.
 
 	* builds/unix/configure.raw (version_info): Set to 9:16:3.
 
 2007-07-01  David Turner  <david@freetype.org>
 
 	* include/freetype/freetype.h, src/base/ftpatent.c
 	(FT_Face_SetUnpatentedHinting): New function to dynamically change
 	the setting after a face is created.
 
 	* src/truetype/ttgload.c (TT_Load_Simple_Glyph): Fix a small bug
 	that created distortions in the bytecode interpreter results.
 
 2007-06-30  David Turner  <david@freetype.org>
 
 	* src/truetype/ttinterp.c (Ins_IUP): Add missing variable
 	initialization.
 
 	* src/autofit/aflatin.c (af_latin_metric_init_blues): Get rid of an
 	infinite loop in the case of degenerate fonts.
 
 2007-06-26  Rahul Bhalerao  <b.rahul.pm@gmail.com>
 
 	Add autofit module for Indic scripts.  This currently just reuses
 	the CJK-specific functions.
 
 	* include/freetype/config/ftoption.h (AF_CONFIG_OPTION_INDIC): New
 	macro.
 	* devel/ftoption.h: Synchronize with
 	include/freetype/config/ftoption.h.
 
 	* src/autofit/afindic.c, src/autofit/afindic.h: New files.
 
 	* src/autofit/afglobal.c, src/autofit/aftypes.h,
 	src/autofit/autofit.c: Updated.
 
 	* src/autofit/Jamfile (_sources), * src/autofit/rules.mk
 	(AUTOF_DRV_SRC): Updated.
 
 2007-06-23  David Turner  <david@freetype.org>
 
 	* src/truetype/ttgload.c (TT_Load_Simple): Fix change from
 	2007-06-16 that prevented the TrueType module from loading most
 	glyphs.
 
 2007-06-20  Werner Lemberg  <wl@gnu.org>
 
 	* src/cff/cffgload.c (cff_slot_load): Fix logic of 2007-05-28
 	change.
 
 2007-06-19  Werner Lemberg  <wl@gnu.org>
 
 	* src/type1/t1load.c (parse_encoding): Handle one more error.
 
 2007-06-19  Dmitry Timoshkov  <dmitry@codeweavers.com>
 
 	* src/winfonts/winfnt.c (fnt_face_get_dll_font): Return error
 	FNT_Err_Invalid_File_Format if file format was recognized but
 	the file doesn't contain any FNT(NE) or RT_FONT(PE) resources.
 	Add verbose debug logs to make it easier to debug failing load
 	attempts.
 	(FNT_Face_Init): A single FNT font can't contain more than 1 face,
 	so return an error if requested face index is > 0.
 	Do not do further attempt to load fonts if a previous attempt has
 	failed but returned error FNT_Err_Invalid_File_Format, i.e., the
 	file format has been recognized but no fonts found in the file.
 
 2007-07-19  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftmac.c: Apply patches proposed by Sean McBride.
 	(FT_GetFile_From_Mac_Name): Insert FT_UNUSED macros to fix
 	the compiler warnings against unused arguments.
 	(FT_ATSFontGetFileReference): Ditto.
 	(FT_GetFile_From_Mac_ATS_Name): Ditto.
 	(FT_New_Face_From_FSSpec): Ditto.
 	(lookup_lwfn_by_fond): Fix wrong comment.
 	Replace `const StringPtr' by more appropriate type
 	`ConstStr255Param'.
 	FSRefMakePathPath always returns UTF8 POSIX pathname in
 	Mach-O, thus HFS pathname support is dropped.
 	(count_faces): Remove HLock and HUnlock which is not
 	required on Mac OS X anymore.
 	(FT_New_Face_From_SFNT): Ditto.
 	(FT_New_Face_From_FOND): Ditto.
 	* builds/mac/ftmac.c: Synchronize to src/base/ftmac.c,
 	except of HFS pathname support and HLock/HUnlock.
 	They are required on classic CFM environment.
 
 2007-06-18  Werner Lemberg  <wl@gnu.org>
 
 	* src/psaux/psobjs.c (ps_parser_skip_PS_token): Remove incorrect
 	assertion.
 	(ps_parser_to_bytes): Fix error message.
 
 	* src/type42/t42objs.c (T42_Open_Face): Handle one more error.
 	* src/type42/t42parse.c (t42_parse_sfnts): s/alloc/allocated/.
 	Don't allow mixed binary and hex strings.
 	Handle string_size == 0 and string_buf == 0.
 	(t42_parse_encoding): Handle one more error.
 
 2007-06-18  Werner Lemberg  <wl@gnu.org>
 
 	* src/psaux/psobjs.c (ps_tofixedarray, ps_tocoordarray): Fix exit
 	logic.
 	(ps_parser_load_field) <T1_FIELD_TYPE_BBOX>: Skip delimiters
 	correctly.
 	(ps_parser_load_field_table): Use `fields->array_max' instead of
 	T1_MAX_TABLE_ELEMENTS to limit the number of arguments.
 
 	* src/cff/cffgload.c (cff_decoder_prepare): Fix change from
 	2007-06-06.
 
 2007-06-17  Werner Lemberg  <wl@gnu.org>
 
 	* src/tools/ftrandom.c (font_size): New global variable.
 	(TestFace): Use it.
 	(main): Handle new option `--size' to set `font_size'.
 	(Usage): Updated.
 
 	* src/winfonts/winfnt.c (fnt_face_get_dll_font): Exit in case of
 	invalid font.
 	(FNT_Load_Glyph): Protect against invalid bitmap width.
 
 2007-06-16  David Turner  <david@freetype.org>
 
 	* src/smooth/ftgrays.c (gray_find_cell, gray_set_cell, gray_hline):
 	Prevent integer overflows when rendering very large outlines.
 
 	* src/truetype/ttgload.c (TT_Load_Simple_Glyph): Check the
 	well-formedness of the contours array when loading a glyph.
 
 	* src/truetype/ttinterp.c (TT_Load_Context): Initialize `zp0', `zp1',
 	and `zp2'.
 	(Ins_IP): Check argument ranges to reject bogus operations properly.
 	(IUP_WorkerRec): Add `max_points' member.
 	(_iup_worker_interpolate): Check argument ranges.
 	(Ins_IUP): Ignore empty outlines.
 
 2007-06-16  Dmitry Timoshkov  <dmitry@codeweavers.com>
 
 	* src/winfonts/winfnt.h: Add necessary structures for PE resource
 	parsing.
 	(WinPE32_HeaderRec): New structure.
 	(WinPE32_SectionRec): New structure.
 	(WinPE_RsrcDirRec): New structure.
 	(WinPE_RsrcDirEntryRec): New structure.
 	(WinPE_RsrcDataEntryRec): New structure.
 	(FNT_FontRec): Remove unused `size_shift' field.
 
 	* src/winfonts/winfnt.c (fnt_face_get_dll_font): Add support for
 	loading bitmap .fon files in PE format.
 
 2007-06-15  Dmitry Timoshkov  <dmitry@codeweavers.com>
 
 	* builds/win32/ftdebug.c: Unify debug level handling with other
 	platforms.
 
 2007-06-14  Dmitry Timoshkov  <dmitry@codeweavers.com>
 
 	* builds/win32/ftdebug.c (FT_Message): Send debug output to the
 	console as well as to the debugger.
 
 2007-06-14  Werner Lemberg  <wl@gnu.org>
 
 	* src/autofit/aflatin.c (af_latin_uniranges): Expand structure to
 	cover all ranges which could possibly be handled by the aflatin
 	module (since the default fallback for unknown ranges is now the
 	afcjk module).  It might be necessary to fine-tune this further by
 	splitting off modules for Greek, Cyrillic, or other blocks.
 
 2007-06-11  David Turner  <david@freetype.org>
 
 	* src/autofit/aflatin.c (af_latin_hints_link_segments): Fix
 	incorrect segment linking computation.  This was the root cause of
 	Savannah bug #19565.
 
 
 	* src/autofit/* [FT_OPTION_AUTOFIT2]: Some very experimental changes
 	to improve the Latin auto-hinter.  Note that the new code is
 	disabled by default since it is not stabilized yet.
 
 	* src/autofit/aflatin2.c, src/autofit/aflatin2.h: New files
 	(disabled currently).
 
 	* src/autofit/afhints.c: Remove dead code.
 	(af_axis_hints_new_edge): Add argument to handle segment directions.
 	(af_edge_flags_to_string): New function.
 	(af_glyph_hints_dump_segments, af_glyph_hints_dump_edges): Handle
 	option flags.
 	(af_glyph_hints_reload): Add argument to handle inflections.
 	Simplify.
 	(af_direction_compute): Fine tuning.
 	(af_glyph_hints_align_edge_points): Fix logic.
 	(af_glyph_hints_align_strong_points): Do linear search for small
 	edge counts.
 	(af_glyph_hints_align_weak_points): Skip any touched neighbors.
 	(af_iup_shift): Handle zero `delta'.
 
 	* src/autofit/afhints.h: Updated.
 	(AF_SORT_SEGMENTS): New macro (disabled).
 	(AF_AxisHintsRec) [AF_SORT_SEGMENTS]: New member `mid_segments'.
 
 	* src/autofit/afglobal.c (af_face_globals_get_metrics): Add
 	argument to pass option flags for handling scripts.
 	* src/autofit/afglobal.h: Updated.
 
 	* src/autofit/afcjk.c: Updated.
 	* src/autofit/aflatin.c: Updated.
 	(af_latin_metrics_scale_dim): Don't reduce scale by 2%.
 
 	(af_latin_hints_compute_segments) [AF_HINT_METRICS]: Remove dead code.
 	(af_latin_hints_compute_edges) [AF_HINT_METRICS]: Remove dead code.
 	Don't set `edge->dir'
 	(af_latin_hint_edges): Add more logging.
 
 	* src/autofit/afloader.c: Updated.
 
 2007-06-11  Werner Lemberg  <wl@gnu.org>
 
 	* docs/CHANGES: Document FT_Face_CheckTrueTypePatents.
 
 2007-06-10  David Turner  <david@freetype.org>
 
 	* src/truetype/ttgload.c (TT_Load_Simple_Glyph): Slight speed-up to
 	the TrueType glyph loader.
 
 	* include/freetype/config/ftoption.h: Clarify documentation
 	regarding unpatented hinting.
 
 
 	Add new `FT_Face_CheckTrueTypePatents' API.
 
 	* include/freetype/freetype.h (FT_Face_CheckTrueTypePatents): New
 	declaration.
 
 	* include/freetype/internal/services/svttglyf.h,
 	src/base/ftpatent.c: New files.
 
 	* include/freetype/internal/ftserv.h (FT_SERVICE_TRUETYPE_GLYF_H):
 	New macro.
 
 	* src/truetype/ttdriver.c: Include FT_SERVICE_TRUETYPE_GLYF_H and
 	`ttpload.h'.
 	(tt_service_truetype_glyf): New service structure.
 	(tt_services): Register it.
 
 	* modules.cfg (BASE_EXTENSIONS), src/base/Jamfile (_sources): Add
 	`ftpatent.c'.
 
 2007-06-08  Werner Lemberg  <wl@gnu.org>
 
 	* src/sfnt/sfobjs.c (sfnt_load_face): Undo change from 2007-04-28.
 	Fonts without a cmap must be handled correctly by FreeType (anything
 	else would be a bug).
 
 
 	* src/psaux/t1decode.c (t1_decoder_parse_charstrings)
 	[FT_DEBUG_LEVEL_TRACE]: Improve tracing message.
 
 2007-06-07  Werner Lemberg  <wl@gnu.org>
 
 	* src/sfnt/ttsbit0.c (tt_sbit_decoder_init,
 	tt_sbit_decoder_load_image): Protect against integer overflows.
 
 
 	* src/pfr/pfrgload.c (pfr_glyph_load_simple): More bounding checks
 	for `x_control' and `y_control'.
 
 2007-06-06  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftoutln.c (FT_Outline_Decompose): Check `last'.
 
 
 	* src/pfr/pfrcmap.c (pfr_cmap_init): Convert assertion into normal
 	FreeType error.
 
 
 	* src/winfonts/winfnt.c (fnt_face_get_dll_font): Do a rough check of
 	`font_count'.
 
 
 	* src/type1/t1load.c (parse_font_matrix): Check `temp_scale'.
 
 
 	* src/cff/cffgload.c (cff_decoder_prepare): Change return type to
 	`FT_Error'.
 	Check `fd_index'.
 	(cff_slot_load): Updated.
 	* src/cff/cffgload.h: Updated.
 
 2007-06-05  Werner Lemberg  <wl@gnu.org>
 
 	* src/pfr/pfrgload.c (pfr_glyph_done): Comment out unused code.
 	(pfr_glyph_load_simple): Convert assertion into normal FreeType
 	error.
 	Check `idx'.
 	(pfr_glyph_load_compound, pfr_glyph_curve_to, pfr_glyph_line_to):
 	Convert assertion into normal FreeType error.
 
 	* src/pfr/pfrtypes.h (PFR_GlyphRec): Comment out unused code.
 
 
 	* src/winfonts/winfnt.c (FNT_Face_Init): Check `family_size'.
 
 
 	* src/psaux/psobjs.c (ps_tocoordarray, ps_tofixedarray): Return -1
 	in case of parsing error.
 	(ps_parser_load_field): Updated.
 
 	* src/type1/t1load.c (parse_font_matrix): Updated.
 
 2007-06-04  Werner Lemberg  <wl@gnu.org>
 
 	* src/cid/cidgload.c (cid_load_glyph): Check `fd_select'.
 
 	* src/tools/ftrandom/Makefile: Depend on `libfreetype.a'.
 
 2007-06-03  Werner Lemberg  <wl@gnu.org>
 
 	* src/tools/ftrandom/*: Add the `ftrandom' test program written by
 	George Williams (with some modifications).
 
 2007-06-03  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftobjs.c (destroy_charmaps), src/type1/t1objs.c
 	(T1_Face_Done), src/winfonts/winfnt.c (FNT_Face_Done): Check for
 	face == NULL.  Suggested by Graham Asher.
 
 2007-06-03  Ismail Dönmez  <ismail@pardus.org.tr>
 
 	* src/base/ftobjs.c (FT_Request_Metrics): Fix compiler warning.
 
 2007-06-02  Werner Lemberg  <wl@gnu.org>
 
 	* include/freetype/fterrdef.h (FT_Err_Corrupted_Font_Header,
 	FT_Err_Corrupted_Font_Glyphs): New error codes for BDF files.
 
 	* src/bdf/bdflib.c (bdf_load_font): Use them.
 
 	* src/bdf/bdflib.c (_bdf_parse_start): Check `FONT' better.
 
 2007-06-01  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftobjs.c (FT_Request_Metrics), src/cache/ftccmap.c
 	(FTC_CMapCache_Lookup): Remove unused code.
 
 2007-06-01  Sean McBride  <sean@rogue-research.com>
 
 	* src/truetype/ttinterp.c (Null_Vector, NULL_Vector): Removed,
 	unused.
 
 2007-06-01  Werner Lemberg  <wl@gnu.org>
 
 	* src/cid/cidparse.c (cid_parser_new): Don't continue second search
 	pass for `StartData' if an error has occurred.
 	Exit properly if no `StartData' has been seen at all.
 
 	* builds/unix/ftsystem.c (FT_Stream_Open): Don't use ULONG_MAX but
 	LONG_MAX to avoid compiler warning.  Suggested by Sean McBride.
 
 2007-05-30  Werner Lemberg  <wl@gnu.org>
 
 	* src/type1/t1load.c (parse_subrs, parse_charstrings): Protect
 	against too small binary data strings.
 
 	* src/bdf/bdflib.c (_bdf_parse_glyphs): Check `STARTCHAR' better.
 
 2007-05-28  David Turner  <david@freetype.org>
 
 	* src/cff/cffgload.c (cff_slot_load): Do not apply the identity
 	transformation.  This significantly reduces the loading time of CFF
 	glyphs.
 
 	* docs/CHANGES: Updated.
 
 	* src/autofit/afglobal.c (AF_SCRIPT_LIST_DEFAULT): Change default
 	hinting script to CJK, since it works well with more scripts than
 	latin.  Thanks to Rahul Bhalerao <b.rahul.pm@gmail.com> for pointing
 	this out!
 
 2007-05-25  Werner Lemberg  <wl@gnu.org>
 
 	* docs/CHANGES: Updated.
 
 2007-05-24  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttobjs.h (tt_size_ready_bytecode): Move declaration
 	into TT_USE_BYTECODE_INTERPRETER preprocessor block.
 
 2007-05-24  Graham Asher  <graham.asher@btinternet.com>
 
 	* src/truetype/ttobjs.c (tt_size_ready_bytecode)
 	[!TT_USE_BYTECODE_INTERPRETER]: Removed.  Unused.
 
 2007-05-22  David Turner  <david@freetype.org>
 
 	* src/truetype/ttgload.c (load_truetype_glyph): Fix last change to
 	avoid crashes in case the bytecode interpreter is not used.
 
 
 	Avoid heap blowup with very large .Z font files.  This fixes
 	Savannah bug #19910.
 
 	* src/lzw/ftzopen.h (FT_LzwStateRec): Remove `in_cursor',
 	`in_limit', `pad', `pad_bits', and `in_buff' members.
 	Add `buf_tab', `buf_offset', `buf_size', `buf_clear', and
 	`buf_total' members.
 
 	* src/lzw/ftzopen.c (ft_lzwstate_get_code): Rewritten.  It now takes
 	only one argument.
 	(ft_lzwstate_refill, ft_lzwstate_reset, ft_lzwstate_io): Updated.
 
 2007-05-20  Ismail Dönmez  <ismail@pardus.org.tr>
 
 	* src/pshinter/pshrec.c (ps_mask_table_set_bits): Add `const'.
 	(ps_dimension_set_mask_bits): Remove `const'.
 
 2007-05-19  Werner Lemberg  <wl@gnu.org>
 
 	* src/sfnt/ttmtx.c (tt_face_get_metrics)
 	[!FT_CONFIG_OPTION_OLD_INTERNALS]: Another type-punning fix.
 
 2007-05-19  Derek Clegg  <dclegg@apple.com>
 
 	Savannah patch #5929.
 
 	* include/freetype/tttables.h, src/base/ftobjcs.c
 	(FT_Get_CMap_Format): New function.
 
 	* include/freetype/internal/services/svttcmap.c (TT_CMapInfo): Add
 	`format' member.
 	* src/sfnt/ttcmap.c (tt_cmap{0,2,4,6,8,10,12}_get_info): Set
 	cmap_info->format.
 
 2007-05-19  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgload.c (load_truetype_glyph): Save graphics state
 	before handling subglyphs so that it can be reinitialized each time.
 	This fixes Savannah bug #19859.
 
 2007-05-16  Werner Lemberg  <wl@gnu.org>
 
 	* src/cache/ftccache.c (ftc_node_mru_link, ftc_node_mru_unlink),
 	src/cache/ftccache.h (FTC_CACHE_LOOKUP_CMP), src/cache/ftcglyph.h
 	(FTC_GCACHE_LOOKUP_CMP), src/pshinter/pshmod.c (ps_hinter_init),
 	src/sfnt/ttmtx.c (tt_face_load_hmtx, tt_face_load_hhea,
 	tt_face_get_metrics): Fix type-punning issues.
 
 2007-05-15  David Turner  <david@freetype.org>
 
 	* include/freetype/config/ftstdlib.h,
 	include/freetype/internal/ftobjs.h: As suggested by Graham Asher,
 	ensure that ft_isalnum, ft_isdigit, etc., use hard-coded values
 	instead on relying on the locale-dependent functions provided by
 	<ctypes.h>.
 
 2007-05-15  Graham Asher  <graham.asher@btinternet.com>
 
 	* src/autofit/afcjk.c (af_cjk_hints_compute_edges): Remove unused
 	variable.
 	* src/autofit/afloader.c (af_loader_load_g): Ditto.
 
 	* src/base/ftobjs.c (ft_validator_error): Use `ft_jmp_buf'.
 	(open_face_from_buffer): Initialize `stream'.
 	(FT_Request_Metrics): Remove unused variable.
 	Remove redundant `break' statements.
 	(FT_Get_Track_Kerning): Remove unused variable.
 
 	* src/psaux/afmparse.c (afm_parse_track_kern, afm_parse_kern_pairs,
 	afm_parse_kern_data): Remove redundant
 	`break' statements.
 	(afm_parser_parse): Ditto.
 	Don't use uninitialized variables.
 
 	* src/psnames/psmodule.c (VARIANT_BIT): Define as unsigned long.
 	Use `|' operator instead of `^' to set it.
 	Update all users.
 
 	* src/sfnt/ttcmap.c (tt_face_build_cmaps): Use `ft_jmp_buf'.
 	* src/sfnt/ttkern.c (tt_face_load_kern): Remove unused variable.
 
 	* src/truetype/ttgload.c (TT_Load_Simple_Glyph): Remove redundant
 	comparison.
 	(TT_Process_Simple_Glyph): Use FT_UInt for `n_points' and `i'.
 	(TT_Load_Glyph): Remove unused variable.
 
 2007-05-13  Derek Clegg  <dclegg@apple.com>
 
 	* src/base/ftobjs.c (FT_New_Library): Only allocate rendering pool
 	if FT_RENDER_POOL_SIZE is > 0.  From Savannah patch #5928.
 
 2007-05-11  David Turner  <david@freetype.org>
 
 	* src/cache/ftbasic.c, include/freetype/ftcache.h
 	(FTC_ImageCache_LookupScaler, FTC_SBit_Cache_LookupScaler): Two new
 	functions that allow us to look up glyphs using an FTC_Scaler object
 	to specify the size, making it possible to use fractional pixel
 	sizes.
 
 	* src/truetype/ttobjs.c (tt_size_ready_bytecode): Set
 	`size->cvt_ready'.  Reported by Boris Letocha.
 
 2007-05-09  Graham Asher  <graham.asher@btinternet.com>
 
 	* src/truetype/ttinterp.c (Ins_IP), src/autofit/aflatin.c
 	(af_latin_metrics_scale_dim): Fix compiler warnings.
 
 2007-05-06  Werner Lemberg  <wl@gnu.org>
 
 	* builds/win32/visualce/freetype.sln: Removed, as requested by
 	Vincent.
 
 2007-05-04  Vincent RICHOMME  <richom.v@free.fr>
 
 	* builds/win32/visualce/*: Add Visual C++ project files for Pocket
 	PC targets.
 
 	* docs/CHANGES: Document them.
 
 2007-05-04  <harry@kdevelop.org>
 
 	* builds/unix/ftsystem.c (FT_Stream_Open): Handle return value 0 of
 	mmap (which might happen on some RTOS).  From Savannah patch #5909.
 
 2007-05-03  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftobjs.c (FT_Set_Char_Size): Simplify code.
 	* include/freetype/freetype.h (FT_Set_Char_Size): Update
 	documentation.
 
 2007-04-28  Victor Stinner  <victor.stinner@inl.fr>
 
 	* src/sfnt/sfobjs.c (sfnt_load_face): Check error code after loading
 	`cmap'.
 
 2007-04-27  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgload.c (TT_Load_Simple_Glyph): Check for negative
 	number of points in contours.  Problem reported by Victor Stinner
 	<victor.stinner@haypocalc.com>.
 	(TT_Process_Simple_Glyph): Synchronize variable types.
 
 2007-04-26  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftglyph.c (FT_Glyph_Copy): Always set second argument to
 	zero in case of error.  This fixes Savannah bug #19689.
 
 2007-04-25  Boris Letocha  <b.letocha@cz.gmc.net>
 
 	* src/truetype/ttobjs.c: Fix a typo that created a speed regression
 	in the TrueType bytecode loader.
 
 2007-04-10  Martin Horak  <horakm@centrum.cz>
 
 	* src/sfnt/sfobjs.c (sfnt_load_face) [FT_CONFIG_OPTION_INCREMENTAL]:
 	Ignore `hhea' table.  This fixes Savannah bug #19261.
 
 2007-04-09  Werner Lemberg  <wl@gnu.org>
 
 
 	* Version 2.3.4 released.
 	=========================
 
 
 	Tag sources with `VER-2-3-4'.
 
 	* docs/CHANGES, docs/VERSION.DLL: Update documentation and bump
 	version number to 2.3.4.
 
 	* README, Jamfile (RefDoc), builds/win32/visualc/index.html,
 	builds/win32/visualc/freetype.dsp,
 	builds/win32/visualc/freetype.vcproj: s/2.3.3/2.3.4/, s/233/234/.
 
 	* include/freetype/freetype.h (FREETYPE_PATCH): Set to 4.
 
 	* builds/unix/configure.raw (version_info): Set to 9:15:3.
 
 2007-04-09  Martin Horak  <horakm@centrum.cz>
 
 	* src/truetype/ttgload.c (load_truetype_glyph): Save and restore
 	memory stream to avoid a crash with the incremental memory
 	interface (Savannah bug #19260).
 
 2007-04-06  David Turner  <david@freetype.org>
 
 	* src/base/ftbimap.c (ft_bitmap_assure_buffer): Fix buffer-overwrite bug
 	(Savannah bug #19536).
 
 2007-04-04  Werner Lemberg  <wl@gnu.org>
 
 
 	* Version 2.3.3 released.
 	=========================
 
 
 	Tag sources with `VER-2-3-3'.
 
 	* docs/CHANGES: Mention CVE-2007-1351.
 
 2007-04-03  David Turner  <david@freetype.org>
 
 	* src/base/ftobjs.c (FT_Set_Char_Size): As suggested by James Cloos,
 	if one of the resolution values is 0, treat it as if it were the
 	same as the other value.
 
 2007-04-02  David Turner  <david@freetype.org>
 
 	Add special code to detect `extra-light' fonts and do not snap their
 	stem widths too much to avoid bizarre hinting effects.
 
 	* src/autofit/aflatin.h (AF_LatinAxisRec): Add `standard_width' and
 	`extra_light' members.
 
 	* src/autofit/aflatin.c (af_latin_metrics_init_widths): Initialize
 	them.
 	(af_latin_metrics_scale_dim): Set `extra_light'.
 	(af_latin_compute_stem_width): Use `extra_light'.
 
 2007-03-28  David Turner  <david@freetype.org>
 
 	* src/base/ftbitmap.c (ft_bitmap_assure_buffer): Fix zero-ing of the
 	padding.
 
 2007-03-28  Werner Lemberg  <wl@gnu.org>
 
 	* src/bdf/bdflib.c (setsbit, sbitset): Handle values >= 128
 	gracefully.
 	(_bdf_set_default_spacing): Increase `name' buffer size to 256 and
 	issue an error for longer names.  This fixes CVE-2007-1351.
 	(_bdf_parse_glyphs): Limit allowed number of glyphs in font to the
 	number of code points in Unicode.
 
 	* builds/win32/visualc/index.html,
 	builds/win32/visualc/freetype.dsp,
 	builds/win32/visualc/freetype.vcproj, README: s/2.3.2/2.3.3/,
 	s/232/233/.
 
 	* docs/CHANGES: Mention ftdiff.
 
 2007-03-26  David Turner  <david@freetype.org>
 
 	* src/truetype/ttinterp.c [FIX_BYTECODE]: Remove it and
 	corresponding code.
 	(Ins_MD): Last regression fix.
 
 	* src/autofit/aflatin.c (af_latin_metrics_init_blues): Fix blues
 	computations in order to ignore single-point contours.  These are
 	never rasterized and correspond in certain fonts to mark-attach
 	points that are very far from the glyph's real outline, ruining the
 	computation.
 
 	* src/autofit/afloader.c (af_loader_load_g): In the case of
 	monospaced fonts, always set `rsb_delta' and `lsb_delta' to 0.
 	Otherwise code that uses them will most certainly ruin the fixed
 	advance property.
 
 	* docs/CHANGES, docs/VERSION.DLL, README, Jamfile (RefDoc): Update
 	documentation and bump version number to 2.3.3.
 
 	* include/freetype/freetype.h (FREETYPE_PATCH): Set to 3.
 
 	* builds/unix/configure.raw (version_info): Set to 9:14:3.
 
 2007-03-26  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* builds/unix/ftconfig.in: Disable Carbon framework dependency on
 	64bit ABI on Mac OS X 10.4.x (ppc & i386).  Found by Sean McBride.
 	* builds/vms/ftconfig.h: Ditto.
 	* include/freetype/config/ftconfig.h: Ditto.
 
 2007-03-22  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* builds/unix/ftsystem.c (FT_Stream_Open): Temporary fix to prevent
 	32bit unsigned long overflow by 64bit filesize on LP64 platform, as
 	proposed by Sean McBride:
 	http://lists.gnu.org/archive/html/freetype-devel/2007-03/msg00032.html
 
 2007-03-22  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* builds/unix/ftconfig.in: Suppress SGI compiler's warning against
 	setjmp, proposed by Sean McBride:
 	http://lists.gnu.org/archive/html/freetype-devel/2007-03/msg00032.html
 
 2007-03-19  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* builds/unix/configure.raw: Dequote `OS_INLINE' in comment of
 	conftest.c, to avoid unexpected shell evaluation.  Possibly it is a
 	bug or undocumented behaviour of autoconf.
 
 2007-03-18  David Turner   <david@freetype.org>
 
 	* src/truetype/ttinterp.c (Ins_MDRP): Another bytecode regression
 	fix; testing still needed.
 
 	* src/truetype/ttinterp.c (Ins_MD): Another bytecode regression fix.
 
 2007-03-17  David Turner   <david@freetype.org>
 
 	* src/truetype/ttinterp.c (Ins_IP): Fix wrong handling of the
 	(undocumented) twilight zone special case.
 
 2007-03-09  Werner Lemberg  <wl@gnu.org>
 
 
 	* Version 2.3.2 released.
 	=========================
 
 
 	Tag sources with `VER-2-3-2'.
 
 	* builds/win32/visualc/index.html,
 	builds/win32/visualc/freetype.dsp,
 	builds/win32/visualc/freetype.vcproj, README: s/2.3.1/2.3.2/,
 	s/231/232/.
 
 2007-03-08  David Turner  <david@freetype.org>
 
 	* docs/CHANGES, docs/VERSION.DLL: Updated for upcoming release.
 
 	* builds/unix/configure.raw (version_info): Set to 9:13:3.
 
 	* include/freetype/freetype.h (FREETYPE_PATCH): Set to 2.
 
 	* README, Jamfile (RefDoc): s/2.3.1/2.3.2/.
 
 	* src/base/ftutil.c (ft_mem_strcpyn): Fix a bug that prevented the
 	function to work properly, over-writing user-provided buffers in
 	some cases.  Reported by James Cloos <cloos@jhcloos.com>.
 
 
 2007-03-05  Werner Lemberg  <wl@gnu.org>
 
 	* include/freetype/config/ftstdlib.h (ft_strstr): New wrapper
 	macro for `strstr'.
 
 	* src/truetype/ttobjs.c (tt_face_init): Use ft_strstr for scanning
 	`trick_names', as suggested by Ivan Nincic.
 
 2007-03-05  David Turner  <david@freetype.org>
 
 	* src/base/ftinit.c (FT_Init_FreeType): Fix a small memory leak in
 	case FT_Init_FreeType fails for some reason.  Problem reported by
 	Maximilian Schwerin <maximilian.schwerin@buelowssiege.de>.
 
 	* src/truetype/ttobs.c (tt_size_init_bytecode): Clear the `x_ppem'
 	and `y_ppem' fields of the `TT_Size.metrics' structure, not those of
 	`TT_Size.root.metrics'.  Problem reported by Daniel Glöckner
 	<daniel-gl@gmx.net>.
 
 	* src/type1/t1afm.c (T1_Read_PFM): Read kerning values as 16-bit
 	signed values, not unsigned ones.  Problem reported by Johannes
 	Walther <joh_walt@yahoo.de>.
 
 2007-02-21  David Turner  <david@freetype.org>
 
 	* src/pshinter/pshalgo.c (psh_hint_align): Fix a bug in the hinting
 	of small and ghost stems in the Postscript interpreter.
 
 2007-02-20  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftmac.c (FT_GetFileRef_From_Mac_ATS_Name): Fix memory
 	leak, patch by "Jjgod Jiang" <gzjjgod@gmail.com>.
 	* builds/mac/ftmac.c (FT_GetFileRef_From_Mac_ATS_Name): Ditto.
 
 2007-02-16  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttinterp.c (Ins_MD): Remove unused variable.
 	* src/autofit/aflatin.c (af_latin_hints_link_segments): Ditto.
 
 2007-02-14  David Turner  <david@freetype.org>
 
 	It seems that the following changes fix most of the known
 	interpreter problems with my fonts, but more testing is needed,
 	though.
 
 	* src/truetype/ttinterp.c (FIX_BYTECODE): Activate.
 	(TT_MulFix14): Rewrite.
 	(Ins_MD, Ins_MDRP, Ins_IP) [FIX_BYTECODE]: Improved and updated.
 	(Ins_MIRP): Ditto.
 
 2007-02-12  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttinterp.c (Project_x, Project_y): Remove compiler
 	warnings.
 
 	* src/pcf/pcfread.c (pcf_interpret_style), src/bdf/bdfdrivr.c
 	(bdf_interpret_style): Ditto.
 
 2007-02-12  David Turner  <david@freetype.org>
 
 	Simplify projection and dual-projection code interface.
 
 	* src/truetype/ttinterp.h (TT_Project_Func): Use `FT_Pos', not
 	FT_Vector' as argument type.
 	* src/truetype/ttinterp.c (CUR_Func_project, CUR_Func_dualproj):
 	Updated.
 	(CUR_fast_project, CUR_fast_dualproj): New macros.
 	(Project, Dual_Project, Project_x, Project_y): Updated.
 	(Ins_GC, Ins_SCFS, Ins_MDAP, Ins_MIAP, Ins_IP): Use new `fast'
 	macros.
 
 
 	* src/autofit/afloader.c (af_loader_load_g): Improve spacing
 	adjustments for the non-light auto-hinted modes.  Gets rid of
 	`inter-letter spacing is too wide' problems.
 
 	* src/autofit/aflatin.c (af_latin_hints_link_segments,
 	af_latin_hints_compute_edges): Slight optimization of the segment
 	linker and better handling of serif segments to get rid of broken
 	`9' in Arial at 9pt (96dpi).
 
 
 	Introduce new string functions and the corresponding macros to get
 	rid of various uses of strcpy and other `evil' functions, as well as
 	to simplify a few things.
 
 	* include/freetype/internal/ftmemory.h (ft_mem_strdup, ft_mem_dup,
 	ft_mem_strcpyn): New declarations.
 	(FT_MEM_STRDUP, FT_STRDUP, FT_MEM_DUP, FT_DUP, FT_STRCPYN): New
 	macros.
 	* src/base/ftutil.c (ft_mem_dup, ft_mem_strdup, ft_mem_strcpyn): New
 	functions.
 
 	* src/bfd/bfddrivr.c (bdf_interpret_style, BDF_Face_Init),
 	src/bdf/bdflib.c (_bdf_add_property), src/pcf/pcfread.c
 	(pcf_get_properties, pcf_interpret_style, pcf_load_font),
 	src/cff/cffdrivr.c (cff_get_glyph_name), src/cff/cffload.c
 	(cff_index_get_sid_string), src/cff/cffobjs.c (cff_strcpy),
 	src/sfnt/sfdriver.c (sfnt_get_glyph_name), src/type1/t1driver.c
 	(t1_get_glyph_name), src/type42/t42drivr.c (t42_get_glyph_name,
 	t42_get_name_index): Use new functions and simplify code.
 
 	* builds/mac/ftmac.c (FT_FSPathMakeSpec): Don't use FT_MIN.
 
 2007-02-11  Werner Lemberg  <wl@gnu.org>
 
 	* src/autofit/afloader.c (af_loader_load_g): Don't change width for
 	non-spacing glyphs.
 
 2007-02-07  Tom Parker  <palfrey@tevp.net>
 
 	* src/cff/cffdrivr.c (cff_get_name_index): Protect against NULL
 	pointer.
 
 2007-02-05  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* include/freetype/ftmac.h (FT_DEPRECATED_ATTRIBUTE):
 	Introduce __attribute((deprecated))__ to warn functions
 	which use non-ANSI data types in its interfaces.
 	(FT_GetFile_From_Mac_Name): Deprecated, using FSSpec.
 	(FT_GetFile_From_Mac_ATS_Name): Deprecated, using FSSpec.
 	(FT_New_Face_From_FSSpec): Deprecated, using FSSpec.
 	(FT_New_Face_From_FSRef): Deprecated, using FSRef.
 
 	* src/base/ftmac.c: Predefine FT_DEPRECATED_ATTRIBUTE as void
 	to avoid warning in building FreeType.
 	* builds/mac/ftmac.c: Ditto.
 
 2007-02-05  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftbase.c: Fix to use builds/mac/ftmac.c, if configured
 	`--with-fsspec' etc.  Replace #include "ftmac.c" with
 	#include <ftmac.c>.
 
 2007-02-05  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* include/freetype/ftmac.h (FT_GetFilePath_From_Mac_ATS_Name):
 	Introduced as replacement of FT_GetFile_From_Mac_ATS_Name.
 	* src/base/ftmac.c (FT_GetFilePath_From_Mac_ATS_Name): Ditto.
 	(FT_GetFile_From_Mac_ATS_Name): Rewritten as wrapper of
 	FT_GetFilePath_From_Mac_ATS_Name.
 	* builds/mac/ftmac.c: Ditto.
 
 2007-02-05  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* include/freetype/ftmac.h: Fixed wrong comment: FSSpec of
 	FT_GetFile_From_Mac_Name, FT_GetFile_From_Mac_ATS_Name are
 	for passing to FT_New_Face_From_FSSpec.
 
 2007-02-05  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* builds/unix/configure.raw: Check whether Mac OS X system headers
 	can be built under ANSI C mode.
 
 	* src/base/ftmac.c (OS_INLINE): Redefine OS_INLINE by a version
 	compatible to ANSI C in case system headers are ANSI C incompatible.
 	* builds/mac/ftmac.c (OS_INLINE): Ditto.
 
 2007-02-01  Werner Lemberg  <wl@gnu.org>
 
 	* include/freetype/ttnameid.h (TT_MS_LANGID_DZONGHKA_BHUTAN):
 	Explain why applications shouldn't use it.  Found by Alexei.
 
 2007-02-01  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* builds/unix/freetype2.m4 (AC_CHECK_FT2): Fix spelling of warning
 	message.
 
 	* src/gxvalid/gxvmort1.c
 	(gxv_mort_subtable_type1_substTable_validate): Fix debugging
 	message.
 
 2007-01-31  Werner Lemberg  <wl@gnu.org>
 
 
 	* Version 2.3.1 released.
 	=========================
 
 
 	Tag sources with `VER-2-3-1-FINAL'.
 
 	* builds/win32/visualc/freetype.dsp,
 	builds/win32/visualc/freetype.vcproj: s/230/231/.
 	* builds/win32/visualc/index.html: s/221/231/.
 
 	* vms_make.com: Add `ftgasp'.
 
 2007-01-30  David Turner  <david@freetype.org>
 
 	Tag sources with VER-2-3-1 to prepare release.
 
 	* include/freetype/freetype.h (FREETYPE_PATCH): Set to 1.
 
 	* docs/VERSION.DLL, docs/release, README, Jamfile (RefDoc):
 	s/2.3.0/2.3.1/.
 
 	* builds/unix/configure.raw (version_info): Set to 9:12:3.
 
 
 	* src/autofit/aftypes.h (AF_USE_WARPER), src/autofit/afloader.c
 	(af_loader_load_g): Disable the warper (i.e., the light hinting
 	improvements) to make a 2.3.1 bugfix release before introducing a
 	new feature.  This should give us more time to tune and improve the
 	warper for the next release.
 
 	* docs/CHANGES: Update accordingly.
 
 2007-01-25  David Turner  <david@freetype.org>
 
 	For light auto-hinting, improve glyph advance widths and resurrect
 	normal/full hinting to its normal quality.
 
 	* src/autofit/afhints.h (AF_GlyphHintsRec): New members `xmin_delta'
 	and `xmax_delta'.
 	* src/autofit/afhints.c (af_glyph_hints_reload): Reset `xmin_delta'
 	and `xmax_delta'.
 
 	* src/autofit/afloader.c (af_loader_load_g) <AF_USE_WARPER>: Replace
 	preprocessor conditional with if-clause, handling both light and
 	normal mode.
 
 	* src/autofit/afwarp.c (AF_WarpScore): Fine-tune again.
 	(af_warper_compute): Handle `xmin_delta' and `xmax_delta'.
 
 2007-01-25  Werner Lemberg  <wl@gnu.org>
 
 	* docs/release: Updated -- Savannah uses a new uploading scheme.
 
 2007-01-25  David Turner  <david@freetype.org>
 
 	* src/cff/cffload.c (cff_index_get_pointers): Improve previous fix.
 
 	* src/cff/cffgload.c (cff_decoder_parse_charstrings)
 	<cff_op_callsubr, cff_op_callgsubr>: Fix sanity check for empty
 	functions.
 
 	* docs/CHANGES: Document light auto-hinting improvement.
 
 2007-01-25  Werner Lemberg  <wl@gnu.org>
 
 	* src/cff/cffload.c (cff_index_get_pointers): Handle last entry
 	correctly in a sanity check.  Since this function is only used to
 	load local and global functions, any charstring that called the last
 	local/global function would fail otherwise.  This fixes Savannah bug
 	#18867.
 
 	* docs/CHANGES: Document it.
 
 2007-01-23  David Turner  <david@freetype.org>
 
 	* src/truetype/ttobjs.c (tt_size_ready_bytecode): Fix typo that
 	prevented compilation when disabling both the unpatented and the
 	bytecode interpreter in the TrueType font driver.
 
 
 	Fix and enable the warper to improve `light' hinting mode.  This is
 	not necessarily a final version, but it seems to work well.
 
 	* src/autofit/aflatin.c (af_latin_hints_init) [AF_USE_WARPER]:
 	Disable code.
 	(af_latin_hints_apply) [AF_USE_WARPER]: Handle FT_RENDER_MODE_LIGHT.
 	* src/autofit/aftypes.h: Activate AF_USE_WARPER.
 
 	* src/autofit/afwarp.c (AF_WarpScore): Tune table.
 	(af_warper_compute_line_best): Fix array size of `scores'.
 	(af_warper_compute): Better handling of border cases.
 	* src/autofit/afwarp.h (AF_WarperRec): Remove unused members `X1'
 	and `X2'.
 
 2007-01-21  Werner Lemberg  <wl@gnu.org>
 
 	* ChangeLog: Split off older entries into...
 	* ChangeLog.22: This new file.
 
 2007-01-21  Werner Lemberg  <wl@gnu.org>
 
 	* docs/CHANGES: Document SHZ fix.
 
 2007-01-21  George Williams  <gww@silcom.com>
 
 	* src/truetype/ttinterp.c (Ins_SHZ): SHZ doesn't move phantom
 	points.
 
 2007-01-21  Werner Lemberg  <wl@gnu.org>
 
 	* src/sfnt/ttmtx.c (tt_face_get_metrics)
 	[!FT_CONFIG_OPTION_OLD_INTERNALS]: Fix limit check.
 
 2007-01-17  Werner Lemberg  <wl@gnu.org>
 
 
 	* Version 2.3.0 released.
 	=========================
 
 
 	Tag sources with `VER-2-3-0-FINAL'.
 
 2007-01-17  Werner Lemberg  <wl@gnu.org>
 
 	* docs/release: Updated.
 
 2007-01-16  David Turner  <david@freetype.org>
 
 	* src/autofit/aflatin.c (af_latin_hints_compute_segments),
 	src/cff/cffdriver.c (cff_ps_get_font_info), src/truetype/ttobjs.c
 	(tt_face_init), src/truetype/ttinterp.c (Ins_SHC): Fix compiler
 	warnings.
 
 2007-01-15  Detlef Würkner  <TetiSoft@apg.lahn.de>
 
 	* builds/amiga/makefile, builds/amiga/makefile.os4,
 	builds/amiga/smakefile: Add `ftgasp.c' and `ftlcdfil.c'.
 
 	* builds/amiga/include/freetype/config/ftconfig.h: Synchronize.
 
 2007-01-14  Detlef Würkner  <TetiSoft@apg.lahn.de>
 
 	Fix various compiler warnings.
 
 	* src/truetype/ttdriver.c (tt_size_select), src/cff/cffobjs.h,
 	src/cff/cffobjs.c (cff_size_request), src/type42/t42objs.h:
 	s/index/strike_index/.
 	* src/base/ftobjs.c (FT_Match_Size): s/index/size_index/.
 
 	* src/gxvalid/gxvmorx5.c
 	(gxv_morx_subtable_type5_InsertList_validate): s/index/table_index/.
 
 	* src/truetype/ttinterp.c (Compute_Point_Displacement),
 	src/pcf/pcfread.c (pcf_seek_to_table_type): Avoid possibly
 	uninitialized variables.
 
 2007-01-13  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* docs/CHANGES, docs/INSTALL.MAC: Improvements.
 
 2007-01-13  Werner Lemberg  <wl@gnu.org>
 
 	* src/type1/t1afm.c (T1_Read_Metrics): MS Windows allows PFM
 	versions up to 0x3FF without complaining.
 
 2007-01-13  Derek Clegg  <dclegg@apple.com>
 
 	Add FT_Get_PS_Font_Info interface to CFF driver.
 
 	* src/cff/cfftypes.h: Include FT_TYPE1_TABLES_H.
 	(CFF_FontRec): Add `font_info' field.
 
 	* src/cff/cffload.c: Include FT_TYPE1_TABLES_H.
 	(cff_font_done): Free font->font_info if necessary.
 
 	* src/cff/cffdrvr.c (cff_ps_get_font_info): New function.
 	(cff_service_ps_info): Register cff_ps_get_font_info.
 
 2007-01-13  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftoutln.c (FT_Outline_Get_Orientation): Fix compilation
 	with C++ compiler.
 
 	* src/autofit/afhints.c (af_glyph_hints_dump_segments,
 	af_glyph_hints_dump_edges): Ditto.
 
 	* src/base/rules.mk (BASE_SRC): Remove ftgasp.c (it's already in
 	`modules.cfg').
 
 	* src/sfnt/ttsbit0.h: Remove.
 
 	* src/sfnt/rules.mk (SFNT_DRV_SRC): Don't include ttsbit0.c.
 
 2007-01-12  David Turner  <david@freetype.org>
 
 	* src/base/ftbitmap.c (ft_bitmap_assure_buffer): Fix memory stomping
 	bug in the bitmap emboldener if the pitch of the source bitmap is
 	much larger than its width.
 
 	* src/truetype/ttinterp.c (Update_Max): Fix aliasing-related
 	compilation warning.
 
 2007-01-12  Werner Lemberg  <wl@gnu.org>
 
 	* builds/unix/install-sh, builds/unix/mkinstalldirs: Updated from
 	`automake' CVS module from sources.redhat.com.
 
 2007-01-11  Werner Lemberg  <wl@gnu.org>
 
 	* src/type1/t1load.c (is_space): Removed.
 	(parse_encoding, parse_charstrings): Use IS_PS_DELIM.
 	(parse_charstrings): Use IS_PS_TOKEN.
 
 
 	* autogen.sh: Avoid bash specific syntax.
 
 2007-01-11  David Turner  <david@freetype.org>
 
 	* docs/CHANGES: Small update.
 
 	* builds/unix/configure.raw (version_info): Set to 9:11:3.
 
 	* src/base/ftobjs.c (IsMacResource): Fix a small bug that caused a
 	crash with some Mac OS X .dfont files.  Submitted by Masatake
 	Yamato.
 
 	* autogen.sh: Small fix to get it working on Mac OS X properly:
 	The issue is that GNU libtool is called `glibtool' on this platform,
 	and we must call `glibtoolize', since `libtoolize' doesn't exist.
 
 2007-01-10  David Turner  <david@freetype.org>
 
 	* all-sources: Tag all sources with VER-2-3-0-RC1 and
 	VER-2-3-0.
 
 	* Jamfile (RefDoc), README, builds/win32/visualc/freetype.dsp,
 	builds/win32/visualc/freetype.vcproj, docs/VERSION.DLL: Update
 	version number to 2.3.0.
 
 	* include/freetype/freetype.h (FREETYPE_MINOR): Set to 3.
 	(FREETYPE_PATCH): Set to 0.
 
 	* include/freetype/ftchapters.h, include/freetype/ftgasp.h,
 	include/freetype/ftlcdfil.h: Update reference documentation with
 	GASP support and LCD filtering sections.
 
 	* src/pshinter/pshalgo.c (psh_glyph_compute_inflections): Fix a typo
 	which created an endless loop with some malformed font files.
 
 2007-01-10  Derek Clegg  <dclegg@apple.com>
 
 	* src/type1/t1load.c (T1_Get_MM_Var): Always return fixed point
 	values.
 
 2007-01-08  David Turner  <david@freetype.org>
 
 	* docs/CHANGES: Updated.
 
 	* include/freetype/ftgasp.h, src/base/ftgasp.c: New files which add
 	a new API `FT_Get_Gasp' to return entries of the `gasp' table
 	corresponding to a given character pixel size.
 
 	* src/sfnt/ttload.c (tt_face_load_gasp): Add version check for the
 	`gasp' table, in order to avoid potential problems with later
 	versions.
 
 	* include/freetype/config/ftheader.h (FT_GASP_H): New macro for
 	<freetype/ftgasp.h>.
 
 	* src/base/rules.mk (BASE_SRC), src/base/Jamfile (_sources),
 	modules.cfg (BASE_EXTENSIONS), builds/win32/visualc/freetype.dsp,
 	builds/win32/visualc/freetype.vcproj: Add src/base/ftgasp.c to the
 	default build.
 
 2007-01-07  Werner Lemberg  <wl@gnu.org>
 
 	* src/cid/cidparse.c (cid_parser_new): Improve error message for
 	Type 11 fonts.
 	Scan for `/sfnts' token.
 
 2007-01-07  Werner Lemberg  <wl@gnu.org>
 
 	* src/cid/cidparse.c (cid_parser_new): Reject Type 11 fonts.
 
 2007-01-06  Werner Lemberg  <wl@gnu.org>
 
 	* src/cff/cffload.c (cff_index_init): Remove unused variable.
 	(cff_index_read_offset): s/perror/errorp/ to avoid global shadowing.
 
 2007-01-04  David Turner  <david@freetype.org>
 
 	* src/pfr/pfrobjs.c (pfr_face_init): Detect non-scalable fonts
 	correctly.  This fixes Savannah bug #17876.
 
 
 	Do not allocate interpreter-specific tables in memory if we are not
 	going to load glyphs with the bytecode interpreter anyway.
 
 	* src/truetype/ttgload.c (tt_loader_init): Load execution context
 	only if glyph is hinted.
 	Updated.
 	* src/truetype/ttobjs.h (TT_SizeRec): Add members `bytecode_ready'
 	and `cvs_ready'.
 	Add `tt_size_ready_bytecode' declaration.
 	* src/truetype/ttobjs.c (tt_size_done_bytecode,
 	tt_size_init_bytecode, tt_size_ready_bytecode): New functions.
 	(tt_size_init): Move most code into `tt_size_init_bytecode'.
 	(tt_size_done): Move most code into `tt_size_done_bytecode'.
 	(tt_size_reset): Move some code to `tt_size_ready_bytecode'.
 
 
 	Don't extract the metrics table from the SFNT font file.  Instead,
 	reparse it on each glyph load.  The runtime difference is not
 	noticeable, and it can save a lot of heap memory when memory-mapped
 	files are not used.
 
 	* include/freetype/internal/tttypes.h (TT_FaceRec): Add members
 	`horz_metrics_offset' and `vert_metrics_ofset'.
 	* src/sfnt/ttmtx.c (tt_face_load_hmtx, tt_face_get_metrics):
 	Updated.
 
 
 	* src/sfnt/ttcmap.c (tt_cmap4_validate): Slight optimization.
 
 
 	Do not load the CFF index offsets into memory, since this wastes a
 	*lot* of heap memory with large Asian CFF fonts.  There is no
 	significant performance loss.
 
 	* src/cff/cffload.h: Add `cff_charset_cid_to_gindex' declaration.
 	* src/cff/cfftypes.h (CFF_IndexRec): Add fields `start' and
 	`data_size'.
 	(CFF_CharsetRec): Add field `num_glyphs'.
 
 	* src/cff/cffload.c (cff_index_read_offset, cff_index_load_offsets,
 	cff_charset_cid_to_gindex): New functions.
 	(cff_new_index): Renamed to...
 	(cff_index_init): This.  Update all callers.
 	Updated -- some code has been moved to `cff_index_load_offsets'.
 	(cff_done_index): Renamed to...
 	(cff_index_done): This.  Update all callers.
 	(cff_index_get_pointers, cff_index_access_element): Updated to use
 	stream offsets.
 	(cff_charset_compute_cids): Set `num_glyphs' field.
 	(cff_encoding_load): Updated.
 
 	* src/cff/cffgload.c (cff_slot_load): Updated.
 
 2007-01-04  David Turner  <david@freetype.org>
 
 	* docs/INSTALL.UNIX: Simplify some parts, add reference to
 	autogen.sh and pointer to README.CVS.
 
 	* README.CVS: Add common problem description and solution
 	when running autogen.sh.
 
 	* docs/INSTALL: Add reference to MacOS X.
 
 	* docs/MAKEPP, docs/INSTALL.MAC: New documentation files.
 
 	* docs/TODO: Remove obsolete items.
 
 	* src/raster/ftraster.c: (TRaster_Instance): Replace it with...
 	(TWorker): This.
 	Remove `count_table' and `memory'.
 	Make `grays' a pointer.
 	(TRaster): New structure.
 	(count_table): New static array.
 	(RAS_ARGS, RAS_ARG, RAS_VARS, RAS_VAR, FT_UNUSED_RASTER, cur_ras,
 	Vertical_Gray_Sweep_Step, ft_black_new, ft_black_done,
 	ft_black_set_mode, ft_black_render): Updated.
 	(ft_black_init): Don't initialize `count_table'.
 	(ft_black_reset): Use the render pool.  This saves about 6KB of
 	heap space for each FT_Library instance.
 
 	* src/smooth/ftgrays.c (TRaster): Replaced with...
 	(TWorker): This.
 	Remove `memory'.
 	(TRaster): New structure.
 
 	(RAS_ARG_, RAS_ARG, RAS_VAR_, RAS_VAR, ras, gray_render_line,
 	gray_move_to, gray_line_to, gray_conic_to, gray_cubic_to,
 	gray_render_span, gray_raster_render): Updated.
 	(gray_raster_reset): Use the render pool.  This saves about 6KB of
 	heap space for each FT_Library instance.
 
 	* src/sfnt/sfobjs.c, src/sfnt/ttkern.c, src/sfnt/ttkern.h,
 	src/sfnt/ttmtx.c, src/sfnt/ttsbit.c, src/sfnt/ttsbit.h,
 	src/truetype/ttpload.c, include/freetype/config/ftoption.h: Remove
 	FT_OPTIMIZE_MEMORY macro (and code for !FT_OPTIMIZE_MEMORY) since
 	the optimization is no longer experimental.
 
 	* src/pshinter/pshalgo.c (psh_glyph_interpolate_normal_points):
 	Remove a typo that results in no hinting and a memory leak with some
 	large Asian CFF fonts.
 
 	* src/base/ftobjs.c (FT_Done_Library): Remove a subtle memory leak
 	which happens when FT_Done_Library is called with still opened
 	CFF_Faces in it.  We need to close all faces before destroying the
 	modules, or else some bad things (memory leaks) may happen.
 
 2007-01-02  Werner Lemberg  <wl@gnu.org>
 
 	* src/gxvalid/gxvkern.c (gxv_kern_subtable_fmt0_pairs_validate):
 	Remove compiler warning.
 
 2007-01-02  David Turner  <david@freetype.org>
 
 	* src/sfnt/sfobjs.c: Add documentation comment.
 
 2006-12-31  Masatake YAMATO  <jet@gyve.org>
 
 	* src/gxvalid/gxvkern.c (gxv_kern_subtable_fmt0_pairs_validate): New
 	function.
 	Check uniqueness of the gid pairs.
 	(gxv_kern_subtable_fmt0_validate): Move some code to
 	`gxv_kern_subtable_fmt0_pairs_validate'.
 
 2006-12-22  David Turner  <david@freetype.org>
 
 	* src/autofit/aflatin.c, src/truetype/ttgload.c: Remove compiler
 	warnings.
 
 	* builds/win32/visualc/freetype.vcproj: Add _CRT_SECURE_NO_DEPRECATE
 	to avoid deprecation warnings with Visual C++ 8.
 
 2006-12-16  Anders Kaseorg  <anders@kaseorg.com>
 
 	* src/base/ftlcdfil.c (FT_Library_SetLcdFilter)
 	[FT_FORCE_LIGHT_LCD_FILTER]: Fix typo.
 
 2006-12-15  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* include/freetype/internal/services/svotval.h: Add `volatile' to
 	sync with the modification by Jens Claudius on 2006-08-22; cf.
 	  http://cvs.savannah.gnu.org/viewcvs/freetype/freetype2/src/otvalid/otvmod.c?r1=1.4&r2=1.5
 
 2006-12-15  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftmac.c: Specialized for Mac OS X only.
 	* builds/unix/ftconfig.in: Fixed for ppc64 missing Carbon framework.
 	* builds/unix/configure.raw: Ditto.  When explicit switches for
 	FSSpec/FSRef/QuickDraw/ATS availability are given to configure,
 	builds/mac/ftmac.c is used instead of default src/base/ftmac.c.
 
 2006-12-15  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* builds/mac/ftmac.c: Copied src/base/ftmac.c for legacy system.
 	* builds/mac/FreeType.m68k_cfm.make.txt: Fix to use builds/mac/ftmac.c
 	instead of src/base/ftmac.c
 	* builds/mac/FreeType.ppc_carbon.make.txt: Ditto.
 	* builds/mac/FreeType.ppc_classic.make.txt: Ditto.
 	* builds/mac/FreeType.m68k_far.make.txt: Ditto, and exclude gxvalid.c
 	that cannot be built at present.
 
 2006-12-15  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftobjs.c: Improvement of resource fork handler for
 	POSIX, cf.
 	  http://lists.gnu.org/archive/html/freetype-devel/2006-10/msg00025.html
 	(Mac_Read_sfnt_Resource): Count only `sfnt' resource of suitcase font
 	format or .dfont, to simulate the face index number counted by ftmac.c.
 	(IsMacResource): Return the number of scalable faces correctly.
 
 2006-12-10  Werner Lemberg  <wl@gnu.org>
 
 	* builds/toplevel.mk (version): Protect against `distclean' target.
 
 2006-12-09  Werner Lemberg  <wl@gnu.org>
 
 	* builds/*/*def.mk, builds/*/detect.mk (CAT): Define to either `cat'
 	or `type'.
 
 	* builds/freetype.mk (version): Extracted from freetype.h, using
 	GNU make's built-in string functions.
 	(refdoc): Use $(version) instead of static version number.
 
 2006-12-08  Werner Lemberg  <wl@gnu.org>
 
 	* builds/toplevel.mk (dist): Extract version number from freetype.h.
 
 2006-12-08  Vladimir Volovich  <vvv@vsu.ru>
 
 	* src/tools/apinames.c (State): Remove final comma in structure --
 	xlc v5 under AIX 4.3 doesn't like this.
 
 2006-12-07  David Turner  <david@freetype.org>
 
 	* src/autofit/afloader.c (af_loader_load_g): Small adjustment
 	to the spacing of auto-fitted glyphs.  This only impacts rare
 	cases (e.g., Arial Bold at rather small character sizes).
 
 2006-12-03  Werner Lemberg  <wl@gnu.org>
 
 	* src/sfnt/rules.mk (SFNT_DRV_SRC): Add ttsbit0.c.
 
 2006-12-01  Werner Lemberg  <wl@gnu.org>
 
 	* src/sfnt/sfobjs.c (tt_face_get_name): All Unicode strings are
 	encoded in UTF-16BE.  Patch from Rajeev Pahuja <rpahuja@esri.com>.
 	(tt_name_entry_ascii_from_ucs4): Removed.
 
 
 	* include/freetype/ftxf86.h: Fix and extend comment so that it
 	appears in the documentation.
 
 	* include/freetype/ftchapters.h: Add `font_format' section.
 
 
 	* src/tools/docmaker/tohtml.py (HtmlFormatter::index_exit): Add link
 	to TOC in index page.
 
 2006-11-28  David Turner  <david@freetype.org>
 
 	* src/smooth/ftgrays.c (gray_raster_render): Return 0 when we are
 	trying to render into a zero-width/height bitmap, not an error code.
 
 	* src/truetype/ttobjs.c (tt_face_init): Fix typo in previous patch.
 
 	* src/smooth/ftgrays.c: Remove hard-coded error values; use FreeType
 	ones instead.
 
 	* src/autofit/afhints.c (af_glyph_hints_dump_segments): Remove unused
 	variable.
 
 2006-11-26  Pierre Hanser  <hanser@club-internet.fr>
 
 	* src/truetype/ttobjs.c (tt_face_init): Protect against NULL pointer.
 
 2006-11-25  David Turner  <david@freetype.org>
 
 	* src/autofit/afhints.c	(af_glyph_hints_dump_points,
 	af_glyph_hints_dump_segments, af_glyph_hints_dumpedges) [!AF_DEBUG]:
 	Add stubs to link the `ftgrid' test program when debugging is
 	disabled in the auto-hinter.
 
 2006-11-23  David Turner  <david@freetype.org>
 
 	* src/autofit/afhints.c, src/autofit/afhints.h, src/autofit/aflatin.c,
 	src/autofit/aftypes.h: Miscellaneous auto-hinter improvements.
 
 	* src/autofit/afhints.c (af_glyph_hints_dump_segments) [AF_DEBUG]:
 	Emit more sensible information.
 
 	* src/autofit/afhints.h (AF_SegmentRec): Add `height' member.
 
 	* src/autofit/aflatin.c (af_latin_metrics_scale_dim): Improve
 	rounding of blue values.
 	(af_latin_hints_compute_segments): Hint segment heights.
 	(af_latin_hints_link_segments): Reduce `len_score' value.
 	(af_latin_hints_compute_edges): Increase `segment_length_threshold'
 	value and use `height' member for comparisons.
 	(af_latin_hint_edges): Extend logging message.
 	Improve handling of remaining edges.
 
 2006-11-22  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #15553.
 
 	* src/truetype/ttgload.c (tt_loader_init): Re-execute the CVT
 	program after a change from mono to grayscaling (and vice versa).
 	Use correct constant for comparison to get `exec->grayscale'.
 
 2006-11-18  Werner Lemberg  <wl@gnu.org>
 
 	Because FT_Load_Glyph expects CID values for CID-keyed fonts, the
 	test for a valid glyph index must be deferred to the font drivers.
 	This patch fixes Savannah bug #18301.
 
 	* src/base/ftobjs.c (FT_Load_Glyph): Don't check `glyph_index'.
 	* src/bdf/bdfdrivr.c (BDF_Glyph_Load), src/cff/cffgload.c
 	(cff_slot_load), src/cid/cidgload.c (cid_slot_load_glyph),
 	src/pcf/pcfdrivr.c (PCF_Glyph_Load), src/pfr/pfrobjs.c
 	(pfr_slot_load), src/truetype/ttdriver.c (Load_Glyph),
 	src/type1/t1gload.c (T1_Load_Glyph), src/winfonts/winfnt.c
 	(FNT_Load_Glyph): Check validity of `glyph_index'.
 
 2006-11-13  David Turner  <david@freetype.org>
 
 	* src/truetype/ttinterp.c (FIX_BYTECODE): Undefine.  The interpreter
 	`enhancements' are still too buggy for general use.
 
 	* src/base/ftlcdfil.c: Add support for FT_FORCE_LIGHT_LCD_FILTER and
 	FT_FORCE_LEGACY_LCD_FILTER at compile time.  Define these macros
 	when building the library to change the default LCD filter to be
 	used.  This is only useful for experimentation.
 
 	* include/freetype/ftlcdfil.h: Update documentation.
 
 2006-11-10  David Turner  <david@freetype.org>
 
 	* src/smooth/ftsmooth.c: API change for the LCD
 	filter.  The FT_LcdFilter value is an enumeration describing which
 	filter to apply, with new values FT_LCD_FILTER_LIGHT and
 	FT_LCD_FILTER_LEGACY (the latter implements the LibXft original
 	algorithm which produces strong color fringes for everything
 	except very-well hinted text).
 
 	* include/freetype/ftlcdfil.h (FT_Library_SetLcdFilter): Change
 	second parameter to an enum type.
 
 	* src/base/ftlcdfil.c (USE_LEGACY): Define.
 	(_ft_lcd_filter): Rename to...
 	(_ft_lcd_filter_fir): This.
 	Update parameters.
 	(_ft_lcd_filter_legacy) [USE_LEGACY]: New filter function.
 	(FT_Library_Set_LcdFilter): Update parameters.
 	Handle new filter modes.
 
 	* include/internal/ftobjs.h: Include FT_LCD_FILTER_H.
 	(FT_Bitmap_LcdFilterFunc): Change third argument to `FT_Library'.
 	(FT_LibraryRec) [FT_CONFIG_OPTION_SUBPIXEL_RENDERING]: Add filtering
 	callback and update other fields.
 
 	* src/smooth/ftsmooth.c (ft_smooth_render_generic)
 	[FT_CONFIG_OPTION_SUBPIXEL_RENDERING]: Update.
 	Other minor improvements.
 
 	* src/autofit/aflatin.c: Various tiny improvements that drastically
 	improve the handling of serif fonts and of LCD/LCD_V hinting modes.
 	(af_latin_hints_compute_edges): Fix typo.
 	(af_latin_compute_stem_width): Take better care of diagonal stems.
 
 2006-11-09  David Turner  <david@freetype.org>
 
 	* src/pshinter/pshalgo.c (psh_glyph_compute_inflections): Fix
 	typo which created a variable-used-before-initialized bug.
 
 2006-11-07  Zhe Su  <james.su@gmail.com>
 
 	* src/base/ftsynth.c (FT_GlyphSlot_Embolden): Handle vertical layout
 	also.
 
 2006-11-03  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftcalc.c: Don't use `long long' but `FT_Int64'.
 
 2006-11-02  David Turner  <david@freetype.org>
 
 	Add a few tweaks to better handle serif fonts.
 	Add more debugging messages.
 
 	* src/autofit/aflatin.c (af_latin_hints_compute_edges): Ignore
 	segments that are less than 1.5 pixels high.  This gets rid of
 	*many* corner cases with serifs.
 	(af_latin_align_linked_edge): Add logging message.
 	(af_latin_hint_edges): Use AF_HINTS_DO_BLUES.
 	Add logging messages.
 	Handle AF_EDGE_FLAG flag specially.
 
 	* src/autofit/afmodule.c [AF_DEBUG]: Add _af_debug,
 	_af_debug_disable_blue_hints, and _af_debug_hints variables.
 
 	* src/autofit/aftypes.h (AF_LOG) [AF_DEBUG]: Use _af_debug.
 	Update external declarations.
 	(af_corner_orientation, af_corner_is_flat): Replaced by...
 
 	* include/freetype/internal/ftcalc.h (ft_corner_orientation,
 	ft_corner_is_flat): These declarations.
 
 	* src/autofit/afangles.c (af_corner_orientation, af_corner_is_flat):
 	Comment out.  Replaced by...
 
 	* src/base/ftcalc.h (ft_corner_orientation, ft_corner_is_flat):
 	These functions.  Update all callers.
 	(FT_Add64) [!FT_LONG64]: Simplify.
 
 	* src/autofit/afhints.c: Include FT_INTERNAL_CALC_H.
 	(af_direction_compute): Add a missing FT_ABS call.  This bug caused
 	production of garbage by missing lots of segments.
 
 	* src/autofit/afhints.h (AF_HINTS_DO_BLUES): New macro.
 
 	* src/autofit/afloader.c (af_loader_init, af_loader_done)
 	[AF_DEBUG]: Set _af_debug_hints.
 
 
 	* src/pshinter/pshalgo.c: Include FT_INTERNAL_CALC_H.
 	(psh_corner_is_flat, psh_corner_orientation): Use ft_corner_is_flat
 	and ft_corner_orientation.
 
 
 	* src/gzip/inftrees.c (huft_build): Remove compiler warning.
 
 2006-10-24  Werner Lemberg  <wl@gnu.org>
 
 	* src/cff/cffload.c (cff_encoding_load): Remove unused variable.
 
 	* src/base/ftobjs.c (FT_Select_Charmap): Disallow FT_ENCODING_NONE
 	as argument.
 
 2006-10-23  Zhe Su  <zsu@novell.com>
 
 	* src/base/ftoutln.c (FT_Outline_Get_Orientation): Re-implement to
 	better deal with broken Asian fonts with strange glyphs, having
 	self-intersections and other peculiarities.  The used algorithm is
 	based on the nonzero winding rule.
 
 2006-10-23  David Turner  <david@freetype.org>
 
 	Speed up the CFF font loader.  With some large CFF fonts,
 	FT_Open_Face is now more than three times faster.
 
 	* src/cff/cffload.c (cff_get_offset): Removed.
 	(cff_new_index): Inline functionality of `cff_get_offset'.
 	(cff_charset_compute_cids, cff_charset_free_cids): New functions.
 	(cff_charset_done): Call `cff_charset_free_cids'.
 	(cff_charset_load): Call `cff_charset_compute_cids'.
 	(cff_encoding_load) <Populate>: Ditto, to replace inefficient loop.
 
 	* src/sfnt/ttmtx.c (tt_face_load_hmtx): Replace calls to FT_GET_XXX
 	with FT_NEXT_XXX.
 
 
 	Speed up the Postscript hinter, with more than 100% speed increase
 	on my machine.
 
 	* src/pshinter/pshalgo.c (psh_corner_is_flat,
 	psh_corner_orientation): New functions.
 	(psh_glyph_compute_inflections): Merge loops for efficiency.
 	Use `psh_corner_orientation'.
 	(psh_glyph_init): Use `psh_corner_is_flat'.
 	(psh_hint_table_find_strong_point): Renamed to...
 	(psh_hint_table_find_strong_points): This.
 	Rewrite, adding argument to handle all points at once.
 	Update all callers.
 	(PSH_MAX_STRONG_INTERNAL): New macro.
 	(psh_glyph_interpolate_normal_points): Rewrite for efficiency.
 
 2006-10-15  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftmac.c (FT_New_Face_From_FOND): Initialize variable
 	`error' with FT_Err_Ok.
 
 2006-10-14  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* docs/INSTALL.CROSS: New document file for cross-building.
 
 	* builds/unix/configure.raw: Preliminary cross-building support.
 	Find native C compiler and pass it by CC_BUILD, and
 	find suffix for native executable and pass it by EXEEXT_BUILD.
 	Also suffix for target executable is passed by EXEEXT.
 
 	* builds/unix/unix-cc.in (CCraw_build, E_BUILD): New variables to
 	build `apinames' which runs on building system.  They are set by
 	CC_BUILD and EXEEXT_BUILD.
 
 	* builds/exports.mk (APINAMES_EXE): Change the extension for
 	apinames from the suffix for target (E) to that for building host
 	(E_BUILD).
 
 2006-10-12  Werner Lemberg  <wl@gnu.org>
 
 	* docs/INSTALL.UNX, docs/UPGRADE.UNX: Renamed to...
 	* docs/INSTALL.UNIX, docs/UPGRADE.UNIX: This.  Update all documents
 	which reference those files.
 
 2006-10-12  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* builds/unix/configure.raw (FT2_EXTRA_LIBS): New variable.  It is
 	embedded in freetype2.pc and freetype-config.  Use it to record
 	Carbon dependency of MacOSX.
 
 	* builds/unix/freetype2.in: Embed FT2_EXTRA_LIBS.
 
 	* builds/unix/freetype-config.in: Ditto.
 
 2006-10-11  Werner Lemberg  <wl@gnu.org>
 
 	* devel/ftoption.h (FT_CONFIG_OPTION_SUBPIXEL_RENDERING): Define for
 	development.
 
 2006-10-03  Jens Claudius  <jens.claudius@yahoo.com>
 
 	* include/freetype/config/ftstdlib.h: Cast away volatileness from
 	argument to ft_setjmp.
 
 	* include/freetype/internal/ftvalid.h: Add comment that
 	ft_validator_run must not be used.
 
 2006-10-01  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftbase.c: Undo change from 2006-09-30.
 
 	* src/base/rules.mk (BASE_SRC): Remove `ftlcdfil.c'.
 
 2006-09-30  David Turner  <david@freetype.org>
 
 	* include/freetype/internal/ftobjs.h (FT_Face_InternalRec):
 	s/unpatented_hinting/ignore_unpatented_hinter/.
 	Update all callers.
 
 	* src/base/ftobjs.c (FT_Load_Glyph): Refine the algorithm whether
 	auto-hinting shall be used or not.
 
 	* src/truetype/ttobjs.c (tt_face_init): Ditto.
 
 2006-09-30  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/rules.mk (BASE_SRC): Remove `ftapi.c' (which is no longer
 	in use).
 
 	* src/base/ftbase.c: Include `ftlcdfil.c'.
 
 2006-09-29  Werner Lemberg  <wl@gnu.org>
 
 	* src/sfnt/ttcmap.c (tt_cmap4_char_map_binary): Fix algorithm for
 	overlapping segments.  Bug reported by Stefan Koch.
 
 2006-09-28  David Turner  <david@freetype.org>
 
 	Fix a bug in the automatic unpatented hinting support which prevents
 	normal bytecode hinting to work properly.
 
 	* include/freetype/internal/ftobjs.h (FT_Face_InternalRec):
 	s/force_autohint/unpatented_hinting/.  Update all callers.
 
 	* src/base/ftobjs.c (FT_Load_Glyph): Updated code.
 
 	* src/autofit/aftypes.h (AF_DEBUG): Undefine to get rid of traces.
 
 2006-09-27  David Turner  <david@freetype.org>
 
 	* include/freetype/freetype.h (FT_FREETYPE_PATCH): Set to 2.
 
 
 	Add a new API to support color filtering of subpixel glyph bitmaps.
 	In a default build, the function `FT_Library_SetLcdFilter' returns
 	`FT_Err_Unimplemented_Feature'; you need to #define
 	FT_CONFIG_OPTION_SUBPIXEL_RENDERING in ftoption.h to compile the
 	real implementation.
 
 	* include/freetype/ftlcdfil.h, src/base/ftlcdfil.c: New files.
 
 	* include/freetype/internal/ftobjs.h (FT_Bitmap_LcdFilterFunc): New
 	typedef.
 	(FT_LibraryRec) [FT_CONFIG_OPTION_SUBPIXEL_RENDERING]: New members
 	`lcd_filter_weights' and `lcd_filter'.
 
 	* src/smooth/ftsmooth.c (ft_smooth_render_generic): Remove arguments
 	`hmul' and `vmul'.
 
 	Handle subpixel rendering.
 	Simplify function.
 	(ft_smooth_render_lcd): Use `FT_RENDER_MODE_LCD'.
 	(ft_smooth_render_lcd_v): Use `FT_RENDER_MODE_LCD_V'.
 
 	* include/freetype/config/ftheader.h (FT_LCD_FILTER_H): New macro,
 	pointing to <freetype/ftlcdfil.h>.
 
 	* src/base/Jamfile (_sources), src/base/rules.mk (BASE_SRC),
 	vms_make.com: Add `ftlcdfil.c' to the list of compiled source files.
 
 	* modules.cfg (BASE_EXTENSIONS): Add ftlcdfil.c.
 
 2006-09-26  David Bustin
 
 	* src/pfr/pfrobjs.c (pfr_face_get_kerning): Skip adjustment bytes
 	correctly.  Reported as Savannah bug #17843.
 
 2006-09-26  David Turner  <david@freetype.org>
 
 	* src/autofit/afhints.h (AF_HINTS_DO_HORIZONTAL,
 	AF_HINTS_DO_VERTICAL, AF_HINTS_DO_ADVANCE): New macros to disable
 	horizontal and vertical hinting for the purpose of debugging the
 	auto-fitter.
 
 	* src/autofit/afmodule.c (_af_debug_disable_horz_hints,
 	_af_debug_disable_vert_hints) [AF_DEBUG]: New global variables.
 
 	* src/autofit/aftypes.h [AF_DEBUG]: Declare above variables.
 
 	* include/freetype/config/ftoption.h, devel/ftoption.h
 	(FT_CONFIG_OPTION_SUBPIXEL_RENDERING): New macro to control whether
 	we want to compile LCD-optimized rendering code (à la ClearType) or
 	not.  The macro *must* be disabled in default builds of the library
 	for patent reasons.
 
 	* src/smooth/ftsmooth.c (ft_smooth_render_generic): Disable
 	LCD-specific rendering when FT_CONFIG_OPTION_SUBPIXEL_RENDERING
 	isn't defined at compile time.  This only changes the content of the
 	rendered glyph to match the one of normal gray-level rendering,
 	hence clients should not need to be modified.
 
 	* docs/CHANGES: Updated.
 
 2006-09-18  Garrick Meeker  <garrick@digitalanarchy.com>
 
 	* src/base/ftmac.c (FT_New_Face_From_FOND): Fall back to SFNT if
 	LWFN fails and both are available.
 
 2006-09-11  David Turner  <david@freetype.org>
 
 	* src/sfnt/sfobjs.c (tt_face_get_name): Support some fonts which
 	report their English names through an Apple Roman
 	(platform,encoding) pair, with language_id != English.
 
 	If the font uses another name entry with language_id == English, it
 	will be selected correctly, though.
 
 	* src/truetype/ttobjs.c (tt_face_init): Add unpatented hinting
 	selection for `mingli.ttf'.
 
 2006-09-05  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttpload.c (tt_face_load_hdmx): Handle `record_size'
 	values which have the upper two bytes set to 0xFF instead of 0x00
 	(as it happens in at least two CJKV fonts, `HAN NOM A.ttf' and
 	`HAN NOM B.ttf').
 
 	* src/smooth/ftgrays.c [GRAYS_USE_GAMMA]: Really remove all code.
 
 2006-09-05  David Turner  <david@freetype.org>
 
 	Minor source cleanups and optimizations.
 
 	* src/smooth/ftgrays.c (GRAYS_COMPACT): Removed.
 	(TRaster): Remove `count_ex' and `count_ey'.
 	(gray_find_cell): Remove 2nd and 3rd argument.
 	(gray_alloc_cell): Merged with `gray_find_cell'.
 	(gray_record_cell): Simplify.
 	(gray_set_cell): Rewrite.
 	(gray_start_cell): Apply offsets to `ras.ex' and `ras.ey'.
 	(gray_render_span): Don't use FT_MEM_SET for small values.
 	(gray_dump_cells) [DEBUG_GRAYS]: New function.
 	(gray_sweep): Avoid buffer overwrites when to drawing the end of a
 	bitmap scanline.
 	(gray_convert_glyph): Fix speed-up.
 
 2006-09-04  David Turner  <david@freetype.org>
 
 	* src/smooth/ftgrays.c (gray_convert_glyphs): Make it work with
 	64bit processors.
 
 2006-09-03  Werner Lemberg  <wl@gnu.org>
 
 	* devel/ftoption.h: Synchronize with
 	include/freetype/config/ftoption.h.
 
 	* src/smooth/ftgrays.c (gray_record_cell): Remove shadowing
 	variable declaration.
 	(gray_convert_glyph): Fix compiler warnings.
 
 2006-09-01  David Turner  <david@freetype.org>
 
 	* src/truetype/ttobjs.c (tt_face_init): Update the TrueType loader
 	to recognize a few fonts that require the automatic unpatented
 	loader.
 
 	* src/smooth/ftgrays.c: Optmize the performance of the anti-aliased
 	rasterizer.  The speed improvement is between 15% and 25%, depending
 	on the font data.
 
 	(GRAYS_USE_GAMMA, GRAYS_COMPACT): Removed, and all associated code.
 	(TCell): Redefine.
 	(TRaster): New members `buffer', `buffer_size', `ycells', `ycount'.
 	(gray_init_cells): Updated.
 	(gray_find_cell, gray_alloc_cell): New functions.
 	(gray_record_cell): Rewritten to use `gray_find_cell' and
 	`gray_alloc_cell'.
 	(PACK, LESS_THAN, SWAP_CELLS, DEBUG_SORT, QUICK_SORT, SHELL_SORT,
 	QSORT_THRESHOLD):
 	Removed.
 	(gray_shell_sort, gray_quick_sort, gray_check_sort,
 	gray_dump_cells): Removed.
 	(gray_sweep): Rewritten.
 	(gray_convert_glyph): Rewrite code which used one of the sorting
 	functions.
 	(gray_raster_render): Updated.
 
 2006-08-29  Dr. Werner Fink  <werner@suse.de>
 
 	* configure: Make it possible to handle configure options which
 	have strings containing spaces.
 
 2006-08-27  David Turner  <david@freetype.org>
 
 	* include/freetype/config/ftoption.h (TT_USE_BYTECODE_INTERPRETER):
 	New macro, defined if either TT_CONFIG_OPTION_BYTECODE_INTERPRETER
 	or TT_CONFIG_OPTION_UNPATENTED_HINTING is defined.
 
 	* include/freetype/internal/ftcalc.h, src/base/ftcalc.c,
 	src/truetype/truetype.c, src/truetype/ttdriver.c,
 	src/truetype/ttgload.c, src/truetype/ttgload.h,
 	src/truetype/ttinterp.c, src/truetype/ttobjs.c,
 	src/truetype/ttobjs.h, src/truetype/ttpload.c, src/type42/t42drivr.c:
 	s/TT_CONFIG_OPTION_BYTECODE_INTERPRETER/TT_USE_BYTECODE_INTERPRETER/.
 
 	* include/freetype/internal/ftobjs.h (FT_Face_InternalRec): New
 	member `force_autohint'.
 
 	* src/base/ftobjs.c (FT_Load_Glyph): Use `force_autohint'.
 
 	* src/truetype/ttobjs.c (tt_face_init): Prepare code for testing
 	against a list of font names which need the bytecode interpreter.
 
 2006-08-27  Jens Claudius  <jens.claudius@yahoo.com>
 
 	Fix miscellaneous compiler warnings.
 
 	* include/freetype/internal/ftobjs.h: Close comment with `*/' to
 	avoid `/* in comment' compiler warning.
 
 	* src/base/ftdbgmem.c (ft_mem_table_get_source): Turn cast
 	`(FT_UInt32)(void*)' into `(FT_UInt32)(FT_PtrDist)(void*)' since on
 	64-bit platforms void* is larger than FT_UInt32.
 
 	* src/base/ftobjs.c (t_validator_error): Cast away
 	volatileness of argument to ft_longjmp.  Spotted by Werner
 	`Putzfrau' Lemberg.
 
 	* src/bdf/bdflib.c (bdf_load_font): Initialize local
 	variable `lineno'.
 
 	* src/gxvalid/gxvmod.c (classic_kern_validate): Mark local variable
 	`error' as volatile.
 
 2006-08-27  Werner Lemberg  <wl@gnu.org>
 
 	* builds/unix/ftconfig.in: Synchronize with main ftconfig.h.
 	Reported by Jens.
 
 2006-08-22  Jens Claudius  <jens.claudius@yahoo.com>
 
 	Fix for previous commit, which caused many compiler warnings/errors
 	about addresses of volatile objects passed as function arguments as
 	non-volatile pointers.
 
 	* include/freetype/internal/ftvalid.h: Make FT_Validator typedef a
 	pointer to a volatile object.
 
 	* src/gxvalid/gxvmod.c (gxv_load_table): Make function argument
 	`table' a pointer to a volatile object.
 
 	* src/otvalid/otvmod.c (otv_load_table): Make function argument
 	`table' a pointer to a volatile object.
 
 2006-08-18  Jens Claudius  <jens.claudius@yahoo.com>
 
 	* src/gxvalid/gxvmod.c (GXV_TABLE_DECL): Mark local variable `_sfnt'
 	as volatile since it must keep its value across a call to ft_setjmp.
 	(gxv_validate): Same for local variables `memory' and `valid'.
 	(classic_kern_validate): Same for local variables `memory',
 	`ckern', and `valid'.
 
 	* src/otvalid/otvmod.c (otv_validate): Same for function parameter
 	`face' and local variables `base', `gdef', `gpos', `gsub', `jstf',
 	and 'valid'.
 
 	* src/sfnt/ttcmap.c (tt_face_build_cmaps): Same for local variable
 	`cmap'.
 
 2006-08-16  David Turner  <david@freetype.org>
 
 	* src/cid/cidgload.c (cid_slot_load_glyph): Remove compiler
 	warnings.
 
 	* src/base/ftobjs.c (ft_validator_run): Disable function; it is
 	buggy by design.  Always return -1.
 
 
 	Improvements to native TrueType hinting.  This is a first try,
 	controlled by the FIX_BYTECODE macro in src/truetype/ttinterp.c.
 
 	* include/freetype/internal/ftgloadr.h (FT_GlyphLoadRec): Add member
 	`extra_points2'.
 
 	* include/freetype/internal/tttypes.h (TT_GlyphZoneRec): Add member
 	`orus'.
 
 	* src/base/ftgloadr.c (FT_GlyphLoader_Reset,
 	FT_GlyphLoader_Adjust_Points, FT_GlyphLoader_CreateExtra,
 	FT_GlyphLoader_CheckPoints, FT_GlyphLoader_CopyPoints): Updated to
 	handle `extra_points2'.
 
 	* src/truetype/ttgload.c (tt_prepare_zone): Handle `orus'.
 	Remove compiler warning.
 	(cur_to_arg): Remove macro.
 	(TT_Hint_Glyph): Updated.
 	(TT_Process_Simple_Glyph): Handle `orus'.
 
 	* src/truetype/ttinterp.c (FIX_BYTECODE): New macro.
 	(Ins_MD, Ins_MDRP, Ins_IP) [FIX_BYTECODE]: Handle `orus'.
 	(LOC_Ins_IUP): Renamed to...
 	(IUP_WorkerRec): This.
 	Add `orus' member.
 	(Shift): Renamed to...
 	(_iup_worker_shift): This.
 	Updated.
 	(Interp): Renamed to...
 	(_iup_worker_interpolate): This.
 	Updated to handle `orus'.
 	(Ins_IUP): Updated.
 
 	* src/truetype/ttobjs.c (tt_glyphzone_done, tt_glyphzone_new):
 	Handle `orus'.
 
 2006-08-15  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* modules.cfg (BASE_EXTENSIONS): Compile in ftgxval.c by default to
 	build ftvalid in ft2demos.  This has been inadvertedly changed
 	2006-08-13.
 
 2006-08-15  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	`ft_validator_run' wrapping `setjmp' can cause a crash, as found by
 	Jens:
 	http://lists.gnu.org/archive/html/freetype-devel/2006-08/msg00004.htm.
 
 	* src/otvalid/otvmod.c: Replace `ft_validator_run' by `ft_setjmp'.
 	It reverts the change introduced on 2005-08-20.
 
 	* src/gxvalid/gxvmod.c: Ditto.
 
 2006-08-13  Jens Claudius  <jens.claudius@yahoo.com>
 
 	* finclude/freetype/internal/psaux.h: (T1_TokenType): Add
 	T1_TOKEN_TYPE_KEY.
 	(T1_FieldRec): Add `dict'.
 	(T1_FIELD_DICT_FONTDICT, T1_FIELD_DICT_PRIVATE): New macros.
 	(T1_NEW_XXX, T1_FIELD_XXX): Update to take the dictionary where a PS
 	keyword is expected as an additional argument.
 
 	* src/cid/cidload.c: (cid_field_records): Adjust invocations of
 	T1_FIELD_XXX.
 
 	* src/cid/cidtoken.h: Adjust invocations of T1_FIELD_XXX.
 
 	* src/psaux/psobjs.c: Add macro FT_COMPONENT for tracing.
 	(ps_parser_to_token): Report a PostScript key as T1_TOKEN_TYPE_KEY,
 	not T1_TOKEN_TYPE_ANY.
 	(ps_parser_load_field): Make sure a token that should be a string or
 	name is really a string or name.
 	Avoid memory leak if a keyword has been already encountered and its
 	value is overwritten.
 	* src/type1/t1load.c: (t1_keywords): Adjust invocations of
 	T1_FIELD_XXX.
 	(parse_dict): Ignore keywords that occur in the wrong dictionary
 	(e.g., in `Private' instead of `FontDict').
 
 	* src/type1/t1tokens.h: Adjust invocations of T1_FIELD_XXX.
 
 	* src/type42/t42parse.c: (t42_keywords): Adjust invocations of
 	T1_FIELD_XXX.
 
 2006-07-18  Jens Claudius  <jens.claudius@yahoo.com>
 
 	Move creation of field `buildchar' of T1_DecoderRec out of
 	`t1_decoder_init' and let the caller of `t1_decoder_init' take care
 	of it.
 
 	Call the finisher for T1_Decoder in `cid_face_compute_max_advance'
 	and `T1_Compute_Max_Advance'.
 
 	* include/freetype/internal/psaux.h (T1_DecoderRec): Remove field
 	`face', add `len_buildchar'.
 
 	* include/freetype/internal/t1types.h (T1_FaceRec): Add field
 	`buildchar'.
 
 	* src/cid/cidgload.c (cid_face_compute_max_advance): Call finisher
 	for T1_Decoder.
 	(cid_slot_load_glyph): Do not ignore failure when initializing the
 	T1_Decoder.
 
 	* src/psaux/t1decode.c (t1_decoder_parse_charstrings): Updated.
 	(t1_decoder_init): Remove initialization of fields `buildchar' and
 	`len_buildchar'.
 	(t1_decoder_done): Remove deallocation of field `buildchar'.
 
 	* freetype/src/type1/t1gload.c (T1_Compute_Max_Advance): Initialize
 	T1_Decoder's `buildchar' and `len_buildchar'; call finisher for
 	T1_Decoder.
 	(T1_Load_Glyph): Initialize T1_Decoder's `buildchar' and
 	`len_buildchar'; make sure to call finisher for T1_Decoder even in
 	case of error.
 
 	* src/type1/t1load.c (T1_Open_Face): Allocate new field `buildchar'
 	of T1_FaceRec.
 
 	* src/type1/t1objs.c (T1_Face_Done): Free new field `buildchar' of
 	T1_FaceRec.
 
 2006-07-14  Jens Claudius  <jens.claudius@yahoo.com>
 
 	* include/freetype/internal/psaux.h: New macros IS_PS_NEWLINE,
 	IS_PS_SPACE, IS_PS_SPECIAL, IS_PS_DELIM, IS_PS_DIGIT, IS_PS_XDIGIT,
 	and IS_PS_BASE85 (from src/psaux/psconv.h).
 	(T1_FieldLocation): Add T1_FIELD_LOCATION_LOADER,
 	T1_FIELD_LOCATION_FACE, and T1_FIELD_LOCATION_BLEND.
 	(T1_DecoderRec): New fields `buildchar' and `face'.
 	(IS_PS_TOKEN): New macro.
 
 	* include/freetype/internal/t1types.h (T1_FaceRec): New fields
 	`ndv_idx', `cdv_idx', and `len_buildchar'.
 
 	* include/freetype/t1tables.h (PS_BlendRec): New fields
 	`default_design_vector' and `num_default_design_vector'.
 
 	* src/psaux/psconv.h: Move macros IS_PS_NEWLINE, IS_PS_SPACE,
 	IS_PS_SPECIAL, IS_PS_DELIM, IS_PS_DIGIT, IS_PS_XDIGIT, and
 	IS_PS_BASE85 to include/freetype/internal/psaux.h.
 
 	* src/psaux/psobjs.c (ps_parser_to_token_array): Allow `token'
 	argument to be NULL if we want only to count the number of tokens.
 	(ps_tocoordarray): Allow `coords' argument to be NULL if we just
 	want to skip the array.
 	(ps_tofixedarray): Allow `values' argument to be NULL if we just
 	want to skip the array.
 
 	* src/psaux/t1decode.c (t1_decoder_parse_charstrings): Add support
 	for (partially commented out) othersubrs 19-25, 27, and 28.
 	(t1_decoder_init): Initialize new fields `face' and `buildchar'.
 	(t1_decoder_done): Release new field `buildchar'.
 
 	* src/type1/t1load.c (parse_buildchar, parse_private): New
 	functions.
 	(t1_keywords): Register them.
 	(t1_allocate_blend): Updated.
 	(t1_load_keyword): Handle field types T1_FIELD_LOCATION_LOADER,
 	T1_FIELD_LOCATION_FACE and T1_FIELD_LOCATION_BLEND.
 	(parse_dict): Remove `keyword_flags' argument.
 	Use new macro IS_PS_TOKEN.
 	Changed function so that later PostScript definitions override
 	earlier ones.
 	(t1_init_loader): Initialize new field `keywords_encountered'.
 	(T1_Open_Face): Initialize new fields `ndv_idx', `cdv_idx', and
 	`len_buildchar'.
 	Remove `keywords_flags'.
 
 	* src/type1/t1load.h (T1_LoaderRect): New field
 	`keywords_encountered'.
 	(T1_PRIVATE, T1_FONTDIR_AFTER_PRIVATE): New macros.
 
 	* src/type1/t1tokens.h [!T1_CONFIG_OPTION_NO_MM_SUPPORT]: New
 	entries for parsing /NDV, /CDV, and /DesignVector.
 
 2006-07-07  Werner Lemberg  <wl@gnu.org>
 
 	Add many checks to protect against malformed PCF files.
 
 	* src/pcf/pcfdrivr.c (PCF_Face_Done): Protect against NULL pointers.
 	(PCF_Face_Init): Add calls to PCF_Face_Done in case of errors.
 
 	* src/pcf/pcfread.c (pcf_read_TOC): Protect against malformed table
 	data and check that tables don't overlap (using a simple
 	bubblesort).
 	(PCF_METRIC_SIZE, PCF_COMPRESSED_METRIC_SIZE, PCF_PROPERTY_SIZE):
 	New macros which give the size of data structures in the data
 	stream.
 	(pcf_get_properties): Use rough estimates to get array size limits.
 	Assign `face->nprops' and `face->properties' earlier so that a call
 	to PCF_Face_Done can do the clean-up in case of error.
 	Protect against invalid string offsets.
 	(pcf_get_metrics): Clean up code.
 	Adjust tracing message levels.
 	Use rough estimate to get array size limit.
 	(pcf_get_bitmaps): Clean up code.
 	Adjust tracing message levels.
 	Use rough estimates to get offset limits.
 	(pcf_get_encodings): Adjust tracing message level.
 	(pcf_get_accel): Clean up code.
 
 2006-06-26  Werner Lemberg  <wl@gnu.org>
 
 	* src/bdf/bdfdrivr.c (BDF_Face_Init): Handle fonts correctly which
 	don't have a POINT_SIZE property.  This fixes Savannah bug #16914.
 
 2006-06-26  Jens Claudius  <jens.claudius@yahoo.com>
 
 	* src/psaux/t1decode.c (T1_Operator, t1_args_count): Add opcode 15.
 	(t1_decoder_parse_charstrings): Operator with
 	opcode 15 pops its two arguments.
 	Handle the case where the pops of an othersubr may be part of a
 	subroutine.
 	Handle unknown othersubrs gracefully: count their operands and let
 	the following pop operators push the operands as the results onto
 	the Type1 stack.
 	Improve handling of setcurrentpoint opcode.
 
 2006-06-25  Jens Claudius  <jens.claudius@yahoo.com>
 
 	The Type 1 parser now skips over top-level procedures as required
 	for a `Simplified Parser'.  This makes the parser more robust as it
 	doesn't poke around in PostScript code.  Additionally, it makes the
 	FontDirectory hackery in src/type1/t1load.c unnecessary.
 
 	* src/psaux/psobjs.c (IS_OCTAL_DIGIT): New macro.
 	(skip_literal_string): Add FT_Error as return value.
 	Handle escapes better.
 	(skip_string): Add FT_Error as return value.
 	Don't set `parser->error' but return error code directly.
 	(skip_procedure): New function.
 	(ps_parser_skip_PS_token): Handle procedures.
 	Update code.
 	(ps_parser_to_token): Update code.
 	(ps_parser_load_field_table): Handle bbox entries also.
 
 	* src/type1/t1load.c (parse_dict): Remove FontDirectory hackery.
 	Add commented-out code for synthetic fonts.
 
 2006-06-24  Eugeniy Meshcheryakov  <eugen@univ.kiev.ua>
 
 	Fix two hinting bugs as reported in
 	http://lists.gnu.org/archive/html/freetype-devel/2006-06/msg00057.html.
 
 	* include/freetype/internal/tttypes.h (TT_GlyphZoneRec): Add
 	`first_point' member.
 
 	* src/truetype/ttgload.c (tt_prepare_zone): Initialize
 	`first_point'.
 	(TT_Process_Composite_Glyph): Always untouch points.
 
 	* src/truetype/ttinterp.c (Ins_SHC): Fix computation of
 	`first_point' and `last_point' in case of composite glyphs.
 	(Ins_IUP): Fix computation of `end_point'.
 
 2006-06-22  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Insert EndianS16_BtoN and EndianS32_BtoN as workaround for Intel
 	Mac.  The original patch was written by David Sachitano and Lawrence
 	Coopet, and modified by Sean McBride for MPW compatibility.  Only
 	required data are converted; unused data are left in big endian.
 
 	* src/base/ftmac.c: Include <Endian.h> for byteorder macros for non
 	Mac OS X platforms.
 	(OS_INLINE): Undefine before definition.
 	(count_faces_sfnt): Insert EndianS16_BtoN to parse the header of
 	FontAssociation table in FOND resource.
 	(count_faces_scalable): Insert EndianS16_BtoN to parse the header
 	and fontSize at each entry of FontAssociation table in FOND
 	resource.
 	(parse_fond): Insert EndianS16_BtoN and EndianS32_BtoN to parse
 	ffStylOff of FamilyRecord header of FOND resource, the header,
 	fontSize, fontID at each entry of FontAssociation table, and
 	StyleMapping table.
 	(count_faces): Call `HUnlock' after all FOND utilization.
 
 2006-06-08  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Public API of TrueTypeGX, OpenType, and classic kern table validator
 	should return `FT_Err_Unimplemented_Feature' if validation service
 	is unavailable (disabled in `modules.cfg').  It is originally
 	suggested by David Turner, cf.
 	http://lists.gnu.org/archive/html/freetype-devel/2005-11/msg00078.html
 
 	* src/base/ftgxval.c (FT_TrueTypeGX_Validate): Return
 	FT_Err_Unimplemented_Feature if TrueTypeGX validation service is
 	unavailable.
 	(FT_ClassicKern_Validate): Return FT_Err_Unimplemented_Feature if
 	classic kern table validation service is unavailable.
 
 	* src/base/ftotval.c (FT_OpenType_Validate): Return
 	FT_Err_Unimplemented_Feature if OpenType validation service is
 	unavailable.
 
 2006-06-08  Werner Lemberg  <wl@gnu.org>
 
 	* src/bdf/bdflib.c (bdf_load_font): Fix memory leaks in case of
 	errors.
 
 2006-06-07  David Turner  <david@freetype.org>
 
 	* src/type1/t1afm.c (KERN_INDEX): Make it more robust.
 	(T1_Read_Metrics): Fix memory leak which happened when the metrics
 	file doesn't have kerning pairs.  This fixes Savannah bug #16768.
 
 2006-06-06  David Turner  <david@freetype.org>
 
 	Fix memory leak described in Savannah bug #16759.
 
 	We change `ps_unicodes_init' so that it also takes a
 	`free_glyph_name' callback to release the glyph names returned by
 	`get_glyph_name'
 
 	* include/freetype/internal/services/svpscmap.h (PS_Glyph_NameFunc):
 	Renamed to ...
 	(PS_GetGlyphNameFunc): This.
 	(PS_FreeGlyphNameFunc): New typedef.
 	(PS_Unicodes_InitFunc): Add variable for PS_FreeGlyphNameFunc.
 
 	* src/cff/cffcmap.c (cff_sid_to_glyph_name): Use `TT_Face' for first
 	argument.
 	(cff_sid_free_glyph_name): New function.
 	(cff_cmap_unicode_init): Updated.
 
 	* src/psaux/t1cmap.c (t1_cmap_unicode_init): Updated.
 
 	* src/psnames/psmodule.c (ps_unicodes_init): Add variable for
 	PS_FreeGlyphNameFunc and use it.
 
 
 2006-06-04  David Turner  <david@freetype.org>
 
 	* src/base/ftutil.c (ft_mem_qrealloc): Fix the function to accept
 	`item_size == 0' as well -- though this sounds weird, it can
 	theoretically happen.  This fixes Savannah bug #16669.
 
 	* src/pfr/pfrobjs.c (pfr_face_init): Fix the computation
 	of `face->num_glyphs' which missed the last glyph, due to
 	the offset-by-1 computation, since the PFR format doesn't
 	guarantee that glyph index 0 corresponds to the `missing
 	glyph.  This fixes Savannah bug #16668.
 
 2006-05-25  Werner Lemberg  <wl@gnu.org>
 
 	* builds/unix/unix-cc.in (LINK_LIBRARY): Don't comment out
 	`-no-undefined'.  Reported by Christian Biesinger.
 
 2006-05-19  Brian Weed  <bw@imaginengine.com>
 
 	* builds/win32/visualc/freetype.dsp: Release libraries no longer
 	have debug information, and debug libraries use `C7 compatible'
 	debug info.
 
 2006-05-19  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Apply patch by Derek Clegg to fix two memory leaks in the MacOS
 	resource fork handler.  This fixes Savannah bug #16631.
 
 	* src/base/ftobjs.c (load_face_in_embedded_rfork): Replace
 	`FT_Stream_Close' by `FT_Stream_Free' to fix memory leak.
 
 	* src/base/ftrfrk.c (raccess_guess_linux_double_from_file_name):
 	Replace `FT_Stream_Close' by `FT_Stream_Free' to fix memory leak.
 
 2006-05-19  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* build/unix/configure.raw: Add a fallback to disable Carbon
 	dependency, if configured with no options on Mac OS X.
 
 2006-05-19  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/base/ftmac.c (open_face_from_buffer): Deallocate stream when
 	its content cannot be parsed as supported font.  This fixes
 	the second part of Savannah bug #16590.
 
 2006-05-18  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgload.c (TT_Load_Composite_Glyph)
 	[FT_CONFIG_OPTION_BYTECODE_INTERPRETER]: Make it compilable again.
 
 2006-05-17  David Turner  <david@freetype.org>
 
 	This is a major patch used to drastically improve the performance of
 	loading glyphs.  This both speeds up loading the glyph vectors
 	themselves and the auto-fitter module.
 
 	We now use inline assembler code with GCC to implement `FT_MulFix',
 	which is probably the most important function related to the
 	engine's performance.
 
 	The resulting speed-up is about 25%.
 
 
 	* include/freetype/internal/tttypes.h (TT_LoaderRec): Add fields
 	`cursor' and `limit'.
 
 	* src/autofit/afangles.c (af_corner_is_flat, af_corner_orientation):
 	New functions.
 	(AF_ATAN_BITS, af_arctan, af_angle_atan): Comment out.
 	[TEST]: Remove.
 
 	* src/autofit/afcjk.c (AF_Script_UniRangeRec): Comment out test
 	code.
 
 	* src/autofit/afhints.c (af_axis_hints_new_segment): Don't call
 	`FT_ZERO'
 	(af_direction_compute, af_glyph_hints_compute_inflections): Rewritten.
 	(af_glyph_hints_reload: Rewrite recognition of weak points.
 
 	* src/autofit/aflatin.c (af_latin_hints_compute_segments): Move
 	constant values out of the loops.
 
 	* src/autofit/aftypes.h: Updated.
 
 	* src/base/ftcalc.c (FT_MulFix): Use inline assembler code.
 
 	* src/base/ftoutln.c (FT_Outline_Get_Orientation): Use vector
 	product to get orientation.
 
 	* src/gzip/ftgzip.c (ft_get_uncompressed_size): New function.
 	(FT_Stream_OpenGzip): Use it to handle small files directly in
 	memory.
 
 	* src/psaux/psconv.c (PS_Conv_ASCIIHexDecode, PS_ConvEexecDecode):
 	Improve performance.
 
 	* src/truetype/ttgload.c (TT_Access_Glyph_Frame): Set `cursor' and
 	`limit'.
 
 	(TT_Load_Glyph_Header, TT_Load_Simple_Glyph,
 	TT_Load_Composite_Glyph): Updated.  Add threshold to protect against
 	exceedingly large values of number of contours.  Speed up by
 	reducing the number of loops.
 
 	* src/type1/t1gload.c (T1_Load_Glyph): Don't apply unit matrix.
 
 
 	* src/cache/ftccmap.c (FTC_CMapCache_Lookup): Change the threshold
 	used to detect rogue clients from 4 to 16.  This is to prevent some
 	segmentation faults with fonts like `KozMinProVI-Regular.otf' which
 	comes from the Japanese Adobe Reader Asian Font pack.
 
 2007-05-17  Werner Lemberg  <wl@gnu.org>
 
 	* src/cff/cffload.c (cff_font_done): Deallocate subfont array.  This
 	fixes the first part of Savannah bug #16590.
 
 2006-05-16  Werner Lemberg  <wl@gnu.org>
 
 	* docs/PROBLEMS: Updated icl issues.
 
 ----------------------------------------------------------------------------
 
diff --git a/src/truetype/ttinterp.c b/src/truetype/ttinterp.c
index f729eaf..3e108f4 100644
--- a/src/truetype/ttinterp.c
+++ b/src/truetype/ttinterp.c
@@ -1,8137 +1,8137 @@
 /***************************************************************************/
 /*                                                                         */
 /*  ttinterp.c                                                             */
 /*                                                                         */
 /*    TrueType bytecode interpreter (body).                                */
 /*                                                                         */
 /*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,   */
 /*            2010                                                         */
 /*  by David Turner, Robert Wilhelm, and Werner Lemberg.                   */
 /*                                                                         */
 /*  This file is part of the FreeType project, and may only be used,       */
 /*  modified, and distributed under the terms of the FreeType project      */
 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
 /*  this file you indicate that you have read the license and              */
 /*  understand and accept it fully.                                        */
 /*                                                                         */
 /***************************************************************************/
 
 
 #include <ft2build.h>
 #include FT_INTERNAL_DEBUG_H
 #include FT_INTERNAL_CALC_H
 #include FT_TRIGONOMETRY_H
 #include FT_SYSTEM_H
 
 #include "ttinterp.h"
 
 #include "tterrors.h"
 
 
 #ifdef TT_USE_BYTECODE_INTERPRETER
 
 
 #define TT_MULFIX           FT_MulFix
 #define TT_MULDIV           FT_MulDiv
 #define TT_MULDIV_NO_ROUND  FT_MulDiv_No_Round
 
 
   /*************************************************************************/
   /*                                                                       */
   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
   /* messages during execution.                                            */
   /*                                                                       */
 #undef  FT_COMPONENT
 #define FT_COMPONENT  trace_ttinterp
 
   /*************************************************************************/
   /*                                                                       */
   /* In order to detect infinite loops in the code, we set up a counter    */
   /* within the run loop.  A single stroke of interpretation is now        */
   /* limited to a maximal number of opcodes defined below.                 */
   /*                                                                       */
 #define MAX_RUNNABLE_OPCODES  1000000L
 
 
   /*************************************************************************/
   /*                                                                       */
   /* There are two kinds of implementations:                               */
   /*                                                                       */
   /* a. static implementation                                              */
   /*                                                                       */
   /*    The current execution context is a static variable, which fields   */
   /*    are accessed directly by the interpreter during execution.  The    */
   /*    context is named `cur'.                                            */
   /*                                                                       */
   /*    This version is non-reentrant, of course.                          */
   /*                                                                       */
   /* b. indirect implementation                                            */
   /*                                                                       */
   /*    The current execution context is passed to _each_ function as its  */
   /*    first argument, and each field is thus accessed indirectly.        */
   /*                                                                       */
   /*    This version is fully re-entrant.                                  */
   /*                                                                       */
   /* The idea is that an indirect implementation may be slower to execute  */
   /* on low-end processors that are used in some systems (like 386s or     */
   /* even 486s).                                                           */
   /*                                                                       */
   /* As a consequence, the indirect implementation is now the default, as  */
   /* its performance costs can be considered negligible in our context.    */
   /* Note, however, that we kept the same source with macros because:      */
   /*                                                                       */
   /* - The code is kept very close in design to the Pascal code used for   */
   /*   development.                                                        */
   /*                                                                       */
   /* - It's much more readable that way!                                   */
   /*                                                                       */
   /* - It's still open to experimentation and tuning.                      */
   /*                                                                       */
   /*************************************************************************/
 
 
 #ifndef TT_CONFIG_OPTION_STATIC_INTERPRETER     /* indirect implementation */
 
 #define CUR  (*exc)                             /* see ttobjs.h */
 
   /*************************************************************************/
   /*                                                                       */
   /* This macro is used whenever `exec' is unused in a function, to avoid  */
   /* stupid warnings from pedantic compilers.                              */
   /*                                                                       */
 #define FT_UNUSED_EXEC  FT_UNUSED( exc )
 
 #else                                           /* static implementation */
 
 #define CUR  cur
 
 #define FT_UNUSED_EXEC  int  __dummy = __dummy
 
   static
   TT_ExecContextRec  cur;   /* static exec. context variable */
 
   /* apparently, we have a _lot_ of direct indexing when accessing  */
   /* the static `cur', which makes the code bigger (due to all the  */
   /* four bytes addresses).                                         */
 
 #endif /* TT_CONFIG_OPTION_STATIC_INTERPRETER */
 
 
   /*************************************************************************/
   /*                                                                       */
   /* The instruction argument stack.                                       */
   /*                                                                       */
 #define INS_ARG  EXEC_OP_ FT_Long*  args    /* see ttobjs.h for EXEC_OP_ */
 
 
   /*************************************************************************/
   /*                                                                       */
   /* This macro is used whenever `args' is unused in a function, to avoid  */
   /* stupid warnings from pedantic compilers.                              */
   /*                                                                       */
 #define FT_UNUSED_ARG  FT_UNUSED_EXEC; FT_UNUSED( args )
 
 
   /*************************************************************************/
   /*                                                                       */
   /* The following macros hide the use of EXEC_ARG and EXEC_ARG_ to        */
   /* increase readability of the code.                                     */
   /*                                                                       */
   /*************************************************************************/
 
 
 #define SKIP_Code() \
           SkipCode( EXEC_ARG )
 
 #define GET_ShortIns() \
           GetShortIns( EXEC_ARG )
 
 #define NORMalize( x, y, v ) \
           Normalize( EXEC_ARG_ x, y, v )
 
 #define SET_SuperRound( scale, flags ) \
           SetSuperRound( EXEC_ARG_ scale, flags )
 
 #define ROUND_None( d, c ) \
           Round_None( EXEC_ARG_ d, c )
 
 #define INS_Goto_CodeRange( range, ip ) \
           Ins_Goto_CodeRange( EXEC_ARG_ range, ip )
 
 #define CUR_Func_move( z, p, d ) \
           CUR.func_move( EXEC_ARG_ z, p, d )
 
 #define CUR_Func_move_orig( z, p, d ) \
           CUR.func_move_orig( EXEC_ARG_ z, p, d )
 
 #define CUR_Func_round( d, c ) \
           CUR.func_round( EXEC_ARG_ d, c )
 
 #define CUR_Func_read_cvt( index ) \
           CUR.func_read_cvt( EXEC_ARG_ index )
 
 #define CUR_Func_write_cvt( index, val ) \
           CUR.func_write_cvt( EXEC_ARG_ index, val )
 
 #define CUR_Func_move_cvt( index, val ) \
           CUR.func_move_cvt( EXEC_ARG_ index, val )
 
 #define CURRENT_Ratio() \
           Current_Ratio( EXEC_ARG )
 
 #define CURRENT_Ppem() \
           Current_Ppem( EXEC_ARG )
 
 #define CUR_Ppem() \
           Cur_PPEM( EXEC_ARG )
 
 #define INS_SxVTL( a, b, c, d ) \
           Ins_SxVTL( EXEC_ARG_ a, b, c, d )
 
 #define COMPUTE_Funcs() \
           Compute_Funcs( EXEC_ARG )
 
 #define COMPUTE_Round( a ) \
           Compute_Round( EXEC_ARG_ a )
 
 #define COMPUTE_Point_Displacement( a, b, c, d ) \
           Compute_Point_Displacement( EXEC_ARG_ a, b, c, d )
 
 #define MOVE_Zp2_Point( a, b, c, t ) \
           Move_Zp2_Point( EXEC_ARG_ a, b, c, t )
 
 
 #define CUR_Func_project( v1, v2 )  \
           CUR.func_project( EXEC_ARG_ (v1)->x - (v2)->x, (v1)->y - (v2)->y )
 
 #define CUR_Func_dualproj( v1, v2 )  \
           CUR.func_dualproj( EXEC_ARG_ (v1)->x - (v2)->x, (v1)->y - (v2)->y )
 
 #define CUR_fast_project( v ) \
           CUR.func_project( EXEC_ARG_ (v)->x, (v)->y )
 
 #define CUR_fast_dualproj( v ) \
           CUR.func_dualproj( EXEC_ARG_ (v)->x, (v)->y )
 
 
   /*************************************************************************/
   /*                                                                       */
   /* Instruction dispatch function, as used by the interpreter.            */
   /*                                                                       */
   typedef void  (*TInstruction_Function)( INS_ARG );
 
 
   /*************************************************************************/
   /*                                                                       */
   /* A simple bounds-checking macro.                                       */
   /*                                                                       */
 #define BOUNDS( x, n )  ( (FT_UInt)(x) >= (FT_UInt)(n) )
 
 #undef  SUCCESS
 #define SUCCESS  0
 
 #undef  FAILURE
 #define FAILURE  1
 
 #ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
 #define GUESS_VECTOR( V )                                         \
   if ( CUR.face->unpatented_hinting )                             \
   {                                                               \
     CUR.GS.V.x = (FT_F2Dot14)( CUR.GS.both_x_axis ? 0x4000 : 0 ); \
     CUR.GS.V.y = (FT_F2Dot14)( CUR.GS.both_x_axis ? 0 : 0x4000 ); \
   }
 #else
 #define GUESS_VECTOR( V )
 #endif
 
   /*************************************************************************/
   /*                                                                       */
   /*                        CODERANGE FUNCTIONS                            */
   /*                                                                       */
   /*************************************************************************/
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    TT_Goto_CodeRange                                                  */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Switches to a new code range (updates the code related elements in */
   /*    `exec', and `IP').                                                 */
   /*                                                                       */
   /* <Input>                                                               */
   /*    range :: The new execution code range.                             */
   /*                                                                       */
   /*    IP    :: The new IP in the new code range.                         */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    exec  :: The target execution context.                             */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   TT_Goto_CodeRange( TT_ExecContext  exec,
                      FT_Int          range,
                      FT_Long         IP )
   {
     TT_CodeRange*  coderange;
 
 
     FT_ASSERT( range >= 1 && range <= 3 );
 
     coderange = &exec->codeRangeTable[range - 1];
 
     FT_ASSERT( coderange->base != NULL );
 
     /* NOTE: Because the last instruction of a program may be a CALL */
     /*       which will return to the first byte *after* the code    */
     /*       range, we test for IP <= Size instead of IP < Size.     */
     /*                                                               */
     FT_ASSERT( (FT_ULong)IP <= coderange->size );
 
     exec->code     = coderange->base;
     exec->codeSize = coderange->size;
     exec->IP       = IP;
     exec->curRange = range;
 
     return TT_Err_Ok;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    TT_Set_CodeRange                                                   */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Sets a code range.                                                 */
   /*                                                                       */
   /* <Input>                                                               */
   /*    range  :: The code range index.                                    */
   /*                                                                       */
   /*    base   :: The new code base.                                       */
   /*                                                                       */
   /*    length :: The range size in bytes.                                 */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    exec   :: The target execution context.                            */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   TT_Set_CodeRange( TT_ExecContext  exec,
                     FT_Int          range,
                     void*           base,
                     FT_Long         length )
   {
     FT_ASSERT( range >= 1 && range <= 3 );
 
     exec->codeRangeTable[range - 1].base = (FT_Byte*)base;
     exec->codeRangeTable[range - 1].size = length;
 
     return TT_Err_Ok;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    TT_Clear_CodeRange                                                 */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Clears a code range.                                               */
   /*                                                                       */
   /* <Input>                                                               */
   /*    range :: The code range index.                                     */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    exec  :: The target execution context.                             */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   /* <Note>                                                                */
   /*    Does not set the Error variable.                                   */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   TT_Clear_CodeRange( TT_ExecContext  exec,
                       FT_Int          range )
   {
     FT_ASSERT( range >= 1 && range <= 3 );
 
     exec->codeRangeTable[range - 1].base = NULL;
     exec->codeRangeTable[range - 1].size = 0;
 
     return TT_Err_Ok;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /*                   EXECUTION CONTEXT ROUTINES                          */
   /*                                                                       */
   /*************************************************************************/
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    TT_Done_Context                                                    */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Destroys a given context.                                          */
   /*                                                                       */
   /* <Input>                                                               */
   /*    exec   :: A handle to the target execution context.                */
   /*                                                                       */
   /*    memory :: A handle to the parent memory object.                    */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   /* <Note>                                                                */
   /*    Only the glyph loader and debugger should call this function.      */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   TT_Done_Context( TT_ExecContext  exec )
   {
     FT_Memory  memory = exec->memory;
 
 
     /* points zone */
     exec->maxPoints   = 0;
     exec->maxContours = 0;
 
     /* free stack */
     FT_FREE( exec->stack );
     exec->stackSize = 0;
 
     /* free call stack */
     FT_FREE( exec->callStack );
     exec->callSize = 0;
     exec->callTop  = 0;
 
     /* free glyph code range */
     FT_FREE( exec->glyphIns );
     exec->glyphSize = 0;
 
     exec->size = NULL;
     exec->face = NULL;
 
     FT_FREE( exec );
 
     return TT_Err_Ok;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    Init_Context                                                       */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Initializes a context object.                                      */
   /*                                                                       */
   /* <Input>                                                               */
   /*    memory :: A handle to the parent memory object.                    */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    exec   :: A handle to the target execution context.                */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   static FT_Error
   Init_Context( TT_ExecContext  exec,
                 FT_Memory       memory )
   {
     FT_Error  error;
 
 
     FT_TRACE1(( "Init_Context: new object at 0x%08p\n", exec ));
 
     exec->memory   = memory;
     exec->callSize = 32;
 
     if ( FT_NEW_ARRAY( exec->callStack, exec->callSize ) )
       goto Fail_Memory;
 
     /* all values in the context are set to 0 already, but this is */
     /* here as a remainder                                         */
     exec->maxPoints   = 0;
     exec->maxContours = 0;
 
     exec->stackSize = 0;
     exec->glyphSize = 0;
 
     exec->stack     = NULL;
     exec->glyphIns  = NULL;
 
     exec->face = NULL;
     exec->size = NULL;
 
     return TT_Err_Ok;
 
   Fail_Memory:
     FT_ERROR(( "Init_Context: not enough memory for 0x%08lx\n",
                (FT_Long)exec ));
     TT_Done_Context( exec );
 
     return error;
  }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    Update_Max                                                         */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Checks the size of a buffer and reallocates it if necessary.       */
   /*                                                                       */
   /* <Input>                                                               */
   /*    memory     :: A handle to the parent memory object.                */
   /*                                                                       */
   /*    multiplier :: The size in bytes of each element in the buffer.     */
   /*                                                                       */
   /*    new_max    :: The new capacity (size) of the buffer.               */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    size       :: The address of the buffer's current size expressed   */
   /*                  in elements.                                         */
   /*                                                                       */
   /*    buff       :: The address of the buffer base pointer.              */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   Update_Max( FT_Memory  memory,
               FT_ULong*  size,
               FT_Long    multiplier,
               void*      _pbuff,
               FT_ULong   new_max )
   {
     FT_Error  error;
     void**    pbuff = (void**)_pbuff;
 
 
     if ( *size < new_max )
     {
       if ( FT_REALLOC( *pbuff, *size * multiplier, new_max * multiplier ) )
         return error;
       *size = new_max;
     }
 
     return TT_Err_Ok;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    TT_Load_Context                                                    */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Prepare an execution context for glyph hinting.                    */
   /*                                                                       */
   /* <Input>                                                               */
   /*    face :: A handle to the source face object.                        */
   /*                                                                       */
   /*    size :: A handle to the source size object.                        */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    exec :: A handle to the target execution context.                  */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   /* <Note>                                                                */
   /*    Only the glyph loader and debugger should call this function.      */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   TT_Load_Context( TT_ExecContext  exec,
                    TT_Face         face,
                    TT_Size         size )
   {
     FT_Int          i;
     FT_ULong        tmp;
     TT_MaxProfile*  maxp;
     FT_Error        error;
 
 
     exec->face = face;
     maxp       = &face->max_profile;
     exec->size = size;
 
     if ( size )
     {
       exec->numFDefs   = size->num_function_defs;
       exec->maxFDefs   = size->max_function_defs;
       exec->numIDefs   = size->num_instruction_defs;
       exec->maxIDefs   = size->max_instruction_defs;
       exec->FDefs      = size->function_defs;
       exec->IDefs      = size->instruction_defs;
       exec->tt_metrics = size->ttmetrics;
       exec->metrics    = size->metrics;
 
       exec->maxFunc    = size->max_func;
       exec->maxIns     = size->max_ins;
 
       for ( i = 0; i < TT_MAX_CODE_RANGES; i++ )
         exec->codeRangeTable[i] = size->codeRangeTable[i];
 
       /* set graphics state */
       exec->GS = size->GS;
 
       exec->cvtSize = size->cvt_size;
       exec->cvt     = size->cvt;
 
       exec->storeSize = size->storage_size;
       exec->storage   = size->storage;
 
       exec->twilight  = size->twilight;
     }
 
     /* XXX: We reserve a little more elements on the stack to deal safely */
     /*      with broken fonts like arialbs, courbs, timesbs, etc.         */
     tmp = exec->stackSize;
     error = Update_Max( exec->memory,
                         &tmp,
                         sizeof ( FT_F26Dot6 ),
                         (void*)&exec->stack,
                         maxp->maxStackElements + 32 );
     exec->stackSize = (FT_UInt)tmp;
     if ( error )
       return error;
 
     tmp = exec->glyphSize;
     error = Update_Max( exec->memory,
                         &tmp,
                         sizeof ( FT_Byte ),
                         (void*)&exec->glyphIns,
                         maxp->maxSizeOfInstructions );
     exec->glyphSize = (FT_UShort)tmp;
     if ( error )
       return error;
 
     exec->pts.n_points   = 0;
     exec->pts.n_contours = 0;
 
     exec->zp1 = exec->pts;
     exec->zp2 = exec->pts;
     exec->zp0 = exec->pts;
 
     exec->instruction_trap = FALSE;
 
     return TT_Err_Ok;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    TT_Save_Context                                                    */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Saves the code ranges in a `size' object.                          */
   /*                                                                       */
   /* <Input>                                                               */
   /*    exec :: A handle to the source execution context.                  */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    size :: A handle to the target size object.                        */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   /* <Note>                                                                */
   /*    Only the glyph loader and debugger should call this function.      */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   TT_Save_Context( TT_ExecContext  exec,
                    TT_Size         size )
   {
     FT_Int  i;
 
 
     /* XXXX: Will probably disappear soon with all the code range */
     /*       management, which is now rather obsolete.            */
     /*                                                            */
     size->num_function_defs    = exec->numFDefs;
     size->num_instruction_defs = exec->numIDefs;
 
     size->max_func = exec->maxFunc;
     size->max_ins  = exec->maxIns;
 
     for ( i = 0; i < TT_MAX_CODE_RANGES; i++ )
       size->codeRangeTable[i] = exec->codeRangeTable[i];
 
     return TT_Err_Ok;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    TT_Run_Context                                                     */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Executes one or more instructions in the execution context.        */
   /*                                                                       */
   /* <Input>                                                               */
   /*    debug :: A Boolean flag.  If set, the function sets some internal  */
   /*             variables and returns immediately, otherwise TT_RunIns()  */
   /*             is called.                                                */
   /*                                                                       */
   /*             This is commented out currently.                          */
   /*                                                                       */
   /* <Input>                                                               */
   /*    exec  :: A handle to the target execution context.                 */
   /*                                                                       */
   /* <Return>                                                              */
   /*    TrueType error code.  0 means success.                             */
   /*                                                                       */
   /* <Note>                                                                */
   /*    Only the glyph loader and debugger should call this function.      */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   TT_Run_Context( TT_ExecContext  exec,
                   FT_Bool         debug )
   {
     FT_Error  error;
 
 
     if ( ( error = TT_Goto_CodeRange( exec, tt_coderange_glyph, 0  ) )
            != TT_Err_Ok )
       return error;
 
     exec->zp0 = exec->pts;
     exec->zp1 = exec->pts;
     exec->zp2 = exec->pts;
 
     exec->GS.gep0 = 1;
     exec->GS.gep1 = 1;
     exec->GS.gep2 = 1;
 
     exec->GS.projVector.x = 0x4000;
     exec->GS.projVector.y = 0x0000;
 
     exec->GS.freeVector = exec->GS.projVector;
     exec->GS.dualVector = exec->GS.projVector;
 
 #ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
     exec->GS.both_x_axis = TRUE;
 #endif
 
     exec->GS.round_state = 1;
     exec->GS.loop        = 1;
 
     /* some glyphs leave something on the stack. so we clean it */
     /* before a new execution.                                  */
     exec->top     = 0;
     exec->callTop = 0;
 
 #if 1
     FT_UNUSED( debug );
 
     return exec->face->interpreter( exec );
 #else
     if ( !debug )
       return TT_RunIns( exec );
     else
       return TT_Err_Ok;
 #endif
   }
 
 
   /* The default value for `scan_control' is documented as FALSE in the */
   /* TrueType specification.  This is confusing since it implies a      */
   /* Boolean value.  However, this is not the case, thus both the       */
   /* default values of our `scan_type' and `scan_control' fields (which */
   /* the documentation's `scan_control' variable is split into) are     */
   /* zero.                                                              */
 
   const TT_GraphicsState  tt_default_graphics_state =
   {
     0, 0, 0,
     { 0x4000, 0 },
     { 0x4000, 0 },
     { 0x4000, 0 },
 
 #ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
     TRUE,
 #endif
 
     1, 64, 1,
     TRUE, 68, 0, 0, 9, 3,
     0, FALSE, 0, 1, 1, 1
   };
 
 
   /* documentation is in ttinterp.h */
 
   FT_EXPORT_DEF( TT_ExecContext )
   TT_New_Context( TT_Driver  driver )
   {
     TT_ExecContext  exec;
     FT_Memory       memory;
 
 
     memory = driver->root.root.memory;
     exec   = driver->context;
 
     if ( !driver->context )
     {
       FT_Error  error;
 
 
       /* allocate object */
       if ( FT_NEW( exec ) )
         goto Fail;
 
       /* initialize it; in case of error this deallocates `exec' too */
       error = Init_Context( exec, memory );
       if ( error )
         goto Fail;
 
       /* store it into the driver */
       driver->context = exec;
     }
 
     return driver->context;
 
   Fail:
     return NULL;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* Before an opcode is executed, the interpreter verifies that there are */
   /* enough arguments on the stack, with the help of the `Pop_Push_Count'  */
   /* table.                                                                */
   /*                                                                       */
   /* For each opcode, the first column gives the number of arguments that  */
   /* are popped from the stack; the second one gives the number of those   */
   /* that are pushed in result.                                            */
   /*                                                                       */
   /* Opcodes which have a varying number of parameters in the data stream  */
   /* (NPUSHB, NPUSHW) are handled specially; they have a negative value in */
   /* the `opcode_length' table, and the value in `Pop_Push_Count' is set   */
   /* to zero.                                                              */
   /*                                                                       */
   /*************************************************************************/
 
 
 #undef  PACK
 #define PACK( x, y )  ( ( x << 4 ) | y )
 
 
   static
   const FT_Byte  Pop_Push_Count[256] =
   {
     /* opcodes are gathered in groups of 16 */
     /* please keep the spaces as they are   */
 
     /*  SVTCA  y  */  PACK( 0, 0 ),
     /*  SVTCA  x  */  PACK( 0, 0 ),
     /*  SPvTCA y  */  PACK( 0, 0 ),
     /*  SPvTCA x  */  PACK( 0, 0 ),
     /*  SFvTCA y  */  PACK( 0, 0 ),
     /*  SFvTCA x  */  PACK( 0, 0 ),
     /*  SPvTL //  */  PACK( 2, 0 ),
     /*  SPvTL +   */  PACK( 2, 0 ),
     /*  SFvTL //  */  PACK( 2, 0 ),
     /*  SFvTL +   */  PACK( 2, 0 ),
     /*  SPvFS     */  PACK( 2, 0 ),
     /*  SFvFS     */  PACK( 2, 0 ),
     /*  GPV       */  PACK( 0, 2 ),
     /*  GFV       */  PACK( 0, 2 ),
     /*  SFvTPv    */  PACK( 0, 0 ),
     /*  ISECT     */  PACK( 5, 0 ),
 
     /*  SRP0      */  PACK( 1, 0 ),
     /*  SRP1      */  PACK( 1, 0 ),
     /*  SRP2      */  PACK( 1, 0 ),
     /*  SZP0      */  PACK( 1, 0 ),
     /*  SZP1      */  PACK( 1, 0 ),
     /*  SZP2      */  PACK( 1, 0 ),
     /*  SZPS      */  PACK( 1, 0 ),
     /*  SLOOP     */  PACK( 1, 0 ),
     /*  RTG       */  PACK( 0, 0 ),
     /*  RTHG      */  PACK( 0, 0 ),
     /*  SMD       */  PACK( 1, 0 ),
     /*  ELSE      */  PACK( 0, 0 ),
     /*  JMPR      */  PACK( 1, 0 ),
     /*  SCvTCi    */  PACK( 1, 0 ),
     /*  SSwCi     */  PACK( 1, 0 ),
     /*  SSW       */  PACK( 1, 0 ),
 
     /*  DUP       */  PACK( 1, 2 ),
     /*  POP       */  PACK( 1, 0 ),
     /*  CLEAR     */  PACK( 0, 0 ),
     /*  SWAP      */  PACK( 2, 2 ),
     /*  DEPTH     */  PACK( 0, 1 ),
     /*  CINDEX    */  PACK( 1, 1 ),
     /*  MINDEX    */  PACK( 1, 0 ),
     /*  AlignPTS  */  PACK( 2, 0 ),
     /*  INS_$28   */  PACK( 0, 0 ),
     /*  UTP       */  PACK( 1, 0 ),
     /*  LOOPCALL  */  PACK( 2, 0 ),
     /*  CALL      */  PACK( 1, 0 ),
     /*  FDEF      */  PACK( 1, 0 ),
     /*  ENDF      */  PACK( 0, 0 ),
     /*  MDAP[0]   */  PACK( 1, 0 ),
     /*  MDAP[1]   */  PACK( 1, 0 ),
 
     /*  IUP[0]    */  PACK( 0, 0 ),
     /*  IUP[1]    */  PACK( 0, 0 ),
     /*  SHP[0]    */  PACK( 0, 0 ),
     /*  SHP[1]    */  PACK( 0, 0 ),
     /*  SHC[0]    */  PACK( 1, 0 ),
     /*  SHC[1]    */  PACK( 1, 0 ),
     /*  SHZ[0]    */  PACK( 1, 0 ),
     /*  SHZ[1]    */  PACK( 1, 0 ),
     /*  SHPIX     */  PACK( 1, 0 ),
     /*  IP        */  PACK( 0, 0 ),
     /*  MSIRP[0]  */  PACK( 2, 0 ),
     /*  MSIRP[1]  */  PACK( 2, 0 ),
     /*  AlignRP   */  PACK( 0, 0 ),
     /*  RTDG      */  PACK( 0, 0 ),
     /*  MIAP[0]   */  PACK( 2, 0 ),
     /*  MIAP[1]   */  PACK( 2, 0 ),
 
     /*  NPushB    */  PACK( 0, 0 ),
     /*  NPushW    */  PACK( 0, 0 ),
     /*  WS        */  PACK( 2, 0 ),
     /*  RS        */  PACK( 1, 1 ),
     /*  WCvtP     */  PACK( 2, 0 ),
     /*  RCvt      */  PACK( 1, 1 ),
     /*  GC[0]     */  PACK( 1, 1 ),
     /*  GC[1]     */  PACK( 1, 1 ),
     /*  SCFS      */  PACK( 2, 0 ),
     /*  MD[0]     */  PACK( 2, 1 ),
     /*  MD[1]     */  PACK( 2, 1 ),
     /*  MPPEM     */  PACK( 0, 1 ),
     /*  MPS       */  PACK( 0, 1 ),
     /*  FlipON    */  PACK( 0, 0 ),
     /*  FlipOFF   */  PACK( 0, 0 ),
     /*  DEBUG     */  PACK( 1, 0 ),
 
     /*  LT        */  PACK( 2, 1 ),
     /*  LTEQ      */  PACK( 2, 1 ),
     /*  GT        */  PACK( 2, 1 ),
     /*  GTEQ      */  PACK( 2, 1 ),
     /*  EQ        */  PACK( 2, 1 ),
     /*  NEQ       */  PACK( 2, 1 ),
     /*  ODD       */  PACK( 1, 1 ),
     /*  EVEN      */  PACK( 1, 1 ),
     /*  IF        */  PACK( 1, 0 ),
     /*  EIF       */  PACK( 0, 0 ),
     /*  AND       */  PACK( 2, 1 ),
     /*  OR        */  PACK( 2, 1 ),
     /*  NOT       */  PACK( 1, 1 ),
     /*  DeltaP1   */  PACK( 1, 0 ),
     /*  SDB       */  PACK( 1, 0 ),
     /*  SDS       */  PACK( 1, 0 ),
 
     /*  ADD       */  PACK( 2, 1 ),
     /*  SUB       */  PACK( 2, 1 ),
     /*  DIV       */  PACK( 2, 1 ),
     /*  MUL       */  PACK( 2, 1 ),
     /*  ABS       */  PACK( 1, 1 ),
     /*  NEG       */  PACK( 1, 1 ),
     /*  FLOOR     */  PACK( 1, 1 ),
     /*  CEILING   */  PACK( 1, 1 ),
     /*  ROUND[0]  */  PACK( 1, 1 ),
     /*  ROUND[1]  */  PACK( 1, 1 ),
     /*  ROUND[2]  */  PACK( 1, 1 ),
     /*  ROUND[3]  */  PACK( 1, 1 ),
     /*  NROUND[0] */  PACK( 1, 1 ),
     /*  NROUND[1] */  PACK( 1, 1 ),
     /*  NROUND[2] */  PACK( 1, 1 ),
     /*  NROUND[3] */  PACK( 1, 1 ),
 
     /*  WCvtF     */  PACK( 2, 0 ),
     /*  DeltaP2   */  PACK( 1, 0 ),
     /*  DeltaP3   */  PACK( 1, 0 ),
     /*  DeltaCn[0] */ PACK( 1, 0 ),
     /*  DeltaCn[1] */ PACK( 1, 0 ),
     /*  DeltaCn[2] */ PACK( 1, 0 ),
     /*  SROUND    */  PACK( 1, 0 ),
     /*  S45Round  */  PACK( 1, 0 ),
     /*  JROT      */  PACK( 2, 0 ),
     /*  JROF      */  PACK( 2, 0 ),
     /*  ROFF      */  PACK( 0, 0 ),
     /*  INS_$7B   */  PACK( 0, 0 ),
     /*  RUTG      */  PACK( 0, 0 ),
     /*  RDTG      */  PACK( 0, 0 ),
     /*  SANGW     */  PACK( 1, 0 ),
     /*  AA        */  PACK( 1, 0 ),
 
     /*  FlipPT    */  PACK( 0, 0 ),
     /*  FlipRgON  */  PACK( 2, 0 ),
     /*  FlipRgOFF */  PACK( 2, 0 ),
     /*  INS_$83   */  PACK( 0, 0 ),
     /*  INS_$84   */  PACK( 0, 0 ),
     /*  ScanCTRL  */  PACK( 1, 0 ),
     /*  SDVPTL[0] */  PACK( 2, 0 ),
     /*  SDVPTL[1] */  PACK( 2, 0 ),
     /*  GetINFO   */  PACK( 1, 1 ),
     /*  IDEF      */  PACK( 1, 0 ),
     /*  ROLL      */  PACK( 3, 3 ),
     /*  MAX       */  PACK( 2, 1 ),
     /*  MIN       */  PACK( 2, 1 ),
     /*  ScanTYPE  */  PACK( 1, 0 ),
     /*  InstCTRL  */  PACK( 2, 0 ),
     /*  INS_$8F   */  PACK( 0, 0 ),
 
     /*  INS_$90  */   PACK( 0, 0 ),
     /*  INS_$91  */   PACK( 0, 0 ),
     /*  INS_$92  */   PACK( 0, 0 ),
     /*  INS_$93  */   PACK( 0, 0 ),
     /*  INS_$94  */   PACK( 0, 0 ),
     /*  INS_$95  */   PACK( 0, 0 ),
     /*  INS_$96  */   PACK( 0, 0 ),
     /*  INS_$97  */   PACK( 0, 0 ),
     /*  INS_$98  */   PACK( 0, 0 ),
     /*  INS_$99  */   PACK( 0, 0 ),
     /*  INS_$9A  */   PACK( 0, 0 ),
     /*  INS_$9B  */   PACK( 0, 0 ),
     /*  INS_$9C  */   PACK( 0, 0 ),
     /*  INS_$9D  */   PACK( 0, 0 ),
     /*  INS_$9E  */   PACK( 0, 0 ),
     /*  INS_$9F  */   PACK( 0, 0 ),
 
     /*  INS_$A0  */   PACK( 0, 0 ),
     /*  INS_$A1  */   PACK( 0, 0 ),
     /*  INS_$A2  */   PACK( 0, 0 ),
     /*  INS_$A3  */   PACK( 0, 0 ),
     /*  INS_$A4  */   PACK( 0, 0 ),
     /*  INS_$A5  */   PACK( 0, 0 ),
     /*  INS_$A6  */   PACK( 0, 0 ),
     /*  INS_$A7  */   PACK( 0, 0 ),
     /*  INS_$A8  */   PACK( 0, 0 ),
     /*  INS_$A9  */   PACK( 0, 0 ),
     /*  INS_$AA  */   PACK( 0, 0 ),
     /*  INS_$AB  */   PACK( 0, 0 ),
     /*  INS_$AC  */   PACK( 0, 0 ),
     /*  INS_$AD  */   PACK( 0, 0 ),
     /*  INS_$AE  */   PACK( 0, 0 ),
     /*  INS_$AF  */   PACK( 0, 0 ),
 
     /*  PushB[0]  */  PACK( 0, 1 ),
     /*  PushB[1]  */  PACK( 0, 2 ),
     /*  PushB[2]  */  PACK( 0, 3 ),
     /*  PushB[3]  */  PACK( 0, 4 ),
     /*  PushB[4]  */  PACK( 0, 5 ),
     /*  PushB[5]  */  PACK( 0, 6 ),
     /*  PushB[6]  */  PACK( 0, 7 ),
     /*  PushB[7]  */  PACK( 0, 8 ),
     /*  PushW[0]  */  PACK( 0, 1 ),
     /*  PushW[1]  */  PACK( 0, 2 ),
     /*  PushW[2]  */  PACK( 0, 3 ),
     /*  PushW[3]  */  PACK( 0, 4 ),
     /*  PushW[4]  */  PACK( 0, 5 ),
     /*  PushW[5]  */  PACK( 0, 6 ),
     /*  PushW[6]  */  PACK( 0, 7 ),
     /*  PushW[7]  */  PACK( 0, 8 ),
 
     /*  MDRP[00]  */  PACK( 1, 0 ),
     /*  MDRP[01]  */  PACK( 1, 0 ),
     /*  MDRP[02]  */  PACK( 1, 0 ),
     /*  MDRP[03]  */  PACK( 1, 0 ),
     /*  MDRP[04]  */  PACK( 1, 0 ),
     /*  MDRP[05]  */  PACK( 1, 0 ),
     /*  MDRP[06]  */  PACK( 1, 0 ),
     /*  MDRP[07]  */  PACK( 1, 0 ),
     /*  MDRP[08]  */  PACK( 1, 0 ),
     /*  MDRP[09]  */  PACK( 1, 0 ),
     /*  MDRP[10]  */  PACK( 1, 0 ),
     /*  MDRP[11]  */  PACK( 1, 0 ),
     /*  MDRP[12]  */  PACK( 1, 0 ),
     /*  MDRP[13]  */  PACK( 1, 0 ),
     /*  MDRP[14]  */  PACK( 1, 0 ),
     /*  MDRP[15]  */  PACK( 1, 0 ),
 
     /*  MDRP[16]  */  PACK( 1, 0 ),
     /*  MDRP[17]  */  PACK( 1, 0 ),
     /*  MDRP[18]  */  PACK( 1, 0 ),
     /*  MDRP[19]  */  PACK( 1, 0 ),
     /*  MDRP[20]  */  PACK( 1, 0 ),
     /*  MDRP[21]  */  PACK( 1, 0 ),
     /*  MDRP[22]  */  PACK( 1, 0 ),
     /*  MDRP[23]  */  PACK( 1, 0 ),
     /*  MDRP[24]  */  PACK( 1, 0 ),
     /*  MDRP[25]  */  PACK( 1, 0 ),
     /*  MDRP[26]  */  PACK( 1, 0 ),
     /*  MDRP[27]  */  PACK( 1, 0 ),
     /*  MDRP[28]  */  PACK( 1, 0 ),
     /*  MDRP[29]  */  PACK( 1, 0 ),
     /*  MDRP[30]  */  PACK( 1, 0 ),
     /*  MDRP[31]  */  PACK( 1, 0 ),
 
     /*  MIRP[00]  */  PACK( 2, 0 ),
     /*  MIRP[01]  */  PACK( 2, 0 ),
     /*  MIRP[02]  */  PACK( 2, 0 ),
     /*  MIRP[03]  */  PACK( 2, 0 ),
     /*  MIRP[04]  */  PACK( 2, 0 ),
     /*  MIRP[05]  */  PACK( 2, 0 ),
     /*  MIRP[06]  */  PACK( 2, 0 ),
     /*  MIRP[07]  */  PACK( 2, 0 ),
     /*  MIRP[08]  */  PACK( 2, 0 ),
     /*  MIRP[09]  */  PACK( 2, 0 ),
     /*  MIRP[10]  */  PACK( 2, 0 ),
     /*  MIRP[11]  */  PACK( 2, 0 ),
     /*  MIRP[12]  */  PACK( 2, 0 ),
     /*  MIRP[13]  */  PACK( 2, 0 ),
     /*  MIRP[14]  */  PACK( 2, 0 ),
     /*  MIRP[15]  */  PACK( 2, 0 ),
 
     /*  MIRP[16]  */  PACK( 2, 0 ),
     /*  MIRP[17]  */  PACK( 2, 0 ),
     /*  MIRP[18]  */  PACK( 2, 0 ),
     /*  MIRP[19]  */  PACK( 2, 0 ),
     /*  MIRP[20]  */  PACK( 2, 0 ),
     /*  MIRP[21]  */  PACK( 2, 0 ),
     /*  MIRP[22]  */  PACK( 2, 0 ),
     /*  MIRP[23]  */  PACK( 2, 0 ),
     /*  MIRP[24]  */  PACK( 2, 0 ),
     /*  MIRP[25]  */  PACK( 2, 0 ),
     /*  MIRP[26]  */  PACK( 2, 0 ),
     /*  MIRP[27]  */  PACK( 2, 0 ),
     /*  MIRP[28]  */  PACK( 2, 0 ),
     /*  MIRP[29]  */  PACK( 2, 0 ),
     /*  MIRP[30]  */  PACK( 2, 0 ),
     /*  MIRP[31]  */  PACK( 2, 0 )
   };
 
 
 #ifdef FT_DEBUG_LEVEL_TRACE
 
   static
   const char*  const opcode_name[256] =
   {
     "SVTCA y",
     "SVTCA x",
     "SPvTCA y",
     "SPvTCA x",
     "SFvTCA y",
     "SFvTCA x",
     "SPvTL ||",
     "SPvTL +",
     "SFvTL ||",
     "SFvTL +",
     "SPvFS",
     "SFvFS",
     "GPV",
     "GFV",
     "SFvTPv",
     "ISECT",
 
     "SRP0",
     "SRP1",
     "SRP2",
     "SZP0",
     "SZP1",
     "SZP2",
     "SZPS",
     "SLOOP",
     "RTG",
     "RTHG",
     "SMD",
     "ELSE",
     "JMPR",
     "SCvTCi",
     "SSwCi",
     "SSW",
 
     "DUP",
     "POP",
     "CLEAR",
     "SWAP",
     "DEPTH",
     "CINDEX",
     "MINDEX",
     "AlignPTS",
     "INS_$28",
     "UTP",
     "LOOPCALL",
     "CALL",
     "FDEF",
     "ENDF",
     "MDAP[0]",
     "MDAP[1]",
 
     "IUP[0]",
     "IUP[1]",
     "SHP[0]",
     "SHP[1]",
     "SHC[0]",
     "SHC[1]",
     "SHZ[0]",
     "SHZ[1]",
     "SHPIX",
     "IP",
     "MSIRP[0]",
     "MSIRP[1]",
     "AlignRP",
     "RTDG",
     "MIAP[0]",
     "MIAP[1]",
 
     "NPushB",
     "NPushW",
     "WS",
     "RS",
     "WCvtP",
     "RCvt",
     "GC[0]",
     "GC[1]",
     "SCFS",
     "MD[0]",
     "MD[1]",
     "MPPEM",
     "MPS",
     "FlipON",
     "FlipOFF",
     "DEBUG",
 
     "LT",
     "LTEQ",
     "GT",
     "GTEQ",
     "EQ",
     "NEQ",
     "ODD",
     "EVEN",
     "IF",
     "EIF",
     "AND",
     "OR",
     "NOT",
     "DeltaP1",
     "SDB",
     "SDS",
 
     "ADD",
     "SUB",
     "DIV",
     "MUL",
     "ABS",
     "NEG",
     "FLOOR",
     "CEILING",
     "ROUND[0]",
     "ROUND[1]",
     "ROUND[2]",
     "ROUND[3]",
     "NROUND[0]",
     "NROUND[1]",
     "NROUND[2]",
     "NROUND[3]",
 
     "WCvtF",
     "DeltaP2",
     "DeltaP3",
     "DeltaCn[0]",
     "DeltaCn[1]",
     "DeltaCn[2]",
     "SROUND",
     "S45Round",
     "JROT",
     "JROF",
     "ROFF",
     "INS_$7B",
     "RUTG",
     "RDTG",
     "SANGW",
     "AA",
 
     "FlipPT",
     "FlipRgON",
     "FlipRgOFF",
     "INS_$83",
     "INS_$84",
     "ScanCTRL",
     "SDVPTL[0]",
     "SDVPTL[1]",
     "GetINFO",
     "IDEF",
     "ROLL",
     "MAX",
     "MIN",
     "ScanTYPE",
     "InstCTRL",
     "INS_$8F",
 
     "INS_$90",
     "INS_$91",
     "INS_$92",
     "INS_$93",
     "INS_$94",
     "INS_$95",
     "INS_$96",
     "INS_$97",
     "INS_$98",
     "INS_$99",
     "INS_$9A",
     "INS_$9B",
     "INS_$9C",
     "INS_$9D",
     "INS_$9E",
     "INS_$9F",
 
     "INS_$A0",
     "INS_$A1",
     "INS_$A2",
     "INS_$A3",
     "INS_$A4",
     "INS_$A5",
     "INS_$A6",
     "INS_$A7",
     "INS_$A8",
     "INS_$A9",
     "INS_$AA",
     "INS_$AB",
     "INS_$AC",
     "INS_$AD",
     "INS_$AE",
     "INS_$AF",
 
     "PushB[0]",
     "PushB[1]",
     "PushB[2]",
     "PushB[3]",
     "PushB[4]",
     "PushB[5]",
     "PushB[6]",
     "PushB[7]",
     "PushW[0]",
     "PushW[1]",
     "PushW[2]",
     "PushW[3]",
     "PushW[4]",
     "PushW[5]",
     "PushW[6]",
     "PushW[7]",
 
     "MDRP[00]",
     "MDRP[01]",
     "MDRP[02]",
     "MDRP[03]",
     "MDRP[04]",
     "MDRP[05]",
     "MDRP[06]",
     "MDRP[07]",
     "MDRP[08]",
     "MDRP[09]",
     "MDRP[10]",
     "MDRP[11]",
     "MDRP[12]",
     "MDRP[13]",
     "MDRP[14]",
     "MDRP[15]",
 
     "MDRP[16]",
     "MDRP[17]",
     "MDRP[18]",
     "MDRP[19]",
     "MDRP[20]",
     "MDRP[21]",
     "MDRP[22]",
     "MDRP[23]",
     "MDRP[24]",
     "MDRP[25]",
     "MDRP[26]",
     "MDRP[27]",
     "MDRP[28]",
     "MDRP[29]",
     "MDRP[30]",
     "MDRP[31]",
 
     "MIRP[00]",
     "MIRP[01]",
     "MIRP[02]",
     "MIRP[03]",
     "MIRP[04]",
     "MIRP[05]",
     "MIRP[06]",
     "MIRP[07]",
     "MIRP[08]",
     "MIRP[09]",
     "MIRP[10]",
     "MIRP[11]",
     "MIRP[12]",
     "MIRP[13]",
     "MIRP[14]",
     "MIRP[15]",
 
     "MIRP[16]",
     "MIRP[17]",
     "MIRP[18]",
     "MIRP[19]",
     "MIRP[20]",
     "MIRP[21]",
     "MIRP[22]",
     "MIRP[23]",
     "MIRP[24]",
     "MIRP[25]",
     "MIRP[26]",
     "MIRP[27]",
     "MIRP[28]",
     "MIRP[29]",
     "MIRP[30]",
     "MIRP[31]"
   };
 
 #endif /* FT_DEBUG_LEVEL_TRACE */
 
 
   static
   const FT_Char  opcode_length[256] =
   {
     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
 
    -1,-2, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
 
     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
     2, 3, 4, 5,  6, 7, 8, 9,  3, 5, 7, 9, 11,13,15,17,
 
     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1
   };
 
 #undef PACK
 
 #if 1
 
   static FT_Int32
   TT_MulFix14( FT_Int32  a,
                FT_Int    b )
   {
     FT_Int32   sign;
     FT_UInt32  ah, al, mid, lo, hi;
 
 
     sign = a ^ b;
 
     if ( a < 0 )
       a = -a;
     if ( b < 0 )
       b = -b;
 
     ah = (FT_UInt32)( ( a >> 16 ) & 0xFFFFU );
     al = (FT_UInt32)( a & 0xFFFFU );
 
     lo    = al * b;
     mid   = ah * b;
     hi    = mid >> 16;
     mid   = ( mid << 16 ) + ( 1 << 13 ); /* rounding */
     lo   += mid;
     if ( lo < mid )
       hi += 1;
 
     mid = ( lo >> 14 ) | ( hi << 18 );
 
     return sign >= 0 ? (FT_Int32)mid : -(FT_Int32)mid;
   }
 
 #else
 
   /* compute (a*b)/2^14 with maximal accuracy and rounding */
   static FT_Int32
   TT_MulFix14( FT_Int32  a,
                FT_Int    b )
   {
     FT_Int32   m, s, hi;
     FT_UInt32  l, lo;
 
 
     /* compute ax*bx as 64-bit value */
     l  = (FT_UInt32)( ( a & 0xFFFFU ) * b );
     m  = ( a >> 16 ) * b;
 
     lo = l + (FT_UInt32)( m << 16 );
     hi = ( m >> 16 ) + ( (FT_Int32)l >> 31 ) + ( lo < l );
 
     /* divide the result by 2^14 with rounding */
     s   = hi >> 31;
     l   = lo + (FT_UInt32)s;
     hi += s + ( l < lo );
     lo  = l;
 
     l   = lo + 0x2000U;
     hi += l < lo;
 
     return ( hi << 18 ) | ( l >> 14 );
   }
 #endif
 
 
   /* compute (ax*bx+ay*by)/2^14 with maximal accuracy and rounding */
   static FT_Int32
   TT_DotFix14( FT_Int32  ax,
                FT_Int32  ay,
                FT_Int    bx,
                FT_Int    by )
   {
     FT_Int32   m, s, hi1, hi2, hi;
     FT_UInt32  l, lo1, lo2, lo;
 
 
     /* compute ax*bx as 64-bit value */
     l = (FT_UInt32)( ( ax & 0xFFFFU ) * bx );
     m = ( ax >> 16 ) * bx;
 
     lo1 = l + (FT_UInt32)( m << 16 );
     hi1 = ( m >> 16 ) + ( (FT_Int32)l >> 31 ) + ( lo1 < l );
 
     /* compute ay*by as 64-bit value */
     l = (FT_UInt32)( ( ay & 0xFFFFU ) * by );
     m = ( ay >> 16 ) * by;
 
     lo2 = l + (FT_UInt32)( m << 16 );
     hi2 = ( m >> 16 ) + ( (FT_Int32)l >> 31 ) + ( lo2 < l );
 
     /* add them */
     lo = lo1 + lo2;
     hi = hi1 + hi2 + ( lo < lo1 );
 
     /* divide the result by 2^14 with rounding */
     s   = hi >> 31;
     l   = lo + (FT_UInt32)s;
     hi += s + ( l < lo );
     lo  = l;
 
     l   = lo + 0x2000U;
     hi += ( l < lo );
 
     return ( hi << 18 ) | ( l >> 14 );
   }
 
 
   /* return length of given vector */
 
 #if 0
 
   static FT_Int32
   TT_VecLen( FT_Int32  x,
              FT_Int32  y )
   {
     FT_Int32   m, hi1, hi2, hi;
     FT_UInt32  l, lo1, lo2, lo;
 
 
     /* compute x*x as 64-bit value */
     lo = (FT_UInt32)( x & 0xFFFFU );
     hi = x >> 16;
 
     l  = lo * lo;
     m  = hi * lo;
     hi = hi * hi;
 
     lo1 = l + (FT_UInt32)( m << 17 );
     hi1 = hi + ( m >> 15 ) + ( lo1 < l );
 
     /* compute y*y as 64-bit value */
     lo = (FT_UInt32)( y & 0xFFFFU );
     hi = y >> 16;
 
     l  = lo * lo;
     m  = hi * lo;
     hi = hi * hi;
 
     lo2 = l + (FT_UInt32)( m << 17 );
     hi2 = hi + ( m >> 15 ) + ( lo2 < l );
 
     /* add them to get 'x*x+y*y' as 64-bit value */
     lo = lo1 + lo2;
     hi = hi1 + hi2 + ( lo < lo1 );
 
     /* compute the square root of this value */
     {
       FT_UInt32  root, rem, test_div;
       FT_Int     count;
 
 
       root = 0;
 
       {
         rem   = 0;
         count = 32;
         do
         {
           rem      = ( rem << 2 ) | ( (FT_UInt32)hi >> 30 );
           hi       = (  hi << 2 ) | (            lo >> 30 );
           lo     <<= 2;
           root   <<= 1;
           test_div = ( root << 1 ) + 1;
 
           if ( rem >= test_div )
           {
             rem  -= test_div;
             root += 1;
           }
         } while ( --count );
       }
 
       return (FT_Int32)root;
     }
   }
 
 #else
 
   /* this version uses FT_Vector_Length which computes the same value */
   /* much, much faster..                                              */
   /*                                                                  */
   static FT_F26Dot6
   TT_VecLen( FT_F26Dot6  X,
              FT_F26Dot6  Y )
   {
     FT_Vector  v;
 
 
     v.x = X;
     v.y = Y;
 
     return FT_Vector_Length( &v );
   }
 
 #endif
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    Current_Ratio                                                      */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Returns the current aspect ratio scaling factor depending on the   */
   /*    projection vector's state and device resolutions.                  */
   /*                                                                       */
   /* <Return>                                                              */
   /*    The aspect ratio in 16.16 format, always <= 1.0 .                  */
   /*                                                                       */
   static FT_Long
   Current_Ratio( EXEC_OP )
   {
     if ( !CUR.tt_metrics.ratio )
     {
 #ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
       if ( CUR.face->unpatented_hinting )
       {
         if ( CUR.GS.both_x_axis )
           CUR.tt_metrics.ratio = CUR.tt_metrics.x_ratio;
         else
           CUR.tt_metrics.ratio = CUR.tt_metrics.y_ratio;
       }
       else
 #endif
       {
         if ( CUR.GS.projVector.y == 0 )
           CUR.tt_metrics.ratio = CUR.tt_metrics.x_ratio;
 
         else if ( CUR.GS.projVector.x == 0 )
           CUR.tt_metrics.ratio = CUR.tt_metrics.y_ratio;
 
         else
         {
           FT_Long  x, y;
 
 
           x = TT_MULDIV( CUR.GS.projVector.x,
                          CUR.tt_metrics.x_ratio, 0x4000 );
           y = TT_MULDIV( CUR.GS.projVector.y,
                          CUR.tt_metrics.y_ratio, 0x4000 );
           CUR.tt_metrics.ratio = TT_VecLen( x, y );
         }
       }
     }
     return CUR.tt_metrics.ratio;
   }
 
 
   static FT_Long
   Current_Ppem( EXEC_OP )
   {
     return TT_MULFIX( CUR.tt_metrics.ppem, CURRENT_Ratio() );
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* Functions related to the control value table (CVT).                   */
   /*                                                                       */
   /*************************************************************************/
 
 
   FT_CALLBACK_DEF( FT_F26Dot6 )
   Read_CVT( EXEC_OP_ FT_ULong  idx )
   {
     return CUR.cvt[idx];
   }
 
 
   FT_CALLBACK_DEF( FT_F26Dot6 )
   Read_CVT_Stretched( EXEC_OP_ FT_ULong  idx )
   {
     return TT_MULFIX( CUR.cvt[idx], CURRENT_Ratio() );
   }
 
 
   FT_CALLBACK_DEF( void )
   Write_CVT( EXEC_OP_ FT_ULong    idx,
                       FT_F26Dot6  value )
   {
     CUR.cvt[idx] = value;
   }
 
 
   FT_CALLBACK_DEF( void )
   Write_CVT_Stretched( EXEC_OP_ FT_ULong    idx,
                                 FT_F26Dot6  value )
   {
     CUR.cvt[idx] = FT_DivFix( value, CURRENT_Ratio() );
   }
 
 
   FT_CALLBACK_DEF( void )
   Move_CVT( EXEC_OP_ FT_ULong    idx,
                      FT_F26Dot6  value )
   {
     CUR.cvt[idx] += value;
   }
 
 
   FT_CALLBACK_DEF( void )
   Move_CVT_Stretched( EXEC_OP_ FT_ULong    idx,
                                FT_F26Dot6  value )
   {
     CUR.cvt[idx] += FT_DivFix( value, CURRENT_Ratio() );
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    GetShortIns                                                        */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Returns a short integer taken from the instruction stream at       */
   /*    address IP.                                                        */
   /*                                                                       */
   /* <Return>                                                              */
   /*    Short read at code[IP].                                            */
   /*                                                                       */
   /* <Note>                                                                */
   /*    This one could become a macro.                                     */
   /*                                                                       */
   static FT_Short
   GetShortIns( EXEC_OP )
   {
     /* Reading a byte stream so there is no endianess (DaveP) */
     CUR.IP += 2;
     return (FT_Short)( ( CUR.code[CUR.IP - 2] << 8 ) +
                          CUR.code[CUR.IP - 1]      );
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    Ins_Goto_CodeRange                                                 */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Goes to a certain code range in the instruction stream.            */
   /*                                                                       */
   /* <Input>                                                               */
   /*    aRange :: The index of the code range.                             */
   /*                                                                       */
   /*    aIP    :: The new IP address in the code range.                    */
   /*                                                                       */
   /* <Return>                                                              */
   /*    SUCCESS or FAILURE.                                                */
   /*                                                                       */
   static FT_Bool
   Ins_Goto_CodeRange( EXEC_OP_ FT_Int    aRange,
                                FT_ULong  aIP )
   {
     TT_CodeRange*  range;
 
 
     if ( aRange < 1 || aRange > 3 )
     {
       CUR.error = TT_Err_Bad_Argument;
       return FAILURE;
     }
 
     range = &CUR.codeRangeTable[aRange - 1];
 
     if ( range->base == NULL )     /* invalid coderange */
     {
       CUR.error = TT_Err_Invalid_CodeRange;
       return FAILURE;
     }
 
     /* NOTE: Because the last instruction of a program may be a CALL */
     /*       which will return to the first byte *after* the code    */
     /*       range, we test for AIP <= Size, instead of AIP < Size.  */
 
     if ( aIP > range->size )
     {
       CUR.error = TT_Err_Code_Overflow;
       return FAILURE;
     }
 
     CUR.code     = range->base;
     CUR.codeSize = range->size;
     CUR.IP       = aIP;
     CUR.curRange = aRange;
 
     return SUCCESS;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    Direct_Move                                                        */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Moves a point by a given distance along the freedom vector.  The   */
   /*    point will be `touched'.                                           */
   /*                                                                       */
   /* <Input>                                                               */
   /*    point    :: The index of the point to move.                        */
   /*                                                                       */
   /*    distance :: The distance to apply.                                 */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    zone     :: The affected glyph zone.                               */
   /*                                                                       */
   static void
   Direct_Move( EXEC_OP_ TT_GlyphZone  zone,
                         FT_UShort     point,
                         FT_F26Dot6    distance )
   {
     FT_F26Dot6  v;
 
 
 #ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
     FT_ASSERT( !CUR.face->unpatented_hinting );
 #endif
 
     v = CUR.GS.freeVector.x;
 
     if ( v != 0 )
     {
       zone->cur[point].x += TT_MULDIV( distance,
                                        v * 0x10000L,
                                        CUR.F_dot_P );
 
       zone->tags[point] |= FT_CURVE_TAG_TOUCH_X;
     }
 
     v = CUR.GS.freeVector.y;
 
     if ( v != 0 )
     {
       zone->cur[point].y += TT_MULDIV( distance,
                                        v * 0x10000L,
                                        CUR.F_dot_P );
 
       zone->tags[point] |= FT_CURVE_TAG_TOUCH_Y;
     }
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    Direct_Move_Orig                                                   */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Moves the *original* position of a point by a given distance along */
   /*    the freedom vector.  Obviously, the point will not be `touched'.   */
   /*                                                                       */
   /* <Input>                                                               */
   /*    point    :: The index of the point to move.                        */
   /*                                                                       */
   /*    distance :: The distance to apply.                                 */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    zone     :: The affected glyph zone.                               */
   /*                                                                       */
   static void
   Direct_Move_Orig( EXEC_OP_ TT_GlyphZone  zone,
                              FT_UShort     point,
                              FT_F26Dot6    distance )
   {
     FT_F26Dot6  v;
 
 
 #ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
     FT_ASSERT( !CUR.face->unpatented_hinting );
 #endif
 
     v = CUR.GS.freeVector.x;
 
     if ( v != 0 )
       zone->org[point].x += TT_MULDIV( distance,
                                        v * 0x10000L,
                                        CUR.F_dot_P );
 
     v = CUR.GS.freeVector.y;
 
     if ( v != 0 )
       zone->org[point].y += TT_MULDIV( distance,
                                        v * 0x10000L,
                                        CUR.F_dot_P );
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* Special versions of Direct_Move()                                     */
   /*                                                                       */
   /*   The following versions are used whenever both vectors are both      */
   /*   along one of the coordinate unit vectors, i.e. in 90% of the cases. */
   /*                                                                       */
   /*************************************************************************/
 
 
   static void
   Direct_Move_X( EXEC_OP_ TT_GlyphZone  zone,
                           FT_UShort     point,
                           FT_F26Dot6    distance )
   {
     FT_UNUSED_EXEC;
 
     zone->cur[point].x += distance;
     zone->tags[point]  |= FT_CURVE_TAG_TOUCH_X;
   }
 
 
   static void
   Direct_Move_Y( EXEC_OP_ TT_GlyphZone  zone,
                           FT_UShort     point,
                           FT_F26Dot6    distance )
   {
     FT_UNUSED_EXEC;
 
     zone->cur[point].y += distance;
     zone->tags[point]  |= FT_CURVE_TAG_TOUCH_Y;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* Special versions of Direct_Move_Orig()                                */
   /*                                                                       */
   /*   The following versions are used whenever both vectors are both      */
   /*   along one of the coordinate unit vectors, i.e. in 90% of the cases. */
   /*                                                                       */
   /*************************************************************************/
 
 
   static void
   Direct_Move_Orig_X( EXEC_OP_ TT_GlyphZone  zone,
                                FT_UShort     point,
                                FT_F26Dot6    distance )
   {
     FT_UNUSED_EXEC;
 
     zone->org[point].x += distance;
   }
 
 
   static void
   Direct_Move_Orig_Y( EXEC_OP_ TT_GlyphZone  zone,
                                FT_UShort     point,
                                FT_F26Dot6    distance )
   {
     FT_UNUSED_EXEC;
 
     zone->org[point].y += distance;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    Round_None                                                         */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Does not round, but adds engine compensation.                      */
   /*                                                                       */
   /* <Input>                                                               */
   /*    distance     :: The distance (not) to round.                       */
   /*                                                                       */
   /*    compensation :: The engine compensation.                           */
   /*                                                                       */
   /* <Return>                                                              */
   /*    The compensated distance.                                          */
   /*                                                                       */
   /* <Note>                                                                */
   /*    The TrueType specification says very few about the relationship    */
   /*    between rounding and engine compensation.  However, it seems from  */
   /*    the description of super round that we should add the compensation */
   /*    before rounding.                                                   */
   /*                                                                       */
   static FT_F26Dot6
   Round_None( EXEC_OP_ FT_F26Dot6  distance,
                        FT_F26Dot6  compensation )
   {
     FT_F26Dot6  val;
 
     FT_UNUSED_EXEC;
 
 
     if ( distance >= 0 )
     {
       val = distance + compensation;
       if ( distance && val < 0 )
         val = 0;
     }
     else
     {
       val = distance - compensation;
       if ( val > 0 )
         val = 0;
     }
     return val;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    Round_To_Grid                                                      */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Rounds value to grid after adding engine compensation.             */
   /*                                                                       */
   /* <Input>                                                               */
   /*    distance     :: The distance to round.                             */
   /*                                                                       */
   /*    compensation :: The engine compensation.                           */
   /*                                                                       */
   /* <Return>                                                              */
   /*    Rounded distance.                                                  */
   /*                                                                       */
   static FT_F26Dot6
   Round_To_Grid( EXEC_OP_ FT_F26Dot6  distance,
                           FT_F26Dot6  compensation )
   {
     FT_F26Dot6  val;
 
     FT_UNUSED_EXEC;
 
 
     if ( distance >= 0 )
     {
       val = distance + compensation + 32;
       if ( distance && val > 0 )
         val &= ~63;
       else
         val = 0;
     }
     else
     {
       val = -FT_PIX_ROUND( compensation - distance );
       if ( val > 0 )
         val = 0;
     }
 
     return  val;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    Round_To_Half_Grid                                                 */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Rounds value to half grid after adding engine compensation.        */
   /*                                                                       */
   /* <Input>                                                               */
   /*    distance     :: The distance to round.                             */
   /*                                                                       */
   /*    compensation :: The engine compensation.                           */
   /*                                                                       */
   /* <Return>                                                              */
   /*    Rounded distance.                                                  */
   /*                                                                       */
   static FT_F26Dot6
   Round_To_Half_Grid( EXEC_OP_ FT_F26Dot6  distance,
                                FT_F26Dot6  compensation )
   {
     FT_F26Dot6  val;
 
     FT_UNUSED_EXEC;
 
 
     if ( distance >= 0 )
     {
       val = FT_PIX_FLOOR( distance + compensation ) + 32;
       if ( distance && val < 0 )
         val = 0;
     }
     else
     {
       val = -( FT_PIX_FLOOR( compensation - distance ) + 32 );
       if ( val > 0 )
         val = 0;
     }
 
     return val;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    Round_Down_To_Grid                                                 */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Rounds value down to grid after adding engine compensation.        */
   /*                                                                       */
   /* <Input>                                                               */
   /*    distance     :: The distance to round.                             */
   /*                                                                       */
   /*    compensation :: The engine compensation.                           */
   /*                                                                       */
   /* <Return>                                                              */
   /*    Rounded distance.                                                  */
   /*                                                                       */
   static FT_F26Dot6
   Round_Down_To_Grid( EXEC_OP_ FT_F26Dot6  distance,
                                FT_F26Dot6  compensation )
   {
     FT_F26Dot6  val;
 
     FT_UNUSED_EXEC;
 
 
     if ( distance >= 0 )
     {
       val = distance + compensation;
       if ( distance && val > 0 )
         val &= ~63;
       else
         val = 0;
     }
     else
     {
       val = -( ( compensation - distance ) & -64 );
       if ( val > 0 )
         val = 0;
     }
 
     return val;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    Round_Up_To_Grid                                                   */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Rounds value up to grid after adding engine compensation.          */
   /*                                                                       */
   /* <Input>                                                               */
   /*    distance     :: The distance to round.                             */
   /*                                                                       */
   /*    compensation :: The engine compensation.                           */
   /*                                                                       */
   /* <Return>                                                              */
   /*    Rounded distance.                                                  */
   /*                                                                       */
   static FT_F26Dot6
   Round_Up_To_Grid( EXEC_OP_ FT_F26Dot6  distance,
                              FT_F26Dot6  compensation )
   {
     FT_F26Dot6  val;
 
     FT_UNUSED_EXEC;
 
 
     if ( distance >= 0 )
     {
       val = distance + compensation + 63;
       if ( distance && val > 0 )
         val &= ~63;
       else
         val = 0;
     }
     else
     {
       val = - FT_PIX_CEIL( compensation - distance );
       if ( val > 0 )
         val = 0;
     }
 
     return val;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    Round_To_Double_Grid                                               */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Rounds value to double grid after adding engine compensation.      */
   /*                                                                       */
   /* <Input>                                                               */
   /*    distance     :: The distance to round.                             */
   /*                                                                       */
   /*    compensation :: The engine compensation.                           */
   /*                                                                       */
   /* <Return>                                                              */
   /*    Rounded distance.                                                  */
   /*                                                                       */
   static FT_F26Dot6
   Round_To_Double_Grid( EXEC_OP_ FT_F26Dot6  distance,
                                  FT_F26Dot6  compensation )
   {
     FT_F26Dot6 val;
 
     FT_UNUSED_EXEC;
 
 
     if ( distance >= 0 )
     {
       val = distance + compensation + 16;
       if ( distance && val > 0 )
         val &= ~31;
       else
         val = 0;
     }
     else
     {
       val = -FT_PAD_ROUND( compensation - distance, 32 );
       if ( val > 0 )
         val = 0;
     }
 
     return val;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    Round_Super                                                        */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Super-rounds value to grid after adding engine compensation.       */
   /*                                                                       */
   /* <Input>                                                               */
   /*    distance     :: The distance to round.                             */
   /*                                                                       */
   /*    compensation :: The engine compensation.                           */
   /*                                                                       */
   /* <Return>                                                              */
   /*    Rounded distance.                                                  */
   /*                                                                       */
   /* <Note>                                                                */
   /*    The TrueType specification says very few about the relationship    */
   /*    between rounding and engine compensation.  However, it seems from  */
   /*    the description of super round that we should add the compensation */
   /*    before rounding.                                                   */
   /*                                                                       */
   static FT_F26Dot6
   Round_Super( EXEC_OP_ FT_F26Dot6  distance,
                         FT_F26Dot6  compensation )
   {
     FT_F26Dot6  val;
 
 
     if ( distance >= 0 )
     {
       val = ( distance - CUR.phase + CUR.threshold + compensation ) &
               -CUR.period;
       if ( distance && val < 0 )
         val = 0;
       val += CUR.phase;
     }
     else
     {
       val = -( ( CUR.threshold - CUR.phase - distance + compensation ) &
                -CUR.period );
       if ( val > 0 )
         val = 0;
       val -= CUR.phase;
     }
 
     return val;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    Round_Super_45                                                     */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Super-rounds value to grid after adding engine compensation.       */
   /*                                                                       */
   /* <Input>                                                               */
   /*    distance     :: The distance to round.                             */
   /*                                                                       */
   /*    compensation :: The engine compensation.                           */
   /*                                                                       */
   /* <Return>                                                              */
   /*    Rounded distance.                                                  */
   /*                                                                       */
   /* <Note>                                                                */
   /*    There is a separate function for Round_Super_45() as we may need   */
   /*    greater precision.                                                 */
   /*                                                                       */
   static FT_F26Dot6
   Round_Super_45( EXEC_OP_ FT_F26Dot6  distance,
                            FT_F26Dot6  compensation )
   {
     FT_F26Dot6  val;
 
 
     if ( distance >= 0 )
     {
       val = ( ( distance - CUR.phase + CUR.threshold + compensation ) /
                 CUR.period ) * CUR.period;
       if ( distance && val < 0 )
         val = 0;
       val += CUR.phase;
     }
     else
     {
       val = -( ( ( CUR.threshold - CUR.phase - distance + compensation ) /
                    CUR.period ) * CUR.period );
       if ( val > 0 )
         val = 0;
       val -= CUR.phase;
     }
 
     return val;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    Compute_Round                                                      */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Sets the rounding mode.                                            */
   /*                                                                       */
   /* <Input>                                                               */
   /*    round_mode :: The rounding mode to be used.                        */
   /*                                                                       */
   static void
   Compute_Round( EXEC_OP_ FT_Byte  round_mode )
   {
     switch ( round_mode )
     {
     case TT_Round_Off:
       CUR.func_round = (TT_Round_Func)Round_None;
       break;
 
     case TT_Round_To_Grid:
       CUR.func_round = (TT_Round_Func)Round_To_Grid;
       break;
 
     case TT_Round_Up_To_Grid:
       CUR.func_round = (TT_Round_Func)Round_Up_To_Grid;
       break;
 
     case TT_Round_Down_To_Grid:
       CUR.func_round = (TT_Round_Func)Round_Down_To_Grid;
       break;
 
     case TT_Round_To_Half_Grid:
       CUR.func_round = (TT_Round_Func)Round_To_Half_Grid;
       break;
 
     case TT_Round_To_Double_Grid:
       CUR.func_round = (TT_Round_Func)Round_To_Double_Grid;
       break;
 
     case TT_Round_Super:
       CUR.func_round = (TT_Round_Func)Round_Super;
       break;
 
     case TT_Round_Super_45:
       CUR.func_round = (TT_Round_Func)Round_Super_45;
       break;
     }
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    SetSuperRound                                                      */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Sets Super Round parameters.                                       */
   /*                                                                       */
   /* <Input>                                                               */
   /*    GridPeriod :: Grid period                                          */
   /*    selector   :: SROUND opcode                                        */
   /*                                                                       */
   static void
   SetSuperRound( EXEC_OP_ FT_F26Dot6  GridPeriod,
                           FT_Long     selector )
   {
     switch ( (FT_Int)( selector & 0xC0 ) )
     {
       case 0:
         CUR.period = GridPeriod / 2;
         break;
 
       case 0x40:
         CUR.period = GridPeriod;
         break;
 
       case 0x80:
         CUR.period = GridPeriod * 2;
         break;
 
       /* This opcode is reserved, but... */
 
       case 0xC0:
         CUR.period = GridPeriod;
         break;
     }
 
     switch ( (FT_Int)( selector & 0x30 ) )
     {
     case 0:
       CUR.phase = 0;
       break;
 
     case 0x10:
       CUR.phase = CUR.period / 4;
       break;
 
     case 0x20:
       CUR.phase = CUR.period / 2;
       break;
 
     case 0x30:
       CUR.phase = CUR.period * 3 / 4;
       break;
     }
 
     if ( ( selector & 0x0F ) == 0 )
       CUR.threshold = CUR.period - 1;
     else
       CUR.threshold = ( (FT_Int)( selector & 0x0F ) - 4 ) * CUR.period / 8;
 
     CUR.period    /= 256;
     CUR.phase     /= 256;
     CUR.threshold /= 256;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    Project                                                            */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Computes the projection of vector given by (v2-v1) along the       */
   /*    current projection vector.                                         */
   /*                                                                       */
   /* <Input>                                                               */
   /*    v1 :: First input vector.                                          */
   /*    v2 :: Second input vector.                                         */
   /*                                                                       */
   /* <Return>                                                              */
   /*    The distance in F26dot6 format.                                    */
   /*                                                                       */
   static FT_F26Dot6
   Project( EXEC_OP_ FT_Pos  dx,
                     FT_Pos  dy )
   {
 #ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
     FT_ASSERT( !CUR.face->unpatented_hinting );
 #endif
 
     return TT_DotFix14( (FT_UInt32)dx, (FT_UInt32)dy,
                         CUR.GS.projVector.x,
                         CUR.GS.projVector.y );
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    Dual_Project                                                       */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Computes the projection of the vector given by (v2-v1) along the   */
   /*    current dual vector.                                               */
   /*                                                                       */
   /* <Input>                                                               */
   /*    v1 :: First input vector.                                          */
   /*    v2 :: Second input vector.                                         */
   /*                                                                       */
   /* <Return>                                                              */
   /*    The distance in F26dot6 format.                                    */
   /*                                                                       */
   static FT_F26Dot6
   Dual_Project( EXEC_OP_ FT_Pos  dx,
                          FT_Pos  dy )
   {
     return TT_DotFix14( (FT_UInt32)dx, (FT_UInt32)dy,
                         CUR.GS.dualVector.x,
                         CUR.GS.dualVector.y );
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    Project_x                                                          */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Computes the projection of the vector given by (v2-v1) along the   */
   /*    horizontal axis.                                                   */
   /*                                                                       */
   /* <Input>                                                               */
   /*    v1 :: First input vector.                                          */
   /*    v2 :: Second input vector.                                         */
   /*                                                                       */
   /* <Return>                                                              */
   /*    The distance in F26dot6 format.                                    */
   /*                                                                       */
   static FT_F26Dot6
   Project_x( EXEC_OP_ FT_Pos  dx,
                       FT_Pos  dy )
   {
     FT_UNUSED_EXEC;
     FT_UNUSED( dy );
 
     return dx;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    Project_y                                                          */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Computes the projection of the vector given by (v2-v1) along the   */
   /*    vertical axis.                                                     */
   /*                                                                       */
   /* <Input>                                                               */
   /*    v1 :: First input vector.                                          */
   /*    v2 :: Second input vector.                                         */
   /*                                                                       */
   /* <Return>                                                              */
   /*    The distance in F26dot6 format.                                    */
   /*                                                                       */
   static FT_F26Dot6
   Project_y( EXEC_OP_ FT_Pos  dx,
                       FT_Pos  dy )
   {
     FT_UNUSED_EXEC;
     FT_UNUSED( dx );
 
     return dy;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    Compute_Funcs                                                      */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Computes the projection and movement function pointers according   */
   /*    to the current graphics state.                                     */
   /*                                                                       */
   static void
   Compute_Funcs( EXEC_OP )
   {
 #ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
     if ( CUR.face->unpatented_hinting )
     {
       /* If both vectors point rightwards along the x axis, set             */
       /* `both-x-axis' true, otherwise set it false.  The x values only     */
       /* need be tested because the vector has been normalised to a unit    */
       /* vector of length 0x4000 = unity.                                   */
       CUR.GS.both_x_axis = (FT_Bool)( CUR.GS.projVector.x == 0x4000 &&
                                       CUR.GS.freeVector.x == 0x4000 );
 
       /* Throw away projection and freedom vector information */
       /* because the patents don't allow them to be stored.   */
       /* The relevant US Patents are 5155805 and 5325479.     */
       CUR.GS.projVector.x = 0;
       CUR.GS.projVector.y = 0;
       CUR.GS.freeVector.x = 0;
       CUR.GS.freeVector.y = 0;
 
       if ( CUR.GS.both_x_axis )
       {
         CUR.func_project   = Project_x;
         CUR.func_move      = Direct_Move_X;
         CUR.func_move_orig = Direct_Move_Orig_X;
       }
       else
       {
         CUR.func_project   = Project_y;
         CUR.func_move      = Direct_Move_Y;
         CUR.func_move_orig = Direct_Move_Orig_Y;
       }
 
       if ( CUR.GS.dualVector.x == 0x4000 )
         CUR.func_dualproj = Project_x;
       else
       {
         if ( CUR.GS.dualVector.y == 0x4000 )
           CUR.func_dualproj = Project_y;
         else
           CUR.func_dualproj = Dual_Project;
       }
 
       /* Force recalculation of cached aspect ratio */
       CUR.tt_metrics.ratio = 0;
 
       return;
     }
 #endif /* TT_CONFIG_OPTION_UNPATENTED_HINTING */
 
     if ( CUR.GS.freeVector.x == 0x4000 )
       CUR.F_dot_P       = CUR.GS.projVector.x * 0x10000L;
     else
     {
       if ( CUR.GS.freeVector.y == 0x4000 )
         CUR.F_dot_P       = CUR.GS.projVector.y * 0x10000L;
       else
         CUR.F_dot_P = (FT_Long)CUR.GS.projVector.x * CUR.GS.freeVector.x * 4 +
                       (FT_Long)CUR.GS.projVector.y * CUR.GS.freeVector.y * 4;
     }
 
     if ( CUR.GS.projVector.x == 0x4000 )
       CUR.func_project = (TT_Project_Func)Project_x;
     else
     {
       if ( CUR.GS.projVector.y == 0x4000 )
         CUR.func_project = (TT_Project_Func)Project_y;
       else
         CUR.func_project = (TT_Project_Func)Project;
     }
 
     if ( CUR.GS.dualVector.x == 0x4000 )
       CUR.func_dualproj = (TT_Project_Func)Project_x;
     else
     {
       if ( CUR.GS.dualVector.y == 0x4000 )
         CUR.func_dualproj = (TT_Project_Func)Project_y;
       else
         CUR.func_dualproj = (TT_Project_Func)Dual_Project;
     }
 
     CUR.func_move      = (TT_Move_Func)Direct_Move;
     CUR.func_move_orig = (TT_Move_Func)Direct_Move_Orig;
 
     if ( CUR.F_dot_P == 0x40000000L )
     {
       if ( CUR.GS.freeVector.x == 0x4000 )
       {
         CUR.func_move      = (TT_Move_Func)Direct_Move_X;
         CUR.func_move_orig = (TT_Move_Func)Direct_Move_Orig_X;
       }
       else
       {
         if ( CUR.GS.freeVector.y == 0x4000 )
         {
           CUR.func_move      = (TT_Move_Func)Direct_Move_Y;
           CUR.func_move_orig = (TT_Move_Func)Direct_Move_Orig_Y;
         }
       }
     }
 
     /* at small sizes, F_dot_P can become too small, resulting   */
     /* in overflows and `spikes' in a number of glyphs like `w'. */
 
     if ( FT_ABS( CUR.F_dot_P ) < 0x4000000L )
       CUR.F_dot_P = 0x40000000L;
 
     /* Disable cached aspect ratio */
     CUR.tt_metrics.ratio = 0;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    Normalize                                                          */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Norms a vector.                                                    */
   /*                                                                       */
   /* <Input>                                                               */
   /*    Vx :: The horizontal input vector coordinate.                      */
   /*    Vy :: The vertical input vector coordinate.                        */
   /*                                                                       */
   /* <Output>                                                              */
   /*    R  :: The normed unit vector.                                      */
   /*                                                                       */
   /* <Return>                                                              */
   /*    Returns FAILURE if a vector parameter is zero.                     */
   /*                                                                       */
   /* <Note>                                                                */
   /*    In case Vx and Vy are both zero, Normalize() returns SUCCESS, and  */
   /*    R is undefined.                                                    */
   /*                                                                       */
 
 
   static FT_Bool
   Normalize( EXEC_OP_ FT_F26Dot6      Vx,
                       FT_F26Dot6      Vy,
                       FT_UnitVector*  R )
   {
     FT_F26Dot6  W;
     FT_Bool     S1, S2;
 
     FT_UNUSED_EXEC;
 
 
     if ( FT_ABS( Vx ) < 0x10000L && FT_ABS( Vy ) < 0x10000L )
     {
       Vx *= 0x100;
       Vy *= 0x100;
 
       W = TT_VecLen( Vx, Vy );
 
       if ( W == 0 )
       {
         /* XXX: UNDOCUMENTED! It seems that it is possible to try   */
         /*      to normalize the vector (0,0).  Return immediately. */
         return SUCCESS;
       }
 
       R->x = (FT_F2Dot14)FT_MulDiv( Vx, 0x4000L, W );
       R->y = (FT_F2Dot14)FT_MulDiv( Vy, 0x4000L, W );
 
       return SUCCESS;
     }
 
     W = TT_VecLen( Vx, Vy );
 
     Vx = FT_MulDiv( Vx, 0x4000L, W );
     Vy = FT_MulDiv( Vy, 0x4000L, W );
 
     W = Vx * Vx + Vy * Vy;
 
     /* Now, we want that Sqrt( W ) = 0x4000 */
     /* Or 0x10000000 <= W < 0x10004000        */
 
     if ( Vx < 0 )
     {
       Vx = -Vx;
       S1 = TRUE;
     }
     else
       S1 = FALSE;
 
     if ( Vy < 0 )
     {
       Vy = -Vy;
       S2 = TRUE;
     }
     else
       S2 = FALSE;
 
     while ( W < 0x10000000L )
     {
       /* We need to increase W by a minimal amount */
       if ( Vx < Vy )
         Vx++;
       else
         Vy++;
 
       W = Vx * Vx + Vy * Vy;
     }
 
     while ( W >= 0x10004000L )
     {
       /* We need to decrease W by a minimal amount */
       if ( Vx < Vy )
         Vx--;
       else
         Vy--;
 
       W = Vx * Vx + Vy * Vy;
     }
 
     /* Note that in various cases, we can only  */
     /* compute a Sqrt(W) of 0x3FFF, eg. Vx = Vy */
 
     if ( S1 )
       Vx = -Vx;
 
     if ( S2 )
       Vy = -Vy;
 
     R->x = (FT_F2Dot14)Vx;   /* Type conversion */
     R->y = (FT_F2Dot14)Vy;   /* Type conversion */
 
     return SUCCESS;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* Here we start with the implementation of the various opcodes.         */
   /*                                                                       */
   /*************************************************************************/
 
 
   static FT_Bool
   Ins_SxVTL( EXEC_OP_ FT_UShort       aIdx1,
                       FT_UShort       aIdx2,
                       FT_Int          aOpc,
                       FT_UnitVector*  Vec )
   {
     FT_Long     A, B, C;
     FT_Vector*  p1;
     FT_Vector*  p2;
 
 
     if ( BOUNDS( aIdx1, CUR.zp2.n_points ) ||
          BOUNDS( aIdx2, CUR.zp1.n_points ) )
     {
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
       return FAILURE;
     }
 
     p1 = CUR.zp1.cur + aIdx2;
     p2 = CUR.zp2.cur + aIdx1;
 
     A = p1->x - p2->x;
     B = p1->y - p2->y;
 
     if ( ( aOpc & 1 ) != 0 )
     {
       C =  B;   /* counter clockwise rotation */
       B =  A;
       A = -C;
     }
 
     NORMalize( A, B, Vec );
 
     return SUCCESS;
   }
 
 
   /* When not using the big switch statements, the interpreter uses a */
   /* call table defined later below in this source.  Each opcode must */
   /* thus have a corresponding function, even trivial ones.           */
   /*                                                                  */
   /* They are all defined there.                                      */
 
 #define DO_SVTCA                            \
   {                                         \
     FT_Short  A, B;                         \
                                             \
                                             \
     A = (FT_Short)( CUR.opcode & 1 ) << 14; \
     B = A ^ (FT_Short)0x4000;               \
                                             \
     CUR.GS.freeVector.x = A;                \
     CUR.GS.projVector.x = A;                \
     CUR.GS.dualVector.x = A;                \
                                             \
     CUR.GS.freeVector.y = B;                \
     CUR.GS.projVector.y = B;                \
     CUR.GS.dualVector.y = B;                \
                                             \
     COMPUTE_Funcs();                        \
   }
 
 
 #define DO_SPVTCA                           \
   {                                         \
     FT_Short  A, B;                         \
                                             \
                                             \
     A = (FT_Short)( CUR.opcode & 1 ) << 14; \
     B = A ^ (FT_Short)0x4000;               \
                                             \
     CUR.GS.projVector.x = A;                \
     CUR.GS.dualVector.x = A;                \
                                             \
     CUR.GS.projVector.y = B;                \
     CUR.GS.dualVector.y = B;                \
                                             \
     GUESS_VECTOR( freeVector );             \
                                             \
     COMPUTE_Funcs();                        \
   }
 
 
 #define DO_SFVTCA                           \
   {                                         \
     FT_Short  A, B;                         \
                                             \
                                             \
     A = (FT_Short)( CUR.opcode & 1 ) << 14; \
     B = A ^ (FT_Short)0x4000;               \
                                             \
     CUR.GS.freeVector.x = A;                \
     CUR.GS.freeVector.y = B;                \
                                             \
     GUESS_VECTOR( projVector );             \
                                             \
     COMPUTE_Funcs();                        \
   }
 
 
 #define DO_SPVTL                                      \
     if ( INS_SxVTL( (FT_UShort)args[1],               \
                     (FT_UShort)args[0],               \
                     CUR.opcode,                       \
                     &CUR.GS.projVector ) == SUCCESS ) \
     {                                                 \
       CUR.GS.dualVector = CUR.GS.projVector;          \
       GUESS_VECTOR( freeVector );                     \
       COMPUTE_Funcs();                                \
     }
 
 
 #define DO_SFVTL                                      \
     if ( INS_SxVTL( (FT_UShort)args[1],               \
                     (FT_UShort)args[0],               \
                     CUR.opcode,                       \
                     &CUR.GS.freeVector ) == SUCCESS ) \
     {                                                 \
       GUESS_VECTOR( projVector );                     \
       COMPUTE_Funcs();                                \
     }
 
 
 #define DO_SFVTPV                          \
     GUESS_VECTOR( projVector );            \
     CUR.GS.freeVector = CUR.GS.projVector; \
     COMPUTE_Funcs();
 
 
 #define DO_SPVFS                                \
   {                                             \
     FT_Short  S;                                \
     FT_Long   X, Y;                             \
                                                 \
                                                 \
     /* Only use low 16bits, then sign extend */ \
     S = (FT_Short)args[1];                      \
     Y = (FT_Long)S;                             \
     S = (FT_Short)args[0];                      \
     X = (FT_Long)S;                             \
                                                 \
     NORMalize( X, Y, &CUR.GS.projVector );      \
                                                 \
     CUR.GS.dualVector = CUR.GS.projVector;      \
     GUESS_VECTOR( freeVector );                 \
     COMPUTE_Funcs();                            \
   }
 
 
 #define DO_SFVFS                                \
   {                                             \
     FT_Short  S;                                \
     FT_Long   X, Y;                             \
                                                 \
                                                 \
     /* Only use low 16bits, then sign extend */ \
     S = (FT_Short)args[1];                      \
     Y = (FT_Long)S;                             \
     S = (FT_Short)args[0];                      \
     X = S;                                      \
                                                 \
     NORMalize( X, Y, &CUR.GS.freeVector );      \
     GUESS_VECTOR( projVector );                 \
     COMPUTE_Funcs();                            \
   }
 
 
 #ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
 #define DO_GPV                                   \
     if ( CUR.face->unpatented_hinting )          \
     {                                            \
       args[0] = CUR.GS.both_x_axis ? 0x4000 : 0; \
       args[1] = CUR.GS.both_x_axis ? 0 : 0x4000; \
     }                                            \
     else                                         \
     {                                            \
       args[0] = CUR.GS.projVector.x;             \
       args[1] = CUR.GS.projVector.y;             \
     }
 #else
 #define DO_GPV                                   \
     args[0] = CUR.GS.projVector.x;               \
     args[1] = CUR.GS.projVector.y;
 #endif
 
 
 #ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
 #define DO_GFV                                   \
     if ( CUR.face->unpatented_hinting )          \
     {                                            \
       args[0] = CUR.GS.both_x_axis ? 0x4000 : 0; \
       args[1] = CUR.GS.both_x_axis ? 0 : 0x4000; \
     }                                            \
     else                                         \
     {                                            \
       args[0] = CUR.GS.freeVector.x;             \
       args[1] = CUR.GS.freeVector.y;             \
     }
 #else
 #define DO_GFV                                   \
     args[0] = CUR.GS.freeVector.x;               \
     args[1] = CUR.GS.freeVector.y;
 #endif
 
 
 #define DO_SRP0                      \
     CUR.GS.rp0 = (FT_UShort)args[0];
 
 
 #define DO_SRP1                      \
     CUR.GS.rp1 = (FT_UShort)args[0];
 
 
 #define DO_SRP2                      \
     CUR.GS.rp2 = (FT_UShort)args[0];
 
 
 #define DO_RTHG                                         \
     CUR.GS.round_state = TT_Round_To_Half_Grid;         \
     CUR.func_round = (TT_Round_Func)Round_To_Half_Grid;
 
 
 #define DO_RTG                                     \
     CUR.GS.round_state = TT_Round_To_Grid;         \
     CUR.func_round = (TT_Round_Func)Round_To_Grid;
 
 
 #define DO_RTDG                                           \
     CUR.GS.round_state = TT_Round_To_Double_Grid;         \
     CUR.func_round = (TT_Round_Func)Round_To_Double_Grid;
 
 
 #define DO_RUTG                                       \
     CUR.GS.round_state = TT_Round_Up_To_Grid;         \
     CUR.func_round = (TT_Round_Func)Round_Up_To_Grid;
 
 
 #define DO_RDTG                                         \
     CUR.GS.round_state = TT_Round_Down_To_Grid;         \
     CUR.func_round = (TT_Round_Func)Round_Down_To_Grid;
 
 
 #define DO_ROFF                                 \
     CUR.GS.round_state = TT_Round_Off;          \
     CUR.func_round = (TT_Round_Func)Round_None;
 
 
 #define DO_SROUND                                \
     SET_SuperRound( 0x4000, args[0] );           \
     CUR.GS.round_state = TT_Round_Super;         \
     CUR.func_round = (TT_Round_Func)Round_Super;
 
 
 #define DO_S45ROUND                                 \
     SET_SuperRound( 0x2D41, args[0] );              \
     CUR.GS.round_state = TT_Round_Super_45;         \
     CUR.func_round = (TT_Round_Func)Round_Super_45;
 
 
 #define DO_SLOOP                       \
     if ( args[0] < 0 )                 \
       CUR.error = TT_Err_Bad_Argument; \
     else                               \
       CUR.GS.loop = args[0];
 
 
 #define DO_SMD                         \
     CUR.GS.minimum_distance = args[0];
 
 
 #define DO_SCVTCI                                     \
     CUR.GS.control_value_cutin = (FT_F26Dot6)args[0];
 
 
 #define DO_SSWCI                                     \
     CUR.GS.single_width_cutin = (FT_F26Dot6)args[0];
 
 
     /* XXX: UNDOCUMENTED! or bug in the Windows engine?   */
     /*                                                    */
     /*      It seems that the value that is read here is  */
     /*      expressed in 16.16 format rather than in font */
     /*      units.                                        */
     /*                                                    */
 #define DO_SSW                                                 \
     CUR.GS.single_width_value = (FT_F26Dot6)( args[0] >> 10 );
 
 
 #define DO_FLIPON            \
     CUR.GS.auto_flip = TRUE;
 
 
 #define DO_FLIPOFF            \
     CUR.GS.auto_flip = FALSE;
 
 
 #define DO_SDB                             \
     CUR.GS.delta_base = (FT_Short)args[0];
 
 
 #define DO_SDS                              \
     CUR.GS.delta_shift = (FT_Short)args[0];
 
 
 #define DO_MD  /* nothing */
 
 
 #define DO_MPPEM              \
     args[0] = CURRENT_Ppem();
 
 
   /* Note: The pointSize should be irrelevant in a given font program; */
   /*       we thus decide to return only the ppem.                     */
 #if 0
 
 #define DO_MPS                       \
     args[0] = CUR.metrics.pointSize;
 
 #else
 
 #define DO_MPS                \
     args[0] = CURRENT_Ppem();
 
 #endif /* 0 */
 
 
 #define DO_DUP         \
     args[1] = args[0];
 
 
 #define DO_CLEAR     \
     CUR.new_top = 0;
 
 
 #define DO_SWAP        \
   {                    \
     FT_Long  L;        \
                        \
                        \
     L       = args[0]; \
     args[0] = args[1]; \
     args[1] = L;       \
   }
 
 
 #define DO_DEPTH       \
     args[0] = CUR.top;
 
 
 #define DO_CINDEX                           \
   {                                         \
     FT_Long  L;                             \
                                             \
                                             \
     L = args[0];                            \
                                             \
     if ( L <= 0 || L > CUR.args )           \
       CUR.error = TT_Err_Invalid_Reference; \
     else                                    \
       args[0] = CUR.stack[CUR.args - L];    \
   }
 
 
 #define DO_JROT                          \
     if ( args[1] != 0 )                  \
     {                                    \
       CUR.IP      += args[0];            \
       if ( CUR.IP < 0 )                  \
         CUR.error = TT_Err_Bad_Argument; \
       CUR.step_ins = FALSE;              \
     }
 
 
 #define DO_JMPR                        \
     CUR.IP      += args[0];            \
     if ( CUR.IP < 0 )                  \
       CUR.error = TT_Err_Bad_Argument; \
     CUR.step_ins = FALSE;
 
 
 #define DO_JROF                          \
     if ( args[1] == 0 )                  \
     {                                    \
       CUR.IP      += args[0];            \
       if ( CUR.IP < 0 )                  \
         CUR.error = TT_Err_Bad_Argument; \
       CUR.step_ins = FALSE;              \
     }
 
 
 #define DO_LT                        \
     args[0] = ( args[0] < args[1] );
 
 
 #define DO_LTEQ                       \
     args[0] = ( args[0] <= args[1] );
 
 
 #define DO_GT                        \
     args[0] = ( args[0] > args[1] );
 
 
 #define DO_GTEQ                       \
     args[0] = ( args[0] >= args[1] );
 
 
 #define DO_EQ                         \
     args[0] = ( args[0] == args[1] );
 
 
 #define DO_NEQ                        \
     args[0] = ( args[0] != args[1] );
 
 
 #define DO_ODD                                                  \
     args[0] = ( ( CUR_Func_round( args[0], 0 ) & 127 ) == 64 );
 
 
 #define DO_EVEN                                                \
     args[0] = ( ( CUR_Func_round( args[0], 0 ) & 127 ) == 0 );
 
 
 #define DO_AND                        \
     args[0] = ( args[0] && args[1] );
 
 
 #define DO_OR                         \
     args[0] = ( args[0] || args[1] );
 
 
 #define DO_NOT          \
     args[0] = !args[0];
 
 
 #define DO_ADD          \
     args[0] += args[1];
 
 
 #define DO_SUB          \
     args[0] -= args[1];
 
 
 #define DO_DIV                                               \
     if ( args[1] == 0 )                                      \
       CUR.error = TT_Err_Divide_By_Zero;                     \
     else                                                     \
       args[0] = TT_MULDIV_NO_ROUND( args[0], 64L, args[1] );
 
 
 #define DO_MUL                                    \
     args[0] = TT_MULDIV( args[0], args[1], 64L );
 
 
 #define DO_ABS                   \
     args[0] = FT_ABS( args[0] );
 
 
 #define DO_NEG          \
     args[0] = -args[0];
 
 
 #define DO_FLOOR    \
     args[0] = FT_PIX_FLOOR( args[0] );
 
 
 #define DO_CEILING                    \
     args[0] = FT_PIX_CEIL( args[0] );
 
 
 #define DO_RS                          \
    {                                   \
      FT_ULong  I = (FT_ULong)args[0];  \
                                        \
                                        \
      if ( BOUNDS( I, CUR.storeSize ) ) \
      {                                 \
        if ( CUR.pedantic_hinting )     \
        {                               \
          ARRAY_BOUND_ERROR;            \
        }                               \
        else                            \
          args[0] = 0;                  \
      }                                 \
      else                              \
        args[0] = CUR.storage[I];       \
    }
 
 
 #define DO_WS                          \
    {                                   \
      FT_ULong  I = (FT_ULong)args[0];  \
                                        \
                                        \
      if ( BOUNDS( I, CUR.storeSize ) ) \
      {                                 \
        if ( CUR.pedantic_hinting )     \
        {                               \
          ARRAY_BOUND_ERROR;            \
        }                               \
      }                                 \
      else                              \
        CUR.storage[I] = args[1];       \
    }
 
 
 #define DO_RCVT                          \
    {                                     \
      FT_ULong  I = (FT_ULong)args[0];    \
                                          \
                                          \
      if ( BOUNDS( I, CUR.cvtSize ) )     \
      {                                   \
        if ( CUR.pedantic_hinting )       \
        {                                 \
          ARRAY_BOUND_ERROR;              \
        }                                 \
        else                              \
          args[0] = 0;                    \
      }                                   \
      else                                \
        args[0] = CUR_Func_read_cvt( I ); \
    }
 
 
 #define DO_WCVTP                         \
    {                                     \
      FT_ULong  I = (FT_ULong)args[0];    \
                                          \
                                          \
      if ( BOUNDS( I, CUR.cvtSize ) )     \
      {                                   \
        if ( CUR.pedantic_hinting )       \
        {                                 \
          ARRAY_BOUND_ERROR;              \
        }                                 \
      }                                   \
      else                                \
        CUR_Func_write_cvt( I, args[1] ); \
    }
 
 
 #define DO_WCVTF                                                \
    {                                                            \
      FT_ULong  I = (FT_ULong)args[0];                           \
                                                                 \
                                                                 \
      if ( BOUNDS( I, CUR.cvtSize ) )                            \
      {                                                          \
        if ( CUR.pedantic_hinting )                              \
        {                                                        \
          ARRAY_BOUND_ERROR;                                     \
        }                                                        \
      }                                                          \
      else                                                       \
        CUR.cvt[I] = TT_MULFIX( args[1], CUR.tt_metrics.scale ); \
    }
 
 
 #define DO_DEBUG                     \
     CUR.error = TT_Err_Debug_OpCode;
 
 
 #define DO_ROUND                                                   \
     args[0] = CUR_Func_round(                                      \
                 args[0],                                           \
                 CUR.tt_metrics.compensations[CUR.opcode - 0x68] );
 
 
 #define DO_NROUND                                                            \
     args[0] = ROUND_None( args[0],                                           \
                           CUR.tt_metrics.compensations[CUR.opcode - 0x6C] );
 
 
 #define DO_MAX               \
     if ( args[1] > args[0] ) \
       args[0] = args[1];
 
 
 #define DO_MIN               \
     if ( args[1] < args[0] ) \
       args[0] = args[1];
 
 
 #ifndef TT_CONFIG_OPTION_INTERPRETER_SWITCH
 
 
 #undef  ARRAY_BOUND_ERROR
 #define ARRAY_BOUND_ERROR                   \
     {                                       \
       CUR.error = TT_Err_Invalid_Reference; \
       return;                               \
     }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SVTCA[a]:     Set (F and P) Vectors to Coordinate Axis                */
   /* Opcode range: 0x00-0x01                                               */
   /* Stack:        -->                                                     */
   /*                                                                       */
   static void
   Ins_SVTCA( INS_ARG )
   {
     DO_SVTCA
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SPVTCA[a]:    Set PVector to Coordinate Axis                          */
   /* Opcode range: 0x02-0x03                                               */
   /* Stack:        -->                                                     */
   /*                                                                       */
   static void
   Ins_SPVTCA( INS_ARG )
   {
     DO_SPVTCA
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SFVTCA[a]:    Set FVector to Coordinate Axis                          */
   /* Opcode range: 0x04-0x05                                               */
   /* Stack:        -->                                                     */
   /*                                                                       */
   static void
   Ins_SFVTCA( INS_ARG )
   {
     DO_SFVTCA
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SPVTL[a]:     Set PVector To Line                                     */
   /* Opcode range: 0x06-0x07                                               */
   /* Stack:        uint32 uint32 -->                                       */
   /*                                                                       */
   static void
   Ins_SPVTL( INS_ARG )
   {
     DO_SPVTL
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SFVTL[a]:     Set FVector To Line                                     */
   /* Opcode range: 0x08-0x09                                               */
   /* Stack:        uint32 uint32 -->                                       */
   /*                                                                       */
   static void
   Ins_SFVTL( INS_ARG )
   {
     DO_SFVTL
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SFVTPV[]:     Set FVector To PVector                                  */
   /* Opcode range: 0x0E                                                    */
   /* Stack:        -->                                                     */
   /*                                                                       */
   static void
   Ins_SFVTPV( INS_ARG )
   {
     DO_SFVTPV
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SPVFS[]:      Set PVector From Stack                                  */
   /* Opcode range: 0x0A                                                    */
   /* Stack:        f2.14 f2.14 -->                                         */
   /*                                                                       */
   static void
   Ins_SPVFS( INS_ARG )
   {
     DO_SPVFS
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SFVFS[]:      Set FVector From Stack                                  */
   /* Opcode range: 0x0B                                                    */
   /* Stack:        f2.14 f2.14 -->                                         */
   /*                                                                       */
   static void
   Ins_SFVFS( INS_ARG )
   {
     DO_SFVFS
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* GPV[]:        Get Projection Vector                                   */
   /* Opcode range: 0x0C                                                    */
   /* Stack:        ef2.14 --> ef2.14                                       */
   /*                                                                       */
   static void
   Ins_GPV( INS_ARG )
   {
     DO_GPV
   }
 
 
   /*************************************************************************/
   /* GFV[]:        Get Freedom Vector                                      */
   /* Opcode range: 0x0D                                                    */
   /* Stack:        ef2.14 --> ef2.14                                       */
   /*                                                                       */
   static void
   Ins_GFV( INS_ARG )
   {
     DO_GFV
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SRP0[]:       Set Reference Point 0                                   */
   /* Opcode range: 0x10                                                    */
   /* Stack:        uint32 -->                                              */
   /*                                                                       */
   static void
   Ins_SRP0( INS_ARG )
   {
     DO_SRP0
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SRP1[]:       Set Reference Point 1                                   */
   /* Opcode range: 0x11                                                    */
   /* Stack:        uint32 -->                                              */
   /*                                                                       */
   static void
   Ins_SRP1( INS_ARG )
   {
     DO_SRP1
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SRP2[]:       Set Reference Point 2                                   */
   /* Opcode range: 0x12                                                    */
   /* Stack:        uint32 -->                                              */
   /*                                                                       */
   static void
   Ins_SRP2( INS_ARG )
   {
     DO_SRP2
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* RTHG[]:       Round To Half Grid                                      */
   /* Opcode range: 0x19                                                    */
   /* Stack:        -->                                                     */
   /*                                                                       */
   static void
   Ins_RTHG( INS_ARG )
   {
     DO_RTHG
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* RTG[]:        Round To Grid                                           */
   /* Opcode range: 0x18                                                    */
   /* Stack:        -->                                                     */
   /*                                                                       */
   static void
   Ins_RTG( INS_ARG )
   {
     DO_RTG
   }
 
 
   /*************************************************************************/
   /* RTDG[]:       Round To Double Grid                                    */
   /* Opcode range: 0x3D                                                    */
   /* Stack:        -->                                                     */
   /*                                                                       */
   static void
   Ins_RTDG( INS_ARG )
   {
     DO_RTDG
   }
 
 
   /*************************************************************************/
   /* RUTG[]:       Round Up To Grid                                        */
   /* Opcode range: 0x7C                                                    */
   /* Stack:        -->                                                     */
   /*                                                                       */
   static void
   Ins_RUTG( INS_ARG )
   {
     DO_RUTG
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* RDTG[]:       Round Down To Grid                                      */
   /* Opcode range: 0x7D                                                    */
   /* Stack:        -->                                                     */
   /*                                                                       */
   static void
   Ins_RDTG( INS_ARG )
   {
     DO_RDTG
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* ROFF[]:       Round OFF                                               */
   /* Opcode range: 0x7A                                                    */
   /* Stack:        -->                                                     */
   /*                                                                       */
   static void
   Ins_ROFF( INS_ARG )
   {
     DO_ROFF
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SROUND[]:     Super ROUND                                             */
   /* Opcode range: 0x76                                                    */
   /* Stack:        Eint8 -->                                               */
   /*                                                                       */
   static void
   Ins_SROUND( INS_ARG )
   {
     DO_SROUND
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* S45ROUND[]:   Super ROUND 45 degrees                                  */
   /* Opcode range: 0x77                                                    */
   /* Stack:        uint32 -->                                              */
   /*                                                                       */
   static void
   Ins_S45ROUND( INS_ARG )
   {
     DO_S45ROUND
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SLOOP[]:      Set LOOP variable                                       */
   /* Opcode range: 0x17                                                    */
   /* Stack:        int32? -->                                              */
   /*                                                                       */
   static void
   Ins_SLOOP( INS_ARG )
   {
     DO_SLOOP
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SMD[]:        Set Minimum Distance                                    */
   /* Opcode range: 0x1A                                                    */
   /* Stack:        f26.6 -->                                               */
   /*                                                                       */
   static void
   Ins_SMD( INS_ARG )
   {
     DO_SMD
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SCVTCI[]:     Set Control Value Table Cut In                          */
   /* Opcode range: 0x1D                                                    */
   /* Stack:        f26.6 -->                                               */
   /*                                                                       */
   static void
   Ins_SCVTCI( INS_ARG )
   {
     DO_SCVTCI
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SSWCI[]:      Set Single Width Cut In                                 */
   /* Opcode range: 0x1E                                                    */
   /* Stack:        f26.6 -->                                               */
   /*                                                                       */
   static void
   Ins_SSWCI( INS_ARG )
   {
     DO_SSWCI
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SSW[]:        Set Single Width                                        */
   /* Opcode range: 0x1F                                                    */
   /* Stack:        int32? -->                                              */
   /*                                                                       */
   static void
   Ins_SSW( INS_ARG )
   {
     DO_SSW
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* FLIPON[]:     Set auto-FLIP to ON                                     */
   /* Opcode range: 0x4D                                                    */
   /* Stack:        -->                                                     */
   /*                                                                       */
   static void
   Ins_FLIPON( INS_ARG )
   {
     DO_FLIPON
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* FLIPOFF[]:    Set auto-FLIP to OFF                                    */
   /* Opcode range: 0x4E                                                    */
   /* Stack: -->                                                            */
   /*                                                                       */
   static void
   Ins_FLIPOFF( INS_ARG )
   {
     DO_FLIPOFF
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SANGW[]:      Set ANGle Weight                                        */
   /* Opcode range: 0x7E                                                    */
   /* Stack:        uint32 -->                                              */
   /*                                                                       */
   static void
   Ins_SANGW( INS_ARG )
   {
     /* instruction not supported anymore */
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SDB[]:        Set Delta Base                                          */
   /* Opcode range: 0x5E                                                    */
   /* Stack:        uint32 -->                                              */
   /*                                                                       */
   static void
   Ins_SDB( INS_ARG )
   {
     DO_SDB
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SDS[]:        Set Delta Shift                                         */
   /* Opcode range: 0x5F                                                    */
   /* Stack:        uint32 -->                                              */
   /*                                                                       */
   static void
   Ins_SDS( INS_ARG )
   {
     DO_SDS
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* MPPEM[]:      Measure Pixel Per EM                                    */
   /* Opcode range: 0x4B                                                    */
   /* Stack:        --> Euint16                                             */
   /*                                                                       */
   static void
   Ins_MPPEM( INS_ARG )
   {
     DO_MPPEM
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* MPS[]:        Measure Point Size                                      */
   /* Opcode range: 0x4C                                                    */
   /* Stack:        --> Euint16                                             */
   /*                                                                       */
   static void
   Ins_MPS( INS_ARG )
   {
     DO_MPS
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* DUP[]:        DUPlicate the top stack's element                       */
   /* Opcode range: 0x20                                                    */
   /* Stack:        StkElt --> StkElt StkElt                                */
   /*                                                                       */
   static void
   Ins_DUP( INS_ARG )
   {
     DO_DUP
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* POP[]:        POP the stack's top element                             */
   /* Opcode range: 0x21                                                    */
   /* Stack:        StkElt -->                                              */
   /*                                                                       */
   static void
   Ins_POP( INS_ARG )
   {
     /* nothing to do */
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* CLEAR[]:      CLEAR the entire stack                                  */
   /* Opcode range: 0x22                                                    */
   /* Stack:        StkElt... -->                                           */
   /*                                                                       */
   static void
   Ins_CLEAR( INS_ARG )
   {
     DO_CLEAR
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SWAP[]:       SWAP the stack's top two elements                       */
   /* Opcode range: 0x23                                                    */
   /* Stack:        2 * StkElt --> 2 * StkElt                               */
   /*                                                                       */
   static void
   Ins_SWAP( INS_ARG )
   {
     DO_SWAP
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* DEPTH[]:      return the stack DEPTH                                  */
   /* Opcode range: 0x24                                                    */
   /* Stack:        --> uint32                                              */
   /*                                                                       */
   static void
   Ins_DEPTH( INS_ARG )
   {
     DO_DEPTH
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* CINDEX[]:     Copy INDEXed element                                    */
   /* Opcode range: 0x25                                                    */
   /* Stack:        int32 --> StkElt                                        */
   /*                                                                       */
   static void
   Ins_CINDEX( INS_ARG )
   {
     DO_CINDEX
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* EIF[]:        End IF                                                  */
   /* Opcode range: 0x59                                                    */
   /* Stack:        -->                                                     */
   /*                                                                       */
   static void
   Ins_EIF( INS_ARG )
   {
     /* nothing to do */
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* JROT[]:       Jump Relative On True                                   */
   /* Opcode range: 0x78                                                    */
   /* Stack:        StkElt int32 -->                                        */
   /*                                                                       */
   static void
   Ins_JROT( INS_ARG )
   {
     DO_JROT
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* JMPR[]:       JuMP Relative                                           */
   /* Opcode range: 0x1C                                                    */
   /* Stack:        int32 -->                                               */
   /*                                                                       */
   static void
   Ins_JMPR( INS_ARG )
   {
     DO_JMPR
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* JROF[]:       Jump Relative On False                                  */
   /* Opcode range: 0x79                                                    */
   /* Stack:        StkElt int32 -->                                        */
   /*                                                                       */
   static void
   Ins_JROF( INS_ARG )
   {
     DO_JROF
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* LT[]:         Less Than                                               */
   /* Opcode range: 0x50                                                    */
   /* Stack:        int32? int32? --> bool                                  */
   /*                                                                       */
   static void
   Ins_LT( INS_ARG )
   {
     DO_LT
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* LTEQ[]:       Less Than or EQual                                      */
   /* Opcode range: 0x51                                                    */
   /* Stack:        int32? int32? --> bool                                  */
   /*                                                                       */
   static void
   Ins_LTEQ( INS_ARG )
   {
     DO_LTEQ
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* GT[]:         Greater Than                                            */
   /* Opcode range: 0x52                                                    */
   /* Stack:        int32? int32? --> bool                                  */
   /*                                                                       */
   static void
   Ins_GT( INS_ARG )
   {
     DO_GT
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* GTEQ[]:       Greater Than or EQual                                   */
   /* Opcode range: 0x53                                                    */
   /* Stack:        int32? int32? --> bool                                  */
   /*                                                                       */
   static void
   Ins_GTEQ( INS_ARG )
   {
     DO_GTEQ
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* EQ[]:         EQual                                                   */
   /* Opcode range: 0x54                                                    */
   /* Stack:        StkElt StkElt --> bool                                  */
   /*                                                                       */
   static void
   Ins_EQ( INS_ARG )
   {
     DO_EQ
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* NEQ[]:        Not EQual                                               */
   /* Opcode range: 0x55                                                    */
   /* Stack:        StkElt StkElt --> bool                                  */
   /*                                                                       */
   static void
   Ins_NEQ( INS_ARG )
   {
     DO_NEQ
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* ODD[]:        Is ODD                                                  */
   /* Opcode range: 0x56                                                    */
   /* Stack:        f26.6 --> bool                                          */
   /*                                                                       */
   static void
   Ins_ODD( INS_ARG )
   {
     DO_ODD
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* EVEN[]:       Is EVEN                                                 */
   /* Opcode range: 0x57                                                    */
   /* Stack:        f26.6 --> bool                                          */
   /*                                                                       */
   static void
   Ins_EVEN( INS_ARG )
   {
     DO_EVEN
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* AND[]:        logical AND                                             */
   /* Opcode range: 0x5A                                                    */
   /* Stack:        uint32 uint32 --> uint32                                */
   /*                                                                       */
   static void
   Ins_AND( INS_ARG )
   {
     DO_AND
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* OR[]:         logical OR                                              */
   /* Opcode range: 0x5B                                                    */
   /* Stack:        uint32 uint32 --> uint32                                */
   /*                                                                       */
   static void
   Ins_OR( INS_ARG )
   {
     DO_OR
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* NOT[]:        logical NOT                                             */
   /* Opcode range: 0x5C                                                    */
   /* Stack:        StkElt --> uint32                                       */
   /*                                                                       */
   static void
   Ins_NOT( INS_ARG )
   {
     DO_NOT
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* ADD[]:        ADD                                                     */
   /* Opcode range: 0x60                                                    */
   /* Stack:        f26.6 f26.6 --> f26.6                                   */
   /*                                                                       */
   static void
   Ins_ADD( INS_ARG )
   {
     DO_ADD
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SUB[]:        SUBtract                                                */
   /* Opcode range: 0x61                                                    */
   /* Stack:        f26.6 f26.6 --> f26.6                                   */
   /*                                                                       */
   static void
   Ins_SUB( INS_ARG )
   {
     DO_SUB
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* DIV[]:        DIVide                                                  */
   /* Opcode range: 0x62                                                    */
   /* Stack:        f26.6 f26.6 --> f26.6                                   */
   /*                                                                       */
   static void
   Ins_DIV( INS_ARG )
   {
     DO_DIV
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* MUL[]:        MULtiply                                                */
   /* Opcode range: 0x63                                                    */
   /* Stack:        f26.6 f26.6 --> f26.6                                   */
   /*                                                                       */
   static void
   Ins_MUL( INS_ARG )
   {
     DO_MUL
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* ABS[]:        ABSolute value                                          */
   /* Opcode range: 0x64                                                    */
   /* Stack:        f26.6 --> f26.6                                         */
   /*                                                                       */
   static void
   Ins_ABS( INS_ARG )
   {
     DO_ABS
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* NEG[]:        NEGate                                                  */
   /* Opcode range: 0x65                                                    */
   /* Stack: f26.6 --> f26.6                                                */
   /*                                                                       */
   static void
   Ins_NEG( INS_ARG )
   {
     DO_NEG
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* FLOOR[]:      FLOOR                                                   */
   /* Opcode range: 0x66                                                    */
   /* Stack:        f26.6 --> f26.6                                         */
   /*                                                                       */
   static void
   Ins_FLOOR( INS_ARG )
   {
     DO_FLOOR
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* CEILING[]:    CEILING                                                 */
   /* Opcode range: 0x67                                                    */
   /* Stack:        f26.6 --> f26.6                                         */
   /*                                                                       */
   static void
   Ins_CEILING( INS_ARG )
   {
     DO_CEILING
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* RS[]:         Read Store                                              */
   /* Opcode range: 0x43                                                    */
   /* Stack:        uint32 --> uint32                                       */
   /*                                                                       */
   static void
   Ins_RS( INS_ARG )
   {
     DO_RS
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* WS[]:         Write Store                                             */
   /* Opcode range: 0x42                                                    */
   /* Stack:        uint32 uint32 -->                                       */
   /*                                                                       */
   static void
   Ins_WS( INS_ARG )
   {
     DO_WS
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* WCVTP[]:      Write CVT in Pixel units                                */
   /* Opcode range: 0x44                                                    */
   /* Stack:        f26.6 uint32 -->                                        */
   /*                                                                       */
   static void
   Ins_WCVTP( INS_ARG )
   {
     DO_WCVTP
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* WCVTF[]:      Write CVT in Funits                                     */
   /* Opcode range: 0x70                                                    */
   /* Stack:        uint32 uint32 -->                                       */
   /*                                                                       */
   static void
   Ins_WCVTF( INS_ARG )
   {
     DO_WCVTF
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* RCVT[]:       Read CVT                                                */
   /* Opcode range: 0x45                                                    */
   /* Stack:        uint32 --> f26.6                                        */
   /*                                                                       */
   static void
   Ins_RCVT( INS_ARG )
   {
     DO_RCVT
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* AA[]:         Adjust Angle                                            */
   /* Opcode range: 0x7F                                                    */
   /* Stack:        uint32 -->                                              */
   /*                                                                       */
   static void
   Ins_AA( INS_ARG )
   {
     /* intentionally no longer supported */
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* DEBUG[]:      DEBUG.  Unsupported.                                    */
   /* Opcode range: 0x4F                                                    */
   /* Stack:        uint32 -->                                              */
   /*                                                                       */
   /* Note: The original instruction pops a value from the stack.           */
   /*                                                                       */
   static void
   Ins_DEBUG( INS_ARG )
   {
     DO_DEBUG
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* ROUND[ab]:    ROUND value                                             */
   /* Opcode range: 0x68-0x6B                                               */
   /* Stack:        f26.6 --> f26.6                                         */
   /*                                                                       */
   static void
   Ins_ROUND( INS_ARG )
   {
     DO_ROUND
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* NROUND[ab]:   No ROUNDing of value                                    */
   /* Opcode range: 0x6C-0x6F                                               */
   /* Stack:        f26.6 --> f26.6                                         */
   /*                                                                       */
   static void
   Ins_NROUND( INS_ARG )
   {
     DO_NROUND
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* MAX[]:        MAXimum                                                 */
   /* Opcode range: 0x68                                                    */
   /* Stack:        int32? int32? --> int32                                 */
   /*                                                                       */
   static void
   Ins_MAX( INS_ARG )
   {
     DO_MAX
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* MIN[]:        MINimum                                                 */
   /* Opcode range: 0x69                                                    */
   /* Stack:        int32? int32? --> int32                                 */
   /*                                                                       */
   static void
   Ins_MIN( INS_ARG )
   {
     DO_MIN
   }
 
 
 #endif  /* !TT_CONFIG_OPTION_INTERPRETER_SWITCH */
 
 
   /*************************************************************************/
   /*                                                                       */
   /* The following functions are called as is within the switch statement. */
   /*                                                                       */
   /*************************************************************************/
 
 
   /*************************************************************************/
   /*                                                                       */
   /* MINDEX[]:     Move INDEXed element                                    */
   /* Opcode range: 0x26                                                    */
   /* Stack:        int32? --> StkElt                                       */
   /*                                                                       */
   static void
   Ins_MINDEX( INS_ARG )
   {
     FT_Long  L, K;
 
 
     L = args[0];
 
     if ( L <= 0 || L > CUR.args )
     {
       CUR.error = TT_Err_Invalid_Reference;
       return;
     }
 
     K = CUR.stack[CUR.args - L];
 
     FT_ARRAY_MOVE( &CUR.stack[CUR.args - L    ],
                    &CUR.stack[CUR.args - L + 1],
                    ( L - 1 ) );
 
     CUR.stack[CUR.args - 1] = K;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* ROLL[]:       ROLL top three elements                                 */
   /* Opcode range: 0x8A                                                    */
   /* Stack:        3 * StkElt --> 3 * StkElt                               */
   /*                                                                       */
   static void
   Ins_ROLL( INS_ARG )
   {
     FT_Long  A, B, C;
 
     FT_UNUSED_EXEC;
 
 
     A = args[2];
     B = args[1];
     C = args[0];
 
     args[2] = C;
     args[1] = A;
     args[0] = B;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* MANAGING THE FLOW OF CONTROL                                          */
   /*                                                                       */
   /*   Instructions appear in the specification's order.                   */
   /*                                                                       */
   /*************************************************************************/
 
 
   static FT_Bool
   SkipCode( EXEC_OP )
   {
     CUR.IP += CUR.length;
 
     if ( CUR.IP < CUR.codeSize )
     {
       CUR.opcode = CUR.code[CUR.IP];
 
       CUR.length = opcode_length[CUR.opcode];
       if ( CUR.length < 0 )
       {
         if ( CUR.IP + 1 > CUR.codeSize )
           goto Fail_Overflow;
         CUR.length = 2 - CUR.length * CUR.code[CUR.IP + 1];
       }
 
       if ( CUR.IP + CUR.length <= CUR.codeSize )
         return SUCCESS;
     }
 
   Fail_Overflow:
     CUR.error = TT_Err_Code_Overflow;
     return FAILURE;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* IF[]:         IF test                                                 */
   /* Opcode range: 0x58                                                    */
   /* Stack:        StkElt -->                                              */
   /*                                                                       */
   static void
   Ins_IF( INS_ARG )
   {
     FT_Int   nIfs;
     FT_Bool  Out;
 
 
     if ( args[0] != 0 )
       return;
 
     nIfs = 1;
     Out = 0;
 
     do
     {
       if ( SKIP_Code() == FAILURE )
         return;
 
       switch ( CUR.opcode )
       {
       case 0x58:      /* IF */
         nIfs++;
         break;
 
       case 0x1B:      /* ELSE */
         Out = FT_BOOL( nIfs == 1 );
         break;
 
       case 0x59:      /* EIF */
         nIfs--;
         Out = FT_BOOL( nIfs == 0 );
         break;
       }
     } while ( Out == 0 );
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* ELSE[]:       ELSE                                                    */
   /* Opcode range: 0x1B                                                    */
   /* Stack:        -->                                                     */
   /*                                                                       */
   static void
   Ins_ELSE( INS_ARG )
   {
     FT_Int  nIfs;
 
     FT_UNUSED_ARG;
 
 
     nIfs = 1;
 
     do
     {
       if ( SKIP_Code() == FAILURE )
         return;
 
       switch ( CUR.opcode )
       {
       case 0x58:    /* IF */
         nIfs++;
         break;
 
       case 0x59:    /* EIF */
         nIfs--;
         break;
       }
     } while ( nIfs != 0 );
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* DEFINING AND USING FUNCTIONS AND INSTRUCTIONS                         */
   /*                                                                       */
   /*   Instructions appear in the specification's order.                   */
   /*                                                                       */
   /*************************************************************************/
 
 
   /*************************************************************************/
   /*                                                                       */
   /* FDEF[]:       Function DEFinition                                     */
   /* Opcode range: 0x2C                                                    */
   /* Stack:        uint32 -->                                              */
   /*                                                                       */
   static void
   Ins_FDEF( INS_ARG )
   {
     FT_ULong       n;
     TT_DefRecord*  rec;
     TT_DefRecord*  limit;
 
 
     /* some font programs are broken enough to redefine functions! */
     /* We will then parse the current table.                       */
 
     rec   = CUR.FDefs;
     limit = rec + CUR.numFDefs;
     n     = args[0];
 
     for ( ; rec < limit; rec++ )
     {
       if ( rec->opc == n )
         break;
     }
 
     if ( rec == limit )
     {
       /* check that there is enough room for new functions */
       if ( CUR.numFDefs >= CUR.maxFDefs )
       {
         CUR.error = TT_Err_Too_Many_Function_Defs;
         return;
       }
       CUR.numFDefs++;
     }
 
     /* Although FDEF takes unsigned 32-bit integer,  */
     /* func # must be within unsigned 16-bit integer */
     if ( n > 0xFFFFU )
     {
       CUR.error = TT_Err_Too_Many_Function_Defs;
       return;
     }
 
     rec->range  = CUR.curRange;
     rec->opc    = (FT_UInt16)n;
     rec->start  = CUR.IP + 1;
     rec->active = TRUE;
 
     if ( n > CUR.maxFunc )
       CUR.maxFunc = (FT_UInt16)n;
 
     /* Now skip the whole function definition. */
     /* We don't allow nested IDEFS & FDEFs.    */
 
     while ( SKIP_Code() == SUCCESS )
     {
       switch ( CUR.opcode )
       {
       case 0x89:    /* IDEF */
       case 0x2C:    /* FDEF */
         CUR.error = TT_Err_Nested_DEFS;
         return;
 
       case 0x2D:   /* ENDF */
         return;
       }
     }
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* ENDF[]:       END Function definition                                 */
   /* Opcode range: 0x2D                                                    */
   /* Stack:        -->                                                     */
   /*                                                                       */
   static void
   Ins_ENDF( INS_ARG )
   {
     TT_CallRec*  pRec;
 
     FT_UNUSED_ARG;
 
 
     if ( CUR.callTop <= 0 )     /* We encountered an ENDF without a call */
     {
       CUR.error = TT_Err_ENDF_In_Exec_Stream;
       return;
     }
 
     CUR.callTop--;
 
     pRec = &CUR.callStack[CUR.callTop];
 
     pRec->Cur_Count--;
 
     CUR.step_ins = FALSE;
 
     if ( pRec->Cur_Count > 0 )
     {
       CUR.callTop++;
       CUR.IP = pRec->Cur_Restart;
     }
     else
       /* Loop through the current function */
       INS_Goto_CodeRange( pRec->Caller_Range,
                           pRec->Caller_IP );
 
     /* Exit the current call frame.                      */
 
     /* NOTE: If the last instruction of a program is a   */
     /*       CALL or LOOPCALL, the return address is     */
     /*       always out of the code range.  This is a    */
     /*       valid address, and it is why we do not test */
     /*       the result of Ins_Goto_CodeRange() here!    */
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* CALL[]:       CALL function                                           */
   /* Opcode range: 0x2B                                                    */
   /* Stack:        uint32? -->                                             */
   /*                                                                       */
   static void
   Ins_CALL( INS_ARG )
   {
     FT_ULong       F;
     TT_CallRec*    pCrec;
     TT_DefRecord*  def;
 
 
     /* first of all, check the index */
 
     F = args[0];
     if ( BOUNDS( F, CUR.maxFunc + 1 ) )
       goto Fail;
 
     /* Except for some old Apple fonts, all functions in a TrueType */
     /* font are defined in increasing order, starting from 0.  This */
     /* means that we normally have                                  */
     /*                                                              */
     /*    CUR.maxFunc+1 == CUR.numFDefs                             */
     /*    CUR.FDefs[n].opc == n for n in 0..CUR.maxFunc             */
     /*                                                              */
     /* If this isn't true, we need to look up the function table.   */
 
     def = CUR.FDefs + F;
     if ( CUR.maxFunc + 1 != CUR.numFDefs || def->opc != F )
     {
       /* look up the FDefs table */
       TT_DefRecord*  limit;
 
 
       def   = CUR.FDefs;
       limit = def + CUR.numFDefs;
 
       while ( def < limit && def->opc != F )
         def++;
 
       if ( def == limit )
         goto Fail;
     }
 
     /* check that the function is active */
     if ( !def->active )
       goto Fail;
 
     /* check the call stack */
     if ( CUR.callTop >= CUR.callSize )
     {
       CUR.error = TT_Err_Stack_Overflow;
       return;
     }
 
     pCrec = CUR.callStack + CUR.callTop;
 
     pCrec->Caller_Range = CUR.curRange;
     pCrec->Caller_IP    = CUR.IP + 1;
     pCrec->Cur_Count    = 1;
     pCrec->Cur_Restart  = def->start;
 
     CUR.callTop++;
 
     INS_Goto_CodeRange( def->range,
                         def->start );
 
     CUR.step_ins = FALSE;
     return;
 
   Fail:
     CUR.error = TT_Err_Invalid_Reference;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* LOOPCALL[]:   LOOP and CALL function                                  */
   /* Opcode range: 0x2A                                                    */
   /* Stack:        uint32? Eint16? -->                                     */
   /*                                                                       */
   static void
   Ins_LOOPCALL( INS_ARG )
   {
     FT_ULong       F;
     TT_CallRec*    pCrec;
     TT_DefRecord*  def;
 
 
     /* first of all, check the index */
     F = args[1];
     if ( BOUNDS( F, CUR.maxFunc + 1 ) )
       goto Fail;
 
     /* Except for some old Apple fonts, all functions in a TrueType */
     /* font are defined in increasing order, starting from 0.  This */
     /* means that we normally have                                  */
     /*                                                              */
     /*    CUR.maxFunc+1 == CUR.numFDefs                             */
     /*    CUR.FDefs[n].opc == n for n in 0..CUR.maxFunc             */
     /*                                                              */
     /* If this isn't true, we need to look up the function table.   */
 
     def = CUR.FDefs + F;
     if ( CUR.maxFunc + 1 != CUR.numFDefs || def->opc != F )
     {
       /* look up the FDefs table */
       TT_DefRecord*  limit;
 
 
       def   = CUR.FDefs;
       limit = def + CUR.numFDefs;
 
       while ( def < limit && def->opc != F )
         def++;
 
       if ( def == limit )
         goto Fail;
     }
 
     /* check that the function is active */
     if ( !def->active )
       goto Fail;
 
     /* check stack */
     if ( CUR.callTop >= CUR.callSize )
     {
       CUR.error = TT_Err_Stack_Overflow;
       return;
     }
 
     if ( args[0] > 0 )
     {
       pCrec = CUR.callStack + CUR.callTop;
 
       pCrec->Caller_Range = CUR.curRange;
       pCrec->Caller_IP    = CUR.IP + 1;
       pCrec->Cur_Count    = (FT_Int)args[0];
       pCrec->Cur_Restart  = def->start;
 
       CUR.callTop++;
 
       INS_Goto_CodeRange( def->range, def->start );
 
       CUR.step_ins = FALSE;
     }
     return;
 
   Fail:
     CUR.error = TT_Err_Invalid_Reference;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* IDEF[]:       Instruction DEFinition                                  */
   /* Opcode range: 0x89                                                    */
   /* Stack:        Eint8 -->                                               */
   /*                                                                       */
   static void
   Ins_IDEF( INS_ARG )
   {
     TT_DefRecord*  def;
     TT_DefRecord*  limit;
 
 
     /*  First of all, look for the same function in our table */
 
     def   = CUR.IDefs;
     limit = def + CUR.numIDefs;
 
     for ( ; def < limit; def++ )
       if ( def->opc == (FT_ULong)args[0] )
         break;
 
     if ( def == limit )
     {
       /* check that there is enough room for a new instruction */
       if ( CUR.numIDefs >= CUR.maxIDefs )
       {
         CUR.error = TT_Err_Too_Many_Instruction_Defs;
         return;
       }
       CUR.numIDefs++;
     }
 
     /* opcode must be unsigned 8-bit integer */
     if ( 0 > args[0] || args[0] > 0x00FF )
     {
       CUR.error = TT_Err_Too_Many_Instruction_Defs;
       return;
     }
 
     def->opc    = (FT_Byte)args[0];
     def->start  = CUR.IP + 1;
     def->range  = CUR.curRange;
     def->active = TRUE;
 
     if ( (FT_ULong)args[0] > CUR.maxIns )
       CUR.maxIns = (FT_Byte)args[0];
 
     /* Now skip the whole function definition. */
     /* We don't allow nested IDEFs & FDEFs.    */
 
     while ( SKIP_Code() == SUCCESS )
     {
       switch ( CUR.opcode )
       {
       case 0x89:   /* IDEF */
       case 0x2C:   /* FDEF */
         CUR.error = TT_Err_Nested_DEFS;
         return;
       case 0x2D:   /* ENDF */
         return;
       }
     }
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* PUSHING DATA ONTO THE INTERPRETER STACK                               */
   /*                                                                       */
   /*   Instructions appear in the specification's order.                   */
   /*                                                                       */
   /*************************************************************************/
 
 
   /*************************************************************************/
   /*                                                                       */
   /* NPUSHB[]:     PUSH N Bytes                                            */
   /* Opcode range: 0x40                                                    */
   /* Stack:        --> uint32...                                           */
   /*                                                                       */
   static void
   Ins_NPUSHB( INS_ARG )
   {
     FT_UShort  L, K;
 
 
     L = (FT_UShort)CUR.code[CUR.IP + 1];
 
     if ( BOUNDS( L, CUR.stackSize + 1 - CUR.top ) )
     {
       CUR.error = TT_Err_Stack_Overflow;
       return;
     }
 
     for ( K = 1; K <= L; K++ )
       args[K - 1] = CUR.code[CUR.IP + K + 1];
 
     CUR.new_top += L;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* NPUSHW[]:     PUSH N Words                                            */
   /* Opcode range: 0x41                                                    */
   /* Stack:        --> int32...                                            */
   /*                                                                       */
   static void
   Ins_NPUSHW( INS_ARG )
   {
     FT_UShort  L, K;
 
 
     L = (FT_UShort)CUR.code[CUR.IP + 1];
 
     if ( BOUNDS( L, CUR.stackSize + 1 - CUR.top ) )
     {
       CUR.error = TT_Err_Stack_Overflow;
       return;
     }
 
     CUR.IP += 2;
 
     for ( K = 0; K < L; K++ )
       args[K] = GET_ShortIns();
 
     CUR.step_ins = FALSE;
     CUR.new_top += L;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* PUSHB[abc]:   PUSH Bytes                                              */
   /* Opcode range: 0xB0-0xB7                                               */
   /* Stack:        --> uint32...                                           */
   /*                                                                       */
   static void
   Ins_PUSHB( INS_ARG )
   {
     FT_UShort  L, K;
 
 
     L = (FT_UShort)( CUR.opcode - 0xB0 + 1 );
 
     if ( BOUNDS( L, CUR.stackSize + 1 - CUR.top ) )
     {
       CUR.error = TT_Err_Stack_Overflow;
       return;
     }
 
     for ( K = 1; K <= L; K++ )
       args[K - 1] = CUR.code[CUR.IP + K];
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* PUSHW[abc]:   PUSH Words                                              */
   /* Opcode range: 0xB8-0xBF                                               */
   /* Stack:        --> int32...                                            */
   /*                                                                       */
   static void
   Ins_PUSHW( INS_ARG )
   {
     FT_UShort  L, K;
 
 
     L = (FT_UShort)( CUR.opcode - 0xB8 + 1 );
 
     if ( BOUNDS( L, CUR.stackSize + 1 - CUR.top ) )
     {
       CUR.error = TT_Err_Stack_Overflow;
       return;
     }
 
     CUR.IP++;
 
     for ( K = 0; K < L; K++ )
       args[K] = GET_ShortIns();
 
     CUR.step_ins = FALSE;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* MANAGING THE GRAPHICS STATE                                           */
   /*                                                                       */
   /*  Instructions appear in the specs' order.                             */
   /*                                                                       */
   /*************************************************************************/
 
 
   /*************************************************************************/
   /*                                                                       */
   /* GC[a]:        Get Coordinate projected onto                           */
   /* Opcode range: 0x46-0x47                                               */
   /* Stack:        uint32 --> f26.6                                        */
   /*                                                                       */
   /* BULLSHIT: Measures from the original glyph must be taken along the    */
   /*           dual projection vector!                                     */
   /*                                                                       */
   static void
   Ins_GC( INS_ARG )
   {
     FT_ULong    L;
     FT_F26Dot6  R;
 
 
     L = (FT_ULong)args[0];
 
     if ( BOUNDS( L, CUR.zp2.n_points ) )
     {
       if ( CUR.pedantic_hinting )
       {
         CUR.error = TT_Err_Invalid_Reference;
         return;
       }
       else
         R = 0;
     }
     else
     {
       if ( CUR.opcode & 1 )
         R = CUR_fast_dualproj( &CUR.zp2.org[L] );
       else
         R = CUR_fast_project( &CUR.zp2.cur[L] );
     }
 
     args[0] = R;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SCFS[]:       Set Coordinate From Stack                               */
   /* Opcode range: 0x48                                                    */
   /* Stack:        f26.6 uint32 -->                                        */
   /*                                                                       */
   /* Formula:                                                              */
   /*                                                                       */
   /*   OA := OA + ( value - OA.p )/( f.p ) * f                             */
   /*                                                                       */
   static void
   Ins_SCFS( INS_ARG )
   {
     FT_Long    K;
     FT_UShort  L;
 
 
     L = (FT_UShort)args[0];
 
     if ( BOUNDS( L, CUR.zp2.n_points ) )
     {
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
       return;
     }
 
     K = CUR_fast_project( &CUR.zp2.cur[L] );
 
     CUR_Func_move( &CUR.zp2, L, args[1] - K );
 
     /* not part of the specs, but here for safety */
 
     if ( CUR.GS.gep2 == 0 )
       CUR.zp2.org[L] = CUR.zp2.cur[L];
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* MD[a]:        Measure Distance                                        */
   /* Opcode range: 0x49-0x4A                                               */
   /* Stack:        uint32 uint32 --> f26.6                                 */
   /*                                                                       */
   /* BULLSHIT: Measure taken in the original glyph must be along the dual  */
   /*           projection vector.                                          */
   /*                                                                       */
   /* Second BULLSHIT: Flag attributes are inverted!                        */
   /*                  0 => measure distance in original outline            */
   /*                  1 => measure distance in grid-fitted outline         */
   /*                                                                       */
   /* Third one: `zp0 - zp1', and not `zp2 - zp1!                           */
   /*                                                                       */
   static void
   Ins_MD( INS_ARG )
   {
     FT_UShort   K, L;
     FT_F26Dot6  D;
 
 
     K = (FT_UShort)args[1];
     L = (FT_UShort)args[0];
 
     if( BOUNDS( L, CUR.zp0.n_points ) ||
         BOUNDS( K, CUR.zp1.n_points ) )
     {
       if ( CUR.pedantic_hinting )
       {
         CUR.error = TT_Err_Invalid_Reference;
         return;
       }
       D = 0;
     }
     else
     {
       if ( CUR.opcode & 1 )
         D = CUR_Func_project( CUR.zp0.cur + L, CUR.zp1.cur + K );
       else
       {
         FT_Vector*  vec1 = CUR.zp0.orus + L;
         FT_Vector*  vec2 = CUR.zp1.orus + K;
 
 
         if ( CUR.metrics.x_scale == CUR.metrics.y_scale )
         {
           /* this should be faster */
           D = CUR_Func_dualproj( vec1, vec2 );
           D = TT_MULFIX( D, CUR.metrics.x_scale );
         }
         else
         {
           FT_Vector  vec;
 
 
           vec.x = TT_MULFIX( vec1->x - vec2->x, CUR.metrics.x_scale );
           vec.y = TT_MULFIX( vec1->y - vec2->y, CUR.metrics.y_scale );
 
           D = CUR_fast_dualproj( &vec );
         }
       }
     }
 
     args[0] = D;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SDPVTL[a]:    Set Dual PVector to Line                                */
   /* Opcode range: 0x86-0x87                                               */
   /* Stack:        uint32 uint32 -->                                       */
   /*                                                                       */
   static void
   Ins_SDPVTL( INS_ARG )
   {
     FT_Long    A, B, C;
     FT_UShort  p1, p2;   /* was FT_Int in pas type ERROR */
 
 
     p1 = (FT_UShort)args[1];
     p2 = (FT_UShort)args[0];
 
     if ( BOUNDS( p2, CUR.zp1.n_points ) ||
          BOUNDS( p1, CUR.zp2.n_points ) )
     {
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
       return;
     }
 
     {
       FT_Vector* v1 = CUR.zp1.org + p2;
       FT_Vector* v2 = CUR.zp2.org + p1;
 
 
       A = v1->x - v2->x;
       B = v1->y - v2->y;
     }
 
     if ( ( CUR.opcode & 1 ) != 0 )
     {
       C =  B;   /* counter clockwise rotation */
       B =  A;
       A = -C;
     }
 
     NORMalize( A, B, &CUR.GS.dualVector );
 
     {
       FT_Vector*  v1 = CUR.zp1.cur + p2;
       FT_Vector*  v2 = CUR.zp2.cur + p1;
 
 
       A = v1->x - v2->x;
       B = v1->y - v2->y;
     }
 
     if ( ( CUR.opcode & 1 ) != 0 )
     {
       C =  B;   /* counter clockwise rotation */
       B =  A;
       A = -C;
     }
 
     NORMalize( A, B, &CUR.GS.projVector );
 
     GUESS_VECTOR( freeVector );
 
     COMPUTE_Funcs();
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SZP0[]:       Set Zone Pointer 0                                      */
   /* Opcode range: 0x13                                                    */
   /* Stack:        uint32 -->                                              */
   /*                                                                       */
   static void
   Ins_SZP0( INS_ARG )
   {
     switch ( (FT_Int)args[0] )
     {
     case 0:
       CUR.zp0 = CUR.twilight;
       break;
 
     case 1:
       CUR.zp0 = CUR.pts;
       break;
 
     default:
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
       return;
     }
 
     CUR.GS.gep0 = (FT_UShort)args[0];
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SZP1[]:       Set Zone Pointer 1                                      */
   /* Opcode range: 0x14                                                    */
   /* Stack:        uint32 -->                                              */
   /*                                                                       */
   static void
   Ins_SZP1( INS_ARG )
   {
     switch ( (FT_Int)args[0] )
     {
     case 0:
       CUR.zp1 = CUR.twilight;
       break;
 
     case 1:
       CUR.zp1 = CUR.pts;
       break;
 
     default:
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
       return;
     }
 
     CUR.GS.gep1 = (FT_UShort)args[0];
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SZP2[]:       Set Zone Pointer 2                                      */
   /* Opcode range: 0x15                                                    */
   /* Stack:        uint32 -->                                              */
   /*                                                                       */
   static void
   Ins_SZP2( INS_ARG )
   {
     switch ( (FT_Int)args[0] )
     {
     case 0:
       CUR.zp2 = CUR.twilight;
       break;
 
     case 1:
       CUR.zp2 = CUR.pts;
       break;
 
     default:
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
       return;
     }
 
     CUR.GS.gep2 = (FT_UShort)args[0];
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SZPS[]:       Set Zone PointerS                                       */
   /* Opcode range: 0x16                                                    */
   /* Stack:        uint32 -->                                              */
   /*                                                                       */
   static void
   Ins_SZPS( INS_ARG )
   {
     switch ( (FT_Int)args[0] )
     {
     case 0:
       CUR.zp0 = CUR.twilight;
       break;
 
     case 1:
       CUR.zp0 = CUR.pts;
       break;
 
     default:
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
       return;
     }
 
     CUR.zp1 = CUR.zp0;
     CUR.zp2 = CUR.zp0;
 
     CUR.GS.gep0 = (FT_UShort)args[0];
     CUR.GS.gep1 = (FT_UShort)args[0];
     CUR.GS.gep2 = (FT_UShort)args[0];
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* INSTCTRL[]:   INSTruction ConTRoL                                     */
   /* Opcode range: 0x8e                                                    */
   /* Stack:        int32 int32 -->                                         */
   /*                                                                       */
   static void
   Ins_INSTCTRL( INS_ARG )
   {
     FT_Long  K, L;
 
 
     K = args[1];
     L = args[0];
 
     if ( K < 1 || K > 2 )
     {
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
       return;
     }
 
     if ( L != 0 )
         L = K;
 
     CUR.GS.instruct_control = FT_BOOL(
       ( (FT_Byte)CUR.GS.instruct_control & ~(FT_Byte)K ) | (FT_Byte)L );
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SCANCTRL[]:   SCAN ConTRoL                                            */
   /* Opcode range: 0x85                                                    */
   /* Stack:        uint32? -->                                             */
   /*                                                                       */
   static void
   Ins_SCANCTRL( INS_ARG )
   {
     FT_Int  A;
 
 
     /* Get Threshold */
     A = (FT_Int)( args[0] & 0xFF );
 
     if ( A == 0xFF )
     {
       CUR.GS.scan_control = TRUE;
       return;
     }
     else if ( A == 0 )
     {
       CUR.GS.scan_control = FALSE;
       return;
     }
 
     if ( ( args[0] & 0x100 ) != 0 && CUR.tt_metrics.ppem <= A )
       CUR.GS.scan_control = TRUE;
 
     if ( ( args[0] & 0x200 ) != 0 && CUR.tt_metrics.rotated )
       CUR.GS.scan_control = TRUE;
 
     if ( ( args[0] & 0x400 ) != 0 && CUR.tt_metrics.stretched )
       CUR.GS.scan_control = TRUE;
 
     if ( ( args[0] & 0x800 ) != 0 && CUR.tt_metrics.ppem > A )
       CUR.GS.scan_control = FALSE;
 
     if ( ( args[0] & 0x1000 ) != 0 && CUR.tt_metrics.rotated )
       CUR.GS.scan_control = FALSE;
 
     if ( ( args[0] & 0x2000 ) != 0 && CUR.tt_metrics.stretched )
       CUR.GS.scan_control = FALSE;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SCANTYPE[]:   SCAN TYPE                                               */
   /* Opcode range: 0x8D                                                    */
   /* Stack:        uint32? -->                                             */
   /*                                                                       */
   static void
   Ins_SCANTYPE( INS_ARG )
   {
     if ( args[0] >= 0 )
       CUR.GS.scan_type = (FT_Int)args[0];
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* MANAGING OUTLINES                                                     */
   /*                                                                       */
   /*   Instructions appear in the specification's order.                   */
   /*                                                                       */
   /*************************************************************************/
 
 
   /*************************************************************************/
   /*                                                                       */
   /* FLIPPT[]:     FLIP PoinT                                              */
   /* Opcode range: 0x80                                                    */
   /* Stack:        uint32... -->                                           */
   /*                                                                       */
   static void
   Ins_FLIPPT( INS_ARG )
   {
     FT_UShort  point;
 
     FT_UNUSED_ARG;
 
 
     if ( CUR.top < CUR.GS.loop )
     {
       CUR.error = TT_Err_Too_Few_Arguments;
       return;
     }
 
     while ( CUR.GS.loop > 0 )
     {
       CUR.args--;
 
       point = (FT_UShort)CUR.stack[CUR.args];
 
       if ( BOUNDS( point, CUR.pts.n_points ) )
       {
         if ( CUR.pedantic_hinting )
         {
           CUR.error = TT_Err_Invalid_Reference;
           return;
         }
       }
       else
         CUR.pts.tags[point] ^= FT_CURVE_TAG_ON;
 
       CUR.GS.loop--;
     }
 
     CUR.GS.loop = 1;
     CUR.new_top = CUR.args;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* FLIPRGON[]:   FLIP RanGe ON                                           */
   /* Opcode range: 0x81                                                    */
   /* Stack:        uint32 uint32 -->                                       */
   /*                                                                       */
   static void
   Ins_FLIPRGON( INS_ARG )
   {
     FT_UShort  I, K, L;
 
 
     K = (FT_UShort)args[1];
     L = (FT_UShort)args[0];
 
     if ( BOUNDS( K, CUR.pts.n_points ) ||
          BOUNDS( L, CUR.pts.n_points ) )
     {
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
       return;
     }
 
     for ( I = L; I <= K; I++ )
       CUR.pts.tags[I] |= FT_CURVE_TAG_ON;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* FLIPRGOFF:    FLIP RanGe OFF                                          */
   /* Opcode range: 0x82                                                    */
   /* Stack:        uint32 uint32 -->                                       */
   /*                                                                       */
   static void
   Ins_FLIPRGOFF( INS_ARG )
   {
     FT_UShort  I, K, L;
 
 
     K = (FT_UShort)args[1];
     L = (FT_UShort)args[0];
 
     if ( BOUNDS( K, CUR.pts.n_points ) ||
          BOUNDS( L, CUR.pts.n_points ) )
     {
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
       return;
     }
 
     for ( I = L; I <= K; I++ )
       CUR.pts.tags[I] &= ~FT_CURVE_TAG_ON;
   }
 
 
   static FT_Bool
   Compute_Point_Displacement( EXEC_OP_ FT_F26Dot6*   x,
                                        FT_F26Dot6*   y,
                                        TT_GlyphZone  zone,
                                        FT_UShort*    refp )
   {
     TT_GlyphZoneRec  zp;
     FT_UShort        p;
     FT_F26Dot6       d;
 
 
     if ( CUR.opcode & 1 )
     {
       zp = CUR.zp0;
       p  = CUR.GS.rp1;
     }
     else
     {
       zp = CUR.zp1;
       p  = CUR.GS.rp2;
     }
 
     if ( BOUNDS( p, zp.n_points ) )
     {
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
       *refp = 0;
       return FAILURE;
     }
 
     *zone = zp;
     *refp = p;
 
     d = CUR_Func_project( zp.cur + p, zp.org + p );
 
 #ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
     if ( CUR.face->unpatented_hinting )
     {
       if ( CUR.GS.both_x_axis )
       {
         *x = d;
         *y = 0;
       }
       else
       {
         *x = 0;
         *y = d;
       }
     }
     else
 #endif
     {
       *x = TT_MULDIV( d,
                       (FT_Long)CUR.GS.freeVector.x * 0x10000L,
                       CUR.F_dot_P );
       *y = TT_MULDIV( d,
                       (FT_Long)CUR.GS.freeVector.y * 0x10000L,
                       CUR.F_dot_P );
     }
 
     return SUCCESS;
   }
 
 
   static void
   Move_Zp2_Point( EXEC_OP_ FT_UShort   point,
                            FT_F26Dot6  dx,
                            FT_F26Dot6  dy,
                            FT_Bool     touch )
   {
 #ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
     if ( CUR.face->unpatented_hinting )
     {
       if ( CUR.GS.both_x_axis )
       {
         CUR.zp2.cur[point].x += dx;
         if ( touch )
           CUR.zp2.tags[point] |= FT_CURVE_TAG_TOUCH_X;
       }
       else
       {
         CUR.zp2.cur[point].y += dy;
         if ( touch )
           CUR.zp2.tags[point] |= FT_CURVE_TAG_TOUCH_Y;
       }
       return;
     }
 #endif
 
     if ( CUR.GS.freeVector.x != 0 )
     {
       CUR.zp2.cur[point].x += dx;
       if ( touch )
         CUR.zp2.tags[point] |= FT_CURVE_TAG_TOUCH_X;
     }
 
     if ( CUR.GS.freeVector.y != 0 )
     {
       CUR.zp2.cur[point].y += dy;
       if ( touch )
         CUR.zp2.tags[point] |= FT_CURVE_TAG_TOUCH_Y;
     }
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SHP[a]:       SHift Point by the last point                           */
   /* Opcode range: 0x32-0x33                                               */
   /* Stack:        uint32... -->                                           */
   /*                                                                       */
   static void
   Ins_SHP( INS_ARG )
   {
     TT_GlyphZoneRec  zp;
     FT_UShort        refp;
 
     FT_F26Dot6       dx,
                      dy;
     FT_UShort        point;
 
     FT_UNUSED_ARG;
 
 
     if ( CUR.top < CUR.GS.loop )
     {
       CUR.error = TT_Err_Invalid_Reference;
       return;
     }
 
     if ( COMPUTE_Point_Displacement( &dx, &dy, &zp, &refp ) )
       return;
 
     while ( CUR.GS.loop > 0 )
     {
       CUR.args--;
       point = (FT_UShort)CUR.stack[CUR.args];
 
       if ( BOUNDS( point, CUR.zp2.n_points ) )
       {
         if ( CUR.pedantic_hinting )
         {
           CUR.error = TT_Err_Invalid_Reference;
           return;
         }
       }
       else
         /* XXX: UNDOCUMENTED! SHP touches the points */
         MOVE_Zp2_Point( point, dx, dy, TRUE );
 
       CUR.GS.loop--;
     }
 
     CUR.GS.loop = 1;
     CUR.new_top = CUR.args;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SHC[a]:       SHift Contour                                           */
   /* Opcode range: 0x34-35                                                 */
   /* Stack:        uint32 -->                                              */
   /*                                                                       */
   static void
   Ins_SHC( INS_ARG )
   {
     TT_GlyphZoneRec zp;
     FT_UShort       refp;
     FT_F26Dot6      dx,
                     dy;
 
     FT_Short        contour;
     FT_UShort       first_point, last_point, i;
 
 
     contour = (FT_UShort)args[0];
 
     if ( BOUNDS( contour, CUR.pts.n_contours ) )
     {
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
       return;
     }
 
     if ( COMPUTE_Point_Displacement( &dx, &dy, &zp, &refp ) )
       return;
 
     if ( contour == 0 )
       first_point = 0;
     else
       first_point = (FT_UShort)( CUR.pts.contours[contour - 1] + 1 -
                                  CUR.pts.first_point );
 
     last_point = (FT_UShort)( CUR.pts.contours[contour] -
                               CUR.pts.first_point );
 
     /* XXX: this is probably wrong... at least it prevents memory */
     /*      corruption when zp2 is the twilight zone              */
     if ( BOUNDS( last_point, CUR.zp2.n_points ) )
     {
       if ( CUR.zp2.n_points > 0 )
         last_point = (FT_UShort)(CUR.zp2.n_points - 1);
       else
         last_point = 0;
     }
 
     /* XXX: UNDOCUMENTED! SHC touches the points */
     for ( i = first_point; i <= last_point; i++ )
     {
       if ( zp.cur != CUR.zp2.cur || refp != i )
         MOVE_Zp2_Point( i, dx, dy, TRUE );
     }
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SHZ[a]:       SHift Zone                                              */
   /* Opcode range: 0x36-37                                                 */
   /* Stack:        uint32 -->                                              */
   /*                                                                       */
   static void
   Ins_SHZ( INS_ARG )
   {
     TT_GlyphZoneRec zp;
     FT_UShort       refp;
     FT_F26Dot6      dx,
                     dy;
 
     FT_UShort       last_point, i;
 
 
     if ( BOUNDS( args[0], 2 ) )
     {
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
       return;
     }
 
     if ( COMPUTE_Point_Displacement( &dx, &dy, &zp, &refp ) )
       return;
 
     /* XXX: UNDOCUMENTED! SHZ doesn't move the phantom points.  */
     /*      Twilight zone has no contours, so use `n_points'.   */
     /*      Normal zone's `n_points' includes phantoms, so must */
     /*      use end of last contour.                            */
     if ( CUR.GS.gep2 == 0 && CUR.zp2.n_points > 0 )
       last_point = (FT_UShort)( CUR.zp2.n_points - 1 );
     else if ( CUR.GS.gep2 == 1 && CUR.zp2.n_contours > 0 )
       last_point = (FT_UShort)( CUR.zp2.contours[CUR.zp2.n_contours - 1] );
     else
       last_point = 0;
 
     /* XXX: UNDOCUMENTED! SHZ doesn't touch the points */
     for ( i = 0; i <= last_point; i++ )
     {
       if ( zp.cur != CUR.zp2.cur || refp != i )
         MOVE_Zp2_Point( i, dx, dy, FALSE );
     }
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* SHPIX[]:      SHift points by a PIXel amount                          */
   /* Opcode range: 0x38                                                    */
   /* Stack:        f26.6 uint32... -->                                     */
   /*                                                                       */
   static void
   Ins_SHPIX( INS_ARG )
   {
     FT_F26Dot6  dx, dy;
     FT_UShort   point;
 
 
     if ( CUR.top < CUR.GS.loop + 1 )
     {
       CUR.error = TT_Err_Invalid_Reference;
       return;
     }
 
 #ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
     if ( CUR.face->unpatented_hinting )
     {
       if ( CUR.GS.both_x_axis )
       {
         dx = TT_MulFix14( (FT_UInt32)args[0], 0x4000 );
         dy = 0;
       }
       else
       {
         dx = 0;
         dy = TT_MulFix14( (FT_UInt32)args[0], 0x4000 );
       }
     }
     else
 #endif
     {
       dx = TT_MulFix14( (FT_UInt32)args[0], CUR.GS.freeVector.x );
       dy = TT_MulFix14( (FT_UInt32)args[0], CUR.GS.freeVector.y );
     }
 
     while ( CUR.GS.loop > 0 )
     {
       CUR.args--;
 
       point = (FT_UShort)CUR.stack[CUR.args];
 
       if ( BOUNDS( point, CUR.zp2.n_points ) )
       {
         if ( CUR.pedantic_hinting )
         {
           CUR.error = TT_Err_Invalid_Reference;
           return;
         }
       }
       else
         MOVE_Zp2_Point( point, dx, dy, TRUE );
 
       CUR.GS.loop--;
     }
 
     CUR.GS.loop = 1;
     CUR.new_top = CUR.args;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* MSIRP[a]:     Move Stack Indirect Relative Position                   */
   /* Opcode range: 0x3A-0x3B                                               */
   /* Stack:        f26.6 uint32 -->                                        */
   /*                                                                       */
   static void
   Ins_MSIRP( INS_ARG )
   {
     FT_UShort   point;
     FT_F26Dot6  distance;
 
 
     point = (FT_UShort)args[0];
 
     if ( BOUNDS( point,      CUR.zp1.n_points ) ||
          BOUNDS( CUR.GS.rp0, CUR.zp0.n_points ) )
     {
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
       return;
     }
 
     /* XXX: UNDOCUMENTED! behaviour */
     if ( CUR.GS.gep1 == 0 )   /* if the point that is to be moved */
                               /* is in twilight zone              */
     {
       CUR.zp1.org[point] = CUR.zp0.org[CUR.GS.rp0];
       CUR_Func_move_orig( &CUR.zp1, point, args[1] );
       CUR.zp1.cur[point] = CUR.zp1.org[point];
     }
 
     distance = CUR_Func_project( CUR.zp1.cur + point,
                                  CUR.zp0.cur + CUR.GS.rp0 );
 
     CUR_Func_move( &CUR.zp1, point, args[1] - distance );
 
     CUR.GS.rp1 = CUR.GS.rp0;
     CUR.GS.rp2 = point;
 
     if ( ( CUR.opcode & 1 ) != 0 )
       CUR.GS.rp0 = point;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* MDAP[a]:      Move Direct Absolute Point                              */
   /* Opcode range: 0x2E-0x2F                                               */
   /* Stack:        uint32 -->                                              */
   /*                                                                       */
   static void
   Ins_MDAP( INS_ARG )
   {
     FT_UShort   point;
     FT_F26Dot6  cur_dist,
                 distance;
 
 
     point = (FT_UShort)args[0];
 
     if ( BOUNDS( point, CUR.zp0.n_points ) )
     {
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
       return;
     }
 
     /* XXX: Is there some undocumented feature while in the */
     /*      twilight zone? ?                                */
     if ( ( CUR.opcode & 1 ) != 0 )
     {
       cur_dist = CUR_fast_project( &CUR.zp0.cur[point] );
       distance = CUR_Func_round( cur_dist,
                                  CUR.tt_metrics.compensations[0] ) - cur_dist;
     }
     else
       distance = 0;
 
     CUR_Func_move( &CUR.zp0, point, distance );
 
     CUR.GS.rp0 = point;
     CUR.GS.rp1 = point;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* MIAP[a]:      Move Indirect Absolute Point                            */
   /* Opcode range: 0x3E-0x3F                                               */
   /* Stack:        uint32 uint32 -->                                       */
   /*                                                                       */
   static void
   Ins_MIAP( INS_ARG )
   {
     FT_ULong    cvtEntry;
     FT_UShort   point;
     FT_F26Dot6  distance,
                 org_dist;
 
 
     cvtEntry = (FT_ULong)args[1];
     point    = (FT_UShort)args[0];
 
     if ( BOUNDS( point,    CUR.zp0.n_points ) ||
          BOUNDS( cvtEntry, CUR.cvtSize )      )
     {
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
       return;
     }
 
     /* XXX: UNDOCUMENTED!                                */
     /*                                                   */
     /* The behaviour of an MIAP instruction is quite     */
     /* different when used in the twilight zone.         */
     /*                                                   */
     /* First, no control value cut-in test is performed  */
     /* as it would fail anyway.  Second, the original    */
     /* point, i.e. (org_x,org_y) of zp0.point, is set    */
     /* to the absolute, unrounded distance found in      */
     /* the CVT.                                          */
     /*                                                   */
     /* This is used in the CVT programs of the Microsoft */
     /* fonts Arial, Times, etc., in order to re-adjust   */
     /* some key font heights.  It allows the use of the  */
     /* IP instruction in the twilight zone, which        */
     /* otherwise would be `illegal' according to the     */
     /* specification.                                    */
     /*                                                   */
     /* We implement it with a special sequence for the   */
     /* twilight zone.  This is a bad hack, but it seems  */
     /* to work.                                          */
 
     distance = CUR_Func_read_cvt( cvtEntry );
 
     if ( CUR.GS.gep0 == 0 )   /* If in twilight zone */
     {
       CUR.zp0.org[point].x = TT_MulFix14( (FT_UInt32)distance, CUR.GS.freeVector.x );
       CUR.zp0.org[point].y = TT_MulFix14( (FT_UInt32)distance, CUR.GS.freeVector.y ),
       CUR.zp0.cur[point]   = CUR.zp0.org[point];
     }
 
     org_dist = CUR_fast_project( &CUR.zp0.cur[point] );
 
     if ( ( CUR.opcode & 1 ) != 0 )   /* rounding and control cutin flag */
     {
       if ( FT_ABS( distance - org_dist ) > CUR.GS.control_value_cutin )
         distance = org_dist;
 
       distance = CUR_Func_round( distance, CUR.tt_metrics.compensations[0] );
     }
 
     CUR_Func_move( &CUR.zp0, point, distance - org_dist );
 
     CUR.GS.rp0 = point;
     CUR.GS.rp1 = point;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* MDRP[abcde]:  Move Direct Relative Point                              */
   /* Opcode range: 0xC0-0xDF                                               */
   /* Stack:        uint32 -->                                              */
   /*                                                                       */
   static void
   Ins_MDRP( INS_ARG )
   {
     FT_UShort   point;
     FT_F26Dot6  org_dist, distance;
 
 
     point = (FT_UShort)args[0];
 
     if ( BOUNDS( point,      CUR.zp1.n_points ) ||
          BOUNDS( CUR.GS.rp0, CUR.zp0.n_points ) )
     {
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
       return;
     }
 
     /* XXX: Is there some undocumented feature while in the */
     /*      twilight zone?                                  */
 
     /* XXX: UNDOCUMENTED: twilight zone special case */
 
     if ( CUR.GS.gep0 == 0 || CUR.GS.gep1 == 0 )
     {
       FT_Vector*  vec1 = &CUR.zp1.org[point];
       FT_Vector*  vec2 = &CUR.zp0.org[CUR.GS.rp0];
 
 
       org_dist = CUR_Func_dualproj( vec1, vec2 );
     }
     else
     {
       FT_Vector*  vec1 = &CUR.zp1.orus[point];
       FT_Vector*  vec2 = &CUR.zp0.orus[CUR.GS.rp0];
 
 
       if ( CUR.metrics.x_scale == CUR.metrics.y_scale )
       {
         /* this should be faster */
         org_dist = CUR_Func_dualproj( vec1, vec2 );
         org_dist = TT_MULFIX( org_dist, CUR.metrics.x_scale );
       }
       else
       {
         FT_Vector  vec;
 
 
         vec.x = TT_MULFIX( vec1->x - vec2->x, CUR.metrics.x_scale );
         vec.y = TT_MULFIX( vec1->y - vec2->y, CUR.metrics.y_scale );
 
         org_dist = CUR_fast_dualproj( &vec );
       }
     }
 
     /* single width cut-in test */
 
     if ( FT_ABS( org_dist - CUR.GS.single_width_value ) <
          CUR.GS.single_width_cutin )
     {
       if ( org_dist >= 0 )
         org_dist = CUR.GS.single_width_value;
       else
         org_dist = -CUR.GS.single_width_value;
     }
 
     /* round flag */
 
     if ( ( CUR.opcode & 4 ) != 0 )
       distance = CUR_Func_round(
                    org_dist,
                    CUR.tt_metrics.compensations[CUR.opcode & 3] );
     else
       distance = ROUND_None(
                    org_dist,
                    CUR.tt_metrics.compensations[CUR.opcode & 3] );
 
     /* minimum distance flag */
 
     if ( ( CUR.opcode & 8 ) != 0 )
     {
       if ( org_dist >= 0 )
       {
         if ( distance < CUR.GS.minimum_distance )
           distance = CUR.GS.minimum_distance;
       }
       else
       {
         if ( distance > -CUR.GS.minimum_distance )
           distance = -CUR.GS.minimum_distance;
       }
     }
 
     /* now move the point */
 
     org_dist = CUR_Func_project( CUR.zp1.cur + point,
                                  CUR.zp0.cur + CUR.GS.rp0 );
 
     CUR_Func_move( &CUR.zp1, point, distance - org_dist );
 
     CUR.GS.rp1 = CUR.GS.rp0;
     CUR.GS.rp2 = point;
 
     if ( ( CUR.opcode & 16 ) != 0 )
       CUR.GS.rp0 = point;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* MIRP[abcde]:  Move Indirect Relative Point                            */
   /* Opcode range: 0xE0-0xFF                                               */
   /* Stack:        int32? uint32 -->                                       */
   /*                                                                       */
   static void
   Ins_MIRP( INS_ARG )
   {
     FT_UShort   point;
     FT_ULong    cvtEntry;
 
     FT_F26Dot6  cvt_dist,
                 distance,
                 cur_dist,
                 org_dist;
 
 
     point    = (FT_UShort)args[0];
     cvtEntry = (FT_ULong)( args[1] + 1 );
 
     /* XXX: UNDOCUMENTED! cvt[-1] = 0 always */
 
     if ( BOUNDS( point,      CUR.zp1.n_points ) ||
          BOUNDS( cvtEntry,   CUR.cvtSize + 1 )  ||
          BOUNDS( CUR.GS.rp0, CUR.zp0.n_points ) )
     {
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
       return;
     }
 
     if ( !cvtEntry )
       cvt_dist = 0;
     else
       cvt_dist = CUR_Func_read_cvt( cvtEntry - 1 );
 
     /* single width test */
 
     if ( FT_ABS( cvt_dist - CUR.GS.single_width_value ) <
          CUR.GS.single_width_cutin )
     {
       if ( cvt_dist >= 0 )
         cvt_dist =  CUR.GS.single_width_value;
       else
         cvt_dist = -CUR.GS.single_width_value;
     }
 
     /* XXX: UNDOCUMENTED! -- twilight zone */
 
     if ( CUR.GS.gep1 == 0 )
     {
       CUR.zp1.org[point].x = CUR.zp0.org[CUR.GS.rp0].x +
                              TT_MulFix14( (FT_UInt32)cvt_dist,
                                           CUR.GS.freeVector.x );
 
       CUR.zp1.org[point].y = CUR.zp0.org[CUR.GS.rp0].y +
                              TT_MulFix14( (FT_UInt32)cvt_dist,
                                           CUR.GS.freeVector.y );
 
       CUR.zp1.cur[point] = CUR.zp0.cur[point];
     }
 
     org_dist = CUR_Func_dualproj( &CUR.zp1.org[point],
                                   &CUR.zp0.org[CUR.GS.rp0] );
     cur_dist = CUR_Func_project ( &CUR.zp1.cur[point],
                                   &CUR.zp0.cur[CUR.GS.rp0] );
 
     /* auto-flip test */
 
     if ( CUR.GS.auto_flip )
     {
       if ( ( org_dist ^ cvt_dist ) < 0 )
         cvt_dist = -cvt_dist;
     }
 
     /* control value cutin and round */
 
     if ( ( CUR.opcode & 4 ) != 0 )
     {
       /* XXX: UNDOCUMENTED!  Only perform cut-in test when both points */
       /*      refer to the same zone.                                  */
 
       if ( CUR.GS.gep0 == CUR.GS.gep1 )
         if ( FT_ABS( cvt_dist - org_dist ) >= CUR.GS.control_value_cutin )
           cvt_dist = org_dist;
 
       distance = CUR_Func_round(
                    cvt_dist,
                    CUR.tt_metrics.compensations[CUR.opcode & 3] );
     }
     else
       distance = ROUND_None(
                    cvt_dist,
                    CUR.tt_metrics.compensations[CUR.opcode & 3] );
 
     /* minimum distance test */
 
     if ( ( CUR.opcode & 8 ) != 0 )
     {
       if ( org_dist >= 0 )
       {
         if ( distance < CUR.GS.minimum_distance )
           distance = CUR.GS.minimum_distance;
       }
       else
       {
         if ( distance > -CUR.GS.minimum_distance )
           distance = -CUR.GS.minimum_distance;
       }
     }
 
     CUR_Func_move( &CUR.zp1, point, distance - cur_dist );
 
     CUR.GS.rp1 = CUR.GS.rp0;
 
     if ( ( CUR.opcode & 16 ) != 0 )
       CUR.GS.rp0 = point;
 
     /* XXX: UNDOCUMENTED! */
     CUR.GS.rp2 = point;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* ALIGNRP[]:    ALIGN Relative Point                                    */
   /* Opcode range: 0x3C                                                    */
   /* Stack:        uint32 uint32... -->                                    */
   /*                                                                       */
   static void
   Ins_ALIGNRP( INS_ARG )
   {
     FT_UShort   point;
     FT_F26Dot6  distance;
 
     FT_UNUSED_ARG;
 
 
     if ( CUR.top < CUR.GS.loop ||
          BOUNDS( CUR.GS.rp0, CUR.zp0.n_points ) )
     {
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
       return;
     }
 
     while ( CUR.GS.loop > 0 )
     {
       CUR.args--;
 
       point = (FT_UShort)CUR.stack[CUR.args];
 
       if ( BOUNDS( point, CUR.zp1.n_points ) )
       {
         if ( CUR.pedantic_hinting )
         {
           CUR.error = TT_Err_Invalid_Reference;
           return;
         }
       }
       else
       {
         distance = CUR_Func_project( CUR.zp1.cur + point,
                                      CUR.zp0.cur + CUR.GS.rp0 );
 
         CUR_Func_move( &CUR.zp1, point, -distance );
       }
 
       CUR.GS.loop--;
     }
 
     CUR.GS.loop = 1;
     CUR.new_top = CUR.args;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* ISECT[]:      moves point to InterSECTion                             */
   /* Opcode range: 0x0F                                                    */
   /* Stack:        5 * uint32 -->                                          */
   /*                                                                       */
   static void
   Ins_ISECT( INS_ARG )
   {
     FT_UShort   point,
                 a0, a1,
                 b0, b1;
 
     FT_F26Dot6  discriminant;
 
     FT_F26Dot6  dx,  dy,
                 dax, day,
                 dbx, dby;
 
     FT_F26Dot6  val;
 
     FT_Vector   R;
 
 
     point = (FT_UShort)args[0];
 
     a0 = (FT_UShort)args[1];
     a1 = (FT_UShort)args[2];
     b0 = (FT_UShort)args[3];
     b1 = (FT_UShort)args[4];
 
     if ( BOUNDS( b0, CUR.zp0.n_points )  ||
          BOUNDS( b1, CUR.zp0.n_points )  ||
          BOUNDS( a0, CUR.zp1.n_points )  ||
          BOUNDS( a1, CUR.zp1.n_points )  ||
          BOUNDS( point, CUR.zp2.n_points ) )
     {
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
       return;
     }
 
     dbx = CUR.zp0.cur[b1].x - CUR.zp0.cur[b0].x;
     dby = CUR.zp0.cur[b1].y - CUR.zp0.cur[b0].y;
 
     dax = CUR.zp1.cur[a1].x - CUR.zp1.cur[a0].x;
     day = CUR.zp1.cur[a1].y - CUR.zp1.cur[a0].y;
 
     dx = CUR.zp0.cur[b0].x - CUR.zp1.cur[a0].x;
     dy = CUR.zp0.cur[b0].y - CUR.zp1.cur[a0].y;
 
     CUR.zp2.tags[point] |= FT_CURVE_TAG_TOUCH_BOTH;
 
     discriminant = TT_MULDIV( dax, -dby, 0x40 ) +
                    TT_MULDIV( day, dbx, 0x40 );
 
     if ( FT_ABS( discriminant ) >= 0x40 )
     {
       val = TT_MULDIV( dx, -dby, 0x40 ) + TT_MULDIV( dy, dbx, 0x40 );
 
       R.x = TT_MULDIV( val, dax, discriminant );
       R.y = TT_MULDIV( val, day, discriminant );
 
       CUR.zp2.cur[point].x = CUR.zp1.cur[a0].x + R.x;
       CUR.zp2.cur[point].y = CUR.zp1.cur[a0].y + R.y;
     }
     else
     {
       /* else, take the middle of the middles of A and B */
 
       CUR.zp2.cur[point].x = ( CUR.zp1.cur[a0].x +
                                CUR.zp1.cur[a1].x +
                                CUR.zp0.cur[b0].x +
                                CUR.zp0.cur[b1].x ) / 4;
       CUR.zp2.cur[point].y = ( CUR.zp1.cur[a0].y +
                                CUR.zp1.cur[a1].y +
                                CUR.zp0.cur[b0].y +
                                CUR.zp0.cur[b1].y ) / 4;
     }
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* ALIGNPTS[]:   ALIGN PoinTS                                            */
   /* Opcode range: 0x27                                                    */
   /* Stack:        uint32 uint32 -->                                       */
   /*                                                                       */
   static void
   Ins_ALIGNPTS( INS_ARG )
   {
     FT_UShort   p1, p2;
     FT_F26Dot6  distance;
 
 
     p1 = (FT_UShort)args[0];
     p2 = (FT_UShort)args[1];
 
     if ( BOUNDS( args[0], CUR.zp1.n_points ) ||
          BOUNDS( args[1], CUR.zp0.n_points ) )
     {
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
       return;
     }
 
     distance = CUR_Func_project( CUR.zp0.cur + p2,
                                  CUR.zp1.cur + p1 ) / 2;
 
     CUR_Func_move( &CUR.zp1, p1, distance );
     CUR_Func_move( &CUR.zp0, p2, -distance );
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* IP[]:         Interpolate Point                                       */
   /* Opcode range: 0x39                                                    */
   /* Stack:        uint32... -->                                           */
   /*                                                                       */
 
   /* SOMETIMES, DUMBER CODE IS BETTER CODE */
 
   static void
   Ins_IP( INS_ARG )
   {
     FT_F26Dot6  old_range, cur_range;
     FT_Vector*  orus_base;
     FT_Vector*  cur_base;
     FT_Int      twilight;
 
     FT_UNUSED_ARG;
 
 
     if ( CUR.top < CUR.GS.loop )
     {
       CUR.error = TT_Err_Invalid_Reference;
       return;
     }
 
     /*
      * We need to deal in a special way with the twilight zone.
      * Otherwise, by definition, the value of CUR.twilight.orus[n] is (0,0),
      * for every n.
      */
     twilight = CUR.GS.gep0 == 0 || CUR.GS.gep1 == 0 || CUR.GS.gep2 == 0;
 
     if ( BOUNDS( CUR.GS.rp1, CUR.zp0.n_points ) )
     {
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
       return;
     }
 
     if ( twilight )
       orus_base = &CUR.zp0.org[CUR.GS.rp1];
     else
       orus_base = &CUR.zp0.orus[CUR.GS.rp1];
 
     cur_base = &CUR.zp0.cur[CUR.GS.rp1];
 
     /* XXX: There are some glyphs in some braindead but popular */
     /*      fonts out there (e.g. [aeu]grave in monotype.ttf)   */
     /*      calling IP[] with bad values of rp[12].             */
     /*      Do something sane when this odd thing happens.      */
     if ( BOUNDS( CUR.GS.rp1, CUR.zp0.n_points ) ||
          BOUNDS( CUR.GS.rp2, CUR.zp1.n_points ) )
     {
       old_range = 0;
       cur_range = 0;
     }
     else
     {
       if ( twilight )
         old_range = CUR_Func_dualproj( &CUR.zp1.org[CUR.GS.rp2],
                                        orus_base );
       else
         old_range = CUR_Func_dualproj( &CUR.zp1.orus[CUR.GS.rp2],
                                        orus_base );
 
       cur_range = CUR_Func_project ( &CUR.zp1.cur[CUR.GS.rp2], cur_base );
     }
 
     for ( ; CUR.GS.loop > 0; --CUR.GS.loop )
     {
       FT_UInt     point = (FT_UInt)CUR.stack[--CUR.args];
       FT_F26Dot6  org_dist, cur_dist, new_dist;
 
 
       /* check point bounds */
       if ( BOUNDS( point, CUR.zp2.n_points ) )
       {
         if ( CUR.pedantic_hinting )
         {
           CUR.error = TT_Err_Invalid_Reference;
           return;
         }
         continue;
       }
 
       if ( twilight )
         org_dist = CUR_Func_dualproj( &CUR.zp2.org[point], orus_base );
       else
         org_dist = CUR_Func_dualproj( &CUR.zp2.orus[point], orus_base );
 
       cur_dist = CUR_Func_project ( &CUR.zp2.cur[point], cur_base );
 
       if ( org_dist )
         new_dist = ( old_range != 0 )
                      ? TT_MULDIV( org_dist, cur_range, old_range )
                      : cur_dist;
       else
         new_dist = 0;
 
       CUR_Func_move( &CUR.zp2, (FT_UShort)point, new_dist - cur_dist );
     }
     CUR.GS.loop = 1;
     CUR.new_top = CUR.args;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* UTP[a]:       UnTouch Point                                           */
   /* Opcode range: 0x29                                                    */
   /* Stack:        uint32 -->                                              */
   /*                                                                       */
   static void
   Ins_UTP( INS_ARG )
   {
     FT_UShort  point;
     FT_Byte    mask;
 
 
     point = (FT_UShort)args[0];
 
     if ( BOUNDS( point, CUR.zp0.n_points ) )
     {
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
       return;
     }
 
     mask = 0xFF;
 
     if ( CUR.GS.freeVector.x != 0 )
       mask &= ~FT_CURVE_TAG_TOUCH_X;
 
     if ( CUR.GS.freeVector.y != 0 )
       mask &= ~FT_CURVE_TAG_TOUCH_Y;
 
     CUR.zp0.tags[point] &= mask;
   }
 
 
   /* Local variables for Ins_IUP: */
   typedef struct  IUP_WorkerRec_
   {
     FT_Vector*  orgs;   /* original and current coordinate */
     FT_Vector*  curs;   /* arrays                          */
     FT_Vector*  orus;
     FT_UInt     max_points;
 
   } IUP_WorkerRec, *IUP_Worker;
 
 
   static void
   _iup_worker_shift( IUP_Worker  worker,
                      FT_UInt     p1,
                      FT_UInt     p2,
                      FT_UInt     p )
   {
     FT_UInt     i;
     FT_F26Dot6  dx;
 
 
     dx = worker->curs[p].x - worker->orgs[p].x;
     if ( dx != 0 )
     {
       for ( i = p1; i < p; i++ )
         worker->curs[i].x += dx;
 
       for ( i = p + 1; i <= p2; i++ )
         worker->curs[i].x += dx;
     }
   }
 
 
   static void
   _iup_worker_interpolate( IUP_Worker  worker,
                            FT_UInt     p1,
                            FT_UInt     p2,
                            FT_UInt     ref1,
                            FT_UInt     ref2 )
   {
     FT_UInt     i;
     FT_F26Dot6  orus1, orus2, org1, org2, delta1, delta2;
 
 
     if ( p1 > p2 )
       return;
 
     if ( BOUNDS( ref1, worker->max_points ) ||
          BOUNDS( ref2, worker->max_points ) )
       return;
 
     orus1 = worker->orus[ref1].x;
     orus2 = worker->orus[ref2].x;
 
     if ( orus1 > orus2 )
     {
       FT_F26Dot6  tmp_o;
       FT_UInt     tmp_r;
 
 
       tmp_o = orus1;
       orus1 = orus2;
       orus2 = tmp_o;
 
       tmp_r = ref1;
       ref1  = ref2;
       ref2  = tmp_r;
     }
 
     org1   = worker->orgs[ref1].x;
     org2   = worker->orgs[ref2].x;
     delta1 = worker->curs[ref1].x - org1;
     delta2 = worker->curs[ref2].x - org2;
 
     if ( orus1 == orus2 )
     {
       /* simple shift of untouched points */
       for ( i = p1; i <= p2; i++ )
       {
         FT_F26Dot6  x = worker->orgs[i].x;
 
 
         if ( x <= org1 )
           x += delta1;
         else
           x += delta2;
 
         worker->curs[i].x = x;
       }
     }
     else
     {
       FT_Fixed  scale       = 0;
       FT_Bool   scale_valid = 0;
 
 
       /* interpolation */
       for ( i = p1; i <= p2; i++ )
       {
         FT_F26Dot6  x = worker->orgs[i].x;
 
 
         if ( x <= org1 )
           x += delta1;
 
         else if ( x >= org2 )
           x += delta2;
 
         else
         {
           if ( !scale_valid )
           {
             scale_valid = 1;
             scale       = TT_MULDIV( org2 + delta2 - ( org1 + delta1 ),
                                      0x10000L, orus2 - orus1 );
           }
 
           x = ( org1 + delta1 ) +
               TT_MULFIX( worker->orus[i].x - orus1, scale );
         }
         worker->curs[i].x = x;
       }
     }
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* IUP[a]:       Interpolate Untouched Points                            */
   /* Opcode range: 0x30-0x31                                               */
   /* Stack:        -->                                                     */
   /*                                                                       */
   static void
   Ins_IUP( INS_ARG )
   {
     IUP_WorkerRec  V;
     FT_Byte        mask;
 
     FT_UInt   first_point;   /* first point of contour        */
     FT_UInt   end_point;     /* end point (last+1) of contour */
 
     FT_UInt   first_touched; /* first touched point in contour   */
     FT_UInt   cur_touched;   /* current touched point in contour */
 
     FT_UInt   point;         /* current point   */
     FT_Short  contour;       /* current contour */
 
     FT_UNUSED_ARG;
 
 
     /* ignore empty outlines */
     if ( CUR.pts.n_contours == 0 )
       return;
 
     if ( CUR.opcode & 1 )
     {
       mask   = FT_CURVE_TAG_TOUCH_X;
       V.orgs = CUR.pts.org;
       V.curs = CUR.pts.cur;
       V.orus = CUR.pts.orus;
     }
     else
     {
       mask   = FT_CURVE_TAG_TOUCH_Y;
       V.orgs = (FT_Vector*)( (FT_Pos*)CUR.pts.org + 1 );
       V.curs = (FT_Vector*)( (FT_Pos*)CUR.pts.cur + 1 );
       V.orus = (FT_Vector*)( (FT_Pos*)CUR.pts.orus + 1 );
     }
     V.max_points = CUR.pts.n_points;
 
     contour = 0;
     point   = 0;
 
     do
     {
       end_point   = CUR.pts.contours[contour] - CUR.pts.first_point;
       first_point = point;
 
-      if ( CUR.pts.n_points <= end_point )
-        end_point = CUR.pts.n_points;
+      if ( BOUNDS ( end_point, CUR.pts.n_points ) )
+        end_point = CUR.pts.n_points - 1;
 
       while ( point <= end_point && ( CUR.pts.tags[point] & mask ) == 0 )
         point++;
 
       if ( point <= end_point )
       {
         first_touched = point;
         cur_touched   = point;
 
         point++;
 
         while ( point <= end_point )
         {
           if ( ( CUR.pts.tags[point] & mask ) != 0 )
           {
             if ( point > 0 )
               _iup_worker_interpolate( &V,
                                        cur_touched + 1,
                                        point - 1,
                                        cur_touched,
                                        point );
             cur_touched = point;
           }
 
           point++;
         }
 
         if ( cur_touched == first_touched )
           _iup_worker_shift( &V, first_point, end_point, cur_touched );
         else
         {
           _iup_worker_interpolate( &V,
                                    (FT_UShort)( cur_touched + 1 ),
                                    end_point,
                                    cur_touched,
                                    first_touched );
 
           if ( first_touched > 0 )
             _iup_worker_interpolate( &V,
                                      first_point,
                                      first_touched - 1,
                                      cur_touched,
                                      first_touched );
         }
       }
       contour++;
     } while ( contour < CUR.pts.n_contours );
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* DELTAPn[]:    DELTA exceptions P1, P2, P3                             */
   /* Opcode range: 0x5D,0x71,0x72                                          */
   /* Stack:        uint32 (2 * uint32)... -->                              */
   /*                                                                       */
   static void
   Ins_DELTAP( INS_ARG )
   {
     FT_ULong   k, nump;
     FT_UShort  A;
     FT_ULong   C;
     FT_Long    B;
 
 
 #ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
     /* Delta hinting is covered by US Patent 5159668. */
     if ( CUR.face->unpatented_hinting )
     {
       FT_Long  n = args[0] * 2;
 
 
       if ( CUR.args < n )
       {
         CUR.error = TT_Err_Too_Few_Arguments;
         return;
       }
 
       CUR.args -= n;
       CUR.new_top = CUR.args;
       return;
     }
 #endif
 
     nump = (FT_ULong)args[0];   /* some points theoretically may occur more
                                    than once, thus UShort isn't enough */
 
     for ( k = 1; k <= nump; k++ )
     {
       if ( CUR.args < 2 )
       {
         CUR.error = TT_Err_Too_Few_Arguments;
         return;
       }
 
       CUR.args -= 2;
 
       A = (FT_UShort)CUR.stack[CUR.args + 1];
       B = CUR.stack[CUR.args];
 
       /* XXX: Because some popular fonts contain some invalid DeltaP */
       /*      instructions, we simply ignore them when the stacked   */
       /*      point reference is off limit, rather than returning an */
       /*      error.  As a delta instruction doesn't change a glyph  */
       /*      in great ways, this shouldn't be a problem.            */
 
       if ( !BOUNDS( A, CUR.zp0.n_points ) )
       {
         C = ( (FT_ULong)B & 0xF0 ) >> 4;
 
         switch ( CUR.opcode )
         {
         case 0x5D:
           break;
 
         case 0x71:
           C += 16;
           break;
 
         case 0x72:
           C += 32;
           break;
         }
 
         C += CUR.GS.delta_base;
 
         if ( CURRENT_Ppem() == (FT_Long)C )
         {
           B = ( (FT_ULong)B & 0xF ) - 8;
           if ( B >= 0 )
             B++;
           B = B * 64 / ( 1L << CUR.GS.delta_shift );
 
           CUR_Func_move( &CUR.zp0, A, B );
         }
       }
       else
         if ( CUR.pedantic_hinting )
           CUR.error = TT_Err_Invalid_Reference;
     }
 
     CUR.new_top = CUR.args;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* DELTACn[]:    DELTA exceptions C1, C2, C3                             */
   /* Opcode range: 0x73,0x74,0x75                                          */
   /* Stack:        uint32 (2 * uint32)... -->                              */
   /*                                                                       */
   static void
   Ins_DELTAC( INS_ARG )
   {
     FT_ULong  nump, k;
     FT_ULong  A, C;
     FT_Long   B;
 
 
 #ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
     /* Delta hinting is covered by US Patent 5159668. */
     if ( CUR.face->unpatented_hinting )
     {
       FT_Long  n = args[0] * 2;
 
 
       if ( CUR.args < n )
       {
         CUR.error = TT_Err_Too_Few_Arguments;
         return;
       }
 
       CUR.args -= n;
       CUR.new_top = CUR.args;
       return;
     }
 #endif
 
     nump = (FT_ULong)args[0];
 
     for ( k = 1; k <= nump; k++ )
     {
       if ( CUR.args < 2 )
       {
         CUR.error = TT_Err_Too_Few_Arguments;
         return;
       }
 
       CUR.args -= 2;
 
       A = (FT_ULong)CUR.stack[CUR.args + 1];
       B = CUR.stack[CUR.args];
 
       if ( BOUNDS( A, CUR.cvtSize ) )
       {
         if ( CUR.pedantic_hinting )
         {
           CUR.error = TT_Err_Invalid_Reference;
           return;
         }
       }
       else
       {
         C = ( (FT_ULong)B & 0xF0 ) >> 4;
 
         switch ( CUR.opcode )
         {
         case 0x73:
           break;
 
         case 0x74:
           C += 16;
           break;
 
         case 0x75:
           C += 32;
           break;
         }
 
         C += CUR.GS.delta_base;
 
         if ( CURRENT_Ppem() == (FT_Long)C )
         {
           B = ( (FT_ULong)B & 0xF ) - 8;
           if ( B >= 0 )
             B++;
           B = B * 64 / ( 1L << CUR.GS.delta_shift );
 
           CUR_Func_move_cvt( A, B );
         }
       }
     }
 
     CUR.new_top = CUR.args;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* MISC. INSTRUCTIONS                                                    */
   /*                                                                       */
   /*************************************************************************/
 
 
   /*************************************************************************/
   /*                                                                       */
   /* GETINFO[]:    GET INFOrmation                                         */
   /* Opcode range: 0x88                                                    */
   /* Stack:        uint32 --> uint32                                       */
   /*                                                                       */
   static void
   Ins_GETINFO( INS_ARG )
   {
     FT_Long  K;
 
 
     K = 0;
 
     /* We return MS rasterizer version 1.7 for the font scaler. */
     if ( ( args[0] & 1 ) != 0 )
       K = 35;
 
     /* Has the glyph been rotated? */
     if ( ( args[0] & 2 ) != 0 && CUR.tt_metrics.rotated )
       K |= 0x80;
 
     /* Has the glyph been stretched? */
     if ( ( args[0] & 4 ) != 0 && CUR.tt_metrics.stretched )
       K |= 1 << 8;
 
     /* Are we hinting for grayscale? */
     if ( ( args[0] & 32 ) != 0 && CUR.grayscale )
       K |= 1 << 12;
 
     args[0] = K;
   }
 
 
   static void
   Ins_UNKNOWN( INS_ARG )
   {
     TT_DefRecord*  def   = CUR.IDefs;
     TT_DefRecord*  limit = def + CUR.numIDefs;
 
     FT_UNUSED_ARG;
 
 
     for ( ; def < limit; def++ )
     {
       if ( (FT_Byte)def->opc == CUR.opcode && def->active )
       {
         TT_CallRec*  call;
 
 
         if ( CUR.callTop >= CUR.callSize )
         {
           CUR.error = TT_Err_Stack_Overflow;
           return;
         }
 
         call = CUR.callStack + CUR.callTop++;
 
         call->Caller_Range = CUR.curRange;
         call->Caller_IP    = CUR.IP + 1;
         call->Cur_Count    = 1;
         call->Cur_Restart  = def->start;
 
         INS_Goto_CodeRange( def->range, def->start );
 
         CUR.step_ins = FALSE;
         return;
       }
     }
 
     CUR.error = TT_Err_Invalid_Opcode;
   }
 
 
 #ifndef TT_CONFIG_OPTION_INTERPRETER_SWITCH
 
 
   static
   TInstruction_Function  Instruct_Dispatch[256] =
   {
     /* Opcodes are gathered in groups of 16. */
     /* Please keep the spaces as they are.   */
 
     /*  SVTCA  y  */  Ins_SVTCA,
     /*  SVTCA  x  */  Ins_SVTCA,
     /*  SPvTCA y  */  Ins_SPVTCA,
     /*  SPvTCA x  */  Ins_SPVTCA,
     /*  SFvTCA y  */  Ins_SFVTCA,
     /*  SFvTCA x  */  Ins_SFVTCA,
     /*  SPvTL //  */  Ins_SPVTL,
     /*  SPvTL +   */  Ins_SPVTL,
     /*  SFvTL //  */  Ins_SFVTL,
     /*  SFvTL +   */  Ins_SFVTL,
     /*  SPvFS     */  Ins_SPVFS,
     /*  SFvFS     */  Ins_SFVFS,
     /*  GPV       */  Ins_GPV,
     /*  GFV       */  Ins_GFV,
     /*  SFvTPv    */  Ins_SFVTPV,
     /*  ISECT     */  Ins_ISECT,
 
     /*  SRP0      */  Ins_SRP0,
     /*  SRP1      */  Ins_SRP1,
     /*  SRP2      */  Ins_SRP2,
     /*  SZP0      */  Ins_SZP0,
     /*  SZP1      */  Ins_SZP1,
     /*  SZP2      */  Ins_SZP2,
     /*  SZPS      */  Ins_SZPS,
     /*  SLOOP     */  Ins_SLOOP,
     /*  RTG       */  Ins_RTG,
     /*  RTHG      */  Ins_RTHG,
     /*  SMD       */  Ins_SMD,
     /*  ELSE      */  Ins_ELSE,
     /*  JMPR      */  Ins_JMPR,
     /*  SCvTCi    */  Ins_SCVTCI,
     /*  SSwCi     */  Ins_SSWCI,
     /*  SSW       */  Ins_SSW,
 
     /*  DUP       */  Ins_DUP,
     /*  POP       */  Ins_POP,
     /*  CLEAR     */  Ins_CLEAR,
     /*  SWAP      */  Ins_SWAP,
     /*  DEPTH     */  Ins_DEPTH,
     /*  CINDEX    */  Ins_CINDEX,
     /*  MINDEX    */  Ins_MINDEX,
     /*  AlignPTS  */  Ins_ALIGNPTS,
     /*  INS_0x28  */  Ins_UNKNOWN,
     /*  UTP       */  Ins_UTP,
     /*  LOOPCALL  */  Ins_LOOPCALL,
     /*  CALL      */  Ins_CALL,
     /*  FDEF      */  Ins_FDEF,
     /*  ENDF      */  Ins_ENDF,
     /*  MDAP[0]   */  Ins_MDAP,
     /*  MDAP[1]   */  Ins_MDAP,
 
     /*  IUP[0]    */  Ins_IUP,
     /*  IUP[1]    */  Ins_IUP,
     /*  SHP[0]    */  Ins_SHP,
     /*  SHP[1]    */  Ins_SHP,
     /*  SHC[0]    */  Ins_SHC,
     /*  SHC[1]    */  Ins_SHC,
     /*  SHZ[0]    */  Ins_SHZ,
     /*  SHZ[1]    */  Ins_SHZ,
     /*  SHPIX     */  Ins_SHPIX,
     /*  IP        */  Ins_IP,
     /*  MSIRP[0]  */  Ins_MSIRP,
     /*  MSIRP[1]  */  Ins_MSIRP,
     /*  AlignRP   */  Ins_ALIGNRP,
     /*  RTDG      */  Ins_RTDG,
     /*  MIAP[0]   */  Ins_MIAP,
     /*  MIAP[1]   */  Ins_MIAP,
 
     /*  NPushB    */  Ins_NPUSHB,
     /*  NPushW    */  Ins_NPUSHW,
     /*  WS        */  Ins_WS,
     /*  RS        */  Ins_RS,
     /*  WCvtP     */  Ins_WCVTP,
     /*  RCvt      */  Ins_RCVT,
     /*  GC[0]     */  Ins_GC,
     /*  GC[1]     */  Ins_GC,
     /*  SCFS      */  Ins_SCFS,
     /*  MD[0]     */  Ins_MD,
     /*  MD[1]     */  Ins_MD,
     /*  MPPEM     */  Ins_MPPEM,
     /*  MPS       */  Ins_MPS,
     /*  FlipON    */  Ins_FLIPON,
     /*  FlipOFF   */  Ins_FLIPOFF,
     /*  DEBUG     */  Ins_DEBUG,
 
     /*  LT        */  Ins_LT,
     /*  LTEQ      */  Ins_LTEQ,
     /*  GT        */  Ins_GT,
     /*  GTEQ      */  Ins_GTEQ,
     /*  EQ        */  Ins_EQ,
     /*  NEQ       */  Ins_NEQ,
     /*  ODD       */  Ins_ODD,
     /*  EVEN      */  Ins_EVEN,
     /*  IF        */  Ins_IF,
     /*  EIF       */  Ins_EIF,
     /*  AND       */  Ins_AND,
     /*  OR        */  Ins_OR,
     /*  NOT       */  Ins_NOT,
     /*  DeltaP1   */  Ins_DELTAP,
     /*  SDB       */  Ins_SDB,
     /*  SDS       */  Ins_SDS,
 
     /*  ADD       */  Ins_ADD,
     /*  SUB       */  Ins_SUB,
     /*  DIV       */  Ins_DIV,
     /*  MUL       */  Ins_MUL,
     /*  ABS       */  Ins_ABS,
     /*  NEG       */  Ins_NEG,
     /*  FLOOR     */  Ins_FLOOR,
     /*  CEILING   */  Ins_CEILING,
     /*  ROUND[0]  */  Ins_ROUND,
     /*  ROUND[1]  */  Ins_ROUND,
     /*  ROUND[2]  */  Ins_ROUND,
     /*  ROUND[3]  */  Ins_ROUND,
     /*  NROUND[0] */  Ins_NROUND,
     /*  NROUND[1] */  Ins_NROUND,
     /*  NROUND[2] */  Ins_NROUND,
     /*  NROUND[3] */  Ins_NROUND,
 
     /*  WCvtF     */  Ins_WCVTF,
     /*  DeltaP2   */  Ins_DELTAP,
     /*  DeltaP3   */  Ins_DELTAP,
     /*  DeltaCn[0] */ Ins_DELTAC,
     /*  DeltaCn[1] */ Ins_DELTAC,
     /*  DeltaCn[2] */ Ins_DELTAC,
     /*  SROUND    */  Ins_SROUND,
     /*  S45Round  */  Ins_S45ROUND,
     /*  JROT      */  Ins_JROT,
     /*  JROF      */  Ins_JROF,
     /*  ROFF      */  Ins_ROFF,
     /*  INS_0x7B  */  Ins_UNKNOWN,
     /*  RUTG      */  Ins_RUTG,
     /*  RDTG      */  Ins_RDTG,
     /*  SANGW     */  Ins_SANGW,
     /*  AA        */  Ins_AA,
 
     /*  FlipPT    */  Ins_FLIPPT,
     /*  FlipRgON  */  Ins_FLIPRGON,
     /*  FlipRgOFF */  Ins_FLIPRGOFF,
     /*  INS_0x83  */  Ins_UNKNOWN,
     /*  INS_0x84  */  Ins_UNKNOWN,
     /*  ScanCTRL  */  Ins_SCANCTRL,
     /*  SDPVTL[0] */  Ins_SDPVTL,
     /*  SDPVTL[1] */  Ins_SDPVTL,
     /*  GetINFO   */  Ins_GETINFO,
     /*  IDEF      */  Ins_IDEF,
     /*  ROLL      */  Ins_ROLL,
     /*  MAX       */  Ins_MAX,
     /*  MIN       */  Ins_MIN,
     /*  ScanTYPE  */  Ins_SCANTYPE,
     /*  InstCTRL  */  Ins_INSTCTRL,
     /*  INS_0x8F  */  Ins_UNKNOWN,
 
     /*  INS_0x90  */   Ins_UNKNOWN,
     /*  INS_0x91  */   Ins_UNKNOWN,
     /*  INS_0x92  */   Ins_UNKNOWN,
     /*  INS_0x93  */   Ins_UNKNOWN,
     /*  INS_0x94  */   Ins_UNKNOWN,
     /*  INS_0x95  */   Ins_UNKNOWN,
     /*  INS_0x96  */   Ins_UNKNOWN,
     /*  INS_0x97  */   Ins_UNKNOWN,
     /*  INS_0x98  */   Ins_UNKNOWN,
     /*  INS_0x99  */   Ins_UNKNOWN,
     /*  INS_0x9A  */   Ins_UNKNOWN,
     /*  INS_0x9B  */   Ins_UNKNOWN,
     /*  INS_0x9C  */   Ins_UNKNOWN,
     /*  INS_0x9D  */   Ins_UNKNOWN,
     /*  INS_0x9E  */   Ins_UNKNOWN,
     /*  INS_0x9F  */   Ins_UNKNOWN,
 
     /*  INS_0xA0  */   Ins_UNKNOWN,
     /*  INS_0xA1  */   Ins_UNKNOWN,
     /*  INS_0xA2  */   Ins_UNKNOWN,
     /*  INS_0xA3  */   Ins_UNKNOWN,
     /*  INS_0xA4  */   Ins_UNKNOWN,
     /*  INS_0xA5  */   Ins_UNKNOWN,
     /*  INS_0xA6  */   Ins_UNKNOWN,
     /*  INS_0xA7  */   Ins_UNKNOWN,
     /*  INS_0xA8  */   Ins_UNKNOWN,
     /*  INS_0xA9  */   Ins_UNKNOWN,
     /*  INS_0xAA  */   Ins_UNKNOWN,
     /*  INS_0xAB  */   Ins_UNKNOWN,
     /*  INS_0xAC  */   Ins_UNKNOWN,
     /*  INS_0xAD  */   Ins_UNKNOWN,
     /*  INS_0xAE  */   Ins_UNKNOWN,
     /*  INS_0xAF  */   Ins_UNKNOWN,
 
     /*  PushB[0]  */  Ins_PUSHB,
     /*  PushB[1]  */  Ins_PUSHB,
     /*  PushB[2]  */  Ins_PUSHB,
     /*  PushB[3]  */  Ins_PUSHB,
     /*  PushB[4]  */  Ins_PUSHB,
     /*  PushB[5]  */  Ins_PUSHB,
     /*  PushB[6]  */  Ins_PUSHB,
     /*  PushB[7]  */  Ins_PUSHB,
     /*  PushW[0]  */  Ins_PUSHW,
     /*  PushW[1]  */  Ins_PUSHW,
     /*  PushW[2]  */  Ins_PUSHW,
     /*  PushW[3]  */  Ins_PUSHW,
     /*  PushW[4]  */  Ins_PUSHW,
     /*  PushW[5]  */  Ins_PUSHW,
     /*  PushW[6]  */  Ins_PUSHW,
     /*  PushW[7]  */  Ins_PUSHW,
 
     /*  MDRP[00]  */  Ins_MDRP,
     /*  MDRP[01]  */  Ins_MDRP,
     /*  MDRP[02]  */  Ins_MDRP,
     /*  MDRP[03]  */  Ins_MDRP,
     /*  MDRP[04]  */  Ins_MDRP,
     /*  MDRP[05]  */  Ins_MDRP,
     /*  MDRP[06]  */  Ins_MDRP,
     /*  MDRP[07]  */  Ins_MDRP,
     /*  MDRP[08]  */  Ins_MDRP,
     /*  MDRP[09]  */  Ins_MDRP,
     /*  MDRP[10]  */  Ins_MDRP,
     /*  MDRP[11]  */  Ins_MDRP,
     /*  MDRP[12]  */  Ins_MDRP,
     /*  MDRP[13]  */  Ins_MDRP,
     /*  MDRP[14]  */  Ins_MDRP,
     /*  MDRP[15]  */  Ins_MDRP,
 
     /*  MDRP[16]  */  Ins_MDRP,
     /*  MDRP[17]  */  Ins_MDRP,
     /*  MDRP[18]  */  Ins_MDRP,
     /*  MDRP[19]  */  Ins_MDRP,
     /*  MDRP[20]  */  Ins_MDRP,
     /*  MDRP[21]  */  Ins_MDRP,
     /*  MDRP[22]  */  Ins_MDRP,
     /*  MDRP[23]  */  Ins_MDRP,
     /*  MDRP[24]  */  Ins_MDRP,
     /*  MDRP[25]  */  Ins_MDRP,
     /*  MDRP[26]  */  Ins_MDRP,
     /*  MDRP[27]  */  Ins_MDRP,
     /*  MDRP[28]  */  Ins_MDRP,
     /*  MDRP[29]  */  Ins_MDRP,
     /*  MDRP[30]  */  Ins_MDRP,
     /*  MDRP[31]  */  Ins_MDRP,
 
     /*  MIRP[00]  */  Ins_MIRP,
     /*  MIRP[01]  */  Ins_MIRP,
     /*  MIRP[02]  */  Ins_MIRP,
     /*  MIRP[03]  */  Ins_MIRP,
     /*  MIRP[04]  */  Ins_MIRP,
     /*  MIRP[05]  */  Ins_MIRP,
     /*  MIRP[06]  */  Ins_MIRP,
     /*  MIRP[07]  */  Ins_MIRP,
     /*  MIRP[08]  */  Ins_MIRP,
     /*  MIRP[09]  */  Ins_MIRP,
     /*  MIRP[10]  */  Ins_MIRP,
     /*  MIRP[11]  */  Ins_MIRP,
     /*  MIRP[12]  */  Ins_MIRP,
     /*  MIRP[13]  */  Ins_MIRP,
     /*  MIRP[14]  */  Ins_MIRP,
     /*  MIRP[15]  */  Ins_MIRP,
 
     /*  MIRP[16]  */  Ins_MIRP,
     /*  MIRP[17]  */  Ins_MIRP,
     /*  MIRP[18]  */  Ins_MIRP,
     /*  MIRP[19]  */  Ins_MIRP,
     /*  MIRP[20]  */  Ins_MIRP,
     /*  MIRP[21]  */  Ins_MIRP,
     /*  MIRP[22]  */  Ins_MIRP,
     /*  MIRP[23]  */  Ins_MIRP,
     /*  MIRP[24]  */  Ins_MIRP,
     /*  MIRP[25]  */  Ins_MIRP,
     /*  MIRP[26]  */  Ins_MIRP,
     /*  MIRP[27]  */  Ins_MIRP,
     /*  MIRP[28]  */  Ins_MIRP,
     /*  MIRP[29]  */  Ins_MIRP,
     /*  MIRP[30]  */  Ins_MIRP,
     /*  MIRP[31]  */  Ins_MIRP
   };
 
 
 #endif /* !TT_CONFIG_OPTION_INTERPRETER_SWITCH */
 
 
   /*************************************************************************/
   /*                                                                       */
   /* RUN                                                                   */
   /*                                                                       */
   /*  This function executes a run of opcodes.  It will exit in the        */
   /*  following cases:                                                     */
   /*                                                                       */
   /*  - Errors (in which case it returns FALSE).                           */
   /*                                                                       */
   /*  - Reaching the end of the main code range (returns TRUE).            */
   /*    Reaching the end of a code range within a function call is an      */
   /*    error.                                                             */
   /*                                                                       */
   /*  - After executing one single opcode, if the flag `Instruction_Trap'  */
   /*    is set to TRUE (returns TRUE).                                     */
   /*                                                                       */
   /*  On exit with TRUE, test IP < CodeSize to know whether it comes from  */
   /*  an instruction trap or a normal termination.                         */
   /*                                                                       */
   /*                                                                       */
   /*  Note: The documented DEBUG opcode pops a value from the stack.  This */
   /*        behaviour is unsupported; here a DEBUG opcode is always an     */
   /*        error.                                                         */
   /*                                                                       */
   /*                                                                       */
   /* THIS IS THE INTERPRETER'S MAIN LOOP.                                  */
   /*                                                                       */
   /*  Instructions appear in the specification's order.                    */
   /*                                                                       */
   /*************************************************************************/
 
 
   /* documentation is in ttinterp.h */
 
   FT_EXPORT_DEF( FT_Error )
   TT_RunIns( TT_ExecContext  exc )
   {
     FT_Long  ins_counter = 0;  /* executed instructions counter */
 
 
 #ifdef TT_CONFIG_OPTION_STATIC_RASTER
     cur = *exc;
 #endif
 
     /* set CVT functions */
     CUR.tt_metrics.ratio = 0;
     if ( CUR.metrics.x_ppem != CUR.metrics.y_ppem )
     {
       /* non-square pixels, use the stretched routines */
       CUR.func_read_cvt  = Read_CVT_Stretched;
       CUR.func_write_cvt = Write_CVT_Stretched;
       CUR.func_move_cvt  = Move_CVT_Stretched;
     }
     else
     {
       /* square pixels, use normal routines */
       CUR.func_read_cvt  = Read_CVT;
       CUR.func_write_cvt = Write_CVT;
       CUR.func_move_cvt  = Move_CVT;
     }
 
     COMPUTE_Funcs();
     COMPUTE_Round( (FT_Byte)exc->GS.round_state );
 
     do
     {
       CUR.opcode = CUR.code[CUR.IP];
 
       FT_TRACE7(( "  " ));
       FT_TRACE7(( opcode_name[CUR.opcode] ));
       FT_TRACE7(( "\n" ));
 
       if ( ( CUR.length = opcode_length[CUR.opcode] ) < 0 )
       {
         if ( CUR.IP + 1 > CUR.codeSize )
           goto LErrorCodeOverflow_;
 
         CUR.length = 2 - CUR.length * CUR.code[CUR.IP + 1];
       }
 
       if ( CUR.IP + CUR.length > CUR.codeSize )
         goto LErrorCodeOverflow_;
 
       /* First, let's check for empty stack and overflow */
       CUR.args = CUR.top - ( Pop_Push_Count[CUR.opcode] >> 4 );
 
       /* `args' is the top of the stack once arguments have been popped. */
       /* One can also interpret it as the index of the last argument.    */
       if ( CUR.args < 0 )
       {
         CUR.error = TT_Err_Too_Few_Arguments;
         goto LErrorLabel_;
       }
 
       CUR.new_top = CUR.args + ( Pop_Push_Count[CUR.opcode] & 15 );
 
       /* `new_top' is the new top of the stack, after the instruction's */
       /* execution.  `top' will be set to `new_top' after the `switch'  */
       /* statement.                                                     */
       if ( CUR.new_top > CUR.stackSize )
       {
         CUR.error = TT_Err_Stack_Overflow;
         goto LErrorLabel_;
       }
 
       CUR.step_ins = TRUE;
       CUR.error    = TT_Err_Ok;
 
 #ifdef TT_CONFIG_OPTION_INTERPRETER_SWITCH
 
       {
         FT_Long*  args   = CUR.stack + CUR.args;
         FT_Byte   opcode = CUR.opcode;
 
 
 #undef  ARRAY_BOUND_ERROR
 #define ARRAY_BOUND_ERROR  goto Set_Invalid_Ref
 
 
         switch ( opcode )
         {
         case 0x00:  /* SVTCA y  */
         case 0x01:  /* SVTCA x  */
         case 0x02:  /* SPvTCA y */
         case 0x03:  /* SPvTCA x */
         case 0x04:  /* SFvTCA y */
         case 0x05:  /* SFvTCA x */
           {
             FT_Short AA, BB;
 
 
             AA = (FT_Short)( ( opcode & 1 ) << 14 );
             BB = (FT_Short)( AA ^ 0x4000 );
 
             if ( opcode < 4 )
             {
               CUR.GS.projVector.x = AA;
               CUR.GS.projVector.y = BB;
 
               CUR.GS.dualVector.x = AA;
               CUR.GS.dualVector.y = BB;
             }
             else
             {
               GUESS_VECTOR( projVector );
             }
 
             if ( ( opcode & 2 ) == 0 )
             {
               CUR.GS.freeVector.x = AA;
               CUR.GS.freeVector.y = BB;
             }
             else
             {
               GUESS_VECTOR( freeVector );
             }
 
             COMPUTE_Funcs();
           }
           break;
 
         case 0x06:  /* SPvTL // */
         case 0x07:  /* SPvTL +  */
           DO_SPVTL
           break;
 
         case 0x08:  /* SFvTL // */
         case 0x09:  /* SFvTL +  */
           DO_SFVTL
           break;
 
         case 0x0A:  /* SPvFS */
           DO_SPVFS
           break;
 
         case 0x0B:  /* SFvFS */
           DO_SFVFS
           break;
 
         case 0x0C:  /* GPV */
           DO_GPV
           break;
 
         case 0x0D:  /* GFV */
           DO_GFV
           break;
 
         case 0x0E:  /* SFvTPv */
           DO_SFVTPV
           break;
 
         case 0x0F:  /* ISECT  */
           Ins_ISECT( EXEC_ARG_ args );
           break;
 
         case 0x10:  /* SRP0 */
           DO_SRP0
           break;
 
         case 0x11:  /* SRP1 */
           DO_SRP1
           break;
 
         case 0x12:  /* SRP2 */
           DO_SRP2
           break;
 
         case 0x13:  /* SZP0 */
           Ins_SZP0( EXEC_ARG_ args );
           break;
 
         case 0x14:  /* SZP1 */
           Ins_SZP1( EXEC_ARG_ args );
           break;
 
         case 0x15:  /* SZP2 */
           Ins_SZP2( EXEC_ARG_ args );
           break;
 
         case 0x16:  /* SZPS */
           Ins_SZPS( EXEC_ARG_ args );
           break;
 
         case 0x17:  /* SLOOP */
           DO_SLOOP
           break;
 
         case 0x18:  /* RTG */
           DO_RTG
           break;
 
         case 0x19:  /* RTHG */
           DO_RTHG
           break;
 
         case 0x1A:  /* SMD */
           DO_SMD
           break;
 
         case 0x1B:  /* ELSE */
           Ins_ELSE( EXEC_ARG_ args );
           break;
 
         case 0x1C:  /* JMPR */
           DO_JMPR
           break;
 
         case 0x1D:  /* SCVTCI */
           DO_SCVTCI
           break;
 
         case 0x1E:  /* SSWCI */
           DO_SSWCI
           break;
 
         case 0x1F:  /* SSW */
           DO_SSW
           break;
 
         case 0x20:  /* DUP */
           DO_DUP
           break;
 
         case 0x21:  /* POP */
           /* nothing :-) */
           break;
 
         case 0x22:  /* CLEAR */
           DO_CLEAR
           break;
 
         case 0x23:  /* SWAP */
           DO_SWAP
           break;
 
         case 0x24:  /* DEPTH */
           DO_DEPTH
           break;
 
         case 0x25:  /* CINDEX */
           DO_CINDEX
           break;
 
         case 0x26:  /* MINDEX */
           Ins_MINDEX( EXEC_ARG_ args );
           break;
 
         case 0x27:  /* ALIGNPTS */
           Ins_ALIGNPTS( EXEC_ARG_ args );
           break;
 
         case 0x28:  /* ???? */
           Ins_UNKNOWN( EXEC_ARG_ args );
           break;
 
         case 0x29:  /* UTP */
           Ins_UTP( EXEC_ARG_ args );
           break;
 
         case 0x2A:  /* LOOPCALL */
           Ins_LOOPCALL( EXEC_ARG_ args );
           break;
 
         case 0x2B:  /* CALL */
           Ins_CALL( EXEC_ARG_ args );
           break;
 
         case 0x2C:  /* FDEF */
           Ins_FDEF( EXEC_ARG_ args );
           break;
 
         case 0x2D:  /* ENDF */
           Ins_ENDF( EXEC_ARG_ args );
           break;
 
         case 0x2E:  /* MDAP */
         case 0x2F:  /* MDAP */
           Ins_MDAP( EXEC_ARG_ args );
           break;
 
 
         case 0x30:  /* IUP */
         case 0x31:  /* IUP */
           Ins_IUP( EXEC_ARG_ args );
           break;
 
         case 0x32:  /* SHP */
         case 0x33:  /* SHP */
           Ins_SHP( EXEC_ARG_ args );
           break;
 
         case 0x34:  /* SHC */
         case 0x35:  /* SHC */
           Ins_SHC( EXEC_ARG_ args );
           break;
 
         case 0x36:  /* SHZ */
         case 0x37:  /* SHZ */
           Ins_SHZ( EXEC_ARG_ args );
           break;
 
         case 0x38:  /* SHPIX */
           Ins_SHPIX( EXEC_ARG_ args );
           break;
 
         case 0x39:  /* IP    */
           Ins_IP( EXEC_ARG_ args );
           break;
 
         case 0x3A:  /* MSIRP */
         case 0x3B:  /* MSIRP */
           Ins_MSIRP( EXEC_ARG_ args );
           break;
 
         case 0x3C:  /* AlignRP */
           Ins_ALIGNRP( EXEC_ARG_ args );
           break;
 
         case 0x3D:  /* RTDG */
           DO_RTDG
           break;
 
         case 0x3E:  /* MIAP */
         case 0x3F:  /* MIAP */
           Ins_MIAP( EXEC_ARG_ args );
           break;
 
         case 0x40:  /* NPUSHB */
           Ins_NPUSHB( EXEC_ARG_ args );
           break;
 
         case 0x41:  /* NPUSHW */
           Ins_NPUSHW( EXEC_ARG_ args );
           break;
 
         case 0x42:  /* WS */
           DO_WS
           break;
 
       Set_Invalid_Ref:
             CUR.error = TT_Err_Invalid_Reference;
           break;
 
         case 0x43:  /* RS */
           DO_RS
           break;
 
         case 0x44:  /* WCVTP */
           DO_WCVTP
           break;
 
         case 0x45:  /* RCVT */
           DO_RCVT
           break;
 
         case 0x46:  /* GC */
         case 0x47:  /* GC */
           Ins_GC( EXEC_ARG_ args );
           break;
 
         case 0x48:  /* SCFS */
           Ins_SCFS( EXEC_ARG_ args );
           break;
 
         case 0x49:  /* MD */
         case 0x4A:  /* MD */
           Ins_MD( EXEC_ARG_ args );
           break;
 
         case 0x4B:  /* MPPEM */
           DO_MPPEM
           break;
 
         case 0x4C:  /* MPS */
           DO_MPS
           break;
 
         case 0x4D:  /* FLIPON */
           DO_FLIPON
           break;
 
         case 0x4E:  /* FLIPOFF */
           DO_FLIPOFF
           break;
 
         case 0x4F:  /* DEBUG */
           DO_DEBUG
           break;
 
         case 0x50:  /* LT */
           DO_LT
           break;
 
         case 0x51:  /* LTEQ */
           DO_LTEQ
           break;
 
         case 0x52:  /* GT */
           DO_GT
           break;
 
         case 0x53:  /* GTEQ */
           DO_GTEQ
           break;
 
         case 0x54:  /* EQ */
           DO_EQ
           break;
 
         case 0x55:  /* NEQ */
           DO_NEQ
           break;
 
         case 0x56:  /* ODD */
           DO_ODD
           break;
 
         case 0x57:  /* EVEN */
           DO_EVEN
           break;
 
         case 0x58:  /* IF */
           Ins_IF( EXEC_ARG_ args );
           break;
 
         case 0x59:  /* EIF */
           /* do nothing */
           break;
 
         case 0x5A:  /* AND */
           DO_AND
           break;
 
         case 0x5B:  /* OR */
           DO_OR
           break;
 
         case 0x5C:  /* NOT */
           DO_NOT
           break;
 
         case 0x5D:  /* DELTAP1 */
           Ins_DELTAP( EXEC_ARG_ args );
           break;
 
         case 0x5E:  /* SDB */
           DO_SDB
           break;
 
         case 0x5F:  /* SDS */
           DO_SDS
           break;
 
         case 0x60:  /* ADD */
           DO_ADD
           break;
 
         case 0x61:  /* SUB */
           DO_SUB
           break;
 
         case 0x62:  /* DIV */
           DO_DIV
           break;
 
         case 0x63:  /* MUL */
           DO_MUL
           break;
 
         case 0x64:  /* ABS */
           DO_ABS
           break;
 
         case 0x65:  /* NEG */
           DO_NEG
           break;
 
         case 0x66:  /* FLOOR */
           DO_FLOOR
           break;
 
         case 0x67:  /* CEILING */
           DO_CEILING
           break;
 
         case 0x68:  /* ROUND */
         case 0x69:  /* ROUND */
         case 0x6A:  /* ROUND */
         case 0x6B:  /* ROUND */
           DO_ROUND
           break;
 
         case 0x6C:  /* NROUND */
         case 0x6D:  /* NROUND */
         case 0x6E:  /* NRRUND */
         case 0x6F:  /* NROUND */
           DO_NROUND
           break;
 
         case 0x70:  /* WCVTF */
           DO_WCVTF
           break;
 
         case 0x71:  /* DELTAP2 */
         case 0x72:  /* DELTAP3 */
           Ins_DELTAP( EXEC_ARG_ args );
           break;
 
         case 0x73:  /* DELTAC0 */
         case 0x74:  /* DELTAC1 */
         case 0x75:  /* DELTAC2 */
           Ins_DELTAC( EXEC_ARG_ args );
           break;
 
         case 0x76:  /* SROUND */
           DO_SROUND
           break;
 
         case 0x77:  /* S45Round */
           DO_S45ROUND
           break;
 
         case 0x78:  /* JROT */
           DO_JROT
           break;
 
         case 0x79:  /* JROF */
           DO_JROF
           break;
 
         case 0x7A:  /* ROFF */
           DO_ROFF
           break;
 
         case 0x7B:  /* ???? */
           Ins_UNKNOWN( EXEC_ARG_ args );
           break;
 
         case 0x7C:  /* RUTG */
           DO_RUTG
           break;
 
         case 0x7D:  /* RDTG */
           DO_RDTG
           break;
 
         case 0x7E:  /* SANGW */
         case 0x7F:  /* AA    */
           /* nothing - obsolete */
           break;
 
         case 0x80:  /* FLIPPT */
           Ins_FLIPPT( EXEC_ARG_ args );
           break;
 
         case 0x81:  /* FLIPRGON */
           Ins_FLIPRGON( EXEC_ARG_ args );
           break;
 
         case 0x82:  /* FLIPRGOFF */
           Ins_FLIPRGOFF( EXEC_ARG_ args );
           break;
 
         case 0x83:  /* UNKNOWN */
         case 0x84:  /* UNKNOWN */
           Ins_UNKNOWN( EXEC_ARG_ args );
           break;
 
         case 0x85:  /* SCANCTRL */
           Ins_SCANCTRL( EXEC_ARG_ args );
           break;
 
         case 0x86:  /* SDPVTL */
         case 0x87:  /* SDPVTL */
           Ins_SDPVTL( EXEC_ARG_ args );
           break;
 
         case 0x88:  /* GETINFO */
           Ins_GETINFO( EXEC_ARG_ args );
           break;
 
         case 0x89:  /* IDEF */
           Ins_IDEF( EXEC_ARG_ args );
           break;
 
         case 0x8A:  /* ROLL */
           Ins_ROLL( EXEC_ARG_ args );
           break;
 
         case 0x8B:  /* MAX */
           DO_MAX
           break;
 
         case 0x8C:  /* MIN */
           DO_MIN
           break;
 
         case 0x8D:  /* SCANTYPE */
           Ins_SCANTYPE( EXEC_ARG_ args );
           break;
 
         case 0x8E:  /* INSTCTRL */
           Ins_INSTCTRL( EXEC_ARG_ args );
           break;
 
         case 0x8F:
           Ins_UNKNOWN( EXEC_ARG_ args );
           break;
 
         default:
           if ( opcode >= 0xE0 )
             Ins_MIRP( EXEC_ARG_ args );
           else if ( opcode >= 0xC0 )
             Ins_MDRP( EXEC_ARG_ args );
           else if ( opcode >= 0xB8 )
             Ins_PUSHW( EXEC_ARG_ args );
           else if ( opcode >= 0xB0 )
             Ins_PUSHB( EXEC_ARG_ args );
           else
             Ins_UNKNOWN( EXEC_ARG_ args );
         }
 
       }
 
 #else
 
       Instruct_Dispatch[CUR.opcode]( EXEC_ARG_ &CUR.stack[CUR.args] );
 
 #endif /* TT_CONFIG_OPTION_INTERPRETER_SWITCH */
 
       if ( CUR.error != TT_Err_Ok )
       {
         switch ( CUR.error )
         {
         case TT_Err_Invalid_Opcode: /* looking for redefined instructions */
           {
             TT_DefRecord*  def   = CUR.IDefs;
             TT_DefRecord*  limit = def + CUR.numIDefs;
 
 
             for ( ; def < limit; def++ )
             {
               if ( def->active && CUR.opcode == (FT_Byte)def->opc )
               {
                 TT_CallRec*  callrec;
 
 
                 if ( CUR.callTop >= CUR.callSize )
                 {
                   CUR.error = TT_Err_Invalid_Reference;
                   goto LErrorLabel_;
                 }
 
                 callrec = &CUR.callStack[CUR.callTop];
 
                 callrec->Caller_Range = CUR.curRange;
                 callrec->Caller_IP    = CUR.IP + 1;
                 callrec->Cur_Count    = 1;
                 callrec->Cur_Restart  = def->start;
 
                 if ( INS_Goto_CodeRange( def->range, def->start ) == FAILURE )
                   goto LErrorLabel_;
 
                 goto LSuiteLabel_;
               }
             }
           }
 
           CUR.error = TT_Err_Invalid_Opcode;
           goto LErrorLabel_;
 
 #if 0
           break;   /* Unreachable code warning suppression.             */
                    /* Leave to remind in case a later change the editor */
                    /* to consider break;                                */
 #endif
 
         default:
           goto LErrorLabel_;
 
 #if 0
         break;
 #endif
         }
       }
 
       CUR.top = CUR.new_top;
 
       if ( CUR.step_ins )
         CUR.IP += CUR.length;
 
       /* increment instruction counter and check if we didn't */
       /* run this program for too long (e.g. infinite loops). */
       if ( ++ins_counter > MAX_RUNNABLE_OPCODES )
         return TT_Err_Execution_Too_Long;
 
     LSuiteLabel_:
       if ( CUR.IP >= CUR.codeSize )
       {
         if ( CUR.callTop > 0 )
         {
           CUR.error = TT_Err_Code_Overflow;
           goto LErrorLabel_;
         }
         else
           goto LNo_Error_;
       }
     } while ( !CUR.instruction_trap );
 
   LNo_Error_:
 
 #ifdef TT_CONFIG_OPTION_STATIC_RASTER
     *exc = cur;
 #endif
 
     return TT_Err_Ok;
 
   LErrorCodeOverflow_:
     CUR.error = TT_Err_Code_Overflow;
 
   LErrorLabel_:
 
 #ifdef TT_CONFIG_OPTION_STATIC_RASTER
     *exc = cur;
 #endif
 
     return CUR.error;
   }
 
 
 #endif /* TT_USE_BYTECODE_INTERPRETER */
 
 
 /* END */
