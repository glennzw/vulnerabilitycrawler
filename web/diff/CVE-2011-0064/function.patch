commit a6a79df5fe2ed2cd307e7a991346faee164e70d9
Author: Behdad Esfahbod <behdad@behdad.org>
Date:   Fri May 14 23:20:16 2010 -0400

    Handle malloc failture in the buffer

diff --git a/src/hb-buffer-private.hh b/src/hb-buffer-private.hh
index b293b96..d897627 100644
--- a/src/hb-buffer-private.hh
+++ b/src/hb-buffer-private.hh
@@ -98,54 +98,55 @@ _hb_buffer_next_glyph (hb_buffer_t *buffer);
 struct _hb_buffer_t {
   hb_reference_count_t ref_count;
 
   /* Information about how the text in the buffer should be treated */
   hb_unicode_funcs_t *unicode;
   hb_direction_t      direction;
   hb_script_t         script;
   hb_language_t       language;
 
   /* Buffer contents */
 
   unsigned int allocated; /* Length of allocated arrays */
 
-  hb_bool_t    have_output; /* Whether we have an output buffer going on */
-  hb_bool_t    have_positions; /* Whether we have positions */
+  hb_bool_t have_output; /* Whether we have an output buffer going on */
+  hb_bool_t have_positions; /* Whether we have positions */
+  hb_bool_t in_error; /* Allocation failed */
 
   unsigned int i; /* Cursor into ->info and ->pos arrays */
   unsigned int len; /* Length of ->info and ->pos arrays */
   unsigned int out_len; /* Length of ->out array */
 
   hb_internal_glyph_info_t     *info;
   hb_internal_glyph_info_t     *out_info;
   hb_internal_glyph_position_t *pos;
 
   /* Other stuff */
 
   unsigned int max_lig_id;
 
 
   /* Methods */
   inline unsigned int allocate_lig_id (void) { return max_lig_id++; }
   inline void swap (void) { _hb_buffer_swap (this); }
   inline void clear_output (void) { _hb_buffer_clear_output (this); }
   inline void next_glyph (void) { _hb_buffer_next_glyph (this); }
   inline void add_output_glyphs (unsigned int num_in,
 				 unsigned int num_out,
 				 const hb_codepoint_t *glyph_data,
 				 unsigned short component,
 				 unsigned short ligID)
   { _hb_buffer_add_output_glyphs (this, num_in, num_out, glyph_data, component, ligID); }
   inline void add_output_glyphs_be16 (unsigned int num_in,
 				      unsigned int num_out,
 				      const uint16_t *glyph_data_be,
 				      unsigned short component,
 				      unsigned short ligID)
   { _hb_buffer_add_output_glyphs_be16 (this, num_in, num_out, glyph_data_be, component, ligID); }
   inline void add_output_glyph (hb_codepoint_t glyph_index,
 				unsigned short component = 0xFFFF,
 				unsigned short ligID = 0xFFFF)
   { _hb_buffer_add_output_glyph (this, glyph_index, component, ligID); }
   inline void replace_glyph (hb_codepoint_t glyph_index) { add_output_glyph (glyph_index); }
 };
 
 
diff --git a/src/hb-buffer.cc b/src/hb-buffer.cc
index e546def..6f970d0 100644
--- a/src/hb-buffer.cc
+++ b/src/hb-buffer.cc
@@ -33,45 +33,45 @@
 static hb_buffer_t _hb_buffer_nil = {
   HB_REFERENCE_COUNT_INVALID, /* ref_count */
 
   &_hb_unicode_funcs_nil  /* unicode */
 };
 
 /* Here is how the buffer works internally:
  *
  * There are two info pointers: info and out_info.  They always have
  * the same allocated size, but different lengths.
  *
  * As an optimization, both info and out_info may point to the
  * same piece of memory, which is owned by info.  This remains the
  * case as long as out_len doesn't exceed len at any time.
  * In that case, swap() is no-op and the glyph operations operate
  * mostly in-place.
  *
  * As soon as out_info gets longer than info, out_info is moved over
  * to an alternate buffer (which we reuse the pos buffer for!), and its
  * current contents (out_len entries) are copied to the new place.
  * This should all remain transparent to the user.  swap() then
  * switches info and out_info.
  */
 
-/* XXX err handling */
 
 /* Internal API */
 
-static void
+static hb_bool_t
 hb_buffer_ensure_separate (hb_buffer_t *buffer, unsigned int size)
 {
-  hb_buffer_ensure (buffer, size);
+  if (unlikely (!hb_buffer_ensure (buffer, size))) return FALSE;
+
   if (buffer->out_info == buffer->info)
   {
     assert (buffer->have_output);
-    if (!buffer->pos)
-      buffer->pos = (hb_internal_glyph_position_t *) calloc (buffer->allocated, sizeof (buffer->pos[0]));
 
     buffer->out_info = (hb_internal_glyph_info_t *) buffer->pos;
     memcpy (buffer->out_info, buffer->info, buffer->out_len * sizeof (buffer->out_info[0]));
   }
+
+  return TRUE;
 }
 
 /* Public API */
 
@@ -79,15 +79,15 @@ hb_buffer_t *
 hb_buffer_create (unsigned int pre_alloc_size)
 {
   hb_buffer_t *buffer;
 
   if (!HB_OBJECT_DO_CREATE (hb_buffer_t, buffer))
     return &_hb_buffer_nil;
 
   if (pre_alloc_size)
-    hb_buffer_ensure(buffer, pre_alloc_size);
+    hb_buffer_ensure (buffer, pre_alloc_size);
 
   buffer->unicode = &_hb_unicode_funcs_nil;
 
   return buffer;
 }
 
@@ -180,63 +180,74 @@ void
 hb_buffer_clear (hb_buffer_t *buffer)
 {
   buffer->have_output = FALSE;
   buffer->have_positions = FALSE;
+  buffer->in_error = FALSE;
   buffer->len = 0;
   buffer->out_len = 0;
   buffer->i = 0;
   buffer->out_info = buffer->info;
   buffer->max_lig_id = 0;
 }
 
-void
+hb_bool_t
 hb_buffer_ensure (hb_buffer_t *buffer, unsigned int size)
 {
-  unsigned int new_allocated = buffer->allocated;
-
-  if (size > new_allocated)
+  if (unlikely (size > buffer->allocated))
   {
+    if (unlikely (buffer->in_error))
+      return FALSE;
+
+    unsigned int new_allocated = buffer->allocated;
+    hb_internal_glyph_position_t *new_pos;
+    hb_internal_glyph_info_t *new_info;
+    bool separate_out;
+
+    separate_out = buffer->out_info != buffer->info;
+
     while (size > new_allocated)
       new_allocated += (new_allocated >> 1) + 8;
 
-    if (buffer->pos)
-      buffer->pos = (hb_internal_glyph_position_t *) realloc (buffer->pos, new_allocated * sizeof (buffer->pos[0]));
+    new_pos = (hb_internal_glyph_position_t *) realloc (buffer->pos, new_allocated * sizeof (buffer->pos[0]));
+    new_info = (hb_internal_glyph_info_t *) realloc (buffer->info, new_allocated * sizeof (buffer->info[0]));
 
-    if (buffer->out_info != buffer->info)
-    {
-      buffer->info = (hb_internal_glyph_info_t *) realloc (buffer->info, new_allocated * sizeof (buffer->info[0]));
-      buffer->out_info = (hb_internal_glyph_info_t *) buffer->pos;
-    }
-    else
-    {
-      buffer->info = (hb_internal_glyph_info_t *) realloc (buffer->info, new_allocated * sizeof (buffer->info[0]));
-      buffer->out_info = buffer->info;
-    }
+    if (unlikely (!new_pos || !new_info))
+      buffer->in_error = TRUE;
 
-    buffer->allocated = new_allocated;
+    if (likely (new_pos))
+      buffer->pos = new_pos;
+
+    if (likely (new_info))
+      buffer->info = new_info;
+
+    buffer->out_info = separate_out ? (hb_internal_glyph_info_t *) buffer->pos : buffer->info;
+    if (likely (!buffer->in_error))
+      buffer->allocated = new_allocated;
   }
+
+  return likely (!buffer->in_error);
 }
 
 void
 hb_buffer_add_glyph (hb_buffer_t    *buffer,
 		     hb_codepoint_t  codepoint,
 		     hb_mask_t       mask,
 		     unsigned int    cluster)
 {
   hb_internal_glyph_info_t *glyph;
 
-  hb_buffer_ensure (buffer, buffer->len + 1);
+  if (unlikely (!hb_buffer_ensure (buffer, buffer->len + 1))) return;
 
   glyph = &buffer->info[buffer->len];
   glyph->codepoint = codepoint;
   glyph->mask = mask;
   glyph->cluster = cluster;
   glyph->component = 0;
   glyph->lig_id = 0;
   glyph->gproperty = HB_BUFFER_GLYPH_PROPERTIES_UNKNOWN;
 
   buffer->len++;
 }
 
 
 /* HarfBuzz-Internal API */
 
@@ -269,42 +280,44 @@ void
 _hb_buffer_swap (hb_buffer_t *buffer)
 {
   unsigned int tmp;
 
   assert (buffer->have_output);
 
+  if (unlikely (buffer->in_error)) return;
+
   if (buffer->out_info != buffer->info)
   {
     hb_internal_glyph_info_t *tmp_string;
     tmp_string = buffer->info;
     buffer->info = buffer->out_info;
     buffer->out_info = tmp_string;
     buffer->pos = (hb_internal_glyph_position_t *) buffer->out_info;
   }
 
   tmp = buffer->len;
   buffer->len = buffer->out_len;
   buffer->out_len = tmp;
 
   buffer->i = 0;
 }
 
 /* The following function copies `num_out' elements from `glyph_data'
    to `buffer->out_info', advancing the in array pointer in the structure
    by `num_in' elements, and the out array pointer by `num_out' elements.
    Finally, it sets the `length' field of `out' equal to
    `pos' of the `out' structure.
 
    If `component' is 0xFFFF, the component value from buffer->i
    will copied `num_out' times, otherwise `component' itself will
    be used to fill the `component' fields.
 
    If `lig_id' is 0xFFFF, the lig_id value from buffer->i
    will copied `num_out' times, otherwise `lig_id' itself will
    be used to fill the `lig_id' fields.
 
    The mask for all replacement glyphs are taken
    from the glyph at position `buffer->i'.
 
    The cluster value for the glyph at position buffer->i is used
    for all replacement glyphs */
 
@@ -312,39 +325,40 @@ void
 _hb_buffer_add_output_glyphs (hb_buffer_t *buffer,
 			      unsigned int num_in,
 			      unsigned int num_out,
 			      const hb_codepoint_t *glyph_data,
 			      unsigned short component,
 			      unsigned short lig_id)
 {
   unsigned int i;
   unsigned int mask;
   unsigned int cluster;
 
   if (buffer->out_info != buffer->info ||
       buffer->out_len + num_out > buffer->i + num_in)
   {
-    hb_buffer_ensure_separate (buffer, buffer->out_len + num_out);
+    if (unlikely (!hb_buffer_ensure_separate (buffer, buffer->out_len + num_out)))
+      return;
   }
 
   mask = buffer->info[buffer->i].mask;
   cluster = buffer->info[buffer->i].cluster;
   if (component == 0xFFFF)
     component = buffer->info[buffer->i].component;
   if (lig_id == 0xFFFF)
     lig_id = buffer->info[buffer->i].lig_id;
 
   for (i = 0; i < num_out; i++)
   {
     hb_internal_glyph_info_t *info = &buffer->out_info[buffer->out_len + i];
     info->codepoint = glyph_data[i];
     info->mask = mask;
     info->cluster = cluster;
     info->component = component;
     info->lig_id = lig_id;
     info->gproperty = HB_BUFFER_GLYPH_PROPERTIES_UNKNOWN;
   }
 
   buffer->i  += num_in;
   buffer->out_len += num_out;
 }
 
@@ -352,39 +366,40 @@ void
 _hb_buffer_add_output_glyphs_be16 (hb_buffer_t *buffer,
 				   unsigned int num_in,
 				   unsigned int num_out,
 				   const uint16_t *glyph_data_be,
 				   unsigned short component,
 				   unsigned short lig_id)
 {
   unsigned int i;
   unsigned int mask;
   unsigned int cluster;
 
   if (buffer->out_info != buffer->info ||
       buffer->out_len + num_out > buffer->i + num_in)
   {
-    hb_buffer_ensure_separate (buffer, buffer->out_len + num_out);
+    if (unlikely (!hb_buffer_ensure_separate (buffer, buffer->out_len + num_out)))
+      return;
   }
 
   mask = buffer->info[buffer->i].mask;
   cluster = buffer->info[buffer->i].cluster;
   if (component == 0xFFFF)
     component = buffer->info[buffer->i].component;
   if (lig_id == 0xFFFF)
     lig_id = buffer->info[buffer->i].lig_id;
 
   for (i = 0; i < num_out; i++)
   {
     hb_internal_glyph_info_t *info = &buffer->out_info[buffer->out_len + i];
     info->codepoint = hb_be_uint16 (glyph_data_be[i]);
     info->mask = mask;
     info->cluster = cluster;
     info->component = component;
     info->lig_id = lig_id;
     info->gproperty = HB_BUFFER_GLYPH_PROPERTIES_UNKNOWN;
   }
 
   buffer->i  += num_in;
   buffer->out_len += num_out;
 }
 
@@ -392,27 +407,27 @@ void
 _hb_buffer_add_output_glyph (hb_buffer_t *buffer,
 			     hb_codepoint_t glyph_index,
 			     unsigned short component,
 			     unsigned short lig_id)
 {
   hb_internal_glyph_info_t *info;
 
   if (buffer->out_info != buffer->info)
   {
-    hb_buffer_ensure (buffer, buffer->out_len + 1);
+    if (unlikely (!hb_buffer_ensure (buffer, buffer->out_len + 1))) return;
     buffer->out_info[buffer->out_len] = buffer->info[buffer->i];
   }
   else if (buffer->out_len != buffer->i)
     buffer->out_info[buffer->out_len] = buffer->info[buffer->i];
 
   info = &buffer->out_info[buffer->out_len];
   info->codepoint = glyph_index;
   if (component != 0xFFFF)
     info->component = component;
   if (lig_id != 0xFFFF)
     info->lig_id = lig_id;
   info->gproperty = HB_BUFFER_GLYPH_PROPERTIES_UNKNOWN;
 
   buffer->i++;
   buffer->out_len++;
 }
 
@@ -420,19 +435,19 @@ void
 _hb_buffer_next_glyph (hb_buffer_t *buffer)
 {
   if (buffer->have_output)
   {
     if (buffer->out_info != buffer->info)
     {
-      hb_buffer_ensure (buffer, buffer->out_len + 1);
+      if (unlikely (!hb_buffer_ensure (buffer, buffer->out_len + 1))) return;
       buffer->out_info[buffer->out_len] = buffer->info[buffer->i];
     }
     else if (buffer->out_len != buffer->i)
       buffer->out_info[buffer->out_len] = buffer->info[buffer->i];
 
     buffer->out_len++;
   }
 
   buffer->i++;
 }
 
 
diff --git a/src/hb-buffer.h b/src/hb-buffer.h
index d1772d4..7b8b7ea 100644
--- a/src/hb-buffer.h
+++ b/src/hb-buffer.h
@@ -101,7 +101,7 @@ hb_buffer_clear (hb_buffer_t *buffer);
 void
 hb_buffer_clear_positions (hb_buffer_t *buffer);
 
-void
+hb_bool_t
 hb_buffer_ensure (hb_buffer_t  *buffer,
 		  unsigned int  size);
 
