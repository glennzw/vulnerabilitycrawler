   Handle malloc failture in the buffer

  unsigned int allocated; /* Length of allocated arrays */

  hb_bool_t    have_output; /* Whether we have an output buffer going on */
  hb_bool_t    have_positions; /* Whether we have positions */

  unsigned int i; /* Cursor into ->info and ->pos arrays */
  unsigned int len; /* Length of ->info and ->pos arrays */
 * switches info and out_info.
 */

/* XXX err handling */

/* Internal API */

static void
hb_buffer_ensure_separate (hb_buffer_t *buffer, unsigned int size)
{
  hb_buffer_ensure (buffer, size);
  if (buffer->out_info == buffer->info)
  {
    assert (buffer->have_output);
    if (!buffer->pos)
      buffer->pos = (hb_internal_glyph_position_t *) calloc (buffer->allocated, sizeof (buffer->pos[0]));

    buffer->out_info = (hb_internal_glyph_info_t *) buffer->pos;
    memcpy (buffer->out_info, buffer->info, buffer->out_len * sizeof (buffer->out_info[0]));
  }
}

/* Public API */
    return &_hb_buffer_nil;

  if (pre_alloc_size)
    hb_buffer_ensure(buffer, pre_alloc_size);

  buffer->unicode = &_hb_unicode_funcs_nil;

{
  buffer->have_output = FALSE;
  buffer->have_positions = FALSE;
  buffer->len = 0;
  buffer->out_len = 0;
  buffer->i = 0;
  buffer->max_lig_id = 0;
}

void
hb_buffer_ensure (hb_buffer_t *buffer, unsigned int size)
{
  unsigned int new_allocated = buffer->allocated;

  if (size > new_allocated)
  {
    while (size > new_allocated)
      new_allocated += (new_allocated >> 1) + 8;

    if (buffer->pos)
      buffer->pos = (hb_internal_glyph_position_t *) realloc (buffer->pos, new_allocated * sizeof (buffer->pos[0]));

    if (buffer->out_info != buffer->info)
    {
      buffer->info = (hb_internal_glyph_info_t *) realloc (buffer->info, new_allocated * sizeof (buffer->info[0]));
      buffer->out_info = (hb_internal_glyph_info_t *) buffer->pos;
    }
    else
    {
      buffer->info = (hb_internal_glyph_info_t *) realloc (buffer->info, new_allocated * sizeof (buffer->info[0]));
      buffer->out_info = buffer->info;
    }

    buffer->allocated = new_allocated;
  }
}

void
{
  hb_internal_glyph_info_t *glyph;

  hb_buffer_ensure (buffer, buffer->len + 1);

  glyph = &buffer->info[buffer->len];
  glyph->codepoint = codepoint;

  assert (buffer->have_output);

  if (buffer->out_info != buffer->info)
  {
    hb_internal_glyph_info_t *tmp_string;
  if (buffer->out_info != buffer->info ||
      buffer->out_len + num_out > buffer->i + num_in)
  {
    hb_buffer_ensure_separate (buffer, buffer->out_len + num_out);
  }

  mask = buffer->info[buffer->i].mask;
  if (buffer->out_info != buffer->info ||
      buffer->out_len + num_out > buffer->i + num_in)
  {
    hb_buffer_ensure_separate (buffer, buffer->out_len + num_out);
  }

  mask = buffer->info[buffer->i].mask;

  if (buffer->out_info != buffer->info)
  {
    hb_buffer_ensure (buffer, buffer->out_len + 1);
    buffer->out_info[buffer->out_len] = buffer->info[buffer->i];
  }
  else if (buffer->out_len != buffer->i)
  {
    if (buffer->out_info != buffer->info)
    {
      hb_buffer_ensure (buffer, buffer->out_len + 1);
      buffer->out_info[buffer->out_len] = buffer->info[buffer->i];
    }
    else if (buffer->out_len != buffer->i)
void
hb_buffer_clear_positions (hb_buffer_t *buffer);

void
hb_buffer_ensure (hb_buffer_t  *buffer,
		  unsigned int  size);

