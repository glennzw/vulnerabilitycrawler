commit 03145beb455cf5c20a761e8451e30b8a74ba58d9
Author: Dan Rosenberg <drosenberg@vsecurity.com>
Date:   Wed Oct 27 15:34:17 2010 -0700

    ipc: initialize structure memory to zero for compat functions
    
    This takes care of leaking uninitialized kernel stack memory to
    userspace from non-zeroed fields in structs in compat ipc functions.
    
    Signed-off-by: Dan Rosenberg <drosenberg@vsecurity.com>
    Cc: Manfred Spraul <manfred@colorfullife.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/compat.c b/ipc/compat.c
index 9dc2c7d..845a287 100644
--- a/ipc/compat.c
+++ b/ipc/compat.c
@@ -235,71 +235,73 @@ static inline int put_compat_semid_ds(struct semid64_ds *s,
 long compat_sys_semctl(int first, int second, int third, void __user *uptr)
 {
 	union semun fourth;
 	u32 pad;
 	int err, err2;
 	struct semid64_ds s64;
 	struct semid64_ds __user *up64;
 	int version = compat_ipc_parse_version(&third);
 
+	memset(&s64, 0, sizeof(s64));
+
 	if (!uptr)
 		return -EINVAL;
 	if (get_user(pad, (u32 __user *) uptr))
 		return -EFAULT;
 	if ((third & (~IPC_64)) == SETVAL)
 		fourth.val = (int) pad;
 	else
 		fourth.__pad = compat_ptr(pad);
 	switch (third & (~IPC_64)) {
 	case IPC_INFO:
 	case IPC_RMID:
 	case SEM_INFO:
 	case GETVAL:
 	case GETPID:
 	case GETNCNT:
 	case GETZCNT:
 	case GETALL:
 	case SETVAL:
 	case SETALL:
 		err = sys_semctl(first, second, third, fourth);
 		break;
 
 	case IPC_STAT:
 	case SEM_STAT:
 		up64 = compat_alloc_user_space(sizeof(s64));
 		fourth.__pad = up64;
 		err = sys_semctl(first, second, third, fourth);
 		if (err < 0)
 			break;
 		if (copy_from_user(&s64, up64, sizeof(s64)))
 			err2 = -EFAULT;
 		else if (version == IPC_64)
 			err2 = put_compat_semid64_ds(&s64, compat_ptr(pad));
 		else
 			err2 = put_compat_semid_ds(&s64, compat_ptr(pad));
 		if (err2)
 			err = -EFAULT;
 		break;
 
 	case IPC_SET:
 		if (version == IPC_64) {
 			err = get_compat_semid64_ds(&s64, compat_ptr(pad));
 		} else {
 			err = get_compat_semid_ds(&s64, compat_ptr(pad));
 		}
 		up64 = compat_alloc_user_space(sizeof(s64));
 		if (copy_to_user(up64, &s64, sizeof(s64)))
 			err = -EFAULT;
 		if (err)
 			break;
 
 		fourth.__pad = up64;
 		err = sys_semctl(first, second, third, fourth);
 		break;
 
 	default:
 		err = -EINVAL;
 		break;
 	}
 	return err;
 }
 
@@ -417,52 +419,54 @@ static inline int put_compat_msqid_ds(struct msqid64_ds *m,
 long compat_sys_msgctl(int first, int second, void __user *uptr)
 {
 	int err, err2;
 	struct msqid64_ds m64;
 	int version = compat_ipc_parse_version(&second);
 	void __user *p;
 
+	memset(&m64, 0, sizeof(m64));
+
 	switch (second & (~IPC_64)) {
 	case IPC_INFO:
 	case IPC_RMID:
 	case MSG_INFO:
 		err = sys_msgctl(first, second, uptr);
 		break;
 
 	case IPC_SET:
 		if (version == IPC_64) {
 			err = get_compat_msqid64(&m64, uptr);
 		} else {
 			err = get_compat_msqid(&m64, uptr);
 		}
 		if (err)
 			break;
 		p = compat_alloc_user_space(sizeof(m64));
 		if (copy_to_user(p, &m64, sizeof(m64)))
 			err = -EFAULT;
 		else
 			err = sys_msgctl(first, second, p);
 		break;
 
 	case IPC_STAT:
 	case MSG_STAT:
 		p = compat_alloc_user_space(sizeof(m64));
 		err = sys_msgctl(first, second, p);
 		if (err < 0)
 			break;
 		if (copy_from_user(&m64, p, sizeof(m64)))
 			err2 = -EFAULT;
 		else if (version == IPC_64)
 			err2 = put_compat_msqid64_ds(&m64, uptr);
 		else
 			err2 = put_compat_msqid_ds(&m64, uptr);
 		if (err2)
 			err = -EFAULT;
 		break;
 
 	default:
 		err = -EINVAL;
 		break;
 	}
 	return err;
 }
 
@@ -589,79 +593,81 @@ static inline int put_compat_shm_info(struct shm_info __user *ip,
 long compat_sys_shmctl(int first, int second, void __user *uptr)
 {
 	void __user *p;
 	struct shmid64_ds s64;
 	struct shminfo64 smi;
 	int err, err2;
 	int version = compat_ipc_parse_version(&second);
 
+	memset(&s64, 0, sizeof(s64));
+
 	switch (second & (~IPC_64)) {
 	case IPC_RMID:
 	case SHM_LOCK:
 	case SHM_UNLOCK:
 		err = sys_shmctl(first, second, uptr);
 		break;
 
 	case IPC_INFO:
 		p = compat_alloc_user_space(sizeof(smi));
 		err = sys_shmctl(first, second, p);
 		if (err < 0)
 			break;
 		if (copy_from_user(&smi, p, sizeof(smi)))
 			err2 = -EFAULT;
 		else if (version == IPC_64)
 			err2 = put_compat_shminfo64(&smi, uptr);
 		else
 			err2 = put_compat_shminfo(&smi, uptr);
 		if (err2)
 			err = -EFAULT;
 		break;
 
 
 	case IPC_SET:
 		if (version == IPC_64) {
 			err = get_compat_shmid64_ds(&s64, uptr);
 		} else {
 			err = get_compat_shmid_ds(&s64, uptr);
 		}
 		if (err)
 			break;
 		p = compat_alloc_user_space(sizeof(s64));
 		if (copy_to_user(p, &s64, sizeof(s64)))
 			err = -EFAULT;
 		else
 			err = sys_shmctl(first, second, p);
 		break;
 
 	case IPC_STAT:
 	case SHM_STAT:
 		p = compat_alloc_user_space(sizeof(s64));
 		err = sys_shmctl(first, second, p);
 		if (err < 0)
 			break;
 		if (copy_from_user(&s64, p, sizeof(s64)))
 			err2 = -EFAULT;
 		else if (version == IPC_64)
 			err2 = put_compat_shmid64_ds(&s64, uptr);
 		else
 			err2 = put_compat_shmid_ds(&s64, uptr);
 		if (err2)
 			err = -EFAULT;
 		break;
 
 	case SHM_INFO:
 		p = compat_alloc_user_space(sizeof(struct shm_info));
 		err = sys_shmctl(first, second, p);
 		if (err < 0)
 			break;
 		err2 = put_compat_shm_info(p, uptr);
 		if (err2)
 			err = -EFAULT;
 		break;
 
 	default:
 		err = -EINVAL;
 		break;
 	}
 	return err;
 }
 
diff --git a/ipc/compat_mq.c b/ipc/compat_mq.c
index d8d1e9f..380ea4f 100644
--- a/ipc/compat_mq.c
+++ b/ipc/compat_mq.c
@@ -49,15 +49,18 @@ static inline int put_compat_mq_attr(const struct mq_attr *attr,
 asmlinkage long compat_sys_mq_open(const char __user *u_name,
 			int oflag, compat_mode_t mode,
 			struct compat_mq_attr __user *u_attr)
 {
 	void __user *p = NULL;
 	if (u_attr && oflag & O_CREAT) {
 		struct mq_attr attr;
+
+		memset(&attr, 0, sizeof(attr));
+
 		p = compat_alloc_user_space(sizeof(attr));
 		if (get_compat_mq_attr(&attr, u_attr) ||
 		    copy_to_user(p, &attr, sizeof(attr)))
 			return -EFAULT;
 	}
 	return sys_mq_open(u_name, oflag, mode, p);
 }
 
@@ -122,25 +125,27 @@ asmlinkage long compat_sys_mq_notify(mqd_t mqdes,
 asmlinkage long compat_sys_mq_getsetattr(mqd_t mqdes,
 			const struct compat_mq_attr __user *u_mqstat,
 			struct compat_mq_attr __user *u_omqstat)
 {
 	struct mq_attr mqstat;
 	struct mq_attr __user *p = compat_alloc_user_space(2 * sizeof(*p));
 	long ret;
 
+	memset(&mqstat, 0, sizeof(mqstat));
+
 	if (u_mqstat) {
 		if (get_compat_mq_attr(&mqstat, u_mqstat) ||
 		    copy_to_user(p, &mqstat, sizeof(mqstat)))
 			return -EFAULT;
 	}
 	ret = sys_mq_getsetattr(mqdes,
 				u_mqstat ? p : NULL,
 				u_omqstat ? p + 1 : NULL);
 	if (ret)
 		return ret;
 	if (u_omqstat) {
 		if (copy_from_user(&mqstat, p + 1, sizeof(mqstat)) ||
 		    put_compat_mq_attr(&mqstat, u_omqstat))
 			return -EFAULT;
 	}
 	return 0;
 }
