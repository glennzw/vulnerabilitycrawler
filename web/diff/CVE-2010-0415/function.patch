commit 6f5a55f1a6c5abee15a0e878e5c74d9f1569b8b0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Feb 5 16:16:50 2010 -0800

    Fix potential crash with sys_move_pages
    
    We incorrectly depended on the 'node_state/node_isset()' functions
    testing the node range, rather than checking it explicitly.  That's not
    reliable, even if it might often happen to work.  So do the proper
    explicit test.
    
    Reported-by: Marcus Meissner <meissner@suse.de>
    Acked-and-tested-by: Brice Goglin <Brice.Goglin@inria.fr>
    Acked-by: Hugh Dickins <hugh.dickins@tiscali.co.uk>
    Cc: stable@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/mm/migrate.c b/mm/migrate.c
index efddbf0..9a0db5b 100644
--- a/mm/migrate.c
+++ b/mm/migrate.c
@@ -866,77 +866,80 @@ set_status:
 static int do_pages_move(struct mm_struct *mm, struct task_struct *task,
 			 unsigned long nr_pages,
 			 const void __user * __user *pages,
 			 const int __user *nodes,
 			 int __user *status, int flags)
 {
 	struct page_to_node *pm;
 	nodemask_t task_nodes;
 	unsigned long chunk_nr_pages;
 	unsigned long chunk_start;
 	int err;
 
 	task_nodes = cpuset_mems_allowed(task);
 
 	err = -ENOMEM;
 	pm = (struct page_to_node *)__get_free_page(GFP_KERNEL);
 	if (!pm)
 		goto out;
 
 	migrate_prep();
 
 	/*
 	 * Store a chunk of page_to_node array in a page,
 	 * but keep the last one as a marker
 	 */
 	chunk_nr_pages = (PAGE_SIZE / sizeof(struct page_to_node)) - 1;
 
 	for (chunk_start = 0;
 	     chunk_start < nr_pages;
 	     chunk_start += chunk_nr_pages) {
 		int j;
 
 		if (chunk_start + chunk_nr_pages > nr_pages)
 			chunk_nr_pages = nr_pages - chunk_start;
 
 		/* fill the chunk pm with addrs and nodes from user-space */
 		for (j = 0; j < chunk_nr_pages; j++) {
 			const void __user *p;
 			int node;
 
 			err = -EFAULT;
 			if (get_user(p, pages + j + chunk_start))
 				goto out_pm;
 			pm[j].addr = (unsigned long) p;
 
 			if (get_user(node, nodes + j + chunk_start))
 				goto out_pm;
 
 			err = -ENODEV;
+			if (node < 0 || node >= MAX_NUMNODES)
+				goto out_pm;
+
 			if (!node_state(node, N_HIGH_MEMORY))
 				goto out_pm;
 
 			err = -EACCES;
 			if (!node_isset(node, task_nodes))
 				goto out_pm;
 
 			pm[j].node = node;
 		}
 
 		/* End marker for this chunk */
 		pm[chunk_nr_pages].node = MAX_NUMNODES;
 
 		/* Migrate this chunk */
 		err = do_move_page_to_node_array(mm, pm,
 						 flags & MPOL_MF_MOVE_ALL);
 		if (err < 0)
 			goto out_pm;
 
 		/* Return status information */
 		for (j = 0; j < chunk_nr_pages; j++)
 			if (put_user(pm[j].status, status + j + chunk_start)) {
 				err = -EFAULT;
 				goto out_pm;
 			}
 	}
 	err = 0;
 
