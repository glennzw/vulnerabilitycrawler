commit a6331d6f9a4298173b413cf99a40cc86a9d92c37
Author: andrew hendry <andrew.hendry@gmail.com>
Date:   Wed Nov 3 12:54:53 2010 +0000

    memory corruption in X.25 facilities parsing
    
    Signed-of-by: Andrew Hendry <andrew.hendry@gmail.com>
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/x25/x25_facilities.c b/net/x25/x25_facilities.c
index 771bab0..3a8c4c4 100644
--- a/net/x25/x25_facilities.c
+++ b/net/x25/x25_facilities.c
@@ -34,135 +34,135 @@
 int x25_parse_facilities(struct sk_buff *skb, struct x25_facilities *facilities,
 		struct x25_dte_facilities *dte_facs, unsigned long *vc_fac_mask)
 {
 	unsigned char *p = skb->data;
 	unsigned int len;
 
 	*vc_fac_mask = 0;
 
 	/*
 	 * The kernel knows which facilities were set on an incoming call but
 	 * currently this information is not available to userspace.  Here we
 	 * give userspace who read incoming call facilities 0 length to indicate
 	 * it wasn't set.
 	 */
 	dte_facs->calling_len = 0;
 	dte_facs->called_len = 0;
 	memset(dte_facs->called_ae, '\0', sizeof(dte_facs->called_ae));
 	memset(dte_facs->calling_ae, '\0', sizeof(dte_facs->calling_ae));
 
 	if (skb->len < 1)
 		return 0;
 
 	len = *p++;
 
 	if (len >= skb->len)
 		return -1;
 
 	while (len > 0) {
 		switch (*p & X25_FAC_CLASS_MASK) {
 		case X25_FAC_CLASS_A:
 			switch (*p) {
 			case X25_FAC_REVERSE:
 				if((p[1] & 0x81) == 0x81) {
 					facilities->reverse = p[1] & 0x81;
 					*vc_fac_mask |= X25_MASK_REVERSE;
 					break;
 				}
 
 				if((p[1] & 0x01) == 0x01) {
 					facilities->reverse = p[1] & 0x01;
 					*vc_fac_mask |= X25_MASK_REVERSE;
 					break;
 				}
 
 				if((p[1] & 0x80) == 0x80) {
 					facilities->reverse = p[1] & 0x80;
 					*vc_fac_mask |= X25_MASK_REVERSE;
 					break;
 				}
 
 				if(p[1] == 0x00) {
 					facilities->reverse
 						= X25_DEFAULT_REVERSE;
 					*vc_fac_mask |= X25_MASK_REVERSE;
 					break;
 				}
 
 			case X25_FAC_THROUGHPUT:
 				facilities->throughput = p[1];
 				*vc_fac_mask |= X25_MASK_THROUGHPUT;
 				break;
 			case X25_MARKER:
 				break;
 			default:
 				printk(KERN_DEBUG "X.25: unknown facility "
 				       "%02X, value %02X\n",
 				       p[0], p[1]);
 				break;
 			}
 			p   += 2;
 			len -= 2;
 			break;
 		case X25_FAC_CLASS_B:
 			switch (*p) {
 			case X25_FAC_PACKET_SIZE:
 				facilities->pacsize_in  = p[1];
 				facilities->pacsize_out = p[2];
 				*vc_fac_mask |= X25_MASK_PACKET_SIZE;
 				break;
 			case X25_FAC_WINDOW_SIZE:
 				facilities->winsize_in  = p[1];
 				facilities->winsize_out = p[2];
 				*vc_fac_mask |= X25_MASK_WINDOW_SIZE;
 				break;
 			default:
 				printk(KERN_DEBUG "X.25: unknown facility "
 				       "%02X, values %02X, %02X\n",
 				       p[0], p[1], p[2]);
 				break;
 			}
 			p   += 3;
 			len -= 3;
 			break;
 		case X25_FAC_CLASS_C:
 			printk(KERN_DEBUG "X.25: unknown facility %02X, "
 			       "values %02X, %02X, %02X\n",
 			       p[0], p[1], p[2], p[3]);
 			p   += 4;
 			len -= 4;
 			break;
 		case X25_FAC_CLASS_D:
 			switch (*p) {
 			case X25_FAC_CALLING_AE:
-				if (p[1] > X25_MAX_DTE_FACIL_LEN)
-					break;
+				if (p[1] > X25_MAX_DTE_FACIL_LEN || p[1] <= 1)
+					return 0;
 				dte_facs->calling_len = p[2];
 				memcpy(dte_facs->calling_ae, &p[3], p[1] - 1);
 				*vc_fac_mask |= X25_MASK_CALLING_AE;
 				break;
 			case X25_FAC_CALLED_AE:
-				if (p[1] > X25_MAX_DTE_FACIL_LEN)
-					break;
+				if (p[1] > X25_MAX_DTE_FACIL_LEN || p[1] <= 1)
+					return 0;
 				dte_facs->called_len = p[2];
 				memcpy(dte_facs->called_ae, &p[3], p[1] - 1);
 				*vc_fac_mask |= X25_MASK_CALLED_AE;
 				break;
 			default:
 				printk(KERN_DEBUG "X.25: unknown facility %02X,"
 					"length %d, values %02X, %02X, "
 					"%02X, %02X\n",
 					p[0], p[1], p[2], p[3], p[4], p[5]);
 				break;
 			}
 			len -= p[1] + 2;
 			p += p[1] + 2;
 			break;
 		}
 	}
 
 	return p - skb->data;
 }
 
 /*
  *	Create a set of facilities.
  */
diff --git a/net/x25/x25_in.c b/net/x25/x25_in.c
index 6317896..f729f02 100644
--- a/net/x25/x25_in.c
+++ b/net/x25/x25_in.c
@@ -90,62 +90,64 @@ static int x25_queue_rx_frame(struct sock *sk, struct sk_buff *skb, int more)
 static int x25_state1_machine(struct sock *sk, struct sk_buff *skb, int frametype)
 {
 	struct x25_address source_addr, dest_addr;
 	int len;
 
 	switch (frametype) {
 		case X25_CALL_ACCEPTED: {
 			struct x25_sock *x25 = x25_sk(sk);
 
 			x25_stop_timer(sk);
 			x25->condition = 0x00;
 			x25->vs        = 0;
 			x25->va        = 0;
 			x25->vr        = 0;
 			x25->vl        = 0;
 			x25->state     = X25_STATE_3;
 			sk->sk_state   = TCP_ESTABLISHED;
 			/*
 			 *	Parse the data in the frame.
 			 */
 			skb_pull(skb, X25_STD_MIN_LEN);
 
 			len = x25_parse_address_block(skb, &source_addr,
 						&dest_addr);
 			if (len > 0)
 				skb_pull(skb, len);
 
 			len = x25_parse_facilities(skb, &x25->facilities,
 						&x25->dte_facilities,
 						&x25->vc_facil_mask);
 			if (len > 0)
 				skb_pull(skb, len);
+			else
+				return -1;
 			/*
 			 *	Copy any Call User Data.
 			 */
 			if (skb->len > 0) {
 				skb_copy_from_linear_data(skb,
 					      x25->calluserdata.cuddata,
 					      skb->len);
 				x25->calluserdata.cudlength = skb->len;
 			}
 			if (!sock_flag(sk, SOCK_DEAD))
 				sk->sk_state_change(sk);
 			break;
 		}
 		case X25_CLEAR_REQUEST:
 			x25_write_internal(sk, X25_CLEAR_CONFIRMATION);
 			x25_disconnect(sk, ECONNREFUSED, skb->data[3], skb->data[4]);
 			break;
 
 		default:
 			break;
 	}
 
 	return 0;
 }
 
 /*
  * State machine for state 2, Awaiting Clear Confirmation State.
  * The handling of the timer(s) is in file x25_timer.c
  * Handling of state 0 and connection release is in af_x25.c.
  */
