   [SCTP]: Allow spillover of receive buffer to avoid deadlock.
   
   This patch fixes a deadlock situation in the receive path by allowing
   temporary spillover of the receive buffer.
   
   - If the chunk we receive has a tsn that immediately follows the ctsn,
     accept it even if we run out of receive buffer space and renege data with
     higher TSNs.
   - Once we accept one chunk in a packet, accept all the remaining chunks
     even if we run out of receive buffer space.
   
   Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
   Acked-by: Mark Butler <butlerm@middle.net>
   Acked-by: Vlad Yasevich <vladislav.yasevich@hp.com>
   Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>
   Signed-off-by: David S. Miller <davem@davemloft.net>
	__u8 tsn_gap_acked;	/* Is this chunk acked by a GAP ACK? */
	__s8 fast_retransmit;	 /* Is this chunk fast retransmitted? */
	__u8 tsn_missing_report; /* Data chunk missing counter. */
};

void sctp_chunk_hold(struct sctp_chunk *);
		/* This is the first chunk in the packet.  */
		chunk->singleton = 1;
		ch = (sctp_chunkhdr_t *) chunk->skb->data;
	}

        chunk->chunk_hdr = ch;
	int tmp;
	__u32 tsn;
	int account_value;
	struct sock *sk = asoc->base.sk;

	data_hdr = chunk->subh.data_hdr = (sctp_datahdr_t *)chunk->skb->data;
	skb_pull(chunk->skb, sizeof(sctp_datahdr_t));
	/* ASSERT:  Now skb->data is really the user data.  */

	/*
	 * if we are established, and we have used up our receive
	 * buffer memory, drop the frame
	 */
	if (asoc->state == SCTP_STATE_ESTABLISHED) {
		/*
		 * If the receive buffer policy is 1, then each
		 * association can allocate up to sk_rcvbuf bytes
			account_value = atomic_read(&asoc->rmem_alloc);
		else
			account_value = atomic_read(&sk->sk_rmem_alloc);

		if (account_value > sk->sk_rcvbuf)
			return SCTP_IERROR_IGNORE_TSN;
	}

	/* Process ECN based congestion.
	datalen -= sizeof(sctp_data_chunk_t);

	deliver = SCTP_CMD_CHUNK_ULP;

	/* Think about partial delivery. */
	if ((datalen >= asoc->rwnd) && (!asoc->ulpq.pd_mode)) {
	 * large spill over.
	 */
	if (!asoc->rwnd || asoc->rwnd_over ||
	    (datalen > asoc->rwnd + asoc->frag_point)) {

		/* If this is the next TSN, consider reneging to make
		 * room.   Note: Playing nice with a confused sender.  A
		 * space and in the future we may want to detect and
		 * do more drastic reneging.
		 */
		if (sctp_tsnmap_has_gap(&asoc->peer.tsn_map) &&
		    (sctp_tsnmap_get_ctsn(&asoc->peer.tsn_map) + 1) == tsn) {
			SCTP_DEBUG_PRINTK("Reneging for tsn:%u\n", tsn);
			deliver = SCTP_CMD_RENEGE;
		} else {
