   Backport of libltdl changes from the 2.26b release.
   
   * libltdl/,tdl.c: Backport changes.
2008-02-27  Peter O'Gorman  <peter@pogma.com>

	* libtool.m4 [darwin]: Really use _lt_dar_allow_undefined for
static	int	try_dlopen	      LT_PARAMS((lt_dlhandle *handle,
						 const char *filename));
static	int	tryall_dlopen	      LT_PARAMS((lt_dlhandle *handle,
						 const char *filename));
static	int	unload_deplibs	      LT_PARAMS((lt_dlhandle handle));
static	int	lt_argz_insert	      LT_PARAMS((char **pargz,
						 size_t *pargz_len,
}

static int
tryall_dlopen (handle, filename)
     lt_dlhandle *handle;
     const char *filename;
{
  lt_dlhandle	 cur;
  lt_dlloader   *loader;

  while (loader)
    {
      lt_user_data data = loader->dlloader_data;

      cur->module = loader->module_open (data, filename);
      error += tryall_dlopen_module (handle,
				     (const char *) 0, prefix, filename);
    }
  else if (tryall_dlopen (handle, filename) != 0)
    {
      ++error;
    }
  /* Try to open the old library first; if it was dlpreopened,
     we want the preopened version of it, even if a dlopenable
     module is available.  */
  if (old_name && tryall_dlopen (handle, old_name) == 0)
    {
      return 0;
    }

  /* Try to dlopen the file, but do not continue searching in any
     case.  */
  if (tryall_dlopen (handle, filename) != 0)
    *handle = 0;

  return 1;
      /* lt_dlclose()ing yourself is very bad!  Disallow it.  */
      LT_DLSET_FLAG (*phandle, LT_DLRESIDENT_FLAG);

      if (tryall_dlopen (&newhandle, 0) != 0)
	{
	  LT_DLFREE (*phandle);
	  return 1;
	    }
#endif
	}
      if (!file)
	{
	  file = fopen (filename, LT_READTEXT_MODE);
	}
#endif
		   )))
	{
          if (tryall_dlopen (&newhandle, filename) != 0)
            {
              newhandle = NULL;
            }
