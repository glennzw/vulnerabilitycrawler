commit 0d3d077cd4f1154e63a9858e47fe3fb1ad0c03e5
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Sun Apr 24 20:16:19 2005 -0700

    [SELINUX]: Fix ipv6_skip_exthdr() invocation causing OOPS.
    
    The SELinux hooks invoke ipv6_skip_exthdr() with an incorrect
    length final argument.  However, the length argument turns out
    to be superfluous.
    
    I was just reading ipv6_skip_exthdr and it occured to me that we can
    get rid of len altogether.  The only place where len is used is to
    check whether the skb has two bytes for ipv6_opt_hdr.  This check
    is done by skb_header_pointer/skb_copy_bits anyway.
    
    Now it might appear that we've made the code slower by deferring
    the check to skb_copy_bits.  However, this check should not trigger
    in the common case so this is OK.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/ipv6.h b/include/net/ipv6.h
index 87c45cb..771b47e 100644
--- a/include/net/ipv6.h
+++ b/include/net/ipv6.h
@@ -416,7 +416,7 @@ extern void			ipv6_push_frag_opts(struct sk_buff *skb,
 						    u8 *proto);
 
 extern int			ipv6_skip_exthdr(const struct sk_buff *, int start,
-					         u8 *nexthdrp, int len);
+					         u8 *nexthdrp);
 
 extern int 			ipv6_ext_hdr(u8 nexthdr);
 
diff --git a/net/ipv6/exthdrs_core.c b/net/ipv6/exthdrs_core.c
index 6dda815..315bc1f 100644
--- a/net/ipv6/exthdrs_core.c
+++ b/net/ipv6/exthdrs_core.c
@@ -11,97 +11,94 @@
 int ipv6_ext_hdr(u8 nexthdr)
 {
 	/* 
 	 * find out if nexthdr is an extension header or a protocol
 	 */
 	return ( (nexthdr == NEXTHDR_HOP)	||
 		 (nexthdr == NEXTHDR_ROUTING)	||
 		 (nexthdr == NEXTHDR_FRAGMENT)	||
 		 (nexthdr == NEXTHDR_AUTH)	||
 		 (nexthdr == NEXTHDR_NONE)	||
 		 (nexthdr == NEXTHDR_DEST) );
 }
 
 /*
  * Skip any extension headers. This is used by the ICMP module.
  *
  * Note that strictly speaking this conflicts with RFC 2460 4.0:
  * ...The contents and semantics of each extension header determine whether 
  * or not to proceed to the next header.  Therefore, extension headers must
  * be processed strictly in the order they appear in the packet; a
  * receiver must not, for example, scan through a packet looking for a
  * particular kind of extension header and process that header prior to
  * processing all preceding ones.
  * 
  * We do exactly this. This is a protocol bug. We can't decide after a
  * seeing an unknown discard-with-error flavour TLV option if it's a 
  * ICMP error message or not (errors should never be send in reply to
  * ICMP error messages).
  * 
  * But I see no other way to do this. This might need to be reexamined
  * when Linux implements ESP (and maybe AUTH) headers.
  * --AK
  *
- * This function parses (probably truncated) exthdr set "hdr"
- * of length "len". "nexthdrp" initially points to some place,
+ * This function parses (probably truncated) exthdr set "hdr".
+ * "nexthdrp" initially points to some place,
  * where type of the first header can be found.
  *
  * It skips all well-known exthdrs, and returns pointer to the start
  * of unparsable area i.e. the first header with unknown type.
  * If it is not NULL *nexthdr is updated by type/protocol of this header.
  *
  * NOTES: - if packet terminated with NEXTHDR_NONE it returns NULL.
  *        - it may return pointer pointing beyond end of packet,
  *	    if the last recognized header is truncated in the middle.
  *        - if packet is truncated, so that all parsed headers are skipped,
  *	    it returns NULL.
  *	  - First fragment header is skipped, not-first ones
  *	    are considered as unparsable.
  *	  - ESP is unparsable for now and considered like
  *	    normal payload protocol.
  *	  - Note also special handling of AUTH header. Thanks to IPsec wizards.
  *
  * --ANK (980726)
  */
 
-int ipv6_skip_exthdr(const struct sk_buff *skb, int start, u8 *nexthdrp, int len)
+int ipv6_skip_exthdr(const struct sk_buff *skb, int start, u8 *nexthdrp)
 {
 	u8 nexthdr = *nexthdrp;
 
 	while (ipv6_ext_hdr(nexthdr)) {
 		struct ipv6_opt_hdr _hdr, *hp;
 		int hdrlen;
 
-		if (len < (int)sizeof(struct ipv6_opt_hdr))
-			return -1;
 		if (nexthdr == NEXTHDR_NONE)
 			return -1;
 		hp = skb_header_pointer(skb, start, sizeof(_hdr), &_hdr);
 		if (hp == NULL)
-			BUG();
+			return -1;
 		if (nexthdr == NEXTHDR_FRAGMENT) {
 			unsigned short _frag_off, *fp;
 			fp = skb_header_pointer(skb,
 						start+offsetof(struct frag_hdr,
 							       frag_off),
 						sizeof(_frag_off),
 						&_frag_off);
 			if (fp == NULL)
 				return -1;
 
 			if (ntohs(*fp) & ~0x7)
 				break;
 			hdrlen = 8;
 		} else if (nexthdr == NEXTHDR_AUTH)
 			hdrlen = (hp->hdrlen+2)<<2; 
 		else
 			hdrlen = ipv6_optlen(hp); 
 
 		nexthdr = hp->nexthdr;
-		len -= hdrlen;
 		start += hdrlen;
 	}
 
 	*nexthdrp = nexthdr;
 	return start;
 }
 
diff --git a/net/ipv6/icmp.c b/net/ipv6/icmp.c
index 87b9082..8e0f569 100644
--- a/net/ipv6/icmp.c
+++ b/net/ipv6/icmp.c
@@ -129,24 +129,24 @@ void icmpv6_param_prob(struct sk_buff *skb, int code, int pos)
 static int is_ineligible(struct sk_buff *skb)
 {
 	int ptr = (u8*)(skb->nh.ipv6h+1) - skb->data;
 	int len = skb->len - ptr;
 	__u8 nexthdr = skb->nh.ipv6h->nexthdr;
 
 	if (len < 0)
 		return 1;
 
-	ptr = ipv6_skip_exthdr(skb, ptr, &nexthdr, len);
+	ptr = ipv6_skip_exthdr(skb, ptr, &nexthdr);
 	if (ptr < 0)
 		return 0;
 	if (nexthdr == IPPROTO_ICMPV6) {
 		u8 _type, *tp;
 		tp = skb_header_pointer(skb,
 			ptr+offsetof(struct icmp6hdr, icmp6_type),
 			sizeof(_type), &_type);
 		if (tp == NULL ||
 		    !(*tp & ICMPV6_INFOMSG_MASK))
 			return 1;
 	}
 	return 0;
 }
 
@@ -502,58 +502,58 @@ out:
 static void icmpv6_notify(struct sk_buff *skb, int type, int code, u32 info)
 {
 	struct in6_addr *saddr, *daddr;
 	struct inet6_protocol *ipprot;
 	struct sock *sk;
 	int inner_offset;
 	int hash;
 	u8 nexthdr;
 
 	if (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))
 		return;
 
 	nexthdr = ((struct ipv6hdr *)skb->data)->nexthdr;
 	if (ipv6_ext_hdr(nexthdr)) {
 		/* now skip over extension headers */
-		inner_offset = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &nexthdr, skb->len - sizeof(struct ipv6hdr));
+		inner_offset = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &nexthdr);
 		if (inner_offset<0)
 			return;
 	} else {
 		inner_offset = sizeof(struct ipv6hdr);
 	}
 
 	/* Checkin header including 8 bytes of inner protocol header. */
 	if (!pskb_may_pull(skb, inner_offset+8))
 		return;
 
 	saddr = &skb->nh.ipv6h->saddr;
 	daddr = &skb->nh.ipv6h->daddr;
 
 	/* BUGGG_FUTURE: we should try to parse exthdrs in this packet.
 	   Without this we will not able f.e. to make source routed
 	   pmtu discovery.
 	   Corresponding argument (opt) to notifiers is already added.
 	   --ANK (980726)
 	 */
 
 	hash = nexthdr & (MAX_INET_PROTOS - 1);
 
 	rcu_read_lock();
 	ipprot = rcu_dereference(inet6_protos[hash]);
 	if (ipprot && ipprot->err_handler)
 		ipprot->err_handler(skb, NULL, type, code, inner_offset, info);
 	rcu_read_unlock();
 
 	read_lock(&raw_v6_lock);
 	if ((sk = sk_head(&raw_v6_htable[hash])) != NULL) {
 		while((sk = __raw_v6_lookup(sk, nexthdr, daddr, saddr))) {
 			rawv6_err(sk, skb, NULL, type, code, inner_offset, info);
 			sk = sk_next(sk);
 		}
 	}
 	read_unlock(&raw_v6_lock);
 }
   
 /*
  *	Handle icmp messages
  */
 
diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c
index 2ae7d3c..0d37814 100644
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@ -2841,51 +2841,50 @@ out:
 static int selinux_parse_skb_ipv6(struct sk_buff *skb, struct avc_audit_data *ad)
 {
 	u8 nexthdr;
 	int ret = -EINVAL, offset;
 	struct ipv6hdr _ipv6h, *ip6;
 
 	offset = skb->nh.raw - skb->data;
 	ip6 = skb_header_pointer(skb, offset, sizeof(_ipv6h), &_ipv6h);
 	if (ip6 == NULL)
 		goto out;
 
 	ipv6_addr_copy(&ad->u.net.v6info.saddr, &ip6->saddr);
 	ipv6_addr_copy(&ad->u.net.v6info.daddr, &ip6->daddr);
 	ret = 0;
 
 	nexthdr = ip6->nexthdr;
 	offset += sizeof(_ipv6h);
-	offset = ipv6_skip_exthdr(skb, offset, &nexthdr,
-				  skb->tail - skb->head - offset);
+	offset = ipv6_skip_exthdr(skb, offset, &nexthdr);
 	if (offset < 0)
 		goto out;
 
 	switch (nexthdr) {
 	case IPPROTO_TCP: {
         	struct tcphdr _tcph, *th;
 
 		th = skb_header_pointer(skb, offset, sizeof(_tcph), &_tcph);
 		if (th == NULL)
 			break;
 
 		ad->u.net.sport = th->source;
 		ad->u.net.dport = th->dest;
 		break;
 	}
 
 	case IPPROTO_UDP: {
 		struct udphdr _udph, *uh;
 
 		uh = skb_header_pointer(skb, offset, sizeof(_udph), &_udph);
 		if (uh == NULL)
 			break;
 
 		ad->u.net.sport = uh->source;
 		ad->u.net.dport = uh->dest;
 		break;
 	}
 
 	/* includes fragments */
 	default:
 		break;
 	}
