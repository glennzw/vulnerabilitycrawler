commit 6905d9e4dda6112f007e9090bca80507da158e63
Author: Benjamin Marzinski <bmarzins@redhat.com>
Date:   Tue Apr 26 01:13:24 2011 -0500

    GFS2: make sure fallocate bytes is a multiple of blksize
    
    The GFS2 fallocate code chooses a target size to for allocating chunks of
    space.  Whenever it can't find any resource groups with enough space free, it
    halves its target. Since this target is in bytes, eventually it will no longer
    be a multiple of blksize.  As long as there is more space available in the
    resource group than the target, this isn't a problem, since gfs2 will use the
    actual space available, which is always a multiple of blksize.  However,
    when gfs couldn't fallocate a bigger chunk than the target, it was using the
    non-blksize aligned number. This caused a BUG in later code that required
    blksize aligned offsets.  GFS2 now ensures that bytes is always a multiple of
    blksize
    
    Signed-off-by: Benjamin Marzinski <bmarzins@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/fs/gfs2/file.c b/fs/gfs2/file.c
index 23eab47..a9f5cbe 100644
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@ -809,86 +809,92 @@ static void calc_max_reserv(struct gfs2_inode *ip, loff_t max, loff_t *len,
 static long gfs2_fallocate(struct file *file, int mode, loff_t offset,
 			   loff_t len)
 {
 	struct inode *inode = file->f_path.dentry->d_inode;
 	struct gfs2_sbd *sdp = GFS2_SB(inode);
 	struct gfs2_inode *ip = GFS2_I(inode);
 	unsigned int data_blocks = 0, ind_blocks = 0, rblocks;
 	loff_t bytes, max_bytes;
 	struct gfs2_alloc *al;
 	int error;
+	loff_t bsize_mask = ~((loff_t)sdp->sd_sb.sb_bsize - 1);
 	loff_t next = (offset + len - 1) >> sdp->sd_sb.sb_bsize_shift;
 	next = (next + 1) << sdp->sd_sb.sb_bsize_shift;
 
 	/* We only support the FALLOC_FL_KEEP_SIZE mode */
 	if (mode & ~FALLOC_FL_KEEP_SIZE)
 		return -EOPNOTSUPP;
 
-	offset = (offset >> sdp->sd_sb.sb_bsize_shift) <<
-		 sdp->sd_sb.sb_bsize_shift;
+	offset &= bsize_mask;
 
 	len = next - offset;
 	bytes = sdp->sd_max_rg_data * sdp->sd_sb.sb_bsize / 2;
 	if (!bytes)
 		bytes = UINT_MAX;
+	bytes &= bsize_mask;
+	if (bytes == 0)
+		bytes = sdp->sd_sb.sb_bsize;
 
 	gfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &ip->i_gh);
 	error = gfs2_glock_nq(&ip->i_gh);
 	if (unlikely(error))
 		goto out_uninit;
 
 	if (!gfs2_write_alloc_required(ip, offset, len))
 		goto out_unlock;
 
 	while (len > 0) {
 		if (len < bytes)
 			bytes = len;
 		al = gfs2_alloc_get(ip);
 		if (!al) {
 			error = -ENOMEM;
 			goto out_unlock;
 		}
 
 		error = gfs2_quota_lock_check(ip);
 		if (error)
 			goto out_alloc_put;
 
 retry:
 		gfs2_write_calc_reserv(ip, bytes, &data_blocks, &ind_blocks);
 
 		al->al_requested = data_blocks + ind_blocks;
 		error = gfs2_inplace_reserve(ip);
 		if (error) {
 			if (error == -ENOSPC && bytes > sdp->sd_sb.sb_bsize) {
 				bytes >>= 1;
+				bytes &= bsize_mask;
+				if (bytes == 0)
+					bytes = sdp->sd_sb.sb_bsize;
 				goto retry;
 			}
 			goto out_qunlock;
 		}
 		max_bytes = bytes;
 		calc_max_reserv(ip, len, &max_bytes, &data_blocks, &ind_blocks);
 		al->al_requested = data_blocks + ind_blocks;
 
 		rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA +
 			  RES_RG_HDR + gfs2_rg_blocks(al);
 		if (gfs2_is_jdata(ip))
 			rblocks += data_blocks ? data_blocks : 1;
 
 		error = gfs2_trans_begin(sdp, rblocks,
 					 PAGE_CACHE_SIZE/sdp->sd_sb.sb_bsize);
 		if (error)
 			goto out_trans_fail;
 
 		error = fallocate_chunk(inode, offset, max_bytes, mode);
 		gfs2_trans_end(sdp);
 
 		if (error)
 			goto out_trans_fail;
 
 		len -= max_bytes;
 		offset += max_bytes;
 		gfs2_inplace_release(ip);
 		gfs2_quota_unlock(ip);
 		gfs2_alloc_put(ip);
 	}
 	goto out_unlock;
 
