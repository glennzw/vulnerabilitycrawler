commit b995299b73ba4cd259f221f500d4e63095508bec
Author: Werner Lemberg <wl@gnu.org>
Date:   Mon Jun 7 09:13:41 2010 +0200

    Fix Savannah bug #30054.
    
    * src/ftdiff.c, src/ftgrid.c, src/ftmulti.c, src/ftstring.c,
    src/ftview.c: Use precision for `%s' where appropriate to avoid
    buffer overflows.

diff --git a/ChangeLog b/ChangeLog
index fa154dd..07b1e6e 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,2187 +1,2195 @@
+2010-06-07  Werner Lemberg  <wl@gnu.org>
+
+	Fix Savannah bug #30054.
+
+	* src/ftdiff.c, src/ftgrid.c, src/ftmulti.c, src/ftstring.c,
+	src/ftview.c: Use precision for `%s' where appropriate to avoid
+	buffer overflows.
+
 2010-04-14  Werner Lemberg  <wl@gnu.org>
 
 	ftdiff: Add support for LCD filter control.
 
 	Key `l' cycles through the filter modes, `[' and `]' select the
 	custom filter weight, `-' and `+' (or `=') adjust the selected
 	filter weight.
 
 	This is based on code written by Lifter
 	<http://unixforum.org/index.php?showuser=11691>.
 
 	* src/ftdiff.c (ColumnStateRec): Add members for LCD filter control.
 	(render_state_init): Updated.
 	(render_state_draw): Add support for custom LCD filter.
 	(event_help): Document new keys.
 	Make help screen more compact.
 	(process_event): Handle new keys.
 
 2010-04-14  Werner Lemberg  <wl@gnu.org>
 
 	ftview: Add support for LCD filter control.
 
 	Key `F' toggles custom LCD filter mode, `[' and `]' select the
 	custom filter weight, `-' and `+' (or `=') adjust the selected
 	filter weight.
 
 	This is based on code written by Lifter
 	<http://unixforum.org/index.php?showuser=11691>.
 
 	* src/ftview.c (INIT_SIZE, Render_Waterfall): Add space for a third
 	header line.
 	(status_): Add members for LCD filter control.
 	(event_help): Document new keys.
 	Make help screen more compact.
 	(Process_Event): Handle new keys.  Use FTC_Manager_RemoveFaceID to
 	flush the bitmap caches, forcing a redraw.  I'm not sure whether
 	this is the right thing, but it seems to work...
 	(write_header): Display custom filter weights.
 
 2010-02-11  Werner Lemberg  <wl@gnu.org>
 
 	* Version 2.3.12 released.
 	==========================
 
 
 	Tag sources with `VER-2-3-12'.
 
 	* README: Updated.
 
 2009-10-10  Werner Lemberg  <wl@gnu.org>
 
 	* Version 2.3.11 released.
 	==========================
 
 
 	Tag sources with `VER-2-3-11'.
 
 	* README: Updated.
 
 2009-10-06  Werner Lemberg  <wl@gnu.org>
 
 	* Version 2.3.10 released.
 	==========================
 
 
 	Tag sources with `VER-2-3-10'.
 
 	* README: Updated.
 
 	* Makefile (major, minor, patch): Fix regexp to allow more
 	than a single digit.
 	(dist): We now use git.
 
 2009-07-30  Boris Letocha  <b.letocha@gmc.net>
 
 	[graph] Fix rendering on Windows.
 
 	* graph/win32/grwin32.c (gr_win32_surface_refresh_rectangle):
 	Handle `gr_pixel_mode_gray' correctly.
 
 2009-06-17  Werner Lemberg  <wl@gnu.org>
 
 	Reduce number of automatically compiled programs.
 	Many GNU/Linux distributions install those programs, and most of
 	them are completely useless or very specialized.
 
 	* Makefile (LINK): Define.
 	(EXES): Reduce list to retain only generally useful programs.
 	(ftsbit): Comment out.  Program doesn't compile (but may be useful).
 	(ttdebug.o): Make it compile again.
 
 2009-06-17  Werner Lemberg  <wl@gnu.org>
 
 	* Makefile: Handle `EXTRAFLAGS' for platform `unixdev' also.
 
 2009-04-30  Werner Lemberg  <wl@gnu.org>
 
 	ftview: Make slant and boldness controllable.
 
 	Keys `e' and `E' adjust emboldening, keys `s' and `S' the slant.
 
 	* src/ftview.c (status): Add `bold_factor' and `slant' members.
 	(Render_Slanted): Use `status.slant'.
 	(Render_Embolden): Copy code from `FT_GlyphSlot_Embolden' and use
 	`status.bold_factor'.
 	(event_bold_change, event_slant_change): New functions.
 	(Process_Event): Handle keys `s', `S', `e', and `E'.
 	(event_help): Updated.
 
 2009-04-26  Werner Lemberg  <wl@gnu.org>
 
 	* graph/grblit.c (blit_lcd8_to_24): Fix typo.
 	Reported by suyu@cooee.cn.
 
 2009-04-22  Werner Lemberg  <wl@gnu.org>
 
 	Fix crash in ftgrid.
 
 	* src/ftgrid.c (grid_status_draw_outline): Handle return value of
 	FT_Load_Glyph.
 
 2009-03-12  Werner Lemberg  <wl@gnu.org>
 
 	* Version 2.3.9 released.
 	=========================
 
 
 	Tag sources with `VER-2-3-9'.
 
 	* README: Updated.
 
 2009-03-10  Werner Lemberg  <wl@gnu.org>
 
 	* src/common.c (CONST): New macro, defined depending on __STDC__.
 	Use it where necessary.
 
 2009-03-10  Werner Lemberg  <wl@gnu.org>
 
 	Fix C++ compilation.
 
 	* src/ftbench.c (test_load_advances): Use cast.
 	* src/ftgrid.c: Protect `extern' declarations with `extern "C"'.
 
 2009-03-03  Werner Lemberg  <wl@gnu.org>
 
 	Fix signedness issues.
 
 	* src/ftcommon.c (FTDemo_String_Set): Fix signedness.
 	Update callers.
 	Include `common.h'.
 	Use __STDC__ macro.
 	* src/ftcommon.h (FTDemo_String_Set): Fix signedness.
 
 	* src/common.h, src/common.c: Use __STDC__ macro.
 
 2009-03-03  David Turner  <david@freetype.org>
 
 	Add utf-8 support to ftview.  Fixes Savannah BUG #18225.
 
 	* src/common.h, src/common.c: Add `utf8_next' function.
 	* src/ftcommon.c (FTDemo_String_Set), src/ftview.c (Render_Text):
 	Use `utf8_next'.
 
 2009-01-14  Werner Lemberg  <wl@gnu.org>
 
 
 	* Version 2.3.8 released.
 	=========================
 
 
 	Tag sources with `VER-2-3-8'.
 
 	* README: Updated.
 
 2009-01-07  Werner Lemberg  <wl@gnu.org>
 
 	ftdiff: Add `a' key to toggle global advance width.
 
 	* src/ftdiff.c (ColumnStateRec): Add `use_global_advance_width'
 	field.
 	(render_state_init): Updated.
 	(render_state_draw): Control FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH.
 	Update screen output.
 	(event_help): Document `a' key.
 	Sort output.
 	(process_keys): Handle `a' key.
 	Sort entries in `case' block.
 
 2008-12-05  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftbench.c: Remove #if FT_ADVANCES_H ... conditionals.
 
 2008-09-02  David Turner  <david@freetype.org>
 
 	* src/ftbench.c: Include FT_ADVANCES_H.
 	(FT_BENCH_LOAD_ADVANCES): New enumeration value.
 	(test_load_advances): New function.
 	(main) <FT_BENCH_LOAD_ADVANCES>: New case.
 
 2008-06-29  Werner Lemberg  <wl@gnu.org>
 
 
 	* Version 2.3.7 released.
 	=========================
 
 
 	Tag sources with `VER-2-3-7'.
 
 	* README: Updated.
 
 2008-06-10  Werner Lemberg  <wl@gnu.org>
 
 
 	* Version 2.3.6 released.
 	=========================
 
 
 	Tag sources with `VER-2-3-6'.
 
 	* README: Updated.
 
 2008-05-18  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftdiff.c (render_mode_names): Use better strings.
 
 2008-05-13  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftcommon.c (string_render_prepare): Always set extent in last
 	slot.
 
 2008-01-10  Allan Yang, Jian Hua - SH  <Allan.Yang@fmc.fujitsu.com>
 
 	* graph/grfill.c: Include <stdlib.h>.
 
 2007-12-29  Allan Yang, Jian Hua - SH  <Allan.Yang@fmc.fujitsu.com>
 	    Werner Lemberg  <wl@gnu.org>
 
 	* src/ftview.c: Implement slanting.
 
 2007-08-08  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftvalid.c (print_usage): Add option `-f'.
 
 2007-08-08  George Williams  <gww@silcom.com>
 
 	* src/ftvalid.c (ot_table_spec): Handle `MATH' table also.
 	(main): Add option `-f' to select font index.
 
 2007-07-07  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftview.c (parse_cmdline): Remove C++ compiler warning.
 
 	* src/ftcommon.c (my_file_requester), src/ftgrid.c
 	(grid_status_draw_grid, ft_outline_draw, ft_outline_new_circle,
 	grid_status_draw_outline, _af_debug_hints), src/ftdiff.c
 	(_render_state_rescale, render_state_set_files,
 	render_state_set_file, adisplay_draw_glyph, adisplay_draw_text,
 	event_help, event_change_gamma, process_event, write_message, main):
 	Fix compilation with C++ compiler.
 
 2007-07-02  Werner Lemberg  <wl@gnu.org>
 
 
 	* Version 2.3.5 released.
 	=========================
 
 
 	Tag sources with `VER-2-3-5'.
 
 	* README: Updated.
 
 2007-06-19  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftview.c (usage): Make it more readable.
 
 2007-06-16  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftpatentcheck.c: Renamed to...
 	* src/ftpatchk.c: This.
 	Minor fixes.
 
 	* src/Jamfile (PROGRAMS), Makefile: Updated.
 
 2007-06-10  David Turner  <david@freetype.org>
 
 	Add the new `ftpatentcheck' program; it is a simple wrapper of the
 	new FT_Face_CheckTrueTypePatents function.
 
 	* src/ftpatentcheck.c: New file.
 	* src/Jamfile (PROGRAMS), Makefile: Updated.
 
 2007-06-09  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftgrid.c (Process_Event): Assign usual actions to keys F7-F12.
 	(event_help): Updated.
 	(main): Don't expect a Unicode encoded font -- we are only working
 	with glyph indices currently.
 
 2007-06-01  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftcommon.c (FTDemo_Index_To_Bitmap): Initialize `*x_advance'.
 
 2007-05-28  David Turner  <david@freetype.org>
 
 	* src/ftcommon.h: fix compilation warning
 
 	* src/ftview.c: fix size bugs in waterfall mode
 
 2007-05-11  David Turner  <david@freetype.org>
 
 	* src/ftcommon.h, src/ftcommon.c, src/ftview.c, src/ftgrid.c,
 	src/ftstring.c: adapt test programs to use the new
 	FTC_ImageCache_LookupScaler and FTC_SBitCache_LookupScaler
 	functions. This allows you to specify fractional pixel/point
 	sizes on the command line (e.g. ftview 13.5 ~/fonts/*)
 
 2007-05-09  Ryan Hill  <dirtyepic@gentoo.org>
 
 	* Makefile: Fix rules for fttimer which doesn't use graphical
 	output.
 	Fix rule for ftdump to make it work with parallel builds.
 
 2007-04-09  Werner Lemberg  <wl@gnu.org>
 
 
 	* Version 2.3.4 released.
 	=========================
 
 
 	Tag sources with `VER-2-3-4'.
 
 	* README: Updated.
 
 	* src/ftdiff.c (process_event): Handle `?' key.
 
 2007-04-04  Werner Lemberg  <wl@gnu.org>
 
 
 	* Version 2.3.3 released.
 	=========================
 
 
 	Tag sources with `VER-2-3-3'.
 
 	* README: Updated.
 
 2007-04-03  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftdiff.c (usage): Make message similar to other ftdemo
 	programs.
 
 2007-04-02  David Turner  <david@freetype.org>
 
 	* graph/win32/grwin32.c (gr_win32_surface_init): Fix the Win32
 	window size computations to properly adjust border thickness and
 	other extras.  Fix by Sébastien Leix <s.leix@sdi.fr>.
 
 	* src/ftdiff.c (render_state_draw): Fix small bug that prevented
 	unhinted rendering from working as expected with embedded bitmaps.
 
 	(adisplay_init): Fix small bug that occurred when the
 	call to grNewSurface() failed.  Reported by Sébastien Leix
 	<s.leix@sdi.fr>.
 
 	(usage): Move up in file.
 
 	(FontFaceRec): New structure.
 	(RenderStateRec): Integrate it.
 	Update all users.
 
 	(render_state_set_files, render_state_set_file): Handle all faces in
 	a multi-face font file.
 
 	(write_message): Handle multi-face font files.
 
 2007-04-01  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftdiff.c: Remove compiler warnings.
 	Formatting.
 
 2007-03-30  David Turner  <david@freetype.org>
 
 	Change interface keys to allow you to change settings for a single
 	column only.  Press F1 for details.
 
 	* src/ftdiff.c: Include FT_LCD_FILTER_H.
 	(DisplayMode): Add DISPLAY_MODE_LCD.
 
 	(Display_textFunc): New function pointer.
 	(DisplayRec): Add it.
 
 	(RenderMode): Replace it with...
 	(HintMode): This.  Update all users.
 
 	(render_mode_names): New array.
 
 	(ColumnStateRec): New struct.
 	(RenderStateRec): Use it.
 	(render_state_init): Initialize it.
 
 	(render_state_draw): Pass index as argument.
 	Use ColumnStateRec.
 	Implement sub-pixel positioning for unhinted mode.
 	Add column footers, showing current rendering state.
 
 	(adisplay_draw_glyph): Handle DISPLAY_MODE_LCD.
 	(adisplay_draw_text): New function.
 
 	(event_help): Updated.
 	(process_event): Add many keys to control rendering modes in more
 	detail.
 
 	(main): Updated.
 
 2007-03-28  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftdiff.c: Remove many compiler warnings.
 	Fix some typos.
 	Improve and fix help texts.
 	Formatting.
 
 2007-03-26  David Turner  <david@freetype.org>
 
 	* src/ftdiff.c: New proofing program that displays text in three
 	columns: bytecode-hinted, auto-hinted with rsb/lsb delta
 	adjustments, and unhinted/subpixel-positioned.  For comparison
 	purposes.
 
 	* Makefile, Jamfile: Add ftdiff.
 
 2007-03-22  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/ftvalid.c (print_usage): Fix a typo in the help message.
 
 2007-03-09  Werner Lemberg  <wl@gnu.org>
 
 
 	* Version 2.3.2 released.
 	=========================
 
 
 	Tag sources with `VER-2-3-2'.
 
 	* README: Updated.
 
 2007-02-14  David Turner  <david@freetype.org>
 
 	* src/ttdebug.c: another refresh of the debugger. Minor improvements
 	to be able to display more useful information during debugging
 
 2007-02-12  David Turner  <david@freetype.org>
 
 	* src/ttdebug.c: refresh the TrueType debugger code
 
 2007-02-06  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/ftstring.c (event_render_mode_change): Fix spelling.
 
 2007-01-31  Werner Lemberg  <wl@gnu.org>
 
 
 	* Version 2.3.1 released.
 	=========================
 
 
 	Tag sources with `VER-2-3-1-FINAL'.
 
 	* README: Updated.
 
 2007-01-17  Werner Lemberg  <wl@gnu.org>
 
 
 	* Version 2.3.0 released.
 	=========================
 
 
 	Tag sources with `VER-2-3-0-FINAL'.
 
 2007-01-11  Masatake YAMATO  <jet@gyve.org>
 
 	* src/ftvalid.c (run_ot_validator, run_gx_validator,
 	run_ckern_validator): Return FT_Error value instead of int value.
 	(main): Return value returned from validator's run method.
 	(report_result): Don't show `invalid' message if there is no target
 	table.
 
 2006-12-15  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* mac/ftoldmac.c: Fix conditional macros of FSSpec/FSRef and
 	QuickDraw/ATS functionalities.
 
 2006-12-10  Werner Lemberg  <wl@gnu.org>
 
 	* Makefile (dist): Extract version number from freetype.h.
 
 2006-11-15  David Turner  <david@freetype.org>
 
 	* graph/x11/rules.mk (X11_PATH): Check /usr also.
 	Search for `Xlib.h'.
 
 2006-11-03  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftgrid.c: Fix external function declarations.
 	(event_help): Document `1', `2', and `3' keys.
 	(grid_status_init, grid_status_rescale_initial,
 	grid_status_draw_grid, grid_status_draw_outline, event_grid_reset):
 	s/status/st/, s/error/err/ where appropriate to avoid shadowed
 	variables.
 	(GridStatusRec): Add `const' to `header'.
 	Update all assignments.
 
 	* Makefile: Add ftgrid.
 
 2006-11-02  David Turner  <david@freetype.org>
 
 	Add `B' key to ftgrid for toggling blue zone hinting.
 	Add `1', `2', and `3' keys to dump hints for edges, segments, and
 	points, respectively.
 
 	* src/ftgrid.c: Add some externs.
 	(_af_debug, _af_debug_disable_blue_hints, _af_debug_hints): New
 	global variables.
 	(GridStatusRec): Add `do_blue_hints' variable.
 	(grid_status_init): Set do_blue_hints.
 	(event_help): Updated.
 	(Process_Event): Updated.
 	(main): Set _af_debug.
 
 2006-10-23  Zhe Su  <zsu@novell.com>
 
 	Add a benchmark for the emboldening algorithm.
 
 	* src/ftbench.c: Include FT_SYNTHESIS_H.
 	(FT_BENCH_EMBOLDEN): New enumeration value.
 	(bench_desc): Add `Embolden'.
 	(test_embolden): New function.
 	(main): Add it.
 
 2006-10-23  David Turner   <david@freetype.org>
 
 	* src/ftgrid.c: Make the file compile again.
 
 2006-10-11  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* mac/ftoldmac.c (print_help): Renamed to...
 	(print_help_and_exit): This.  Update callers.
 	Improve the conditionals in source to separate Toolbox QuickDraw and
 	Carbon QuickDraw.
 	(reserveToolBoxQuickDrawFontName, test_face_quickdraw,
 	test_font_list_quickdraw_old, test_font_list_quickdraw,
 	test_font_list_ats): Ditto.
 
 2006-10-11  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* mac/Makefile: Synchronize with the changes of top-level Makefile
 	on 2006-02-01.
 
 2006-09-27  David Turner  <david@freetype.org>
 
 	Add support for LCD color filtering to ftview.
 
 	* src/ftview.c: Include FT_LCD_FILTER_H.
 	(status): Initialize it completely.
 	(main): Call FT_Library_SetLcdFilter.
 
 	* src/ftcommon.c (FT_Demo_Draw_Glyph): Renamed to...
 	(FT_Demo_Draw_Glyph_Color): This.  Add an argument to pass the
 	colour.
 	(FT_Demo_Draw_Glyph): New function, calling
 	FT_Demo_Draw_Glyph_Color.
 
 	* src/ftcommon.h (FT_Demo_Draw_Glyph_Color): New declaration.
 
 	* src/ftgrid.c: New file, implementing an auto-fitter debugger.
 	This is a very preliminary version.  It only compiles with Jam at
 	the moment, and you must have AF_DEBUG defined in your
 	`src/autofit/aftypes.h' file to be able to link it.
 
 	* src/Jamfile (GRAPHIC_PROGRAMS): Add ftgrid.
 
 	* graph/graph.h (grFindColor, grFillHLine, grFillVLine, grFillRect):
 	New declarations.
 
 	* graph/grfill.c: New file which implements `grFillHLine',
 	`grFillVLine', and `grFillRect'.  They are mainly used by the
 	auto-fitter debugger.
 
 	* graph/grobjs.c (grFindColor): New function for the auto-fitter
 	debugger.
 
 	* graph/gblender.c (gblender_set_gamma_table): Set
 	`gamma_ramp_inv[gmax]'.
 
 	* graph/gblender.h (GBLENDER_STAT_HIT, GBLENDER_LOOKUP): Move them
 	up in source file.
 
 	* graph/Jamfile (graph_sources), graph/rules.mk (GRAPH_OBJS): Add
 	`grfill'.
 
 2006-09-11  David Turner  <david@freetype.org>
 
 	Add support for OLPC swizzle simulation (must define SWIZZLE at
 	compile time for this to work).
 
 	* graph/grswizzle.c, graph/grswizzle.h: New files.
 
 	* graph/grdevice.h (gr_swizzle_rbg24): Declare.
 
 	* graph/Jamfile (graph_sources): Add `grswizzle'.
 
 	* graph/win32/grwin32.c [SWIZZLE]: Include `grswizzle.h'.
 	(gr_win32_surface_refresh_rectangle) [SWIZZLE]: Don't call
 	gr_swizzle_rgb24 but gr_rect_swizzle_rgb24.
 	Remove unused variables.
 
 2006-09-01  David Turner  <david@freetype.org>
 
 	Fix various bugs in the glyph blender/blitter.
 
 	* graph/gblcolor.h, graph/gblhbgr.h, graph/gblhrgb.h,
 	graph/gblvbgr.h, graph/gblvrgb.h: Fix off-by-one
 	error.
 
 	* graph/gblender.c (gblender_lookup): Fix computation of key->cells.
 	(gblender_lookup_channel): Fix computation of key->index.
 
 	* graph/win32/grwin32.c: Fix RGB/BGR ordering -- Win32 uses BGR
 	ordering for its 24-bit bitmaps.
 	(SWIZZLE): New macro (set to undefined).
 	(grWin32SurfaceRec): Add `bgrBitmap'.
 	[SWIZZLE]: Add `swizzle_bitmap'.
 	(gr_win32_surface_done) [SWIZZLE]: Handle `swizzle_bitmap'.
 	(gr_win32_surface_refresh_rectangle): Do conversion RGB->BGR.
 	(gr_win32_surface_init): Initialize `bgrBitmap'.
 	[SWIZZLE]: Initialize `swizzle_bitmap'.
 
 2006-07-03  Masatake YAMATO  <jet@gyve.org>
 
 	* src/ftvalid.c (library): Move this global variable to main as a
 	local variable.
 	(print_usage): Introduce function static variable `library'.
 	Add one argument for initializing the static variable.
 	(main): Call print_usage with `library'.
 	(main, else, parse_table_specs, find_validation_flag): Call
 	print_usage with NULL.
 
 2006-06-17  Masatake YAMATO  <jet@gyve.org>
 
 	* src/ftvalid.c: Rearrange code.
 	(library): Make variable having global scope.
 	(OT_VALIDATOR_SYMBOL): Remove.
 	(GX_VALIDATOR_SYMBOL): Remove.
 	(CKERN_VALIDATOR_SYMBOL): Remove.
 	(validator_symbols): Remove.
 	(ValidatorType::LAST_VALIDATE): New enum element used in loop
 	sentinel.
 	(ot_table_spec): Remove const modifier.
 	(gx_table_spec): Remove const modifier.
 	(Validator): New data type.
 	(validators): New variable.
 	(print_usage): Use validators.
 	(report_header, report_result): Use validators.
 	(is_ot_validator_implemented): New function.
 	(is_gx_validator_implemented): New function.
 	(is_ckern_validator_implemented): New function.
 	(run_ckern_validator): Use validators.
 	(main): Initialize library at the beginning of main.
 	Use validators.
 	Report messages and exit if the validator specified by command line
 	is not implemented in libfreetype2 linked to ftvalid.  Suggested by
 	George Williams.
 
 2006-06-09  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftcommon.c (FTDemo_Install_Font): Fix index range for MS
 	Symbol.
 
 2006-06-07  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftcommon.c (FTDemo_Display_Done, FTDemo_Done): Protect against
 	NULL argument.
 
 	* src/ftview.c (Fatal): New function to finalize FreeType library.
 	This allows to use FreeType's memory debugger in case of errors.
 	s/PanicZ/Fatal/.
 
 2006-06-04  David Turner  <david@freetype.org>
 
 	* src/ftbench.c (main): fixed a subtle memory corruption bug
 	at program exit.  Reported by <luoy.li@gmail.com>.
 
 2006-05-21  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftdump.c (Print_Type): Fix type for `module'.  Reported by
 	Mark Wang.
 
 2006-05-17  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftcommon.c, src/ftview.c [_WIN32]: Define `strcasecmp' and
 	`snprintf'.
 
 2006-05-17  yi luo  <luoyi.ly@gmail.com>
 
 	* graph/win32/rules.mk: Add support for icl compiler.
 
 	* src/ftcommon.c (strcasecmp): Define to `_stricmp' if not
 	available.
 
 	* src/ftview.c (snprintf): Define to `_snprintf' if not available.
 
 2006-05-12  Werner Lemberg  <wl@gnu.org>
 
 
 	* Version 2.2.1 released.
 	=========================
 
 
 2006-05-10  Werner Lemberg  <wl@gnu.org>
 
 	* Makefile (clean distclean) [no_config_mk]: Fix warning message.
 	(dist): New target to build .tar.bz2, .tar.gz, and .zip bundles.
 	Note that there are still many hard-coded version strings.
 
 2006-05-06  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftdump.c (main): Fix compiler warning.
 
 2006-05-02  David Turner <david@freetype.org>
 
 	Add support for font preloading with the `-p' flag, simulating
 	memory-mapped file access.
 
 	* src/ftcommon.h (TFont): New elements `file_address' and
 	`file_size'.
 	(FTDemo_Handle): New element `preload'.
 	(FTDemo_Set_Preload): New prototype.
 
 	* src/ftcommon.c (my_face_requester): Use FT_New_Memory_Face for
 	preloaded font.
 	Handle PFM files also.
 	(FTDemo_Install_Font): Handle preloading (this is, load font into a
 	buffer).
 	(FTDemo_Set_Preload): New function.
 
 	* src/ftview.c (status): Add `preload' field.
 	(parse_cmdline): Handle `-p' command line option.
 	(usage): Updated.
 	(main):
 
 	* src/ftdump.c (main): Add glyph count dump.
 
 2006-04-26  David Turner <david@freetype.org>
 
 
 	* Version 2.2 released.
 	=======================
 
 
 2006-04-24  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftview.c (Render_Stroke): Update parameters in call to
 	FT_Stroker_New.
 
 2006-03-20  David Turner  <david@freetype.org>
 
 	Disable cache statistics dump, since the cache
 	internals are not available anymore.
 	Rename `-l' to `-L'.
 	Add new command line options `-m text' and `-l render_mode'.
 
 	* src/ftview.c (status): Add member `lcd_mode'.
 	(Render_Text): Compensate the additional empty pixels inserted by
 	Draw_Index.
 	Hande number of glyph indices better.
 	(parse_cmdline): Handle `-m' and `-l'.
 	Updated.
 	(usage): Updated.
 	(main): Handle `status.lcd_mode'.
 	Updated.
 	Print cache statistics only conditionally (for FreeType versions
 	lower than 2.2).
 
 2006-03-02  Chia-I Wu  <b90201047@ntu.edu.tw>
 
 	* src/ftcommon.c (string_render_prepare): Fix a possible crash.
 
 2006-02-28  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* Makefile: include modules.cfg to reflect module configuration,
 	and ftvalid is built when required stubs (ftgxval and ftotval)
 	are built in libfreetype.
 
 2006-02-27  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* mac/ftoldmac.m68k_far.make.txt, mac/ftoldmac.ppc_classic.make.txt:
 	Update to new header inclusion introduced on 2006-02-16.
 
 2006-02-27  Chia-I Wu  <b90201047@ntu.edu.tw>
 
 	* src/ftcommon.c (my_face_requester): Attach the AFM only for PFA
 	and PFB.
 
 2006-02-25  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftbench.c, src/ftcommon.c, src/ftvalid.c: Add proper casts
 	where necessary to allow compilation with C++.
 	Other minor fixes to remove compiler warnings.
 
 2006-02-01  Werner Lemberg  <wl@gnu.org>
 
 	* Makefile (PLATFORM): Define to `unixdev' if PLATFORM=unix and
 	DEVEL_DIR is defined.
 	(BIN_DIR, OBJ_DIR): Replaced with...
 	(BIN_DIR_2, OBJ_DIR_2): New variables, set with `?='.
 	Update all callers.
 	(BIN_DIR): Set also.
 	(COMPILE): Add definition for FT_CONFIG_MODULES_H since we always
 	build with an uninstalled FreeType version.
 	(ftdump.$(SO), ftvalid.$(SO), ftview.$(SO)): Add -DFT2_BUILD_LIBRARY
 	since these programs use internal headers.
 
 	* graph/rules.mk, graph/*/rules.mk: s/OBJ_DIR/OBJ_DIR_2/.
 
 	* src/ftcommon.c (string_render_prepare): Fix compiler warnings.
 
 2006-01-16  Chia-I Wu  <b90201047@ntu.edu.tw>
 
 	Add support for track kerning and a new rendering mode for kerning
 	comparison to ftstring.
 
 	* src/ftcommon.c (my_face_requester): Try to attach the file having
 	the same name as the font, but with suffix `.afm'.
 	(FTDemo_New): Updated.
 	(FTDemo_String_Set_Kerning, FTDemo_String_Set_Vertical): Removed.
 	(string_load): Rewritten.
 	(string_render_prepare): New function.
 	(FTDemo_String_Draw): Rewritten to have more flexibility.  For
 	example, we can now draw the string twice with different kerning
 	modes without reloading the glyphs.
 
 	* src/ftcommon.h (TGlyph): Add more data, mainly taken from
 	FTDemo_Handle structure.
 	(KERNING_DEGREE_XXX): New enumerations.
 	(FTDemo_String_Context): New structure.
 	(FTDemo_Handle): Updated.
 	(FTDemo_String_Set_Kerning, FTDemo_String_Set_Vertical): Removed.
 	(FTDemo_String_Draw): Updated.
 
 	* src/ftstring.c: Updated along with many cleanups.
 	(CELLSTRING_HEIGHT): New macro.
 	(RENDER_MODE_XXX): New enumeration values.
 	(status): Add more fields.
 	(event_help, event_angle_change): Updated.
 	(event_render_mode_change): New function.
 	(Process_Event): Handle `1', `2', and `t' events.
 	Update handling of `g', `k', and `V' events.
 	(error_message): Renamed to...
 	(write_header): This.
 	Display point size and rotation angle.
 	(main): Handle new render mode.
 
 2006-01-12  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Add `ftoldmac' commandline program to test MacOS specific feature:
 	font file access by FSSpec, font file search by old/new QuickDraw,
 	and font name or ATS font name.
 
 	* mac/ftoldmac.c: Added.
 	* mac/Makefile: Unix Makefile for MacOS X.
 	* mac/ftoldmac.m68k_far.make.txt: MPW Makefile skeleton.
 	* mac/ftoldmac.ppc_carbon.make.txt: MPW Makefile skeleton.
 	* mac/ascii2mpw.py: Python script to generate MPW Makefile from
 	the skeletons.
 	* mac/README: Add note about ftoldmac, because ft2demos/mac was
 	originally for demos built by CodeWarrior.
 
 2005-12-08  Chia-I Wu  <b90201047@ntu.edu.tw>
 
 	* src/ftview.c (error_message): Renamed to write_header.
 	Also write face size, first glyph index.
 	Write glyph name if available.
 	(main): Updated to use write_header.
 
 2005-12-04  Chia-I Wu  <b90201047@ntu.edu.tw>
 
 	* src/ftbench.c: Update copyright date.
 	Use `getopt' from `common.h'.
 
 2005-12-04  Chia-I Wu  <b90201047@ntu.edu.tw>
 
 	* src/ftbench.c: Formatting.
 	Make `face' and `charset' local variables.
 	(btest_t): Use `const' qualifier for `title'.
 	(bcharset_t): Change the type of `size' to `FT_Int'.
 	(face_requester, benchmark): Updated because `face' is no longer
 	global.
 	(test_get_char_index, test_cmap_cache, get_charset): Updated because
 	`charset' is no longer global.
 	(main): New variables, `face' and `charset'.
 	Updated because `face' and `charset' are local now.
 	`get_charset' only when perform FT_BENCH_CMAP.
 
 2005-12-02  Chia-I Wu  <b90201047@ntu.edu.tw>
 
 	Overhaul `ftbench.'  Now it can perform tests with arbitrary load
 	flags and render mode.  Testing `Render' instead of `Load + Render',
 	for example, is also possible now.
 
 	* src/ftbench.c: Overhauled.
 
 2005-11-30  Werner Lemberg  <wl@gnu.org>
 
 	Replace flag `-c' with `-v' to indicate verbosity.
 
 	* src/ftdump.c (verbose): New global variable.
 	(usage): Updated.
 	(Print_Charmaps): Only take a single argument.  Update caller.
 	Always show some charmap info.
 	Use `verbose'.
 	(main): Remove verbose_cmap.
 	Handle `-v' instead of `-c'.
 
 	* src/common.c (getopt): s/illegal/invalid/.
 
 2005-11-30  Chia-I Wu  <b90201047@ntu.edu.tw>
 
 	* src/ftdump.c (Print_Charmaps): face->charmap might be NULL.
 
 2005-11-30  Chia-I Wu  <b90201047@ntu.edu.tw>
 
 	* src/ftdump.c (main): New command line option `c' to show the
 	contents of charmaps.
 	(Print_Charmaps): Take one more argument: `verbose'.
 	(usage): Updated.
 
 2005-11-21  Werner Lemberg  <wl@gnu.org>
 
 	* graph/grinit.c (grDoneDevices): New function.
 
 	* graph/graph.h (grInit, grDone): Remove unused declarations.
 	(grDoneDevices): New declaration.
 
 	* src/ftcommon.c (FTDemo_Display_Done): Call grDoneDevices.
 	(FTDemo_Done): Free `handle'.
 
 	* src/ftmulti.c (main): Call grDoneSurface and grDoneDevices.
 
 2005-11-18  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftvalid.c (run_ot_validator, run_gx_validator,
 	run_ckern_validator): Remove unused variable `memory'.
 
 2005-11-18  suzuki toshiya <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/ftvalid.c: Use FT_TrueTypeGX_Validate, FT_ClassicKern_Validate
 	and FT_OpenType_Validate instead of FT_FREE (it calls FT_Free_Debug
 	of libfreetype, which is not a public function).
 
 2005-11-16  David Turner  <david@freetype.org>
 
 	* graph/graph.h: Updated.
 
 	* graph/grdevice.c (grSurfaceDone): New function to free surface
 	correctly.  This was commented out previously.
 
 	* graph/x11/grx11.c (gr_x11_device_done): Call XFreeCursor.
 	(gr_x11_surface_done): Call XFreeGC to fix memory leak.
 
 	* src/ftcommon.c (FTDemo_Display_Done): Call `grDoneSurface' instead
 	of `free' to fix memory leak.
 
 	* src/ftbench.c (main): Add the `-c' flag to specify maximum
 	iteration count.  Useful for repeat profiling.
 	(usage): Updated.
 
 2004-09-29  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftcommon.c (FT_Demo_Update_Current_Flags): Fix variable
 	shadowing.
 
 2004-09-27  David Turner <david@freetype.org>
 
 	Fix gamma handling, mainly for LCD modes.
 
 	* graph/gblgblit.c (GRGB_TO_RGB565): Protect arguments correctly.
 
 	* graph/gblcolor.h, graph/gblhbgr.h, graph/gblhrgb.h,
 	graph/gblvbgr.h, graph/gblvrgb.h: Call gblender_use_channels.
 
 	* graph/gblender.c (gblender_clear, gblender_reset): Handle blender
 	cache.
 	(gblender_use_channels): New function.
 	(gblender_reset_key): Improve.
 	(gblender_lookup, gblender_lookup_channel): Comment possible call to
 	gblender_reset.
 	Fix computation of `idx'.
 	(gblender_reset_channel_key): Fix computation of `a' and `r'.
 
 	* graph/gblender.h (GBLENDER_SHADE_INDEX): Corrected definition.
 	(gblender_use_channels): New declaration.
 
 	* src/Jamfile: Include ftcommon.c.
 	Fix oder of link libraries.
 
 2004-09-22  David Turner  <david@freetype.org>
 
 	* src/ftcommon.c (FTDemo_Update_Current_Flags): Fix load flags
 	computation to mimic libXft's behaviour.
 
 2005-08-30  Werner Lemberg  <wl@gnu.org>
 
 	* graph/graph.h (grFillRectangle): Comment out -- we don't have an
 	implementation.
 
 2005-08-23  Masatake YAMATO  <jet@gyve.org>
 
 	* src/ftvalid.c: Add gxvalid support.
 	(GX_VALIDATOR_SYMBOL): New definition.
 	(CKERN_VALIDATOR_SYMBOL): New definition.
 	(ValidatorType::GX_VALIDATE): New enum member.
 	(ValidatorType::CKERN_VALIDATE): New enum member.
 	(validator_symbols): Added GX_VALIDATOR_SYMBOL and
 	CKERN_VALIDATOR_SYMBOL.
 	(gx_table_spec): New const.
 	(N_GX_TABLE_SPEC): New definition.
 	(print_usage): Write about gxvalid and ckern valid.
 	(run_gx_validator): New funtion.
 	(list_gx_tables): Ditto.
 	(run_ckern_validator): Ditto.
 	(list_ckern_tables): Ditto.
 	(main): Call new validators.
 
 	* src/ftvalid.c: Following are misc modifications.
 	(report_result): Use printf instead fprintf. Fix incorrect message.
 	(main): Use switch/case instead of if/else
 	when calling per validator funtions.
 	Call FT_Done_Face. Use a loop to set validator.
 	(print_usage): Insert empty line in usage strings.
 	(validator_symbols): Added NULL as the last
 	array element.
 
 2005-07-04  Chia I Wu  <b90201047@ntu.edu.tw>
 
 	* src/ftcommon.i: Removed.
 
 	* src/ftgamma.c: Updated to use api provided by ftcommon.c.
 
 	* Makefile: Make ftgamma depend on ftcommon.c.
 	Remove dependency of ftmulti.c on ftcommon.i.
 
 2005-06-17  Werner Lemberg  <wl@gnu.org>
 
 	* Makefile: Update rules for ftview and ftstring which no longer
 	depend on ftcommon.i but on ftcommon.c.
 
 	(LINK_ITEMS, LINK_CMD, LINK_LIBS): New variables.
 	(GRAPH_LINK2): Removed.
 	(COMMON_LINK, GRAPH_LINK): Replace with...
 	(LINK_COMMON, LINK_GRAPH): This.  Use LINK_ITEMS, LINK_CMD, and
 	LINK_LIBS.
 	Update all affected targets.
 	(LINK_NEW): Temporary new link command to handle executables which
 	use ftcommon.c.
 	(FTCOMMON_OBJ): New variable to handle ftcommon.c.
 
 2005-06-17  Chia I Wu  <b90201047@ntu.edu.tw>
 
 	* src/ftcommon.c, src/ftcommon.h: New files.
 
 	* src/ftstring.c: Rewritten.
 	Make the function keys more compatible with ftview.c.
 	New key 'V' for vertical rendering.
 
 	* src/ftview.c: Rewritten.
 	Now we can use number keys (i.e. 1, 2, ...) to select rendering mode.
 
 2005-06-08  Werner Lemberg  <wl@gnu.org>
 
 
 	* Version 2.1.10 released.
 	==========================
 
 
 2005-05-26  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftcommon.i (get_glyph_bitmap, glyph_to_bitmap): Initialize
 	`target->grays' even for FT_PIXEL_MODE_MONO since it is tested in
 	grBlitGlyphToBitmap.
 
 	* graph/x11/grx11.c (gr_x11_surface_init): Initialize
 	`xswa.border_pixel'.
 
 2005-05-25  Chia I Wu  <b90201047@ntu.edu.tw>
 
 	* src/ftcommon.i: Include FT_SYNTHESIS_H.
 	Make `render_mode' an enumeration.
 
 	* src/ftview.c (Render_Embolden): New function.
 	(Process_Event, main): Update to `render_mode' enumeration.
 
 2005-05-23  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftvalid (main) <'v'>: Add cast to make it compile with C++.
 
 2005-04-24  YAMATO Masatake  <jet@gyve.org>
 
 	* src/ftvalid.c: New file.
 
 	* Makefile, src/Jamfile: Add ftvalid.
 
 2005-03-04  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftgamma.c (Render_GammaGrid), src/ftmulti.c
 	(parse_design_coords), src/ftview.c (Render_GammaGrid): Fix compiler
 	warnings.
 
 2005-02-28  David Turner  <david@freetype.org>
 
 	* src/ftbench.c (preload, memory_file, memory_size): New global
 	variables.
 	(bench_open_close): Handle `preload' by using `FT_New_Memory_Face'.
 	(main): Remove `preload', `memory_file', and `memory_size'.
 
 2005-02-23  David Turner  <david@freetype.org>
 
 	* src/ftbench.c (fetch_test, cbox_test): Fix memory leaks.
 
 2005-02-12  Werner Lemberg  <wl@gnu.org>
 
 	Make ft2demos support a separate build directory.
 
 	* Makefile (have_makefile): New variable.  Set if the build
 	directory is the same as the source directory.
 	(GRAPH_DIR): Give full path.
 	(BIN_DIR, OBJ_DIR): Updated.
 	(FT_INCLUDES): Include $(OBJ_BUILD).
 	(LINK) <unix>: Fix path to `libtool'.
 
 	* README: Updated.
 
 2004-12-15  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftcommon.i (glyph_to_bitmap): Don't convert 1bpp bitmaps.
 
 2004-12-14  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftcommon.i: Include new FT_BITMAP_H.
 	Remove dead code.
 	(ft_bitmap): New global variable.
 	(init_freetype): Call FT_Bitmap_New.
 	(done_freetype): Call FT_Bitmap_Done.
 	(glyph_to_bitmap, get_glyph_bitmap): Handle 2bpp and 4bpp bitmaps
 	using FT_Bitmap_Convert.
 
 2004-12-12  Steve Hartwell  <shspamsink@comcast.net>
 
 	* graph/grblit.c (blit_mono_to_rgb32): Advance read buffer properly.
 
 2004-11-26  Jouk Jansen <joukj@hrem.stm.tudelft.nl>
 
 	* vms_make.com: Don't assume that the ft2demos package is a
 	subdirectory of freetype2.
 	Fix `ccopt'.
 
 2004-11-19  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftview.c (Render_Waterfall): Handle size as points, not as
 	pixels.
 
 	* src/ftstring.c (layout_glyphs), src/ftmulti.c (LoadChar),
 	src/ftcommon.i (set_current_image_type): Always use
 	FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH.
 
 2004-11-16  Dr. Martin P.J. Zinser  <zinser@decus.de>
 
 	* vms_make.com: Updated to be in sync with vms_make.com from FT2.
 
 2004-10-18  Werner Lemberg  <wl@gnu.org>
 
 	* graph/gblblit.c (gblender_blit_init): Fix blit test.
 
 2004-09-08  Jouk Jansen <joukj@hrem.stm.tudelft.nl>
 
 	* graph/x11/grx11.c [__VMS]: Include vms_x_fix.h.
 
 	* vms_make.com: Updated.
 
 2004-08-29  Werner Lemberg  <wl@gnu.org>
 
 	* graph/gblender.c (gblender_lookup, gblender_lookup_channel):
 	s/index/idx/ to avoid compiler warnings.
 
 2004-08-19  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftstring.c (prepare_text): Handle encoding = 0.
 
 2004-07-14  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftcommon.i (get_glyph_bitmap): Don't accept a `missing'
 	character with zero or negative width.
 
 2004-07-13  David Turner  <david@freetype.org>
 
 	* graph/x11/grx11.c (gr_x11_device_init): Fix memory leak.
 
 	* src/ftbench.c (bench_cmap_parse): New function, assigned to
 	key `j'.
 	(usage, main): Updated.
 
 	* src/ftcommon.i (install_font_file): Initialize `cmap_index' here.
 	(my_face_requester): Don't initialize `cmap_index'.
 	(glyph_to_bitmap): Add new argument to get glyph reference.
 	(get_glyph_bitmap): Updated.
 
 	* src/ftview.c (Render_Stroke): Increase stroker limit.
 	Fix glyph indices.
 	Fix memory leaks.
 
 2004-06-24  David Turner  <david@freetype.org>
 
 
 	* Version 2.1.9 released.
 	=========================
 
 
 2004-06-24  Werner Lemberg  <wl@gnu.org>
 
 	* Makefile (GRAPH_LINK): Add $(MATH).
 	Remove $(MATH) from link rule for ftstring.
 
 2004-06-23  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftbench.c: Fix compiler warnings.
 	(usage): Updated.
 
 2004-06-23  David Turner  <david@freetype.org>
 
 	* src/ftbench.c (bench_open_close): New benchmark to measure face
 	open/close performance (controlled by the `i' flag for the `-b'
 	command-line option flag).
 	(main): Use it.
 
 2004-06-11  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftstring.c (layout_glyphs): Updated to latest FreeType library
 	changes.
 
 2004-06-03  Werner Lemberg  <wl@gnu.org>
 
 	Add autohinting toggling (using the `f' key) to ftstring.
 	Handle new inter-letter spacing support for autohinting.
 
 	* src/ftstring.c (autohint): New global variable.
 	(layout_glyphs): Handle `autohint' variable.
 	Handle new `lsb_delta' and `rsb_delta' elements of
 	face->glyph->metrics.
 	Remove some dead code.
 	(Help): Updated.
 	(Process_Event): Handle key `f'.
 	Extend key `k'.
 
 2004-05-23  Werner Lemberg  <wl@gnu.org>
 
 	* graph/gblender_blit.c: Renamed to...
 	* graph/gblblit.c: This.
 	Updated to use new include file names.
 	(gblender_blit_init): Change 11th argument to `unsigned char*'
 
 	* graph/gblender_blit.h: Renamed to...
 	* graph/gblblit.h: This.
 	Updated.
 
 	* graph/gblender_blit_any.h: Renamed to...
 	* graph/gblany.h: This.
 	Updated to use new include file names.
 
 	* graph/gblender_blit_hbgr.h: Renamed to...
 	* graph/gblhbgr.h: This.
 
 	* graph/gblender_blit_hrgb.h: Renamed to...
 	* graph/gblhrgb.h: This.
 
 	* graph/gblender_blit_vbgr.h: Renamed to...
 	* graph/gblvbgr.h: This.
 
 	* graph/gblender_blit_vrgb.h: Renamed to...
 	* graph/gblvrgb.h: This.
 
 	* graph/gblender.h (GBLENDER_CHANNEL_VARS): Remove final `;'.
 	* graph/grblit.c: Updated to use new include file names.
 
 	* graph/rules.mk, graph/Jamfile: Updated.
 
 	* Makefile: Build `ftgamma'.
 
 	* src/ftview.c (Render_GammaGrid): Fix compiler warnings.
 	(Help): Updated.
 
 	* src/ftgamma.c: Fix compiler warnings.
 
 2004-05-20  David Turner  <david@freetype.org>
 
 	Adding support for fast gamma-corrected alpha-blending.
 	New test program `ftgamma'.
 
 	* graph/grblit.c: Include gblender_blit.h.
 	(GRAY8): New macro.
 	(blit_gray8_to_555, blit_gray8_to_565, blit_gray8_to_24,
 	blit_lcd8_to_24, blit_lcd28_to_24) [GRAY8]: New functions.
 	(blit_gray8_to_32): New function.
 	(gr_gray8_blitters) [GRAY8]: New function table.
 	(grSetGlyphGamma): New function.
 	(grBlitGlyphToBitmap): Implement blending.
 	* graph/graph.h (grSetGlyphGamma): New declaration.
 
 	* graph/grfont.c, graph/grfont.h (grSetPixelMargin): New function.
 
 	* graph/gblender.c, graph/gblender.h, graph/gblender_blit.c,
 	graph/gblender_blit.h, graph/gblender_blit_any.h,
 	gblender_blit_color.h, gblender_blit_hbgr.h, gblender_blit_hrgb.h,
 	gblender_blit_vbgr.h, gblender_blit_vrgb.h: New files.
 
 	* graph/Jamfile (graph_sources): Add gblender and gblender_bnit.
 	* graph/rules.mk (GRAPH_H, GRAPH_OBJS): Updated.
 
 	* src/ftcommon.i (the_gamma): New global variable.
 	(Init_Display): Call grSetGlyphGamma.
 
 	* src/ftgamma.c: New demo program.
 
 	* src/ftview.c: Include math.h.
 	(Render_GammaGrid): New function.
 	(Help): Updated.
 	(Process_Event): Assign increase and decrease of gamma value to
 	keys `g' and `G'.
 	Assign gamma grid rendering mode to key `K'.
 	(main): Updated.
 
 	* src/Jamfile (LINKLIBS): Add -lm.
 	(GRAPHIC_PROGRAMS): Add ftgamma.c.
 	Add LINKLIBS for all GRAPHIC_PROGRAMS.
 	* vms_make.com: Updated.
 
 2004-05-19  George Williams  <gww@silcom.com>
 
 	* src/ftmulti.c (main): Use default axis values.
 
 2004-05-09  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftdump.c (put_unicode_be16): Initialize `ch'.
 
 2004-04-29  Flavio Stanchina  <flavio@stanchina.net>
 
 	Parse SFNT `name' table in ftdump if new option -n is given.
 
 	* src/ftdump.c: Include FT_SFNT_NAMES_H and FT_TRUETYPE_IDS_H.
 	(name_tables): New global variable.
 	(usage): Show -d and -i info conditionally.
 	Add -n info.
 	(platform_id, name_id, put_ascii, put_unicode_be16,
 	Print_Sfnt_Names): New functions.
 	(main): Handle -n.
 
 2004-04-24  George Williams  <gww@silcom.com>
 
 	Add GX var font support to ftmulti.
 	Add command line option `-d' to ftmulti to select design
 	coordinates.
 
 	* src/ftmulti.c: New global variables `requested_pos' and
 	`requested_cnt'.
 	Make `multimaster' a pointer.
 	(parse_design_coords): New function.
 	(Help, usage): Updated.
 	(Process_Event) <do_axis>: Don't use fixed 20 unit steps but a
 	proportional granularity.
 	Use FT_Set_Var_Design_Coordinates instead of
 	FT_Set_MM_Design_Coordinates.
 	(main): Handle new option `-d'.
 	Use FT_Get_MM_Var and FT_Set_Var_Design_Coordinates instead of
 	FT_Get_Multi_Master and FT_Set_MM_Design_Coordinates.
 
 2004-04-23  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftcommon.i (TFont): Add `cmap_index'.
 	(my_face_requester): Set `font->cmap_index'.
 	(get_glyph_index): Properly set third argument.
 
 2004-04-21  David Turner  <david@freetype.org>
 
 
 	* Version 2.1.8 released.
 	=========================
 
 
 2004-04-10  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftbench.c (cmap_cache_test, main): Use proper cast for
 	`face_id'.
 
 2004-03-26  Ulrich  <ulrich@infopuls.com>
 
 	* graph/x11/grx11.c (grX11DeviceRec): Add `visual' member.
 	(gr_x11_device_init): Directly manipulate `x11dev'.
 	Use XGetVisualInfo.
 	(gr_x11_surface_init): Directly use `x11dev'.
 	Fix other visual selection problems.
 
 2004-03-20  Steve Hartwell  <shspamsink@comcast.net>
 
 	Updated to make it compile with newer MacOS versions.
 
 	* graph/mac: Don't include Windows.h but MacWindows.h.
 	Include SIOUX.h only if __MWERKS__ is defined.
 	(refresh_rectangle): Updated.
 	(listen_event): Remove `theEventMask'.
 	Updated.
 	Make code conditional to __MWERKS__ which is related to SIOUX.
 	(init_surface): Handle gr_pixel_mode_rgb24.
 	Updated.
 
 2004-02-20  Werner Lemberg  <wl@gnu.org>
 
 	Add `light' render mode to ftview (using key `L').
 
 	* src/ftcommon.i (set_current_image_type): Handle
 	FT_LOAD_TARGET_LIGHT.
 	(glyph_to_bitmap, get_glyph_bitmap): Updated.
 	* src/ftview.c (Process_Event): Provide proper header for `light'
 	render mode.
 	(Help): Updated.
 
 2004-02-18  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftcommon.i: Include FT_CACHE_MANAGER_H and FT_STROKER_H.
 	Don't include obsolete FT_CACHE_* macros.
 	(glyph_to_bitmap): Remove declaration of `error'.
 
 	* src/ftview.c: Don't include FT_CACHE_MANAGER_H.
 	(Render_Stroke): Remove declaration of `error'.
 	Fix other compiler warnings.
 	(Render_Waterfall): Remove declaration of `face'.
 
 2004-01-29  David Turner  <david@freetype.org>
 
 	* src/ftcommon.i (get_glyph_bitmap): Rewritten for new cache code.
 	(glyph_to_bitmap): New function.
 
 	* src/ftview.c (Render_Stroke): New function.
 	(Render_Waterfall): Use FTC_Manager_LookupFace.
 	(Process_Event) <' '>: Provide header text for stroked text.
 	(main): Add Render_Stroke.
 
 2003-12-26  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftcommon.i (set_current_size): Don't allow values larger than
 	0xFFFF.
 	* src/ftview.c (main): Set `face'.
 	(Render_Waterfall): Don't set `face'.
 	use precomputed value instead.
 	(main): Don't use `face->' but `size->face->'.
 	Use `exit' in case of fatal error.
 	Don't test `face' but `size' for printing error messages.
 	Print proper error message for FT_Err_Invalid_PPem.
 
 2003-12-21  David Turner  <david@freetype.org>
 
 	* graph/graph.h (grPixelMode): Add `gr_pixel_mode_lcd2' and
 	`gr_pixel_mode_lcdv2' modes.
 	(grBlitGlyphToBitmap): Remove `is_bgr' argument.
 	Updated all callers.
 	* graph/grblit.c (blit_mono_to_pal8): Speed up loop.
 	(blit_lcd_to_24, blit_lcdv_to_24): Remove `is_bgr' argument.
 	(blit_lcd2_to_24, blit_lcdv2_to_24): New functions.
 	(compute_clips): Updated.
 	(grBlitGlyphToBitmap): Remove `is_bgr' argument.
 	Use new blitter functions for the two new modes.
 
 	* graph/win32/Jamfile: s/TOOLSET/JAM_TOOLSET/.
 
 	* src/gbench.c, src/gbench.h: New files.
 
 	* src/Jamfile: Handle `gbench'.
 
 	* src/ftbench.c, src/ftcommon.i, src/ftview.c: Updated to use new
 	FreeType cache implementation and new blitter modes.
 
 2003-11-10  Werner Lemberg  <wl@gnu.org>
 
 	Add display of bitmap fonts to ftstring.
 
 	* src/ftstring.c (layout_glyphs): Call FT_Vector_Transform for
 	scalable fonts only.
 	(render_string): Handle bitmap fonts.
 
 2003-11-07  Werner Lemberg  <wl@gnu.org>
 
 
 	* Version 2.1.7 released.
 	=========================
 
 
 2003-11-06  David Turner  <david@freetype.org>
 
 
 	* Version 2.1.6 released.
 	=========================
 
 
 2003-11-01  Werner Lemberg  <wl@gnu.org>
 
 	* src/testname.c: Include ft2build.h.
 
 2003-10-22  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftdump.c (usage): Fix typo.
 
 2003-10-17  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftmulti.c (main): Call `FT_Done_Face'.
 
 	* src/ftstring.c (main): Clean up glyph and face objects, then
 	finish FreeType library.
 
 2003-10-10  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftmulti.c (Help): Document all keys.
 	(main): Call FT_Done_FreeType.
 
 2003-09-02  David Turner  <david@freetype.org>
 
 
 	* Version 2.1.5 released.
 	=========================
 
 
 2003-06-30  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftdump.c (Print_Fixed): Print all elements of
 	face->available_sizes.
 
 2003-06-17  Werner Lemberg  <wl@gnu.org>
 
 	* src/*.c: s/ft_glyph_format_*/FT_GLYPH_FORMAT_*/.
 	s/ft_pixel_mode_*/FT_PIXEL_MODE_*/.
 	s/ft_glyph_bbox_*/FT_GLYPH_BBOX_*/.
 
 2003-06-16  YAMANO-UCHI Hidetoshi  <mer@din.or.jp>
 
 	* graph/x11/rules.mk (GRAPH_LINK): Add run-time search path on
 	Unix systems.
 
 2003-06-16  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftcheckfixedwidth.c: Renamed to...
 	* src/ftchkwd.c: This.
 	* src/testnames.c: Renamed to...
 	* src/testname.c: This.
 	* src/Jamfile, Makefile: Updated.
 
 2003-06-15  Werner Lemberg  <wl@gnu.org>
 
 	* *.mk: Updated and revised to latest changes in FreeType 2.
 
 2003-06-13  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftdump.c (Print_Type): Don't emit bbox, ascender, descender,
 	and height for non-scalable fonts.
 
 2003-06-08  Werner Lemberg  <wl@gnu.org>
 
 	* graph/x11/grx11.c (gr_x11_surface_init): Add proper cast in call
 	to grAlloc.
 
 	* src/ftbench.c (main): Add proper cast in call to malloc.
 	Use FT_ENCODING_NONE, not 0.
 
 2003-06-01  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftview.c (Render_Waterfall): Handle fixed-sized fonts better.
 
 2003-05-27  Martin Zinser  <zinser@decus.de>
 
 	* vms_make.com: Handle ftbench.
 
 2003-05-21  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftcommon.i (install_font_file): Initialize new elements of
 	reallocated `fonts' array with zero bytes.
 
 2003-05-20  Martin Zinser  <zinser@decus.de>
 
 	* descrip.mms: Removed.  Now created by...
 
 	* vms_make.com: New file.
 
 2003-05-19  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftcommon.i (install_font_file): Use calloc to allocate
 	`fonts'.
 	(done_freetype): Deallocate `fonts'.
 
 2003-04-28  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftcheckfixedwidth.c: Remove unused global variables; make
 	global variables local to `main' if possible.
 	Fixed compiler warnings (s/index/idx/).
 
 2003-04-25  Davor Buvinic  <davor@vtr.net>
 
 	* Makefile: Add rules to build ftcheckfixedwidth.
 
 2003-04-24  Anthony Fok  <anthony@thizlinux.com>
 
 	* src/ftcommon.i: Replace `ft_encoding_*' with `FT_ENCODING_*'.
 	(file_suffixes): Add `.otf'.
 	(install_font_file): Set font->num_indices depending on encoding.
 	* src/ftmulti.c, src/ftstring.c, src/fttimer.c, src/ftview.c:
 	Replace `ft_encoding_*' with `FT_ENCODING_*'.
 	* src/testnames.c: Replace `ft_render_mode_mono' with
 	`FT_RENDER_MODE_MONO'.
 
 2003-04-09  David Turner  <david@freetype.org>
 
 	* Jamfile: Set FT2_TOP.
 	* src/ftbench.c (main): Use `long' for `max_bytes'.
 	* src/ftcheckfixidwidth.c: New test program.
 	* src/ftstring.c: (prepare_text): Remove unused variable `codepoint'.
 	(apply_gamma): Fix initialization of `buffer'.
 	* src/ftview.c (Render_Waterfall): Print more characters.
 
 2003-04-08  David Turner  <david@freetype.org>
 
 
 	* Version 2.1.4 released.
 	=========================
 
 
 2002-12-02  Antoine Leca  <Antoine-Freetype@Leca-Marti.org>
 
 	* src/ftstring.c: Use `FT_ENCODING_*' everywhere instead of
 	deprecated lowercase variants.
 	(prepare_text): 'message' for the -m option is now expected to be
 	encoded with UTF-8.  This allows testing of Unicode chars, including
 	non-BMP characters.
 
 2002-12-01  Antoine Leca  <Antoine-Freetype@Leca-Marti.org>
 
 	* graph/win32/rules.mk: Adding link rules for Borland C++.
 
 2002-11-18  David Turner  <david@freetype.org>
 
 
 	* Version 2.1.3 released.
 	=========================
 
 
 2002-11-10  David Turner  <david@freetype.org>
 
 	* src/Jamfile (PROGRAMS): Add `ftcheckfixedwidth'.
 
 2002-09-25  David Turner  <david@freetype.org>
 
 	* graph/win32/grwin32.c: Removing compiler warnings.
 
 	* descrip.mms: Removing 'ftmemchk' and 'testnames' from the list
 	of programs to compile, these are now obsolete.
 
 2002-09-25  Anthony Fok  <anthony@thizlinux.com>
 
 	* src/ftbench.c: The program did perform out-of-bound memory writes
 	with certain fonts containing a buggy charmap.
 
 2002-09-18  Werner Lemberg  <wl@gnu.org>
 
 	Add LCD BGR support.
 
 	* graph/grblit.c (blit_lcd_to_24, blit_lcdv_to_24): Add parameter
 	`is_bgr' to assign color components in reversed order.
 	(grBlitGlyphToBitmap): Add parameter `is_bgr' passed on to
 	`blit_lcd_lcd*'.
 	Updated all callers.
 	Remove unused label.
 	* graph/graph.h, graph/grfont.c: Updated.
 
 	* src/ftcommon.i (set_current_image_type), src/ftview.c (Render_All,
 	Render_Text, Render_Waterfall, Process_Event): Handle LCD modes
 	3 and 4.
 	* src/ftstring.c, src/ftmulti.c: Updated.
 
 	* graph/x11/grx11.c (gr_x11_device_init, gr_x11_surface_init):
 	Remove unused variables.
 	(gr_x11_format_rgb555): Fix typos.
 
 2002-09-08  David Turner  <david@freetype.org>
 
 	Add support for sub-pixel rendering.
 
 	* graph/x11/grx11.c, graph/win32/grwin32.c: Completely rewritten to
 	support 24-bits RGB surfaces.  This is needed to test sub-pixel
 	rendering.
 
 	Note that other drivers haven't been touched yet.  The X11 driver
 	doesn't work with 8-bit displays for now, but a reduced mode will
 	probably be introduced in the near future.
 
 	* graph/graph.h (grPixelMode): Add `gr_pixel_mode_lcd' and
 	`gr_pixel_mode_lcdv'.
 	* graph/grblit.c (compute_clips): Use `gr_pixel_mode_lcd' and
 	`gr_pixel_mode_lcdv'.
 	(compose_pixel_full): New macro.
 	(compose_pixel): Use it.
 	(blit_lcd_to_24, blit_lcdv_to_24): New functions. for RGB-decimated
 	modes (BGR not yet implemented).
 	(gr_color_blitters): Updated.
 	(grBlitGlyphToBitmap): Support new pixel modes.
 
 	* src/Jamfile (PROGRAMS): Don't include fttimer, fttry, and
 	testnames.
 
 	* src/ftbench.c: Updated to latest changes in FreeType library.
 	* src/ftcommon.i (Init_Display): New default mode is
 	`gr_pixel_mode_rgb24'.
 	(set_current_image_type, get_glyph_bitmap): Add support for LCD
 	modes (horizontal and vertical).
 	* src/ftview.c (Render_Waterfall): Call `set_current_size'.
 	(Help): Document new `L' key for cycling through the pixel modes.
 	(Process_Event): Handle `L' key.
 
 2002-08-04  Vincent Caron  <v.caron@zerodeux.net>
 
 	* src/ftcommon.i (Text), src/ftmulti.c (Text): s/jumped/jumps/.
 	* src/ftview.c (Render_Waterfall): Remove unused variable.
 
 2002-07-03  David Turner  <david@freetype.org>
 
 	* src/ftview.c (Render_Waterfall): New function, adding a
 	"waterfall" rendering mode (accessible by cycling modes with the
 	space bar).
 	(Process_Event, main): Use it.
 
 2002-07-01  David Turner  <david@freetype.org>
 
 	* src/ftbench.c: Adding the "-p" option to pre-load font files in
 	memory.  This is a very useful thing to quantify the performance
 	improvements achieved by many of FreeType internal optimizations
 	regarding stream i/o.
 
 	* src/ftstring.c (reset_transform): Fix Werner's incorrect fix.
 
 2002-06-25  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftstring.c (reset_transform): Fix transformation matrix.
 
 2002-06-23  Vincent Caron  <v.caron@zerodeux.net>
 
 	Adding support for gamma-corrected display to ftstring (assigned to
 	`g', F9, and F10 keys).
 
 	* src/ftstring.c (use_gamma, gamma_value, gamma_ramp): New global
 	variables.
 	(init_gamma, apply_gamma, draw_gamma_ramp): New functions.
 	(render_string): Use apply_gamma.
 	(Help): Updated.
 	(Process_Event): Handle `g', F9, and F10 keys.
 	(main): Call init_gamma and draw_gamma_ramp.
 
 2002-06-21  David Turner  <david@freetype.org>
 
 
 	* Version 2.1.2 released.
 	=========================
 
 
 2002-06-14  Werner Lemberg  <wl@gnu.org>
 
 	* Makefile, graph/rules.mk: s/TOP/TOP_DIR/, s/TOP2/TOP_DIR_2/.
 
 2002-06-10  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftbench.c: s/index/idx/.
 	Fixed more gcc compiler warnings.
 
 2002-06-10  David Turner  <david@freetype.org>
 
 	* src/ftbench.c: Removing compiler warnings.
 
 	* src/ttdebug.c: Updating to latest internal changes.
 
 2002-06-09  David Turner  <david@freetype.org>
 
 
 	* Version 2.1.1 released.
 	=========================
 
 
 2002-06-07  David Turner  <david@freetype.org>
 
 	Adding Vincent Caron's benchmark program.
 
 	* src/ftbench.c: New file.
 	* Makefile, src/Jamfile: Updated.
 	Other minor fixes.
 
 	* src/ftview.c (Render_Text): Call get_glyph_index() conditionally.
 
 2002-05-20  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftcommon.i (get_glyph_bitmap): Use `sbit->num_grays'.
 	Handle `sbit->buffer == 0' correctly.
 
 2002-05-17  Michael Pfeiffer  <michael.pfeiffer@utanet.at>
 
 	* graph/beos/Jamfile: New file.
 
 2002-05-12  Werner Lemberg  <wl@gnu.org>
 
 	* README: Updated.
 
 2002-05-12  Michael Pfeiffer  <michael.pfeiffer@utanet.at>
 
 	* graph/Jamfile: Add support for BeOS.
 
 2002-04-28  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftview.c (Render_Text): Don't call `get_glyph_index'.  This
 	is done in `get_glyph_bitmap'.
 
 	* src/ftstring.c (encoding): New global variable, initialized to
 	`ft_encoding_unicode'.
 	(render_mode): Removed.
 	(make_tag): New utility function (copied from ftcommon.i).
 	(prepare_text): Call `FT_Select_Charmap'.
 	(Process_Event): Don't handle ` '.
 	(main): Add option -e to select encoding.
 	(usage): Document it.
 
 	* src/ftmulti.c (encoding): New global variable.
 	(make_tag): New utility function (copied from ftcommon.i).
 	(main): Add option -e to select encoding.
 	(usage): Document it.
 
 2002-04-28  Martin Zinser  <zinser@decus.de>
 
 	* descrip.mms: Add clean target.
 	Handle compiler options better.
 
 2002-04-17  David Turner  <david@freetype.org>
 
 
 	* Version 2.1.0 released.
 	=========================
 
 
 2002-04-01  Werner Lemberg  <wl@gnu.org>
 
 	* graph/x11/grx11.c: Use `c_class' instead of `class' if compiling
 	with C++.
 	* src/ftcommon.i (encoding): Use `FT_Encoding' type.  Update all
 	using code.
 	(done_glyph_bitmap): Use cast.
 	* src/ftview.c: Updated to changes in `ftcommon.i'.
 	(main): Use cast for `encoding'.
 
 2002-03-30  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftdump.c (Print_Type): Use `%ld' for some fields.
 	* src/testnames.c (main): Exit if no parameter.
 
 2002-03-21  David Turner  <david@freetype.org>
 
 	* graph/grblit.c, graph/win32/grwin32.c, src/common.c,
 	src/ftcommon.i, src/ftdump.c: Getting rid of compiler warnings.
 
 2002-03-08  David Turner  <david@freetype.org>
 
 
 	* Version 2.0.9 released.
 	=========================
 
 
 2002-03-06  David Turner  <david@freetype.org>
 
 	* src/ftdump.c: Added display of ascender/descender/text height.
 
 	* Jamfile: Support the FT2_TOP environment variable to indicate
 	where the FreeType 2 sources are located.  This is very useful for
 	switching between the STABLE and HEAD branches of the library.
 
 2002-03-05  David Turner  <david@freetype.org>
 
 	* src/ftdump.c: Added the display of a font's Postscript name,
 	EM size and global Bbox.  Now supports the debugging mode of
 	2.1.x.
 
 	* src/ftview.c: Minor change to support debugging mode of 2.1.x.
 
 2002-02-14  Detlef Würkner  <tetisoft@apg.lahn.de>
 
 	* src/fttimer.c (ConvertRaster): Handle embedded bitmaps properly.
 	* src/ftstring.c (use_sbits): Default value is no 0.
 	(layout_glyphs): Handle `use_sbits'.
 	(Process_Event): Make friendlier error messages.
 
 2002-02-09  David Turner  <david@freetype.org>
 
 
 	* Version 2.0.8 released.
 	=========================
 
 
 2002-02-02  David Turner  <david@freetype.org>
 
 
 	* Version 2.0.7 released.
 	=========================
 
 
 2002-01-25  Martin Zinser  <zinser@decus.de>
 
 	* src/common.h ([VMS]): Alias stuff specific to getopt.
 	* graph/grinit.c ([DEVICE_X11]): Handle VMS.
 	* descrip.mms: New file for compiling the demo programs with
 	OpenVMS.
 
 2002-01-07  David Turner  <david@freetype.org>
 
 
 	* Version 2.0.6 released.
 	=========================
 
 
 2001-12-31  Werner Lemberg  <wl@gnu.org>
 
 	* graph/x11/rules.mk: Fix typo (wilcard -> wildcard).
 
 2001-12-30  David Turner  <david@freetype.org>
 
 	* README: Updated to version 2.0.6.
 
 	* graph/x11/rules.mk: Updated X11 detection rules: "/usr/X11R6" and
 	"/usr/local/X11R6" are now probed as a fallback.  This allows the
 	test programs to work automatically on Debian Linux systems (which
 	only use "/usr/bin/X11" in the path).
 
 2001-12-21  David Turner  <david@freetype.org>
 
 	* src/ftcommon.i (get_glyph_bitmap): Added a missing error check.
 	Make the function return an error code if necessary.
 	* src/testnames.c (main): Fix typo.
 
 2001-12-15  Werner Lemberg  <wl@gnu.org>
 
 	* Makefile: Add `testnames' program.
 	* src/testnames.c (main): Remove unused variable.
 	First command line parameter is now used as the font to be tested
 	instead of a fixed string.
 
 2001-12-14  David Turner  <david@freetype.org>
 
 	* src/ftstring.c (layout_glyphs): Fix centering bug.
 
 2001-12-12  David Turner  <david@freetype.org>
 
 	* src/testnames.c: New test program.
 
 2001-12-08  David Turner  <david@freetype.org>
 
 	Use new charmap cache.
 
 	* src/ftcommon.i: Include FT_CACHE_CHARMAP_H.
 	(cmap_cache): New global variable.
 	(encoding): Change type to FT_UInt32.
 	(init_freetype): Initialize charmap cache.
 	(get_glyph_index): New function.
 	(get_glyph_bitmap): Use it.
 	Increase pixel dimensions to 48 for sbit cache.
 	Add ftc_image_format_outline flag if not a bitmap glyph.
 	* src/ftview.c: Use `get_glyph_index'.
 
 2001-12-06  David Turner  <david@freetype.org>
 
 	An update to use the new cache manager code.
 
 	* src/ftcommon.i: s/FTC_Image_Cache/FTC_ImageCache/.
 	s/FTC_SBit_Cache/FTC_SBitCache/.
 	s/FTC_Image_Desc/FTC_ImageDesc/.
 	s/image_type/type/.
 	(done_glyph_bitmap): New function.
 	(get_glyph_bitmap): Add new argument.
 	Use sbits cache only of pixel size <= 32.
 	Other fixes.
 	* src/ftview.c (Render_All, Render_Text): Updated to changes in
 	ftcommon.i.
 
 2001-12-05  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftcommon.i, src/ftview.c: s/manager/cache_manager/ to avoid
 	compiler warnings.
 
 2001-12-05  Taiji Yamada  <taiji@aihara.co.jp>
 
 	* src/graph/x11/grx11.c (done_surface): Free and reset color map.
 	(init_surface): Use private colormap if there are no more shared
 	colormap entries.
 
 2001-10-27  David Turner  <david@freetype.org>
 
 	* src/ftcommon.i (use_sbits_cache): Set to 1.
 
 2001-10-26  Leonard Rosenthol  <leonardr@lazerware.com>
 
 	* mac/codewarror/carbonprefix.h: New file to define building
 	the demos Carbonized.
 	* mac/codewarror/ftview.prj: Updated for CW7 and to build a
 	Carbonized version.
 	* mac/getargv.c: Updated to build Carbonized.
 	* mac/ftview_m.c: Updated to build Carbonized.
 
 2001-10-18  David Turner  <david@freetype.org>
 
 	* Jamrules: Define X11_LINKLIBS.
 	* README: Updated.
 	* graph/os2/Jamfile: Define GROS2_PATH and GRAPH_LINKLIBS.
 	* src/Jamfile (PROGRAMS): Add fttry.
 	Fix order of libraries.
 	* src/ftview.c (main): Update cache dump code.
 	* src/ftlint.c (main) [TEST_PSNAMES]: Add some debugging code.
 	* src/fttry.c (main) [DUMP_NAME]: Add some glyph name debugging code.
 
 2001-10-17  David Turner  <david@freetype.org>
 
 
 	* Version 2.0.5 released.
 	=========================
 
 
 2001-09-21  Eric Olson  <eric.olson@sympatico.ca>
 
 	* graph/os2/gros2pm.c: Remove global variable `window_created'.
 	(LOCK): Fix typo.
 	(refresh_rectangle): Use LOCK() and UNLOCK().
 	(init_surface): Don't use `window_created'.
 	Use LOCK() and UNLOCK().
 	(RunPMWindow): Use LOCK() and UNLOCK().
 	Fix typo.
 	Don't use `window_created'.
 	(Message_Process): Allow F9, F10, and others keys to pass through
 	the application.
 	Use LOCK() and UNLOCK().
 
 2001-09-10  Werner Lemberg  <wl@gnu.org>
 
 	* README: Slight update.
 
 2001-08-25  Werner Lemberg  <wl@gnu.org>
 
 	Added CMap support to ftview: The new flag `-e' accepts an encoding
 	tag as defined in freetype.h (e.g. `unic') to select a character
 	map.  Only fonts with a valid character map are selected.
 
 	* src/ftcommon.i: s/num_glyphs/num_indices/.
 	(encoding): New global variable.
 	(make_tag): New function.
 	(install_font_file): If a cmap tag has been specified, load
 	functions only which have a valid cmap.
 	(my_face_requester): Select cmap also if `encoding' is non-zero.
 	(get_glyph_bitmap): Map char index to glyph if `encoding' is
 	non-zero.
 
 	* src/ftview.c: s/first_glyph/first_index/.
 	(Help): Adjust help text.
 	(usage): Document -e switch.
 	(main): Implement -e switch.
 	Adjust `Header'.
 
 
 	* Version 2.0.4 released.
 	=========================
 
 
 2001-06-27  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftmemchk.c: s/memtest/ftmemchk/.
 
 2001-06-27  David Turner  <david@freetype.org>
 
 	* src/ftcommon.i, src/ftmemchk.c: Changes due to the modification of
 	the FT_CALLBACK_DEF macro definition.
 
 2001-06-24  David Turner  <david@freetype.org>
 
 	Renamed the test program "memtest" to "ftmemchk".
 
 	* src/memtest.c: Renamed to ...
 	* src/ftmemchk.c: This file.
 	* Makefile, src/Jamfile: Updated.
 
 
 	* Version 2.0.3 released.
 	=========================
 
 
 2001-05-28  David Turner  <david@freetype.org>
 
 	* Jamfile, src/Jamfile, graph/os2/Jamfile, graph/win32/Jamfile,
 	graph/x11/Jamfile: Updating Jamfiles to correctly link the graphics
 	programs on all platforms with Jam.
 
 	* src/ftstring.c: Removing debugging output.
 
 2001-04-25  David Turner  <david@freetype.org>
 
 	* graph/beos/grbeos.cpp, graph/beos/grbeos.h, graph/beos/rules.mk,
 	graph/grinit.c: added BeOS graphics driver to MiGS.
 
 2001-04-04  Werner Lemberg  <wl@gnu.org>
 
 	* graph/allegro/gralleg.c, graph/mac/grmac.c, graph/os2/gros2pm.c,
 	graph/x11/grx11.c: Don't include system-specific header but
 	`grobjs.h'.
 	* graph/x11/grx11.c: Some structural reorderings.
 	Include `grdevice.h'.
 	* graph/grinit.c: Use subdirectories for #include.
 	* graph/rules.mk, graph/*/rules.mk (DEVICE_INCLUDE): Removed.
 
 	* Jamrules, Jamfile, */Jamfile: Updated.  It now compiles with
 	X11 also (no checking for X header and lib locations yet).
 
 2001-04-04  David Turner  <david@freetype.org>
 
 	* Jamrules, Jamfile, graph/Jamfile, graph/x11/Jamfile,
 	graph/win32/Jamfile, graph/os2/Jamfile, src/Jamfile: Added Jamfiles
 	to build the FreeType 2 demos with Jam.  Be careful, they probably
 	don't work on Unix and OS/2 yet.
 
 2000-03-24  David Turner  <david.turner@freetype.org>
 
 
 	* Version 2.0.2 released.
 	=========================
 
 
 2001-03-23  David Turner  <david@freetype.org>
 
 	* Makefile, src/*.c: Changed to new header inclusion scheme.
 
 2001-03-13  Werner Lemberg  <wl@gnu.org>
 
 	* graph/x11/grx11.c: Increase MAX_PIXEL_MODES to 100.
 
 2001-03-06  Werner Lemberg  <wl@gnu.org>
 
 	* src/memtest.c (my_memory): Add cast to remove C++ compiler error.
 
 2001-02-22  David Turner  <david.turner@freetype.org>
 
 	* src/memtest.c: Fixed the debug memory allocator.  The constant
 	"my_memory" was replaced by a function that allocates a new "memory
 	allocator through "my_alloc()" and returns it.
 
 2001-02-06  James H. Cloos Jr.  <cloos@jhcloos.com>
 
 	* src/ftview.c (Render_Text): Fix rendering of test string.
 
 2001-01-31  Werner Lemberg  <wl@gnu.org>
 
 	* src/ftstring.c (Help): Added `void' type.
 
 2000-12-09  Werner Lemberg  <wl@gnu.org>
 
 	* Makefile: Added $(LDFLAGS) variable for `unix' link target.
 
 2000-12-01  David Turner  <david.turner@freetype.org>
 
 
 	* Version 2.0.1 released.
 	=========================
 
 
 2000-11-09  David Turner  <david@freetype.org>
 
 
 	* Version 2.0 released.
 	=======================
 
 
diff --git a/src/ftdiff.c b/src/ftdiff.c
index d540058..7e97dd9 100644
--- a/src/ftdiff.c
+++ b/src/ftdiff.c
@@ -1,1282 +1,1282 @@
 /****************************************************************************/
 /*                                                                          */
 /*  The FreeType project -- a free and portable quality TrueType renderer.  */
 /*                                                                          */
 /*  Copyright 2007, 2008, 2009, 2010 by                                     */
 /*  D. Turner, R.Wilhelm, and W. Lemberg                                    */
 /*                                                                          */
 /*                                                                          */
 /*  FTDiff - a simple viewer to compare different hinting modes.            */
 /*                                                                          */
 /*  Press F1 when running this program to have a list of key-bindings.      */
 /*                                                                          */
 /****************************************************************************/
 
 
 #include <ft2build.h>
 #include FT_FREETYPE_H
 #include FT_OUTLINE_H
 #include FT_CACHE_H
 #include FT_LCD_FILTER_H
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
 
 
   static void
   usage( void )
   {
     fprintf( stderr,
       "ftdiff: a simple program to proof several text hinting modes\n"
       "-----------------------------------------------------------\n"
       "\n"
       "Usage: ftdiff [options] fontfile [fontfile2 ...]\n"
       "\n"
       "  -r R         use resolution R dpi (default: 72 dpi)\n"
       "  -s S         set character size to S points (default: 16 pt)\n"
       "  -f TEXTFILE  change displayed text, using text in TEXTFILE\n"
       "\n" );
     exit( 1 );
   }
 
 
 
   static void
   panic( const char*  fmt,
          ... )
   {
     va_list  args;
 
 
     va_start( args, fmt );
     vfprintf( stderr, fmt, args );
     va_end( args );
     exit( 1 );
   }
 
 
   /** DISPLAY ABSTRACTION **/
 
   typedef enum  _DisplayMode
   {
     DISPLAY_MODE_MONO = 0,
     DISPLAY_MODE_GRAY,
     DISPLAY_MODE_LCD
 
   } DisplayMode;
 
   typedef void
   (*Display_drawFunc)( void*        disp,
                        DisplayMode  mode,
                        int          x,
                        int          y,
                        int          width,
                        int          height,
                        int          pitch,
                        void*        buffer );
 
   typedef void
   (*Display_textFunc)( void*        disp,
                        int          x,
                        int          y,
                        const char*  msg );
 
 
   typedef struct  _DisplayRec
   {
     void*             disp;
     Display_drawFunc  disp_draw;
     Display_textFunc  disp_text;
 
   } DisplayRec, *Display;
 
 
   static const unsigned char*  default_text = (unsigned char*)
     "Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Cras sit amet"
     " dui.  Nam sapien. Fusce vestibulum ornare metus. Maecenas ligula orci,"
     " consequat vitae, dictum nec, lacinia non, elit. Aliquam iaculis"
     " molestie neque. Maecenas suscipit felis ut pede convallis malesuada."
     " Aliquam erat volutpat. Nunc pulvinar condimentum nunc. Donec ac sem vel"
     " leo bibendum aliquam. Pellentesque habitant morbi tristique senectus et"
     " netus et malesuada fames ac turpis egestas.\n\n"
 
     "Sed commodo. Nulla ut libero sit amet justo varius blandit. Mauris vitae"
     " nulla eget lorem pretium ornare. Proin vulputate erat porta risus."
     " Vestibulum malesuada, odio at vehicula lobortis, nisi metus hendrerit"
     " est, vitae feugiat quam massa a ligula. Aenean in tellus. Praesent"
     " convallis. Nullam vel lacus.  Aliquam congue erat non urna mollis"
     " faucibus. Morbi vitae mauris faucibus quam condimentum ornare. Quisque"
     " sit amet augue. Morbi ullamcorper mattis enim. Aliquam erat volutpat."
     " Morbi nec felis non enim pulvinar lobortis.  Ut libero. Nullam id orci"
     " quis nisl dapibus rutrum. Suspendisse consequat vulputate leo. Aenean"
     " non orci non tellus iaculis vestibulum. Sed neque.\n\n";
 
 
   /***********************************************************************/
   /***********************************************************************/
   /*****                                                             *****/
   /*****               T E X T   R E N D E R I N G                   *****/
   /*****                                                             *****/
   /***********************************************************************/
   /***********************************************************************/
 
   typedef enum  _HintMode
   {
     HINT_MODE_UNHINTED,
     HINT_MODE_AUTOHINT,
     HINT_MODE_AUTOHINT_LIGHT,
     HINT_MODE_BYTECODE,
     HINT_MODE_MAX
 
   } HintMode;
 
   static const char* const  render_mode_names[HINT_MODE_MAX] =
   {
     "unhinted",
     "auto hinter",
     "light auto hinter",
     "native hinter"
   };
 
   /** RENDER STATE **/
 
   typedef struct  _ColumnStateRec
   {
     int            use_kerning;
     int            use_deltas;
     int            use_lcd_filter;
     int            use_global_advance_width;
     FT_LcdFilter   lcd_filter;
     HintMode       hint_mode;
     DisplayMode    disp_mode;
 
     int            use_custom_lcd_filter;
     unsigned char  filter_weights[5];
     int            fw_index;
 
   } ColumnStateRec, *ColumnState;
 
   typedef struct  _FontFaceRec
   {
     const char*  filepath;
     int          index;
 
   } FontFaceRec, *FontFace;
 
   typedef struct  _RenderStateRec
   {
     FT_Library            library;
     const unsigned char*  text;
     int                   resolution;
     float                 char_size;
     int                   need_rescale;
     int                   col;
     ColumnStateRec        columns[3];
     FontFace              faces;
     int                   num_faces;
     int                   face_index;
     const char*           filepath;
     const char*           filename;
     FT_Face               face;
     FT_Size               size;
     char**                files;
     char*                 message;
     DisplayRec            display;
     char                  filepath0[1024];
     char                  message0[1024];
 
   } RenderStateRec, *RenderState;
 
 
   static void
   render_state_init( RenderState  state,
                      Display      display )
   {
     memset( state, 0, sizeof ( *state ) );
 
     state->text         = default_text;
     state->filepath     = state->filepath0;
     state->filename     = "<none>";
     state->filepath0[0] = 0;
     state->resolution   = 72;
     state->char_size    = 16;
     state->display      = display[0];
 
     state->columns[0].use_kerning              = 1;
     state->columns[0].use_deltas               = 1;
     state->columns[0].use_lcd_filter           = 1;
     state->columns[0].use_global_advance_width = 1;
     state->columns[0].lcd_filter               = FT_LCD_FILTER_DEFAULT;
     state->columns[0].hint_mode                = HINT_MODE_BYTECODE;
     state->columns[0].use_custom_lcd_filter    = 0;
     state->columns[0].fw_index                 = 2;
     /* freetype default filter weights */
     memcpy( state->columns[0].filter_weights, "\x10\x40\x70\x40\x10", 5);
 
     state->columns[1]                       = state->columns[0];
     state->columns[1].hint_mode             = HINT_MODE_AUTOHINT;
     state->columns[1].use_custom_lcd_filter = 1;
 
     state->columns[2]           = state->columns[0];
     state->columns[2].hint_mode = HINT_MODE_UNHINTED;
 
     state->col = 1;
 
     if ( FT_Init_FreeType( &state->library ) != 0 )
       panic( "could not initialize FreeType library. Check your code\n" );
   }
 
 
   static void
   render_state_done( RenderState  state )
   {
     if ( state->filepath != state->filepath0 )
     {
       free( (char*)state->filepath );
       state->filepath = state->filepath0;
     }
     state->filepath0[0] = 0;
     state->filename     = 0;
 
     if ( state->face )
     {
       FT_Done_Face( state->face );
       state->face = NULL;
       state->size = NULL;
     }
 
     if ( state->library )
     {
       FT_Done_FreeType( state->library );
       state->library = NULL;
     }
   }
 
 
   static void
   render_state_set_resolution( RenderState  state,
                                int          resolution )
   {
     state->resolution   = resolution;
     state->need_rescale = 1;
   }
 
 
   static void
   render_state_set_size( RenderState  state,
                          float        char_size )
   {
     state->char_size    = char_size;
     state->need_rescale = 1;
   }
 
 
   static void
   _render_state_rescale( RenderState  state )
   {
     if ( state->need_rescale && state->size )
     {
       FT_Set_Char_Size( state->face, 0,
                         (FT_F26Dot6)( state->char_size * 64.0 ),
                         0, state->resolution );
       state->need_rescale = 0;
     }
   }
 
 
   static void
   render_state_set_files( RenderState  state,
                           char**       files )
   {
     FontFace  faces     = NULL;
     int       num_faces = 0;
     int       max_faces = 0;
 
 
     state->files = files;
     for ( ; files[0] != NULL; files++ )
     {
       FT_Face   face;
       FT_Error  error = FT_New_Face( state->library, files[0], -1, &face );
       int       count;
 
 
       if ( error )
       {
         fprintf( stderr,
                  "ftdiff: could not open font file `%s'\n", files[0] );
         continue;
       }
 
       for ( count = 0; count < (int)face->num_faces; count++ )
       {
         if ( num_faces >= max_faces )
         {
           max_faces += ( max_faces >> 1 ) + 8;
           faces = (FontFace)realloc( faces,
                                      max_faces * sizeof ( faces[0] ) );
           if ( faces == NULL )
             panic("ftdiff: not enough memory\n");
         }
 
         faces[num_faces].filepath = files[0];
         faces[num_faces].index    = count;
         num_faces++;
       }
 
       FT_Done_Face( face );
     }
 
     state->faces     = faces;
     state->num_faces = num_faces;
 
     if ( num_faces == 0 )
     {
       fprintf( stderr, "ftdiff: no input font files!\n" );
       usage();
     }
 
     state->face_index = 0;
   }
 
 
   static int
   render_state_set_file( RenderState  state,
                          int          idx )
   {
     const char*  filepath;
 
 
     if ( idx < 0 )
       idx = state->num_faces - 1;
     else if ( idx >= state->num_faces )
       idx = 0;
 
     if ( idx >= state->num_faces )
       return -2;
 
     state->face_index = idx;
     filepath = state->faces[idx].filepath;
 
     if ( state->face )
     {
       FT_Done_Face( state->face );
       state->face         = NULL;
       state->size         = NULL;
       state->need_rescale = 1;
     }
 
     if ( filepath != NULL && filepath[0] != 0 )
     {
       FT_Error  error;
 
 
       error = FT_New_Face( state->library, filepath,
                            state->faces[idx].index, &state->face );
       if ( error )
         return -1;
 
       {
         unsigned int  len = strlen( filepath );
         char*         p;
 
 
         if ( len + 1 > sizeof ( state->filepath0 ) )
         {
           state->filepath = (const char*)malloc( len + 1 );
           if ( state->filepath == NULL )
           {
             state->filepath = state->filepath0;
             return -1;
           }
         }
         memcpy( (char*)state->filepath, filepath, len + 1 );
         p = strrchr( state->filepath, '\\' );
         if ( p == NULL )
           p = strrchr( state->filepath, '/' );
 
         state->filename = p ? p + 1 : state->filepath;
       }
 
       state->size         = state->face->size;
       state->need_rescale = 1;
     }
 
     return 0;
   }
 
 
   /** RENDERING **/
 
   static void
   render_state_draw( RenderState           state,
                      const unsigned char*  text,
                      int                   idx,
                      int                   x,
                      int                   y,
                      int                   width,
                      int                   height )
   {
     ColumnState           column         = &state->columns[idx];
     const unsigned char*  p              = text;
     long                  load_flags     = FT_LOAD_DEFAULT;
     FT_Face               face           = state->face;
     int                   left           = x;
     int                   right          = x + width;
     int                   bottom         = y + height;
     int                   line_height;
     FT_UInt               prev_glyph     = 0;
     FT_Pos                prev_rsb_delta = 0;
     FT_Pos                x_origin       = x << 6;
     HintMode              rmode          = column->hint_mode;
 
 
     if ( !face )
       return;
 
     _render_state_rescale( state );
 
     if ( column->use_lcd_filter )
       FT_Library_SetLcdFilter( face->glyph->library, column->lcd_filter );
 
     if ( column->use_custom_lcd_filter )
       FT_Library_SetLcdFilterWeights( face->glyph->library,
                                       column->filter_weights );
 
     y          += state->size->metrics.ascender / 64;
     line_height = state->size->metrics.height / 64;
 
     if ( rmode == HINT_MODE_AUTOHINT )
       load_flags = FT_LOAD_FORCE_AUTOHINT;
 
     if ( rmode == HINT_MODE_AUTOHINT_LIGHT )
       load_flags = FT_LOAD_TARGET_LIGHT;
 
     if ( rmode == HINT_MODE_UNHINTED )
       load_flags |= FT_LOAD_NO_HINTING | FT_LOAD_NO_BITMAP;
 
     if ( !column->use_global_advance_width )
       load_flags |= FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH;
 
     for ( ; *p; p++ )
     {
       FT_UInt       gindex;
       FT_Error      error;
       FT_GlyphSlot  slot = face->glyph;
       FT_Bitmap*    map  = &slot->bitmap;
       int           xmax;
 
 
       /* handle newlines */
       if ( *p == 0x0A )
       {
         if ( p[1] == 0x0D )
           p++;
         x_origin = left << 6;
         y       += line_height;
         prev_rsb_delta = 0;
         if ( y >= bottom )
           break;
         continue;
       }
       else if ( *p == 0x0D )
       {
         if ( p[1] == 0x0A )
           p++;
         x_origin = left << 6;
         y       += line_height;
         prev_rsb_delta = 0;
         if ( y >= bottom )
           break;
         continue;
       }
 
       gindex = FT_Get_Char_Index( state->face, p[0] );
       error  = FT_Load_Glyph( face, gindex, load_flags );
 
       if ( error )
         continue;
 
       if ( column->use_kerning && gindex != 0 && prev_glyph != 0 )
       {
         FT_Vector  vec;
         FT_Int     kerning_mode = FT_KERNING_DEFAULT;
 
 
         if ( rmode == HINT_MODE_UNHINTED )
           kerning_mode = FT_KERNING_UNFITTED;
 
         FT_Get_Kerning( face, prev_glyph, gindex, kerning_mode, &vec );
 
         x_origin += vec.x;
       }
 
       if ( column->use_deltas )
       {
         if ( prev_rsb_delta - face->glyph->lsb_delta >= 32 )
           x_origin -= 64;
         else if ( prev_rsb_delta - face->glyph->lsb_delta < -32 )
           x_origin += 64;
       }
       prev_rsb_delta = face->glyph->rsb_delta;
 
       /* implement sub-pixel positining for un-hinted mode */
       if ( rmode == HINT_MODE_UNHINTED           &&
            slot->format == FT_GLYPH_FORMAT_OUTLINE )
       {
         FT_Pos  shift = x_origin & 63;
 
 
         FT_Outline_Translate( &slot->outline, shift, 0 );
       }
 
       if ( slot->format == FT_GLYPH_FORMAT_OUTLINE )
       {
         FT_BBox  cbox;
 
 
         FT_Outline_Get_CBox( &slot->outline, &cbox );
         xmax = ( x_origin + cbox.xMax + 63 ) >> 6;
 
         FT_Render_Glyph( slot,
                          column->use_lcd_filter ? FT_RENDER_MODE_LCD
                                                 : FT_RENDER_MODE_NORMAL );
       }
       else
         xmax = ( x_origin >> 6 ) + slot->bitmap_left + slot->bitmap.width;
 
       if ( xmax >= right )
       {
         x  = left;
         y += line_height;
         if ( y >= bottom )
           break;
 
         x_origin       = x << 6;
         prev_rsb_delta = 0;
       }
 
       {
         DisplayMode  mode = DISPLAY_MODE_MONO;
 
 
         if ( slot->bitmap.pixel_mode == FT_PIXEL_MODE_GRAY )
           mode = DISPLAY_MODE_GRAY;
         else if ( slot->bitmap.pixel_mode == FT_PIXEL_MODE_LCD )
           mode = DISPLAY_MODE_LCD;
 
         state->display.disp_draw( state->display.disp, mode,
                                   ( x_origin >> 6 ) + slot->bitmap_left,
                                   y - slot->bitmap_top,
                                   map->width, map->rows,
                                   map->pitch, map->buffer );
       }
       if ( rmode == HINT_MODE_UNHINTED )
         x_origin += slot->linearHoriAdvance >> 10;
       else
         x_origin += slot->advance.x;
 
       prev_glyph = gindex;
     }
 
     /* display footer on this column */
     {
       void*        disp = state->display.disp;
       const char  *msg;
       char         temp[64];
 
 
       msg = render_mode_names[column->hint_mode];
       state->display.disp_text( disp, left, bottom + 5, msg );
 
       if ( !column->use_lcd_filter )
         msg = "gray rendering";
       else if ( column->use_custom_lcd_filter )
       {
         int             fwi = column->fw_index;
         unsigned char  *fw  = column->filter_weights;
 
 
         msg = "";
 
         sprintf( temp,
                  "%s0x%02X%s0x%02X%s0x%02X%s0x%02X%s0x%02X%s",
                  fwi == 0 ? "[" : " ",
                    fw[0],
                  fwi == 0 ? "]" : ( fwi == 1 ? "[" : " " ),
                    fw[1],
                  fwi == 1 ? "]" : ( fwi == 2 ? "[" : " " ),
                    fw[2],
                  fwi == 2 ? "]" : ( fwi == 3 ? "[" : " " ),
                    fw[3],
                  fwi == 3 ? "]" : ( fwi == 4 ? "[" : " " ),
                    fw[4],
                  fwi == 4 ? "]" : " " );
         state->display.disp_text( disp, left, bottom + 15, temp );
       }
       else switch ( column->lcd_filter )
       {
       case FT_LCD_FILTER_NONE:
         msg = "LCD without filtering";
         break;
       case FT_LCD_FILTER_DEFAULT:
         msg = "default LCD filter";
         break;
       case FT_LCD_FILTER_LIGHT:
         msg = "light LCD filter";
         break;
       default:
         msg = "legacy LCD filter";
       }
       state->display.disp_text( disp, left, bottom + 15, msg );
 
       sprintf(temp, "%s %s %s",
               column->use_kerning ? "+kern"
                                   : "-kern",
               column->use_deltas ? "+delta"
                                  : "-delta",
               column->use_global_advance_width ? "+advance"
                                                : "-advance" );
       state->display.disp_text( disp, left, bottom + 25, temp );
 
       if ( state->col == idx )
         state->display.disp_text( disp, left, bottom + 35, "**************" );
     }
   }
 
 
   /***********************************************************************/
   /***********************************************************************/
   /*****                                                             *****/
   /*****                D I S P L A Y                                *****/
   /*****                                                             *****/
   /***********************************************************************/
   /***********************************************************************/
 
 #include "graph.h"
 #include "grobjs.h"
 #include "grfont.h"
 
   typedef struct  _ADisplayRec
   {
     grSurface*  surface;
     grBitmap*   bitmap;
     grColor     fore_color;
     grColor     back_color;
     double      gamma;
 
   } ADisplayRec, *ADisplay;
 
 #define  DIM_X   640
 #define  DIM_Y   480
 
 
   static int
   adisplay_init( ADisplay     display,
                  grPixelMode  mode )
   {
     grSurface*  surface;
     grBitmap    bit;
 
 
     if ( mode != gr_pixel_mode_gray  &&
          mode != gr_pixel_mode_rgb24 )
       return -1;
 
     grInitDevices();
 
     bit.mode  = mode;
     bit.width = DIM_X;
     bit.rows  = DIM_Y;
     bit.grays = 256;
 
     surface = grNewSurface( 0, &bit );
 
     if ( !surface )
       return -1;
 
     display->surface = surface;
     display->bitmap  = &surface->bitmap;
     display->gamma   = 1.0;
 
     grSetGlyphGamma( display->gamma );
 
     memset( &display->fore_color, 0, sizeof( grColor ) );
     memset( &display->back_color, 0xff, sizeof( grColor ) );
 
     return 0;
   }
 
 
   static void
   adisplay_clear( ADisplay  display )
   {
     grBitmap*  bit   = display->bitmap;
     int        pitch = bit->pitch;
 
 
     if ( pitch < 0 )
       pitch = -pitch;
 
     if ( bit->mode == gr_pixel_mode_gray )
       memset( bit->buffer, display->back_color.value, pitch * bit->rows );
     else
     {
       unsigned char*  p = bit->buffer;
       int             i, j;
 
 
       for ( i = 0; i < bit->rows; i++ )
       {
         for ( j = 0; j < bit->width; j++ )
           memcpy( p + 3 * j, display->back_color.chroma, 3 );
 
         p += pitch;
       }
     }
   }
 
 
   static void
   adisplay_done( ADisplay  display )
   {
     grDoneBitmap( display->bitmap );
     grDoneSurface( display->surface );
 
     display->bitmap  = NULL;
     display->surface = NULL;
 
     grDoneDevices();
   }
 
 
   static void
   adisplay_draw_glyph( void*        _display,
                        DisplayMode  mode,
                        int          x,
                        int          y,
                        int          width,
                        int          height,
                        int          pitch,
                        void*        buffer )
   {
     ADisplay  display = (ADisplay)_display;
     grBitmap  glyph;
 
 
     glyph.width  = width;
     glyph.rows   = height;
     glyph.pitch  = pitch;
     glyph.buffer = (unsigned char*)buffer;
     glyph.grays  = 256;
     glyph.mode   = gr_pixel_mode_mono;
 
     if ( mode == DISPLAY_MODE_GRAY )
       glyph.mode = gr_pixel_mode_gray;
     else if ( mode == DISPLAY_MODE_LCD )
       glyph.mode = gr_pixel_mode_lcd;
 
     grBlitGlyphToBitmap( display->bitmap, &glyph,
                          x, y, display->fore_color );
   }
 
 
   static void
   adisplay_draw_text( void*        _display,
                       int          x,
                       int          y,
                       const char*  msg )
   {
     ADisplay  adisplay = (ADisplay)_display;
 
 
     grWriteCellString( adisplay->bitmap, x, y, msg,
                        adisplay->fore_color );
   }
 
 
   static void
   adisplay_change_gamma( ADisplay  display,
                          double    delta )
   {
     display->gamma += delta;
     if ( display->gamma > 3.0 )
       display->gamma = 3.0;
     else if ( display->gamma < 0.0 )
       display->gamma = 0.0;
 
     grSetGlyphGamma( display->gamma );
   }
 
 
   static void
   event_help( RenderState  state )
   {
     ADisplay  display = (ADisplay)state->display.disp;
     grEvent   dummy_event;
 
 
     adisplay_clear( display );
     grGotoxy( 0, 0 );
     grSetMargin( 2, 1 );
     grGotobitmap( display->bitmap );
 
     grWriteln( "Text Viewer - Simple text/font proofer for the FreeType project" );
     grLn();
     grWriteln( "This program is used to display text using two distinct algorithms." );
     grWriteln( "On the left, text is rendered by the TrueType bytecode interpreter." );
     grWriteln( "In the middle, text is rendered through the FreeType auto-hinter." );
     grWriteln( "On the right, text is rendered unhinted." );
     grLn();
     grWriteln( "Use the following keys:" );
     grLn();
     grWriteln( "  F1, ?       display this help screen" );
     grLn();
     grWriteln( "  n, p        select previous/next font" );
     grLn();
     grWriteln( "  1, 2, 3     select left, middle, or right column" );
     grWriteln( "  a           toggle `ignore global advance width flag'" );
     grWriteln( "  d           toggle lsb/rsb deltas" );
     grWriteln( "  h           toggle hinting mode" );
     grWriteln( "  k           toggle kerning" );
     grWriteln( "  g, v        adjust gamma value" );
     grWriteln( "  r           toggle rendering mode" );
     grLn();
     grWriteln( "  l           change LCD filter type" );
     grWriteln( "  [, ]        select custom LCD filter weight" );
     grWriteln( "  -, +(=)     adjust selected custom LCD filter weight");
     grLn();
     grWriteln( "  Up, Down    adjust pointsize by 0.5 unit" );
     grWriteln( "  PgUp, PgDn  adjust pointsize by 5 units" );
     grLn();
     grWriteln( "press any key to exit this help screen" );
 
     grRefreshSurface( display->surface );
     grListenSurface( display->surface, gr_event_key, &dummy_event );
   }
 
 
   static void
   event_change_gamma( RenderState  state,
                       double       delta )
   {
     ADisplay  display = (ADisplay)state->display.disp;
 
 
     adisplay_change_gamma( display, delta );
     if ( display->gamma == 0.0 )
       sprintf( state->message0, "gamma set to sRGB" );
     else
       sprintf( state->message0, "gamma set to %.1f", display->gamma );
 
     state->message = state->message0;
   }
 
 
   static void
   event_change_size( RenderState  state,
                      double       delta )
   {
     double  char_size = state->char_size;
 
 
     char_size += delta;
     if ( char_size < 6.0 )
       char_size = 6.0;
     else if ( char_size > 300.0 )
       char_size = 300.0;
 
     render_state_set_size( state, char_size );
   }
 
 
   static int
   process_event( RenderState  state,
                  grEvent*     event )
   {
     int          ret    = 0;
     ColumnState  column = &state->columns[state->col];
 
 
     switch ( event->key )
     {
     case grKeyEsc:
     case grKEY( 'q' ):
       ret = 1;
       break;
 
     case grKeyF1:
     case grKEY( '?' ):
       event_help( state );
       break;
 
     case grKeyLeft:
       if ( --state->col < 0 )
         state->col = 2;
       state->message = state->message0;
       sprintf( state->message0, "column %d selected", state->col + 1 );
       break;
 
     case grKeyRight:
       if ( ++state->col > 2 )
         state->col = 0;
       state->message = state->message0;
       sprintf( state->message0, "column %d selected", state->col + 1 );
       break;
 
     case grKeyUp:
       event_change_size( state, +0.5 );
       break;
 
     case grKeyDown:
       event_change_size( state, -0.5 );
       break;
 
     case grKeyPageUp:
       event_change_size( state, +5. );
       break;
 
     case grKeyPageDown:
       event_change_size( state, -5. );
       break;
 
     case grKEY( '1' ):
       state->col     = 0;
       state->message = (char *)"column 1 selected";
       break;
 
     case grKEY( '2' ):
       state->col     = 1;
       state->message = (char *)"column 2 selected";
       break;
 
     case grKEY( '3' ):
       state->col     = 2;
       state->message = (char *)"column 3 selected";
       break;
 
     case grKEY( 'a' ):
       column->use_global_advance_width
                      = !column->use_global_advance_width;
       state->message = column->use_global_advance_width
                          ? (char *)"using global advance width"
                          : (char *)"ignoring global advance width";
       break;
 
     case grKEY( 'd' ):
       column->use_deltas = !column->use_deltas;
       state->message     = column->use_deltas
                              ? (char *)"using rsb/lsb deltas"
                              : (char *)"ignoring rsb/lsb deltas";
       break;
 
     case grKEY( 'g' ):
       event_change_gamma( state, +0.1 );
       break;
 
     case grKEY( 'h' ):
       column->hint_mode =
         (HintMode)( ( column->hint_mode + 1 ) % HINT_MODE_MAX );
       state->message = state->message0;
       sprintf( state->message0, "column %d is %s",
                state->col + 1, render_mode_names[column->hint_mode] );
       break;
 
     case grKEY( 'k' ):
       column->use_kerning = !column->use_kerning;
       state->message      = column->use_kerning
                               ? (char *)"using kerning"
                               : (char *)"ignoring kerning";
       break;
 
     case grKEY( 'l' ):
       switch ( column->lcd_filter )
       {
       case FT_LCD_FILTER_NONE:
         column->lcd_filter = FT_LCD_FILTER_DEFAULT;
         state->message     = (char *)"using default LCD filter";
         break;
 
       case FT_LCD_FILTER_DEFAULT:
         if ( !column->use_custom_lcd_filter )
         {
           column->use_custom_lcd_filter = 1;
           state->message                = (char*)"using custom LCD filter";
         }
         else
         {
           column->use_custom_lcd_filter = 0;
           column->lcd_filter            = FT_LCD_FILTER_LIGHT;
           state->message                = (char *)"using light LCD filter";
         }
         break;
 
       case FT_LCD_FILTER_LIGHT:
         column->lcd_filter = FT_LCD_FILTER_LEGACY;
         state->message     = (char *)"using legacy LCD filter";
         break;
 
       case FT_LCD_FILTER_LEGACY:
         column->lcd_filter = FT_LCD_FILTER_NONE;
         state->message     = (char *)"using no LCD filter";
         break;
 
       default:  /* to satisfy picky compilers */
         break;
       }
       break;
 
     case grKEY( 'n' ):
       render_state_set_file( state, state->face_index + 1 );
       break;
 
     case grKEY( 'p' ):
       render_state_set_file( state, state->face_index - 1 );
       break;
 
     case grKEY( 'r' ):
       column->use_lcd_filter = !column->use_lcd_filter;
       state->message         = state->message0;
       sprintf( state->message0, "column %d is using %s",
                state->col + 1, column->use_lcd_filter ? "LCD filtering"
                                                       : "gray rendering" );
       break;
 
     case grKEY( 'v' ):
       event_change_gamma( state, -0.1 );
       break;
 
     case grKEY( '[' ):
       if ( !column->use_custom_lcd_filter )
         break;
 
       column->fw_index--;
       if ( column->fw_index < 0 )
         column->fw_index = 4;
       break;
 
     case grKEY( ']' ):
       if ( !column->use_custom_lcd_filter )
         break;
 
       column->fw_index++;
       if ( column->fw_index > 4 )
         column->fw_index = 0;
       break;
 
     case grKEY( '-' ):
       if ( !column->use_custom_lcd_filter )
         break;
 
       column->filter_weights[column->fw_index]--;
       break;
 
     case grKEY( '+' ):
     case grKEY( '=' ):
       if ( !column->use_custom_lcd_filter )
         break;
 
       column->filter_weights[column->fw_index]++;
       break;
 
     default:
       break;
     }
 
     return ret;
   }
 
 
   static char*
   get_option_arg( char*   option,
                   char** *pargv,
                   char**  argend )
   {
     if ( option[2] == 0 )
     {
       char**  argv = *pargv;
 
 
       if ( ++argv >= argend )
         usage();
       option = argv[0];
       *pargv = argv;
     }
     else
       option += 2;
 
     return option;
   }
 
 
   static void
   write_message( RenderState  state )
   {
     ADisplay  adisplay = (ADisplay)state->display.disp;
 
 
     if ( state->message == NULL )
     {
       FontFace  face = &state->faces[state->face_index];
       int       idx, total;
 
 
       idx   = face->index;
       total = 1;
       while ( total + state->face_index < state->num_faces &&
               face[total].filepath == face[0].filepath     )
         total++;
 
       total += idx;
 
       state->message = state->message0;
       if ( total > 1 )
-        sprintf( state->message0, "%s %d/%d @ %5.1fpt",
+        sprintf( state->message0, "%.100s %d/%d @ %5.1fpt",
                  state->filename, idx + 1, total,
                  state->char_size );
       else
-        sprintf( state->message0, "%s @ %5.1fpt",
+        sprintf( state->message0, "%.100s @ %5.1fpt",
                  state->filename,
                  state->char_size );
     }
 
     grWriteCellString( adisplay->bitmap, 0, DIM_Y - 10, state->message,
                        adisplay->fore_color );
 
     state->message = NULL;
   }
 
 
   int
   main( int  argc,
         char**  argv )
   {
     char**          argend = argv + argc;
     ADisplayRec     adisplay[1];
     RenderStateRec  state[1];
     DisplayRec      display[1];
     int             resolution = -1;
     double          size       = -1;
     const char*     textfile   = NULL;
     unsigned char*  text       = (unsigned char*)default_text;
 
 
     /* Read Options */
     ++argv;
     while ( argv < argend && argv[0][0] == '-' )
     {
       char*  arg = argv[0];
 
 
       switch (arg[1])
       {
       case 'r':
         arg = get_option_arg( arg, &argv, argend );
         resolution = atoi( arg );
         break;
 
       case 's':
         arg = get_option_arg( arg, &argv, argend );
         size = atof( arg );
         break;
 
       case 'f':
         arg      = get_option_arg( arg, &argv, argend );
         textfile = arg;
         break;
 
       default:
         usage();
       }
       argv++;
     }
 
     if ( argv >= argend )
       usage();
 
     /* Read Text File, if any */
     if ( textfile != NULL )
     {
       FILE*  tfile = fopen( textfile, "r" );
 
 
       if ( tfile == NULL )
         fprintf( stderr, "could not read textfile '%s'\n", textfile );
       else
       {
         long   tsize;
 
 
         fseek( tfile, 0, SEEK_END );
         tsize = ftell( tfile );
 
         fseek( tfile, 0, SEEK_SET );
         text = (unsigned char*)malloc( tsize + 1 );
 
         if ( text != NULL )
         {
           fread( text, tsize, 1, tfile );
           text[tsize] = 0;
         }
         else
         {
           fprintf( stderr, "not enough memory to read '%s'\n", textfile );
           text = (unsigned char *)default_text;
         }
 
         fclose( tfile );
       }
     }
 
     /* Initialize display */
     if ( adisplay_init( adisplay, gr_pixel_mode_rgb24 ) < 0 )
     {
       fprintf( stderr, "could not initialize display!  Aborting.\n" );
       exit( 1 );
     }
     display->disp      = adisplay;
     display->disp_draw = adisplay_draw_glyph;
     display->disp_text = adisplay_draw_text;
 
     render_state_init( state, display );
 
     if ( resolution > 0 )
       render_state_set_resolution( state, resolution );
 
     if (size > 0.0)
       render_state_set_size( state, size );
 
     render_state_set_files( state, argv );
     render_state_set_file( state, 0 );
 
     grSetTitle( adisplay->surface, "FreeType Text Proofer, press F1 for help" );
 
     for (;;)
     {
       grEvent  event;
 
       adisplay_clear( adisplay );
 
       render_state_draw( state, text, 0,
                          10,                10, DIM_X / 3 - 15, DIM_Y - 70 );
       render_state_draw( state, text, 1,
                          DIM_X     / 3 + 5, 10, DIM_X / 3 - 15, DIM_Y - 70 );
       render_state_draw( state, text, 2,
                          DIM_X * 2 / 3 + 5, 10, DIM_X / 3 - 15, DIM_Y - 70 );
 
       write_message( state );
       grRefreshSurface( adisplay->surface );
       grListenSurface( adisplay->surface, 0, &event );
       if ( process_event( state, &event ) )
         break;
     }
 
     render_state_done( state );
     adisplay_done( adisplay );
     exit( 0 );  /* for safety reasons */
 
     return 0;   /* never reached */
   }
 
 
 /* End */
diff --git a/src/ftgrid.c b/src/ftgrid.c
index ff7122f..75cd6ce 100644
--- a/src/ftgrid.c
+++ b/src/ftgrid.c
@@ -1,45 +1,45 @@
 /****************************************************************************/
 /*                                                                          */
 /*  The FreeType project -- a free and portable quality TrueType renderer.  */
 /*                                                                          */
-/*  Copyright 1996-2000, 2003, 2004, 2005, 2006, 2007, 2009 by              */
+/*  Copyright 1996-2000, 2003, 2004, 2005, 2006, 2007, 2009, 2010 by        */
 /*  D. Turner, R.Wilhelm, and W. Lemberg                                    */
 /*                                                                          */
 /*                                                                          */
 /*  FTGrid - a simple viewer to debug the auto-hinter                       */
 /*                                                                          */
 /*  Press F1 when running this program to have a list of key-bindings       */
 /*                                                                          */
 /****************************************************************************/
 
 
 #include "ftcommon.h"
 #include "common.h"
 #include <math.h>
 
   /* the following header shouldn't be used in normal programs */
 #include FT_INTERNAL_DEBUG_H
 #include FT_STROKER_H
 #include FT_SYNTHESIS_H
 
 #define MAXPTSIZE      500                 /* dtp */
 #define HEADER_HEIGHT  8
 
 #ifdef CEIL
 #undef CEIL
 #endif
 #define CEIL( x )   ( ( (x) + 63 ) >> 6 )
 
 #define X_TOO_LONG( x, size, display) \
           ( ( x ) + ( ( size )->metrics.max_advance >> 6 ) > ( display )->bitmap->width )
 #define Y_TOO_LONG( y, size, display) \
           ( ( y ) >= ( display )->bitmap->rows )
 
 #ifdef _WIN32
 #define snprintf  _snprintf
 #endif
 
 
 /* these variables, structures and declarations  are for  */
 /* communication with the debugger in the autofit module; */
 /* normal programs don't need this                        */
@@ -378,608 +378,608 @@ static void
 grid_status_draw_outline( GridStatus       st,
                           FTDemo_Handle*   handle,
                           FTDemo_Display*  display )
 {
   static FT_Stroker  stroker;
   FT_Size            size;
   FT_GlyphSlot       slot;
   double             scale = 64.0 * st->scale;
   int                ox    = (int)st->x_origin;
   int                oy    = (int)st->y_origin;
 
 
   if ( stroker == NULL )
   {
     FT_Stroker_New( handle->library, &stroker );
 
     FT_Stroker_Set( stroker, 32, FT_STROKER_LINECAP_BUTT,
                     FT_STROKER_LINEJOIN_ROUND, 0x20000 );
   }
 
   FTDemo_Get_Size( handle, &size );
 
   _af_debug_disable_horz_hints = !st->do_horz_hints;
   _af_debug_disable_vert_hints = !st->do_vert_hints;
 
   if ( FT_Load_Glyph( size->face, st->Num,
                       handle->load_flags | FT_LOAD_NO_BITMAP ) )
     return;
 
   slot = size->face->glyph;
   if ( slot->format == FT_GLYPH_FORMAT_OUTLINE )
   {
     FT_Glyph     glyph;
     FT_Outline*  gimage = &slot->outline;
     int          nn;
 
 
     /* scale the outline */
     for (nn = 0; nn < gimage->n_points; nn++)
     {
       FT_Vector*  vec = &gimage->points[nn];
 
 
       vec->x = (FT_F26Dot6)( vec->x * scale );
       vec->y = (FT_F26Dot6)( vec->y * scale );
     }
 
     /* stroke then draw it */
     if ( st->do_outline )
     {
       FT_Get_Glyph( slot, &glyph );
       FT_Glyph_Stroke( &glyph, stroker, 1 );
 
       FTDemo_Draw_Glyph_Color( handle, display, glyph, &ox, &oy,
                                st->outline_color );
       FT_Done_Glyph( glyph );
     }
 
     /* now draw the points */
     if ( st->do_dots )
     {
       for (nn = 0; nn < gimage->n_points; nn++)
         circle_draw( (FT_F26Dot6)( st->x_origin * 64 + gimage->points[nn].x ),
                      (FT_F26Dot6)( st->y_origin * 64 - gimage->points[nn].y ),
                      128,
                      handle,
                      display,
                      ( gimage->tags[nn] & FT_CURVE_TAG_ON )
                        ? st->on_color
                        : st->conic_color );
     }
   }
 }
 
 
   static FTDemo_Display*  display;
   static FTDemo_Handle*   handle;
 
 #if 0
   static const unsigned char*  Text = (unsigned char*)
     "The quick brown fox jumps over the lazy dog 0123456789 "
     "\342\352\356\373\364\344\353\357\366\374\377\340\371\351\350\347 "
     "&#~\"\'(-`_^@)=+\260 ABCDEFGHIJKLMNOPQRSTUVWXYZ "
     "$\243^\250*\265\371%!\247:/;.,?<>";
 #endif
 
 
   static void
   Fatal( const char* message )
   {
     FTDemo_Display_Done( display );
     FTDemo_Done( handle );
     PanicZ( message );
   }
 
 
 
   /*************************************************************************/
   /*************************************************************************/
   /*****                                                               *****/
   /*****                REST OF THE APPLICATION/PROGRAM                *****/
   /*****                                                               *****/
   /*************************************************************************/
   /*************************************************************************/
 
   static void
   event_help( void )
   {
     grEvent  dummy_event;
 
 
     FTDemo_Display_Clear( display );
     grGotoxy( 0, 0 );
     grSetMargin( 2, 1 );
     grGotobitmap( display->bitmap );
 
     grWriteln( "FreeType Glyph Viewer - part of the FreeType test suite" );
     grLn();
     grWriteln( "This program is used to display all glyphs from one or" );
     grWriteln( "several font files, with the FreeType library." );
     grLn();
     grWriteln( "Use the following keys:" );
     grLn();
     grWriteln( "  F1 or ?    : display this help screen" );
     grLn();
     grWriteln( "  a          : toggle anti-aliasing" );
     grWriteln( "  left/right : decrement/increment glyph index" );
     grWriteln( "  up/down    : change character size" );
     grLn();
     grWriteln( "  F7         : decrement index by 10" );
     grWriteln( "  F8         : increment index by 10" );
     grWriteln( "  F9         : decrement index by 100" );
     grWriteln( "  F10        : increment index by 100" );
     grWriteln( "  F11        : decrement index by 1000" );
     grWriteln( "  F12        : increment index by 1000" );
     grLn();
     grWriteln( "  i          : move grid up" );
     grWriteln( "  j          : move grid left" );
     grWriteln( "  k          : move grid down" );
     grWriteln( "  l          : move grid right" );
     grWriteln( "  Page up/dn : zoom in/out grid" );
     grWriteln( "  RETURN     : reset zoom and position" );
     grLn();
     grWriteln( "  H          : toggle horizontal hinting" );
     grWriteln( "  V          : toggle vertical hinting" );
     grWriteln( "  B          : toggle blue zone hinting" );
     grWriteln( "  d          : toggle dots display" );
     grWriteln( "  o          : toggle outline display" );
     grWriteln( "  g          : increase gamma by 0.1" );
     grWriteln( "  v          : decrease gamma by 0.1" );
     grLn();
     grWriteln( "  n          : next font" );
     grWriteln( "  p          : previous font" );
     grWriteln( "  q / ESC    : exit program" );
     grLn();
     grWriteln( "  1          : dump edge hints" );
     grWriteln( "  2          : dump segment hints" );
     grWriteln( "  3          : dump point hints" );
     grLn();
     grWriteln( "press any key to exit this help screen" );
 
     grRefreshSurface( display->surface );
     grListenSurface( display->surface, gr_event_key, &dummy_event );
   }
 
 
   static void
   event_gamma_change( double delta )
   {
     status.gamma += delta;
 
     if ( status.gamma > 3.0 )
       status.gamma = 3.0;
     else if ( status.gamma < 0.0 )
       status.gamma = 0.0;
 
     grSetGlyphGamma( status.gamma );
 
     sprintf( status.header_buffer, "gamma changed to %.1f%s",
              status.gamma, status.gamma == 0.0 ? " (sRGB mode)" : "" );
 
     status.header = (const char *)status.header_buffer;
   }
 
 
   static void
   event_grid_reset( GridStatus  st )
   {
     st->x_origin = st->x_origin_0;
     st->y_origin = st->y_origin_0;
     st->scale    = st->scale_0;
   }
 
 
   static void
   event_grid_translate( int  dx, int  dy )
   {
     status.x_origin += 32*dx;
     status.y_origin += 32*dy;
   }
 
   static void
   event_grid_zoom( double  zoom )
   {
     status.scale *= zoom;
 
     sprintf( status.header_buffer, "zoom level %.2f %%\n",
              status.scale / status.scale_0 );
 
     status.header = (const char *)status.header_buffer;
   }
 
 
   static void
   event_size_change( int delta )
   {
     status.ptsize += delta;
 
     if ( status.ptsize < 1*64 )
       status.ptsize = 1*64;
     else if ( status.ptsize > MAXPTSIZE*64 )
       status.ptsize = MAXPTSIZE*64;
 
     FTDemo_Set_Current_Charsize( handle, status.ptsize, status.res );
   }
 
 
   static void
   event_index_change( int delta )
   {
     int num_indices = handle->current_font->num_indices;
 
 
     status.Num += delta;
 
     if ( status.Num < 0 )
       status.Num = 0;
     else if ( status.Num >= num_indices )
       status.Num = num_indices - 1;
   }
 
 
 
   static void
   event_font_change( int  delta )
   {
     int      num_indices;
 
 
     if ( status.font_index + delta >= handle->num_fonts ||
          status.font_index + delta < 0 )
       return;
 
     status.font_index += delta;
 
     FTDemo_Set_Current_Font( handle, handle->fonts[status.font_index] );
     FTDemo_Set_Current_Charsize( handle, status.ptsize, status.res );
     FTDemo_Update_Current_Flags( handle );
 
     num_indices = handle->current_font->num_indices;
 
     if ( status.Num >= num_indices )
       status.Num = num_indices - 1;
   }
 
 
   static int
   Process_Event( grEvent*  event )
   {
     int  ret = 0;
 
     status.header = NULL;
 
     switch ( event->key )
     {
     case grKeyEsc:
     case grKEY( 'q' ):
       ret = 1;
       break;
 
     case grKeyF1:
     case grKEY( '?' ):
       event_help();
       break;
 
     case grKEY( 'a' ):
       handle->antialias = !handle->antialias;
       status.header     = handle->antialias ? "anti-aliasing is now on"
                                             : "anti-aliasing is now off";
 
       FTDemo_Update_Current_Flags( handle );
       break;
 
     case grKEY( '1' ):
       af_glyph_hints_dump_edges( _af_debug_hints );
       break;
 
     case grKEY( '2' ):
       af_glyph_hints_dump_segments( _af_debug_hints );
       break;
 
     case grKEY( '3' ):
       af_glyph_hints_dump_points( _af_debug_hints );
       break;
 
 
     case grKEY( 'g' ):
       event_gamma_change( 0.1 );
       break;
 
     case grKEY( 'v' ):
       event_gamma_change( -0.1 );
       break;
 
     case grKEY( 'n' ):
       event_font_change( 1 );
       break;
 
     case grKEY( 'h' ):
       handle->hinted = !handle->hinted;
       status.header  = handle->hinted ? "glyph hinting is now active"
                                       : "glyph hinting is now ignored";
 
       FTDemo_Update_Current_Flags( handle );
       break;
 
     case grKEY( 'd' ):
       status.do_dots = !status.do_dots;
       break;
 
     case grKEY( 'o' ):
       status.do_outline = !status.do_outline;
       break;
 
     case grKEY( 'p' ):
       event_font_change( -1 );
       break;
 
     case grKEY('H'):
       status.do_horz_hints = !status.do_horz_hints;
       status.header = status.do_horz_hints ? "horizontal hinting enabled"
                                            : "horizontal hinting disabled";
       break;
 
     case grKEY('V'):
       status.do_vert_hints = !status.do_vert_hints;
       status.header        = status.do_vert_hints
                              ? "vertical hinting enabled"
                              : "vertical hinting disabled";
       break;
 
     case grKEY('B'):
       status.do_blue_hints = !status.do_blue_hints;
       status.header        = status.do_blue_hints
                              ? "blue zone hinting enabled"
                              : "blue zone hinting disabled";
       break;
 
 
     case grKeyLeft:     event_index_change( -1 ); break;
     case grKeyRight:    event_index_change( +1 ); break;
     case grKeyF7:       event_index_change(   -10 ); break;
     case grKeyF8:       event_index_change(    10 ); break;
     case grKeyF9:       event_index_change(  -100 ); break;
     case grKeyF10:      event_index_change(   100 ); break;
     case grKeyF11:      event_index_change( -1000 ); break;
     case grKeyF12:      event_index_change(  1000 ); break;
 
     case grKeyUp:       event_size_change( +32 ); break;
     case grKeyDown:     event_size_change( -32 ); break;
 
     case grKEY( ' ' ):  event_grid_reset( &status );
                         status.do_horz_hints = 1;
                         status.do_vert_hints = 1;
                         break;
 
     case grKEY('i'):    event_grid_translate( 0, +1 ); break;
     case grKEY('k'):    event_grid_translate( 0, -1 ); break;
     case grKEY('l'):    event_grid_translate( +1, 0 ); break;
     case grKEY('j'):    event_grid_translate( -1, 0 ); break;
 
     case grKeyPageUp:   event_grid_zoom( 1.25 ); break;
     case grKeyPageDown: event_grid_zoom( 1/1.25 ); break;
 
     default:
       ;
     }
 
     return ret;
   }
 
 
   static void
   write_header( FT_Error error_code )
   {
     FT_Face      face;
     const char*  basename;
     const char*  format;
 
 
     error = FTC_Manager_LookupFace( handle->cache_manager,
                                     handle->scaler.face_id, &face );
     if ( error )
       Fatal( "can't access font file" );
 
     if ( !status.header )
     {
       basename = ft_basename( handle->current_font->filepathname );
 
       switch ( error_code )
       {
       case FT_Err_Ok:
-        sprintf( status.header_buffer, "%s %s (file `%s')",
+        sprintf( status.header_buffer, "%.50s %.50s (file `%.100s')",
                  face->family_name, face->style_name, basename );
         break;
 
       case FT_Err_Invalid_Pixel_Size:
-        sprintf( status.header_buffer, "Invalid pixel size (file `%s')",
+        sprintf( status.header_buffer, "Invalid pixel size (file `%.100s')",
                  basename );
         break;
 
       case FT_Err_Invalid_PPem:
-        sprintf( status.header_buffer, "Invalid ppem value (file `%s')",
+        sprintf( status.header_buffer, "Invalid ppem value (file `%.100s')",
                  basename );
         break;
 
       default:
-        sprintf( status.header_buffer, "File `%s': error 0x%04x",
+        sprintf( status.header_buffer, "File `%.100s': error 0x%04x",
                  basename, (FT_UShort)error_code );
         break;
       }
 
       status.header = (const char *)status.header_buffer;
     }
 
     grWriteCellString( display->bitmap, 0, 0, status.header,
                        display->fore_color );
 
     format = "at %g points, first glyph index = %d";
 
     snprintf( status.header_buffer, 256, format, status.ptsize/64., status.Num );
 
     if ( FT_HAS_GLYPH_NAMES( face ) )
     {
       char*  p;
       int    format_len, gindex, size;
 
 
       size = strlen( status.header_buffer );
       p    = status.header_buffer + size;
       size = 256 - size;
 
       format = ", name = ";
       format_len = strlen( format );
 
       if ( size >= format_len + 2 )
       {
         gindex = status.Num;
 
         strcpy( p, format );
         if ( FT_Get_Glyph_Name( face, gindex, p + format_len, size - format_len ) )
           *p = '\0';
       }
     }
 
     status.header = (const char *)status.header_buffer;
     grWriteCellString( display->bitmap, 0, HEADER_HEIGHT,
                        status.header_buffer, display->fore_color );
 
     grRefreshSurface( display->surface );
   }
 
 
   static void
   usage( char*  execname )
   {
     fprintf( stderr,  "\n" );
     fprintf( stderr,  "ftgrid: simple glyph grid viewer -- part of the FreeType project\n" );
     fprintf( stderr,  "-----------------------------------------------------------\n" );
     fprintf( stderr,  "\n" );
     fprintf( stderr,  "Usage: %s [status below] ppem fontname[.ttf|.ttc] ...\n",
              execname );
     fprintf( stderr,  "\n" );
     fprintf( stderr,  "  -r R      use resolution R dpi (default: 72 dpi)\n" );
     fprintf( stderr,  "  -f index  specify first index to display\n" );
     fprintf( stderr,  "\n" );
 
     exit( 1 );
   }
 
 
   static void
   parse_cmdline( int*    argc,
                  char**  argv[] )
   {
     char*  execname;
     int    option;
 
 
     execname = ft_basename( (*argv)[0] );
 
     while ( 1 )
     {
       option = getopt( *argc, *argv, "f:r:" );
 
       if ( option == -1 )
         break;
 
       switch ( option )
       {
       case 'f':
         status.Num  = atoi( optarg );
         break;
 
       case 'r':
         status.res = atoi( optarg );
         if ( status.res < 1 )
           usage( execname );
         break;
 
       default:
         usage( execname );
         break;
       }
     }
 
     *argc -= optind;
     *argv += optind;
 
     if ( *argc <= 1 )
       usage( execname );
 
     status.ptsize = (int)(atof( *argv[0] ) * 64.0);
     if ( status.ptsize == 0 )
       status.ptsize = 64*10;
 
     if ( status.res <= 0 )
       status.res = 72;
 
     (*argc)--;
     (*argv)++;
   }
 
 
   int
   main( int    argc,
         char*  argv[] )
   {
     grEvent      event;
 
     display = FTDemo_Display_New( gr_pixel_mode_rgb24 );
     if ( !display )
       Fatal( "could not allocate display surface" );
 
     memset( display->fore_color.chroma, 0, 4 );
     memset( display->back_color.chroma, 0xff, 4 );
     grSetTitle( display->surface, "FreeType Glyph Grid Viewer - press F1 for help" );
 
     grid_status_init( &status, display );
 
     parse_cmdline( &argc, &argv );
 
     /* Initialize engine */
     handle = FTDemo_New( FT_ENCODING_NONE );
 
     for ( ; argc > 0; argc--, argv++ )
       FTDemo_Install_Font( handle, argv[0] );
 
     if ( handle->num_fonts == 0 )
       Fatal( "could not find/open any font file" );
 
     printf( "ptsize =%g \n", status.ptsize/64.0 );
     FTDemo_Set_Current_Charsize( handle, status.ptsize, status.res );
     FTDemo_Update_Current_Flags( handle );
 
     event_font_change( 0 );
 
     grid_status_rescale_initial( &status, handle );
 
     _af_debug = 1;
 
     for ( ;; )
     {
       FTDemo_Display_Clear( display );
 
       grid_status_draw_grid( &status );
 
       if ( status.do_outline || status.do_dots )
         grid_status_draw_outline( &status, handle, display );
 
       write_header( 0 );
 
       grListenSurface( display->surface, 0, &event );
       if ( Process_Event( &event ) )
         break;
     }
 
     printf( "Execution completed successfully.\n" );
 
     FTDemo_Display_Done( display );
     FTDemo_Done( handle );
     exit( 0 );      /* for safety reasons */
 
     return 0;       /* never reached */
   }
 
 
 /* End */
diff --git a/src/ftmulti.c b/src/ftmulti.c
index 15133d4..bb030fb 100644
--- a/src/ftmulti.c
+++ b/src/ftmulti.c
@@ -1,890 +1,890 @@
 /****************************************************************************/
 /*                                                                          */
 /*  The FreeType project -- a free and portable quality TrueType renderer.  */
 /*                                                                          */
-/*  Copyright 1996-2000, 2003, 2004, 2005 by                                */
+/*  Copyright 1996-2000, 2003, 2004, 2005, 2010 by                          */
 /*  D. Turner, R.Wilhelm, and W. Lemberg                                    */
 /*                                                                          */
 /*                                                                          */
 /*  FTMulti- a simple multiple masters font viewer                          */
 /*                                                                          */
 /*  Press F1 when running this program to have a list of key-bindings       */
 /*                                                                          */
 /****************************************************************************/
 
 #include <ft2build.h>
 #include FT_FREETYPE_H
 #include FT_MULTIPLE_MASTERS_H
 
 #include "common.h"
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdarg.h>
 
 #include "graph.h"
 #include "grfont.h"
 
 #define  DIM_X   500
 #define  DIM_Y   400
 
 #define  CENTER_X   ( bit.width / 2 )
 #define  CENTER_Y   ( bit.rows / 2 )
 
 #define  MAXPTSIZE  500                 /* dtp */
 
-  char  Header[128];
+  char  Header[256];
   char* new_header = 0;
 
   const unsigned char*  Text = (unsigned char*)
     "The quick brown fox jumps over the lazy dog 0123456789 "
     "\342\352\356\373\364\344\353\357\366\374\377\340\371\351\350\347 "
     "&#~\"\'(-`_^@)=+\260 ABCDEFGHIJKLMNOPQRSTUVWXYZ "
     "$\243^\250*\265\371%!\247:/;.,?<>";
 
   FT_Library    library;      /* the FreeType library        */
   FT_Face       face;         /* the font face               */
   FT_Size       size;         /* the font size               */
   FT_GlyphSlot  glyph;        /* the glyph slot              */
 
   FT_Encoding   encoding = FT_ENCODING_NONE;
 
   FT_Error      error;        /* error returned by FreeType? */
 
   grSurface*    surface;      /* current display surface     */
   grBitmap      bit;          /* current display bitmap      */
 
   int  num_glyphs;            /* number of glyphs */
   int  ptsize;                /* current point size */
 
   int  hinted    = 1;         /* is glyph hinting active?    */
   int  antialias = 1;         /* is anti-aliasing active?    */
   int  use_sbits = 1;         /* do we use embedded bitmaps? */
   int  low_prec  = 0;         /* force low precision         */
   int  Num;                   /* current first glyph index   */
 
   int  res       = 72;
 
   static grColor  fore_color = { 255 };
 
   int            Fail;
   unsigned char  autorun;
 
   int  graph_init  = 0;
 
   int  render_mode = 1;
   int  use_grays   = 1;
 
   FT_MM_Var       *multimaster = NULL;
   FT_Fixed         design_pos   [T1_MAX_MM_AXIS];
   FT_Fixed         requested_pos[T1_MAX_MM_AXIS];
   int              requested_cnt = 0;
 
 #define RASTER_BUFF_SIZE  32768
   char             raster_buff[RASTER_BUFF_SIZE];
 
 #define DEBUGxxx
 
 #ifdef DEBUG
 #define LOG( x )  LogMessage##x
 #else
 #define LOG( x )  /* empty */
 #endif
 
 #ifdef DEBUG
   static void
   LogMessage( const char*  fmt, ... )
   {
     va_list  ap;
 
 
     va_start( ap, fmt );
     vfprintf( stderr, fmt, ap );
     va_end( ap );
   }
 #endif
 
 
   /* PanicZ */
   static void
   PanicZ( const char*  message )
   {
     fprintf( stderr, "%s\n  error = 0x%04x\n", message, error );
     exit( 1 );
   }
 
 
   static unsigned long
   make_tag( char  *s )
   {
     int            i;
     unsigned long  l = 0;
 
 
     for ( i = 0; i < 4; i++ )
     {
       if ( !s[i] )
         break;
       l <<= 8;
       l  += (unsigned long)s[i];
     }
 
     return l;
   }
 
 
   static void
   parse_design_coords( char  *s )
   {
     for ( requested_cnt = 0; requested_cnt < T1_MAX_MM_AXIS && *s;
           requested_cnt++ )
     {
       requested_pos[requested_cnt] = (FT_Fixed)( strtod( s, &s ) * 65536.0 );
 
       while ( *s==' ' )
         ++s;
     }
   }
 
 
   /* Clears the Bit bitmap/pixmap */
   static void
   Clear_Display( void )
   {
     long  bitmap_size = (long)bit.pitch * bit.rows;
 
 
     if ( bitmap_size < 0 )
       bitmap_size = -bitmap_size;
     memset( bit.buffer, 0, bitmap_size );
   }
 
 
   /* Initialize the display bitmap named `bit' */
   static void
   Init_Display( void )
   {
     grInitDevices();
 
     bit.mode  = gr_pixel_mode_gray;
     bit.width = DIM_X;
     bit.rows  = DIM_Y;
     bit.grays = 256;
 
     surface = grNewSurface( 0, &bit );
     if ( !surface )
       PanicZ( "could not allocate display surface\n" );
 
     graph_init = 1;
   }
 
 
 #define FLOOR( x )  ( (x) & -64 )
 #define CEIL( x )   ( ( (x) + 63 ) & -64 )
 #define TRUNC( x )  ( (x) >> 6 )
 
 
   /* Render a single glyph with the `grays' component */
   static FT_Error
   Render_Glyph( int  x_offset,
                 int  y_offset )
   {
     grBitmap  bit3;
     FT_Pos    x_top, y_top;
 
 
     /* first, render the glyph image into a bitmap */
     if ( glyph->format != FT_GLYPH_FORMAT_BITMAP )
     {
       error = FT_Render_Glyph( glyph, antialias ? FT_RENDER_MODE_NORMAL
                                                 : FT_RENDER_MODE_MONO );
       if ( error )
         return error;
     }
 
     /* now blit it to our display screen */
     bit3.rows   = glyph->bitmap.rows;
     bit3.width  = glyph->bitmap.width;
     bit3.pitch  = glyph->bitmap.pitch;
     bit3.buffer = glyph->bitmap.buffer;
 
     switch ( glyph->bitmap.pixel_mode )
     {
     case FT_PIXEL_MODE_MONO:
       bit3.mode  = gr_pixel_mode_mono;
       bit3.grays = 0;
       break;
 
     case FT_PIXEL_MODE_GRAY:
       bit3.mode  = gr_pixel_mode_gray;
       bit3.grays = glyph->bitmap.num_grays;
     }
 
     /* Then, blit the image to the target surface */
     x_top = x_offset + glyph->bitmap_left;
     y_top = y_offset - glyph->bitmap_top;
 
     grBlitGlyphToBitmap( &bit, &bit3, x_top, y_top, fore_color );
 
     return 0;
   }
 
 
   static void
   Reset_Scale( int  pointSize )
   {
     (void)FT_Set_Char_Size( face, pointSize << 6, pointSize << 6, res, res );
   }
 
 
   static FT_Error
   LoadChar( int  idx,
             int  hint )
   {
     int  flags;
 
 
     flags = FT_LOAD_DEFAULT | FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH;
 
     if ( !hint )
       flags |= FT_LOAD_NO_HINTING;
 
     if ( !use_sbits )
       flags |= FT_LOAD_NO_BITMAP;
 
     return FT_Load_Glyph( face, idx, flags );
   }
 
 
   static FT_Error
   Render_All( int  first_glyph,
               int  pt_size )
   {
     FT_F26Dot6  start_x, start_y, step_x, step_y, x, y;
     int         i;
 
 
     start_x = 4;
     start_y = 36 + pt_size;
 
     step_x = size->metrics.x_ppem + 4;
     step_y = size->metrics.y_ppem + 10;
 
     x = start_x;
     y = start_y;
 
     i = first_glyph;
 
 #if 0
      while ( i < first_glyph + 1 )
 #else
      while ( i < num_glyphs )
 #endif
     {
       if ( !( error = LoadChar( i, hinted ) ) )
       {
 #ifdef DEBUG
         if ( i <= first_glyph + 6 )
         {
           LOG(( "metrics[%02d] = [%x %x]\n",
                 i,
                 glyph->metrics.horiBearingX,
                 glyph->metrics.horiAdvance ));
 
           if ( i == first_glyph + 6 )
             LOG(( "-------------------------\n" ));
         }
 #endif
 
         Render_Glyph( x, y );
 
         x += ( glyph->metrics.horiAdvance >> 6 ) + 1;
 
         if ( x + size->metrics.x_ppem > bit.width )
         {
           x  = start_x;
           y += step_y;
 
           if ( y >= bit.rows )
             return FT_Err_Ok;
         }
       }
       else
         Fail++;
 
       i++;
     }
 
     return FT_Err_Ok;
   }
 
 
   static FT_Error
   Render_Text( int  first_glyph )
   {
     FT_F26Dot6  start_x, start_y, step_x, step_y, x, y;
     int         i;
 
     const unsigned char*  p;
 
 
     start_x = 4;
     start_y = 32 + size->metrics.y_ppem;
 
     step_x = size->metrics.x_ppem + 4;
     step_y = size->metrics.y_ppem + 10;
 
     x = start_x;
     y = start_y;
 
     i = first_glyph;
     p = Text;
     while ( i > 0 && *p )
     {
       p++;
       i--;
     }
 
     while ( *p )
     {
       if ( !( error = LoadChar( FT_Get_Char_Index( face,
                                                    (unsigned char)*p ),
                                 hinted ) ) )
       {
 #ifdef DEBUG
         if ( i <= first_glyph + 6 )
         {
           LOG(( "metrics[%02d] = [%x %x]\n",
                 i,
                 glyph->metrics.horiBearingX,
                 glyph->metrics.horiAdvance ));
 
           if ( i == first_glyph + 6 )
           LOG(( "-------------------------\n" ));
         }
 #endif
 
         Render_Glyph( x, y );
 
         x += ( glyph->metrics.horiAdvance >> 6 ) + 1;
 
         if ( x + size->metrics.x_ppem > bit.width )
         {
           x  = start_x;
           y += step_y;
 
           if ( y >= bit.rows )
             return FT_Err_Ok;
         }
       }
       else
         Fail++;
 
       i++;
       p++;
     }
 
     return FT_Err_Ok;
   }
 
 
   static void
   Help( void )
   {
     grEvent  dummy_event;
 
 
     Clear_Display();
 
     grGotoxy( 0, 0 );
     grSetMargin( 2, 1 );
     grGotobitmap( &bit );
 
     grWriteln( "FreeType Multiple Masters Glyph Viewer - part of the FreeType test suite" );
     grLn();
     grWriteln( "This program is used to display all glyphs from one or" );
     grWriteln( "several Multiple Masters font files, with the FreeType library.");
     grLn();
     grWriteln( "Use the following keys:");
     grLn();
     grWriteln( "  F1 or ?   : display this help screen" );
     grWriteln( "  a         : toggle anti-aliasing" );
     grWriteln( "  h         : toggle outline hinting" );
     grWriteln( "  b         : toggle embedded bitmaps" );
     grWriteln( "  l         : toggle low precision rendering" );
     grWriteln( "  space     : toggle rendering mode" );
     grLn();
     grWriteln( "  n         : next font" );
     grWriteln( "  p         : previous font" );
     grLn();
     grWriteln( "  Up        : increase pointsize by 1 unit" );
     grWriteln( "  Down      : decrease pointsize by 1 unit" );
     grWriteln( "  Page Up   : increase pointsize by 10 units" );
     grWriteln( "  Page Down : decrease pointsize by 10 units" );
     grLn();
     grWriteln( "  Right     : increment first glyph index" );
     grWriteln( "  Left      : decrement first glyph index" );
     grLn();
     grWriteln( "  F3        : decrement first axis pos by 1/50th of its range" );
     grWriteln( "  F4        : increment first axis pos by 1/50th of its range" );
     grWriteln( "  F5        : decrement second axis pos by 1/50th of its range" );
     grWriteln( "  F6        : increment second axis pos by 1/50th of its range" );
     grWriteln( "  F7        : decrement third axis pos by 1/50th of its range" );
     grWriteln( "  F8        : increment third axis pos by 1/50th of its range" );
     grWriteln( "  F9        : decrement index by 100" );
     grWriteln( "  F10       : increment index by 100" );
     grWriteln( "  F11       : decrement index by 1000" );
     grWriteln( "  F12       : increment index by 1000" );
     grLn();
     grWriteln( "press any key to exit this help screen" );
 
     grRefreshSurface( surface );
     grListenSurface( surface, gr_event_key, &dummy_event );
   }
 
 
   static int
   Process_Event( grEvent*  event )
   {
     int  i, axis;
 
 
     switch ( event->key )
     {
     case grKeyEsc:            /* ESC or q */
     case grKEY( 'q' ):
       return 0;
 
     case grKeyF1:
     case grKEY( '?' ):
       Help();
       return 1;
 
     /* mode keys */
 
     case grKEY( 'a' ):
       antialias = !antialias;
       new_header = antialias ? (char *)"anti-aliasing is now on"
                              : (char *)"anti-aliasing is now off";
       return 1;
 
     case grKEY( 'b' ):
       use_sbits  = !use_sbits;
       new_header = use_sbits
                      ? (char *)"embedded bitmaps are now used if available"
                      : (char *)"embedded bitmaps are now ignored";
       return 1;
 
     case grKEY( 'n' ):
     case grKEY( 'p' ):
       return (int)event->key;
 
     case grKEY( 'l' ):
       low_prec = !low_prec;
       new_header = low_prec
                      ? (char *)"rendering precision is now forced to low"
                      : (char *)"rendering precision is now normal";
       break;
 
     case grKEY( 'h' ):
       hinted = !hinted;
       new_header = hinted ? (char *)"glyph hinting is now active"
                           : (char *)"glyph hinting is now ignored";
       break;
 
     case grKEY( ' ' ):
       render_mode ^= 1;
       new_header = render_mode ? (char *)"rendering all glyphs in font"
                                : (char *)"rendering test text string";
       break;
 
     /* MM related keys */
 
     case grKeyF3:
       i = -20;
       axis = 0;
       goto Do_Axis;
 
     case grKeyF4:
       i = 20;
       axis = 0;
       goto Do_Axis;
 
     case grKeyF5:
       i = -20;
       axis = 1;
       goto Do_Axis;
 
     case grKeyF6:
       i = 20;
       axis = 1;
       goto Do_Axis;
 
     case grKeyF7:
       i = -20;
       axis = 2;
       goto Do_Axis;
 
     case grKeyF8:
       i = 20;
       axis = 2;
       goto Do_Axis;
 
     /* scaling related keys */
 
     case grKeyPageUp:
       i = 10;
       goto Do_Scale;
 
     case grKeyPageDown:
       i = -10;
       goto Do_Scale;
 
     case grKeyUp:
       i = 1;
       goto Do_Scale;
 
     case grKeyDown:
       i = -1;
       goto Do_Scale;
 
     /* glyph index related keys */
 
     case grKeyLeft:
       i = -1;
       goto Do_Glyph;
 
     case grKeyRight:
       i = 1;
       goto Do_Glyph;
 
     case grKeyF9:
       i = -100;
       goto Do_Glyph;
 
     case grKeyF10:
       i = 100;
       goto Do_Glyph;
 
     case grKeyF11:
       i = -1000;
       goto Do_Glyph;
 
     case grKeyF12:
       i = 1000;
       goto Do_Glyph;
 
     default:
       ;
     }
     return 1;
 
   Do_Axis:
     if ( axis < (int)multimaster->num_axis )
     {
       FT_Var_Axis* a   = multimaster->axis + axis;
       FT_Fixed     pos = design_pos[axis];
 
       /* Normalize i. changing by 20 is all very well for PostScript fonts  */
       /*  which tend to have a range of ~1000 per axis, but it's not useful */
       /*  for mac fonts which have a range of ~3.                           */
       /* And it's rather extreme for optical size even in PS                */
       pos += FT_MulDiv( i, a->maximum-a->minimum, 1000 );
       if ( pos < a->minimum ) pos = a->minimum;
       if ( pos > a->maximum ) pos = a->maximum;
 
       design_pos[axis] = pos;
 
       FT_Set_Var_Design_Coordinates( face, multimaster->num_axis, design_pos );
     }
     return 1;
 
   Do_Scale:
     ptsize += i;
     if ( ptsize < 1 )         ptsize = 1;
     if ( ptsize > MAXPTSIZE ) ptsize = MAXPTSIZE;
     return 1;
 
   Do_Glyph:
     Num += i;
     if ( Num < 0 )           Num = 0;
     if ( Num >= num_glyphs ) Num = num_glyphs - 1;
     return 1;
   }
 
 
   static void
   usage( char*  execname )
   {
     fprintf( stderr,  "\n" );
     fprintf( stderr,  "ftmulti: multiple masters font viewer - part of FreeType\n" );
     fprintf( stderr,  "--------------------------------------------------------\n" );
     fprintf( stderr,  "\n" );
     fprintf( stderr,  "Usage: %s [options below] ppem fontname[.pfb|.ttf] ...\n",
              execname );
     fprintf( stderr,  "\n" );
     fprintf( stderr,  "  -e encoding  select encoding (default: no encoding)\n" );
     fprintf( stderr,  "  -r R         use resolution R dpi (default: 72 dpi)\n" );
     fprintf( stderr,  "  -f index     specify first glyph index to display\n" );
     fprintf( stderr,  "  -d \"axis1 axis2 ...\"\n"
                       "               specify the design coordinates for each axis\n" );
     fprintf( stderr,  "\n" );
 
     exit( 1 );
   }
 
 
   int
   main( int    argc,
         char*  argv[] )
   {
     int    old_ptsize, orig_ptsize, file;
     int    first_glyph = 0;
     int    XisSetup = 0;
     char*  execname;
     int    option;
     int    file_loaded;
 
     grEvent  event;
 
 
     execname = ft_basename( argv[0] );
 
     while ( 1 )
     {
       option = getopt( argc, argv, "d:e:f:r:" );
 
       if ( option == -1 )
         break;
 
       switch ( option )
       {
       case 'd':
         parse_design_coords( optarg );
         break;
 
       case 'e':
         encoding = (FT_Encoding)make_tag( optarg );
         break;
 
       case 'f':
         first_glyph = atoi( optarg );
         break;
 
       case 'r':
         res = atoi( optarg );
         if ( res < 1 )
           usage( execname );
         break;
 
       default:
         usage( execname );
         break;
       }
     }
 
     argc -= optind;
     argv += optind;
 
     if ( argc <= 1 )
       usage( execname );
 
     if ( sscanf( argv[0], "%d", &orig_ptsize ) != 1 )
       orig_ptsize = 64;
 
     file = 1;
 
     /* Initialize engine */
     error = FT_Init_FreeType( &library );
     if ( error )
       PanicZ( "Could not initialize FreeType library" );
 
   NewFile:
     ptsize      = orig_ptsize;
     hinted      = 1;
     file_loaded = 0;
 
     /* Load face */
     error = FT_New_Face( library, argv[file], 0, &face );
     if ( error )
       goto Display_Font;
 
     if ( encoding != FT_ENCODING_NONE )
     {
       error = FT_Select_Charmap( face, encoding );
       if ( error )
         goto Display_Font;
     }
 
     /* retrieve multiple master information */
     error = FT_Get_MM_Var( face, &multimaster );
     if ( error )
       goto Display_Font;
 
     /* if the user specified a position, use it, otherwise */
     /* set the current position to the median of each axis */
     {
       int  n;
 
 
       for ( n = 0; n < (int)multimaster->num_axis; n++ )
       {
         design_pos[n] = n < requested_cnt ? requested_pos[n]
                                           : multimaster->axis[n].def;
         if ( design_pos[n] < multimaster->axis[n].minimum )
           design_pos[n] = multimaster->axis[n].minimum;
         else if ( design_pos[n] > multimaster->axis[n].maximum )
           design_pos[n] = multimaster->axis[n].maximum;
       }
     }
 
     error = FT_Set_Var_Design_Coordinates( face,
                                            multimaster->num_axis,
                                            design_pos );
     if ( error )
       goto Display_Font;
 
     file_loaded++;
 
     Reset_Scale( ptsize );
 
     num_glyphs = face->num_glyphs;
     glyph      = face->glyph;
     size       = face->size;
 
   Display_Font:
     /* initialize graphics if needed */
     if ( !XisSetup )
     {
       XisSetup = 1;
       Init_Display();
     }
 
     grSetTitle( surface, "FreeType Glyph Viewer - press F1 for help" );
     old_ptsize = ptsize;
 
     if ( file_loaded >= 1 )
     {
       Fail = 0;
       Num  = first_glyph;
 
       if ( Num >= num_glyphs )
         Num = num_glyphs - 1;
 
       if ( Num < 0 )
         Num = 0;
     }
 
     for ( ;; )
     {
       int  key;
 
 
       Clear_Display();
 
       if ( file_loaded >= 1 )
       {
         switch ( render_mode )
         {
         case 0:
           Render_Text( Num );
           break;
 
         default:
           Render_All( Num, ptsize );
         }
 
-        sprintf( Header, "%s %s (file %s)",
+        sprintf( Header, "%.50s %.50s (file %.100s)",
                          face->family_name,
                          face->style_name,
                          ft_basename( argv[file] ) );
 
         if ( !new_header )
           new_header = Header;
 
         grWriteCellString( &bit, 0, 0, new_header, fore_color );
         new_header = 0;
 
         sprintf( Header, "axis: " );
         {
           int  n;
 
 
           for ( n = 0; n < (int)multimaster->num_axis; n++ )
           {
             char  temp[32];
 
 
             sprintf( temp, "  %s:%g",
                            multimaster->axis[n].name,
                            design_pos[n]/65536. );
             strcat( Header, temp );
           }
         }
         grWriteCellString( &bit, 0, 16, Header, fore_color );
 
         sprintf( Header, "at %d points, first glyph = %d",
                          ptsize,
                          Num );
       }
       else
       {
-        sprintf( Header, "%s: not an MM font file, or could not be opened",
+        sprintf( Header, "%.100s: not an MM font file, or could not be opened",
                          ft_basename( argv[file] ) );
       }
 
       grWriteCellString( &bit, 0, 8, Header, fore_color );
       grRefreshSurface( surface );
 
       grListenSurface( surface, 0, &event );
       if ( !( key = Process_Event( &event ) ) )
         goto End;
 
       if ( key == 'n' )
       {
         if ( file_loaded >= 1 )
           FT_Done_Face( face );
 
         if ( file < argc - 1 )
           file++;
 
         goto NewFile;
       }
 
       if ( key == 'p' )
       {
         if ( file_loaded >= 1 )
           FT_Done_Face( face );
 
         if ( file > 1 )
           file--;
 
         goto NewFile;
       }
 
       if ( ptsize != old_ptsize )
       {
         Reset_Scale( ptsize );
 
         old_ptsize = ptsize;
       }
     }
 
   End:
     grDoneSurface( surface );
     grDoneDevices();
 
     free            ( multimaster );
     FT_Done_Face    ( face        );
     FT_Done_FreeType( library     );
 
     printf( "Execution completed successfully.\n" );
     printf( "Fails = %d\n", Fail );
 
     exit( 0 );      /* for safety reasons */
     return 0;       /* never reached */
   }
 
 
 /* End */
diff --git a/src/ftstring.c b/src/ftstring.c
index f567596..ffa7f45 100644
--- a/src/ftstring.c
+++ b/src/ftstring.c
@@ -1,654 +1,655 @@
 /****************************************************************************/
 /*                                                                          */
 /*  The FreeType project -- a free and portable quality TrueType renderer.  */
 /*                                                                          */
-/*  Copyright 1996-2002, 2003, 2004, 2005, 2006, 2007, 2009 by              */
+/*  Copyright 1996-2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010 by        */
 /*  D. Turner, R.Wilhelm, and W. Lemberg                                    */
 /*                                                                          */
 /*                                                                          */
 /*  ftstring.c - simple text string display                                 */
 /*                                                                          */
 /****************************************************************************/
 
 #include <ft2build.h>
 #include FT_FREETYPE_H
 
 #include "common.h"
 #include "ftcommon.h"
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdarg.h>
 #include <math.h>
 
 #define CELLSTRING_HEIGHT  8
 #define MAXPTSIZE  500                 /* dtp */
 
 
   static char*  Text = (char *)"The quick brown fox jumps over the lazy dog";
 
   enum {
     RENDER_MODE_STRING,
     RENDER_MODE_KERNCMP,
     N_RENDER_MODES
   };
 
   static struct {
     int          render_mode;
     FT_Encoding  encoding;
     int          res;
     int          ptsize;            /* current point size */
     double       gamma;
     int          angle;
 
     FTDemo_String_Context  sc;
 
     FT_Byte      gamma_ramp[256];
     FT_Matrix    trans_matrix;
     int          font_index;
     char*        header;
     char         header_buffer[256];
 
   } status = { RENDER_MODE_STRING, FT_ENCODING_UNICODE, 72, 48, 2.0, 0 };
 
   static FTDemo_Display*  display;
   static FTDemo_Handle*   handle;
 
 
 /****************************************************************************/
 /****************************************************************************/
 /****************************************************************************/
 /****                                                                    ****/
 /****                     E V E N T   H A N D L I N G                    ****/
 /****                                                                    ****/
 /****************************************************************************/
 /****************************************************************************/
 /****************************************************************************/
 
   static void
   event_help( void )
   {
     grEvent  dummy_event;
 
 
     FTDemo_Display_Clear( display );
     grGotoxy( 0, 0 );
     grSetMargin( 2, 1 );
     grGotobitmap( display->bitmap );
 
     grWriteln( "FreeType String Viewer - part of the FreeType test suite" );
     grLn();
     grWriteln( "This program is used to display a string of text using" );
     grWriteln( "the new convenience API of the FreeType 2 library." );
     grLn();
     grWriteln( "Use the following keys :" );
     grLn();
     grWriteln( "  F1 or ?   : display this help screen" );
     grLn();
     grWriteln( "  a         : toggle anti-aliasing" );
     grWriteln( "  b         : toggle embedded bitmaps (and disable rotation)" );
     grWriteln( "  f         : toggle forced auto-hinting" );
     grWriteln( "  h         : toggle outline hinting" );
     grWriteln( "  l         : toggle low precision rendering" );
     grLn();
     grWriteln( "  1-2       : select rendering mode" );
     grWriteln( "  k         : cycle through kerning modes" );
     grWriteln( "  t         : cycle through kerning degrees" );
     grWriteln( "  V         : toggle vertical rendering" );
     grLn();
     grWriteln( "  G         : toggle gamma correction" );
     grWriteln( "  g         : increase gamma by 0.1" );
     grWriteln( "  v         : decrease gamma by 0.1" );
     grLn();
     grWriteln( "  n         : next font" );
     grWriteln( "  p         : previous font" );
     grLn();
     grWriteln( "  Up        : increase pointsize by 1 unit" );
     grWriteln( "  Down      : decrease pointsize by 1 unit" );
     grWriteln( "  Page Up   : increase pointsize by 10 units" );
     grWriteln( "  Page Down : decrease pointsize by 10 units" );
     grLn();
     grWriteln( "  Right     : rotate counter-clockwise" );
     grWriteln( "  Left      : rotate clockwise" );
     grWriteln( "  F7        : big rotate counter-clockwise" );
     grWriteln( "  F8        : big rotate clockwise" );
     grLn();
     grLn();
     grWriteln( "press any key to exit this help screen" );
 
     grRefreshSurface( display->surface );
     grListenSurface( display->surface, gr_event_key, &dummy_event );
   }
 
 
   static void
   event_font_change( int  delta )
   {
     if ( status.font_index + delta >= handle->num_fonts ||
          status.font_index + delta < 0 )
       return;
 
     status.font_index += delta;
 
     FTDemo_Set_Current_Font( handle, handle->fonts[status.font_index] );
     FTDemo_Set_Current_Charsize( handle, status.ptsize, status.res );
     FTDemo_Update_Current_Flags( handle );
 
     FTDemo_String_Set( handle, Text );
   }
 
 
   static void
   event_angle_change( int  delta )
   {
     double    radian;
     FT_Fixed  cosinus;
     FT_Fixed  sinus;
 
 
     status.angle = ( status.angle + delta ) % 360;
 
     if ( status.angle == 0 )
     {
       status.sc.matrix = NULL;
 
       return;
     }
 
     status.sc.matrix = &status.trans_matrix;
 
     if ( status.angle < 0 )
       status.angle += 360;
 
     radian  = status.angle * 3.14159 / 180.0;
     cosinus = (FT_Fixed)( cos( radian ) * 65536.0 );
     sinus   = (FT_Fixed)( sin( radian ) * 65536.0 );
 
     status.trans_matrix.xx = cosinus;
     status.trans_matrix.yx = sinus;
     status.trans_matrix.xy = -sinus;
     status.trans_matrix.yy = cosinus;
   }
 
 
   static void
   event_gamma_change( double delta )
   {
     int i;
     double gamma_inv;
 
     status.gamma += delta;
 
     if ( status.gamma > 3.0 )
       status.gamma = 3.0;
     else if ( status.gamma < 0.1 )
       status.gamma = 0.1;
 
     sprintf( status.header_buffer, "gamma changed to %.1f", status.gamma );
     status.header = status.header_buffer;
 
     gamma_inv = 1.0f / status.gamma;
 
     for ( i = 0; i < 256; i++ )
       status.gamma_ramp[i] = (FT_Byte)( pow( (double)i / 255.0f, gamma_inv )
                                         * 255.0f );
   }
 
 
   static void
   event_size_change( int delta )
   {
     status.ptsize += delta;
 
     if ( status.ptsize < 1*64 )
       status.ptsize = 1*64;
     else if ( status.ptsize > MAXPTSIZE*64 )
       status.ptsize = MAXPTSIZE*64;
 
     FTDemo_Set_Current_Charsize( handle, status.ptsize, status.res );
   }
 
 
   static void
   event_render_mode_change( int delta )
   {
     if ( delta )
     {
       status.render_mode = ( status.render_mode + delta ) % N_RENDER_MODES;
 
       if ( status.render_mode < 0 )
         status.render_mode += N_RENDER_MODES;
     }
 
     switch ( status.render_mode )
     {
     case RENDER_MODE_STRING:
       status.header = NULL;
       break;
 
     case RENDER_MODE_KERNCMP:
       status.header = (char *)"Kerning comparison";
       break;
     }
   }
 
 
   static int
   Process_Event( grEvent*  event )
   {
     FTDemo_String_Context*  sc = &status.sc;
     int                     ret = 0;
 
 
     if ( event->key >= '1' && event->key < '1' + N_RENDER_MODES )
     {
       status.render_mode = event->key - '1';
       event_render_mode_change( 0 );
 
       return ret;
     }
 
     switch ( event->key )
     {
     case grKeyEsc:
     case grKEY( 'q' ):
       ret = 1;
       break;
 
     case grKeyF1:
     case grKEY( '?' ):
       event_help();
       break;
 
     case grKEY( 'a' ):
       handle->antialias = !handle->antialias;
       status.header     = handle->antialias
                           ? (char *)"anti-aliasing is now on"
                           : (char *)"anti-aliasing is now off";
 
       FTDemo_Update_Current_Flags( handle );
       break;
 
     case grKEY( 'b' ):
       handle->use_sbits = !handle->use_sbits;
       status.header     = handle->use_sbits
                           ? (char *)"embedded bitmaps are now used when available"
                           : (char *)"embedded bitmaps are now ignored";
 
       FTDemo_Update_Current_Flags( handle );
       break;
 
     case grKEY( 'f' ):
       handle->autohint = !handle->autohint;
       status.header     = handle->autohint
                           ? (char *)"forced auto-hinting is now on"
                           : (char *)"forced auto-hinting is now off";
 
       FTDemo_Update_Current_Flags( handle );
       break;
 
     case grKEY( 'h' ):
       handle->hinted = !handle->hinted;
       status.header   = handle->hinted
                         ? (char *)"glyph hinting is now active"
                         : (char *)"glyph hinting is now ignored";
 
       FTDemo_Update_Current_Flags( handle );
       break;
 
     case grKEY( 'l' ):
       handle->low_prec = !handle->low_prec;
       status.header    = handle->low_prec
                          ? (char *)"rendering precision is now forced to low"
                          : (char *)"rendering precision is now normal";
 
       FTDemo_Update_Current_Flags( handle );
       break;
 
     case grKEY( 'k' ):
       sc->kerning_mode = ( sc->kerning_mode + 1 ) % N_KERNING_MODES;
       status.header =
         sc->kerning_mode == KERNING_MODE_SMART
         ? (char *)"pair kerning and side bearing correction is now active"
         : sc->kerning_mode == KERNING_MODE_NORMAL
           ? (char *)"pair kerning is now active"
           : (char *)"pair kerning is now ignored";
       break;
 
     case grKEY( 't' ):
       sc->kerning_degree = ( sc->kerning_degree + 1 ) % N_KERNING_DEGREES;
       status.header =
         sc->kerning_degree == KERNING_DEGREE_NONE
         ? (char *)"no track kerning"
         : sc->kerning_degree == KERNING_DEGREE_LIGHT
           ? (char *)"light track kerning active"
           : sc->kerning_degree == KERNING_DEGREE_MEDIUM
             ? (char *)"medium track kerning active"
             : (char *)"tight track kerning active";
       break;
 
     case grKEY( 'V' ):
       sc->vertical  = !sc->vertical;
       status.header = sc->vertical
                       ? (char *)"using vertical layout"
                       : (char *)"using horizontal layout";
       break;
 
     case grKEY( 'G' ):
       sc->gamma_ramp = sc->gamma_ramp ? NULL : status.gamma_ramp;
       status.header  = sc->gamma_ramp
                        ? (char *)"gamma correction is now on"
                        : (char *)"gamma correction is now off";
       break;
 
     case grKEY( 'g' ):
       event_gamma_change( 0.1 );
       break;
 
     case grKEY( 'v' ):
       event_gamma_change( -0.1 );
       break;
 
     case grKEY( 'n' ):
       event_font_change( 1 );
       break;
 
     case grKEY( 'p' ):
       event_font_change( -1 );
       break;
 
     case grKeyUp:       event_size_change(   64 ); break;
     case grKeyDown:     event_size_change(  -64 ); break;
     case grKeyPageUp:   event_size_change(  640); break;
     case grKeyPageDown: event_size_change( -640 ); break;
 
     case grKeyLeft:  event_angle_change(    -3 ); break;
     case grKeyRight: event_angle_change(     3 ); break;
     case grKeyF7:    event_angle_change(   -30 ); break;
     case grKeyF8:    event_angle_change(    30 ); break;
 
     default:
       break;
     }
 
     return ret;
   }
 
 
   static void
   gamma_ramp_draw( FT_Byte    gamma_ramp[256],
                    grBitmap*  bitmap )
   {
     int       i, x, y;
     FT_Byte*  p = (FT_Byte*)bitmap->buffer;
 
     if ( bitmap->pitch < 0 )
       p += -bitmap->pitch * ( bitmap->rows - 1 );
 
     x = ( bitmap->width - 256 ) / 2;
     y = ( bitmap->rows + 256 ) / 2;
 
     for (i = 0; i < 256; i++)
       p[bitmap->pitch * ( y - gamma_ramp[i] ) + ( x + i )] = 80;
   }
 
 
   static void
   write_header( FT_Error  error_code )
   {
     FT_Face      face;
     const char*  basename;
 
 
     error = FTC_Manager_LookupFace( handle->cache_manager,
                                     handle->scaler.face_id, &face );
     if ( error )
       PanicZ( "can't access font file" );
 
     if ( !status.header )
     {
       basename = ft_basename( handle->current_font->filepathname );
 
       switch ( error_code )
       {
       case FT_Err_Ok:
-        sprintf( status.header_buffer, "%s %s (file `%s')", face->family_name,
+        sprintf( status.header_buffer,
+                 "%.50s %.50s (file `%.100s')", face->family_name,
                  face->style_name, basename );
         break;
       case FT_Err_Invalid_Pixel_Size:
-        sprintf( status.header_buffer, "Invalid pixel size (file `%s')",
+        sprintf( status.header_buffer, "Invalid pixel size (file `%.100s')",
                  basename );
         break;
       case FT_Err_Invalid_PPem:
-        sprintf( status.header_buffer, "Invalid ppem value (file `%s')",
+        sprintf( status.header_buffer, "Invalid ppem value (file `%.100s')",
                  basename );
         break;
       default:
-        sprintf( status.header_buffer, "File `%s': error 0x%04x", basename,
+        sprintf( status.header_buffer, "File `%.100s': error 0x%04x", basename,
             (FT_UShort)error_code );
         break;
       }
 
       status.header = status.header_buffer;
     }
 
     grWriteCellString( display->bitmap, 0, 0,
                        status.header, display->fore_color );
 
     sprintf( status.header_buffer, "at %g points, angle = %d",
              status.ptsize/64.0, status.angle );
     grWriteCellString( display->bitmap, 0, CELLSTRING_HEIGHT,
                        status.header_buffer, display->fore_color );
 
     grRefreshSurface( display->surface );
   }
 
 
   static void
   usage( char*  execname )
   {
     fprintf( stderr,  "\n" );
     fprintf( stderr,  "ftstring: string viewer -- part of the FreeType project\n" );
     fprintf( stderr,  "-------------------------------------------------------\n" );
     fprintf( stderr,  "\n" );
     fprintf( stderr,  "Usage: %s [options below] ppem fontname[.ttf|.ttc] ...\n",
              execname );
     fprintf( stderr,  "\n" );
     fprintf( stderr,  "  -e enc      specify encoding tag (default: unic)\n" );
     fprintf( stderr,  "  -r R        use resolution R dpi (default: 72 dpi)\n" );
     fprintf( stderr,  "  -m message  message to display\n" );
     fprintf( stderr,  "\n" );
 
     exit( 1 );
   }
 
 
   static void
   parse_cmdline( int*     argc,
                  char***  argv )
   {
     char*  execname;
     int    option;
 
 
     execname = ft_basename( (*argv)[0] );
 
     while ( 1 )
     {
       option = getopt( *argc, *argv, "e:m:r:" );
 
       if ( option == -1 )
         break;
 
       switch ( option )
       {
       case 'e':
         status.encoding = FTDemo_Make_Encoding_Tag( optarg );
         break;
 
       case 'r':
         status.res = atoi( optarg );
         if ( status.res < 1 )
           usage( execname );
         break;
 
       case 'm':
         if ( *argc < 3 )
           usage( execname );
         Text = optarg;
         break;
 
       default:
         usage( execname );
         break;
       }
     }
 
     *argc -= optind;
     *argv += optind;
 
     if ( *argc <= 1 )
       usage( execname );
 
     status.ptsize = (int)(atof( *argv[0] ) * 64.0);
     if ( status.ptsize == 0 )
       status.ptsize = 64;
 
     (*argc)--;
     (*argv)++;
   }
 
 
   int
   main( int     argc,
         char**  argv )
   {
     grEvent  event;
 
 
     parse_cmdline( &argc, &argv );
 
     /* Initialize engine */
     handle = FTDemo_New( status.encoding );
 
     handle->use_sbits = 0;
     FTDemo_Update_Current_Flags( handle );
 
     for ( ; argc > 0; argc--, argv++ )
     {
       error = FTDemo_Install_Font( handle, argv[0] );
 
       if ( error )
       {
         fprintf( stderr, "failed to install %s", argv[0] );
         if ( error == FT_Err_Invalid_CharMap_Handle )
           fprintf( stderr, ": missing valid charmap\n" );
         else
           fprintf( stderr, "\n" );
       }
     }
 
     if ( handle->num_fonts == 0 )
       PanicZ( "could not open any font file" );
 
     display = FTDemo_Display_New( gr_pixel_mode_gray );
     display->back_color.value = 0;
     display->fore_color.value = 0xff;
 
     if ( !display )
       PanicZ( "could not allocate display surface" );
 
     grSetTitle( display->surface,
                 "FreeType String Viewer - press F1 for help" );
 
     event_gamma_change( 0 );
     event_font_change( 0 );
     status.header = 0;
 
     for ( ;; )
     {
       FTDemo_Display_Clear( display );
 
       switch ( status.render_mode )
       {
       case RENDER_MODE_STRING:
         status.sc.center = 1L << 15;
         error = FTDemo_String_Draw( handle, display,
                                     &status.sc,
                                     display->bitmap->width / 2,
                                     display->bitmap->rows / 2 );
         break;
 
       case RENDER_MODE_KERNCMP:
         {
           FTDemo_String_Context  sc = status.sc;
           FT_Int                 x, y;
           FT_UInt                height;
 
 
           x = 55;
 
           /* whatever.. */
           height = status.ptsize * status.res / 72;
           if ( height < CELLSTRING_HEIGHT )
             height = CELLSTRING_HEIGHT;
 
           /* First line: none */
           sc.center         = 0;
           sc.kerning_mode   = 0;
           sc.kerning_degree = 0;
           sc.vertical       = 0;
           sc.matrix         = NULL;
 
           y = CELLSTRING_HEIGHT * 2 + display->bitmap->rows / 4 + height;
           grWriteCellString( display->bitmap, 5,
                              y - ( height + CELLSTRING_HEIGHT ) / 2,
                              "none", display->fore_color );
           error = FTDemo_String_Draw( handle, display, &sc, x, y );
 
 
           /* Second line: track kern only */
           sc.kerning_degree = status.sc.kerning_degree;
 
           y += height;
           grWriteCellString( display->bitmap, 5,
                              y - ( height + CELLSTRING_HEIGHT ) / 2,
                              "track", display->fore_color );
           error = FTDemo_String_Draw( handle, display, &sc, x, y );
 
 
           /* Third line: track kern + pair kern */
           sc.kerning_mode      = status.sc.kerning_mode;
 
           y += height;
           grWriteCellString( display->bitmap, 5,
                              y - ( height + CELLSTRING_HEIGHT ) / 2,
                              "both", display->fore_color );
           error = FTDemo_String_Draw( handle, display, &sc, x, y );
         }
         break;
       }
 
       if ( !error && status.sc.gamma_ramp )
         gamma_ramp_draw( status.gamma_ramp, display->bitmap );
 
       write_header( error );
 
       status.header = 0;
       grListenSurface( display->surface, 0, &event );
       if ( Process_Event( &event ) )
         break;
     }
 
     printf( "Execution completed successfully.\n" );
 
     FTDemo_Display_Done( display );
     FTDemo_Done( handle );
     exit( 0 );      /* for safety reasons */
 
     return 0;       /* never reached */
   }
 
 
 /* End */
diff --git a/src/ftview.c b/src/ftview.c
index 4bdf533..42ed67c 100644
--- a/src/ftview.c
+++ b/src/ftview.c
@@ -1,1481 +1,1481 @@
 /****************************************************************************/
 /*                                                                          */
 /*  The FreeType project -- a free and portable quality TrueType renderer.  */
 /*                                                                          */
 /*  Copyright 1996-2000, 2003, 2004, 2005, 2006, 2007, 2009, 2010 by        */
 /*  D. Turner, R.Wilhelm, and W. Lemberg                                    */
 /*                                                                          */
 /*                                                                          */
 /*  FTView - a simple font viewer.                                          */
 /*                                                                          */
 /*  This is a new version using the MiGS graphics subsystem for             */
 /*  blitting and display.                                                   */
 /*                                                                          */
 /*  Press F1 when running this program to have a list of key-bindings       */
 /*                                                                          */
 /****************************************************************************/
 
 
 #include "ftcommon.h"
 #include "common.h"
 #include <math.h>
 #include <stdio.h>
 
   /* the following header shouldn't be used in normal programs */
 #include FT_INTERNAL_DEBUG_H
 #include FT_STROKER_H
 #include FT_SYNTHESIS_H
 #include FT_LCD_FILTER_H
 
 #define MAXPTSIZE      500                 /* dtp */
 #define HEADER_HEIGHT  8
 
 #ifdef CEIL
 #undef CEIL
 #endif
 #define CEIL( x )  ( ( (x) + 63 ) >> 6 )
 
 #define INIT_SIZE( size, start_x, start_y, step_x, step_y, x, y )       \
           do {                                                          \
             start_x = 4;                                                \
             start_y = CEIL( size->metrics.height ) + 3 * HEADER_HEIGHT; \
             step_x  = CEIL( size->metrics.max_advance );                \
             step_y  = CEIL( size->metrics.height ) + 4;                 \
                                                                         \
             x = start_x;                                                \
             y = start_y;                                                \
           } while ( 0 )
 
 #define X_TOO_LONG( x, size, display )                   \
           ( (x) + ( (size)->metrics.max_advance >> 6 ) > \
             (display)->bitmap->width )
 #define Y_TOO_LONG( y, size, display )       \
           ( (y) >= (display)->bitmap->rows )
 
 #ifdef _WIN32
 #define snprintf  _snprintf
 #endif
 
 
   enum
   {
     RENDER_MODE_ALL = 0,
     RENDER_MODE_EMBOLDEN,
     RENDER_MODE_SLANTED,
     RENDER_MODE_STROKE,
     RENDER_MODE_TEXT,
     RENDER_MODE_WATERFALL,
     N_RENDER_MODES
   };
 
   static struct  status_
   {
     int            render_mode;
     FT_Encoding    encoding;
     int            res;
     int            ptsize;            /* current point size, 26.6 format */
     int            lcd_mode;
     double         gamma;
     double         bold_factor;
     double         slant;
 
     int            debug;
     int            trace_level;
     int            font_index;
     int            dump_cache_stats;  /* do we need to dump cache statistics? */
     int            Num;               /* current first index */
     char*          header;
     char           header_buffer[256];
     int            Fail;
     int            preload;
 
     int            use_custom_lcd_filter;
     unsigned char  filter_weights[5];
     int            fw_index;
 
   } status = { RENDER_MODE_ALL, FT_ENCODING_NONE, 72, 48, -1,
                1.0, 0.04, 0.22,
                0, 0, 0, 0, 0, NULL, { 0 }, 0, 0,
                0, "\x10\x40\x70\x40\x10", 2 };
 
 
   static FTDemo_Display*  display;
   static FTDemo_Handle*   handle;
 
 
   static const unsigned char*  Text = (unsigned char*)
     "The quick brown fox jumps over the lazy dog 0123456789"
     " \342\352\356\373\364\344\353\357\366\374\377\340\371\351\350\347"
     " &#~\"\'(-`_^@)=+\260 ABCDEFGHIJKLMNOPQRSTUVWXYZ"
     " $\243^\250*\265\371%!\247:/;.,?<>";
 
 
 
   static void
   Fatal( const char*  message )
   {
     FTDemo_Display_Done( display );
     FTDemo_Done( handle );
     PanicZ( message );
   }
 
 
   static FT_Error
   Render_Stroke( int  num_indices,
                  int  first_index )
   {
     int         start_x, start_y, step_x, step_y, x, y;
     int         i;
     FT_Size     size;
     FT_Stroker  stroker = NULL;
 
 
     error = FTDemo_Get_Size( handle, &size );
 
     if ( error )
     {
       /* probably a non-existent bitmap font size */
       return error;
     }
 
     INIT_SIZE( size, start_x, start_y, step_x, step_y, x, y );
 
     i = first_index;
 
     error = FT_Stroker_New( handle->library, &stroker );
     if ( error )
       goto Exit;
 
     FT_Stroker_Set( stroker, 64,
                     FT_STROKER_LINECAP_ROUND,
                     FT_STROKER_LINEJOIN_ROUND,
                     0 );
 
     while ( i < num_indices )
     {
       int           gindex;
       FT_GlyphSlot  slot;
 
 
       if ( handle->encoding == FT_ENCODING_NONE )
         gindex = i;
       else
         gindex = FTDemo_Get_Index( handle, i );
 
       error = FT_Load_Glyph( size->face, gindex,
                              handle->load_flags | FT_LOAD_NO_BITMAP );
       slot = size->face->glyph;
 
       if ( !error && slot->format == FT_GLYPH_FORMAT_OUTLINE )
       {
         FT_Glyph  glyph;
 
 
         error = FT_Get_Glyph( slot, &glyph );
         if ( error )
           goto Next;
 
         error = FT_Glyph_Stroke( &glyph, stroker, 1 );
         if ( error )
         {
           FT_Done_Glyph( glyph );
           goto Next;
         }
 
         error = FTDemo_Draw_Glyph( handle, display, glyph, &x, &y );
         FT_Done_Glyph( glyph );
 
         if ( error )
           status.Fail++;
         else if ( X_TOO_LONG( x, size, display ) )
         {
           x  = start_x;
           y += step_y;
 
           if ( Y_TOO_LONG( y, size, display ) )
             break;
         }
       }
       else
       {
     Next:
         status.Fail++;
       }
 
       i++;
     }
 
   Exit:
     if ( stroker )
       FT_Stroker_Done( stroker );
 
     return error;
   }
 
 
   static FT_Error
   Render_Slanted( int  num_indices,
                   int  first_index )
   {
     int      start_x, start_y, step_x, step_y, x, y;
     int      i;
     FT_Size  size;
 
 
     error = FTDemo_Get_Size( handle, &size );
 
     if ( error )
     {
       /* probably a non-existent bitmap font size */
       return error;
     }
 
     INIT_SIZE( size, start_x, start_y, step_x, step_y, x, y );
 
     i = first_index;
 
     while ( i < num_indices )
     {
       int      gindex;
       FT_Face  face = size->face;
 
 
       if ( handle->encoding == FT_ENCODING_NONE )
         gindex = i;
       else
         gindex = FTDemo_Get_Index( handle, i );
 
       error = FT_Load_Glyph( face, gindex, handle->load_flags );
       if ( !error )
       {
         FT_Matrix    shear;
         FT_Outline*  outline;
 
 
         /***************************************************************/
         /*                                                             */
         /*  2*2 affine transformation matrix, 16.16 fixed float format */
         /*                                                             */
         /*  Shear matrix:                                              */
         /*                                                             */
         /*         | x' |     | 1  k |   | x |          x' = x + ky    */
         /*         |    |  =  |      | * |   |   <==>                  */
         /*         | y' |     | 0  1 |   | y |          y' = y         */
         /*                                                             */
         /*        outline'     shear    outline                        */
         /*                                                             */
         /***************************************************************/
 
         shear.xx = 1 << 16;
         shear.xy = (FT_Fixed)( status.slant * ( 1 << 16 ) );
         shear.yx = 0;
         shear.yy = 1 << 16;
 
         outline = &(face->glyph)->outline;
 
         FT_Outline_Transform( outline, &shear );
 
         error = FTDemo_Draw_Slot( handle, display, face->glyph, &x, &y );
 
         if ( error )
           status.Fail++;
         else if ( X_TOO_LONG( x, size, display ) )
         {
           x  = start_x;
           y += step_y;
 
           if ( Y_TOO_LONG( y, size, display ) )
             break;
         }
       }
       else
         status.Fail++;
 
       i++;
     }
 
     return error;
   }
 
 
   static FT_Error
   Render_Embolden( int  num_indices,
                    int  first_index )
   {
     int      start_x, start_y, step_x, step_y, x, y;
     int      i;
     FT_Size  size;
 
 
     error = FTDemo_Get_Size( handle, &size );
 
     if ( error )
     {
       /* probably a non-existent bitmap font size */
       return error;
     }
 
     INIT_SIZE( size, start_x, start_y, step_x, step_y, x, y );
 
     i = first_index;
 
     while ( i < num_indices )
     {
       int      gindex;
       FT_Face  face = size->face;
 
 
       if ( handle->encoding == FT_ENCODING_NONE )
         gindex = i;
       else
         gindex = FTDemo_Get_Index( handle, i );
 
       error = FT_Load_Glyph( face, gindex, handle->load_flags );
       if ( !error )
       {
         /* this is essentially the code of function */
         /* `FT_GlyphSlot_Embolden'                  */
 
         FT_GlyphSlot  slot    = face->glyph;
         FT_Library    library = slot->library;
         FT_Pos        xstr, ystr;
 
 
         if ( slot->format != FT_GLYPH_FORMAT_OUTLINE &&
              slot->format != FT_GLYPH_FORMAT_BITMAP )
           goto Next;
 
         xstr = FT_MulFix( face->units_per_EM,
                           face->size->metrics.y_scale );
         xstr = (FT_Fixed)( xstr * status.bold_factor );
         ystr = xstr;
 
         if ( slot->format == FT_GLYPH_FORMAT_OUTLINE )
         {
           error = FT_Outline_Embolden( &slot->outline, xstr );
           /* ignore error */
 
           xstr = xstr * 2;
           ystr = xstr;
         }
         else if ( slot->format == FT_GLYPH_FORMAT_BITMAP )
         {
           /* round to full pixels */
           xstr &= ~63;
           ystr &= ~63;
 
           error = FT_GlyphSlot_Own_Bitmap( slot );
           if ( error )
             goto Next;
 
           error = FT_Bitmap_Embolden( library, &slot->bitmap, xstr, ystr );
           if ( error )
             goto Next;
         }
 
         if ( slot->advance.x )
           slot->advance.x += xstr;
 
         if ( slot->advance.y )
           slot->advance.y += ystr;
 
         slot->metrics.width        += xstr;
         slot->metrics.height       += ystr;
         slot->metrics.horiBearingY += ystr;
         slot->metrics.horiAdvance  += xstr;
         slot->metrics.vertBearingX -= xstr / 2;
         slot->metrics.vertBearingY += ystr;
         slot->metrics.vertAdvance  += ystr;
 
         if ( slot->format == FT_GLYPH_FORMAT_BITMAP )
           slot->bitmap_top += ystr >> 6;
 
         error = FTDemo_Draw_Slot( handle, display, slot, &x, &y );
 
         if ( error )
           goto Next;
         else if ( X_TOO_LONG( x, size, display ) )
         {
           x  = start_x;
           y += step_y;
 
           if ( Y_TOO_LONG( y, size, display ) )
             break;
         }
       }
       else
     Next:
         status.Fail++;
 
       i++;
     }
 
     return error;
   }
 
 
   static FT_Error
   Render_All( int  num_indices,
               int  first_index )
   {
     int      start_x, start_y, step_x, step_y, x, y;
     int      i;
     FT_Size  size;
 
 
     error = FTDemo_Get_Size( handle, &size );
 
     if ( error )
     {
       /* probably a non-existent bitmap font size */
       return error;
     }
 
     INIT_SIZE( size, start_x, start_y, step_x, step_y, x, y );
 
     i = first_index;
 
     while ( i < num_indices )
     {
       int  gindex;
 
 
       if ( handle->encoding == FT_ENCODING_NONE )
         gindex = i;
       else
         gindex = FTDemo_Get_Index( handle, i );
 
       error = FTDemo_Draw_Index( handle, display, gindex, &x, &y );
       if ( error )
         status.Fail++;
       else if ( X_TOO_LONG( x, size, display ) )
       {
         x = start_x;
         y += step_y;
 
         if ( Y_TOO_LONG( y, size, display ) )
           break;
       }
 
       i++;
     }
 
     return FT_Err_Ok;
   }
 
 
   static FT_Error
   Render_Text( int  num_indices,
                int  first_index )
   {
     int      start_x, start_y, step_x, step_y, x, y;
     int      i;
     FT_Size  size;
 
     const char*  p;
     const char*  pEnd;
 
 
     num_indices = num_indices;  /* pacify compiler */
 
     error = FTDemo_Get_Size( handle, &size );
     if ( error )
     {
       /* probably a non-existent bitmap font size */
       return error;
     }
 
     INIT_SIZE( size, start_x, start_y, step_x, step_y, x, y );
 
     i = first_index;
 
     p    = (const char*)Text;
     pEnd = p + strlen( (const char*)Text );
 
     while ( i > 0 )
     {
       utf8_next( &p, pEnd );
       i--;
     }
 
     while ( num_indices != 0 )
     {
       FT_UInt  gindex;
       int      ch;
 
 
       ch = utf8_next( &p, pEnd );
       if ( ch < 0 )
         break;
 
       gindex = FTDemo_Get_Index( handle, ch );
 
       error = FTDemo_Draw_Index( handle, display, gindex, &x, &y );
       if ( error )
         status.Fail++;
       else
       {
         /* Draw_Index adds one pixel space */
         x--;
 
         if ( X_TOO_LONG( x, size, display ) )
         {
           x  = start_x;
           y += step_y;
 
           if ( Y_TOO_LONG( y, size, display ) )
             break;
         }
       }
 
       if ( num_indices > 0 )
         num_indices -= 1;
     }
 
     return FT_Err_Ok;
   }
 
 
   static FT_Error
   Render_Waterfall( int  first_size )
   {
     int      start_x, start_y, step_x, step_y, x, y;
     int      pt_size, max_size = 100000;
     FT_Size  size;
     FT_Face  face;
 
     unsigned char         text[256];
     const unsigned char*  p;
 
 
     error = FTC_Manager_LookupFace( handle->cache_manager,
                                     handle->scaler.face_id, &face );
     if ( error )
     {
       /* can't access the font file: do not render anything */
       fprintf( stderr, "can't access font file %p\n",
                (void*)handle->scaler.face_id );
       return 0;
     }
 
     if ( !FT_IS_SCALABLE( face ) )
     {
       int  i;
 
 
       max_size = 0;
       for ( i = 0; i < face->num_fixed_sizes; i++ )
         if ( face->available_sizes[i].height >= max_size / 64 )
           max_size = face->available_sizes[i].height * 64;
     }
 
     start_x = 4;
     start_y = 3 * HEADER_HEIGHT;
 
     for ( pt_size = first_size; pt_size < max_size; pt_size += 64 )
     {
       sprintf( (char*)text,
                "%g: the quick brown fox jumps over the lazy dog"
                " ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", pt_size / 64.0 );
 
       p = text;
 
       FTDemo_Set_Current_Charsize( handle, pt_size, status.res );
 
       error = FTDemo_Get_Size( handle, &size );
       if ( error )
       {
         /* probably a non-existent bitmap font size */
         continue;
       }
 
       step_x = ( size->metrics.max_advance >> 6 ) + 4;
       step_y = ( size->metrics.height >> 6 ) + 1;
 
       x = start_x;
       y = start_y + ( size->metrics.ascender >> 6 );
 
       start_y += step_y;
 
       if ( y >= display->bitmap->rows )
         break;
 
       while ( *p )
       {
         FT_UInt  gindex;
 
 
         gindex = FTDemo_Get_Index( handle, *p );
 
         error = FTDemo_Draw_Index( handle, display, gindex, &x, &y );
         if ( error )
           status.Fail++;
         else if ( X_TOO_LONG( x, size, display ) )
           break;
 
         p++;
       }
     }
 
     FTDemo_Set_Current_Charsize( handle, first_size, status.res );
 
     return FT_Err_Ok;
   }
 
 
   /*************************************************************************/
   /*************************************************************************/
   /*****                                                               *****/
   /*****                REST OF THE APPLICATION/PROGRAM                *****/
   /*****                                                               *****/
   /*************************************************************************/
   /*************************************************************************/
 
   static void
   event_help( void )
   {
     grEvent  dummy_event;
 
 
     FTDemo_Display_Clear( display );
     grGotoxy( 0, 0 );
     grSetMargin( 2, 1 );
     grGotobitmap( display->bitmap );
 
     grWriteln( "FreeType Glyph Viewer - part of the FreeType test suite" );
     grLn();
     grWriteln( "This program is used to display all glyphs from one or" );
     grWriteln( "several font files, with the FreeType library." );
     grLn();
     grWriteln( "Use the following keys:" );
     grLn();
     grWriteln( "  F1, ?       display this help screen" );
     grLn();
     grWriteln( "  a           toggle anti-aliasing" );
     grWriteln( "  b           toggle embedded bitmaps" );
     grWriteln( "  c           toggle between cache modes" );
     grWriteln( "  f           toggle forced auto-hinting" );
     grWriteln( "  h           toggle outline hinting" );
     grWriteln( "  l           toggle low precision rendering" );
     grLn();
     grWriteln( "  L           cycle through LCD modes" );
     grWriteln( "  space       cycle through rendering modes" );
     grWriteln( "  1-6         select rendering mode" );
     grLn();
     grWriteln( "  e, E        adjust emboldening" );
     grWriteln( "  s, S        adjust slanting" );
     grLn();
     grWriteln( "  F           toggle custom LCD filter mode" );
     grWriteln( "  [, ]        select custom LCD filter weight" );
     grWriteln( "  -, +(=)     adjust selected custom LCD filter weight" );
     grLn();
     grWriteln( "  G           show gamma ramp" );
     grWriteln( "  g, v        adjust gamma value" );
     grLn();
     grWriteln( "  p, n        select previous/next font" );
     grLn();
     grWriteln( "  Up, Down    adjust pointsize by 1 unit" );
     grWriteln( "  PgUp, PgDn  adjust pointsize by 10 units" );
     grLn();
     grWriteln( "  Left, Right adjust index by 1" );
     grWriteln( "  F7, F8      adjust index by 10" );
     grWriteln( "  F9, F10     adjust index by 100" );
     grWriteln( "  F11, F12    adjust index by 1000" );
     grLn();
     grWriteln( "press any key to exit this help screen" );
 
     grRefreshSurface( display->surface );
     grListenSurface( display->surface, gr_event_key, &dummy_event );
   }
 
 
   static void
   event_gamma_grid( void )
   {
     grEvent  dummy_event;
     int      g;
     int      yside  = 11;
     int      xside  = 10;
     int      levels = 17;
     int      gammas = 30;
     int      x_0    = ( display->bitmap->width - levels * xside ) / 2;
     int      y_0    = ( display->bitmap->rows - gammas * ( yside + 1 ) ) / 2;
     int      pitch  = display->bitmap->pitch;
 
 
     FTDemo_Display_Clear( display );
     grGotobitmap( display->bitmap );
 
     if ( pitch < 0 )
       pitch = -pitch;
 
     memset( display->bitmap->buffer, 100, pitch * display->bitmap->rows );
 
     grWriteCellString( display->bitmap, 0, 0, "Gamma grid",
                        display->fore_color );
 
     for ( g = 1; g <= gammas; g += 1 )
     {
       double  ggamma = g / 10.0;
       char    temp[6];
       int     y = y_0 + ( yside + 1 ) * ( g - 1 );
       int     nx, ny;
 
       unsigned char*  line = display->bitmap->buffer +
                              y * display->bitmap->pitch;
 
 
       if ( display->bitmap->pitch < 0 )
         line -= display->bitmap->pitch * ( display->bitmap->rows - 1 );
 
       line += x_0 * 3;
 
       grSetPixelMargin( x_0 - 32, y + ( yside - 8 ) / 2 );
       grGotoxy( 0, 0 );
 
       sprintf( temp, "%.1f", ggamma );
       grWrite( temp );
 
       for ( ny = 0; ny < yside; ny++, line += display->bitmap->pitch )
       {
         unsigned char*  dst = line;
 
 
         for ( nx = 0; nx < levels; nx++, dst += 3 * xside )
         {
           double  p   = nx / (double)( levels - 1 );
           int     gm  = (int)( 255.0 * pow( p, ggamma ) );
 
 
           memset( dst, gm, xside * 3 );
         }
       }
     }
 
     grRefreshSurface( display->surface );
     grListenSurface( display->surface, gr_event_key, &dummy_event );
   }
 
 
   static void
   event_gamma_change( double  delta )
   {
     status.gamma += delta;
 
     if ( status.gamma > 3.0 )
       status.gamma = 3.0;
     else if ( status.gamma < 0.0 )
       status.gamma = 0.0;
 
     grSetGlyphGamma( status.gamma );
 
     sprintf( status.header_buffer, "gamma changed to %.1f%s",
              status.gamma, status.gamma == 0.0 ? " (sRGB mode)" : "" );
 
     status.header = status.header_buffer;
   }
 
 
   static void
   event_bold_change( double  delta )
   {
     status.bold_factor += delta;
 
     if ( status.bold_factor > 0.1 )
       status.bold_factor = 0.1;
     else if ( status.bold_factor < -0.1 )
       status.bold_factor = -0.1;
 
     sprintf( status.header_buffer, "embolding factor changed to %.3f",
              status.bold_factor );
 
     status.header = status.header_buffer;
   }
 
 
   static void
   event_slant_change( double  delta )
   {
     status.slant += delta;
 
     if ( status.slant > 1.0 )
       status.slant = 1.0;
     else if ( status.slant < -1.0 )
       status.slant = -1.0;
 
     sprintf( status.header_buffer, "slanting changed to %.3f",
              status.slant );
 
     status.header = status.header_buffer;
   }
 
 
   static void
   event_size_change( int  delta )
   {
     status.ptsize += delta;
 
     if ( status.ptsize < 64 * 1 )
       status.ptsize = 1 * 64;
     else if ( status.ptsize > MAXPTSIZE * 64 )
       status.ptsize = MAXPTSIZE * 64;
 
     FTDemo_Set_Current_Charsize( handle, status.ptsize, status.res );
   }
 
 
   static void
   event_index_change( int  delta )
   {
     int  num_indices = handle->current_font->num_indices;
 
 
     status.Num += delta;
 
     if ( status.Num < 0 )
       status.Num = 0;
     else if ( status.Num >= num_indices )
       status.Num = num_indices - 1;
   }
 
 
   static void
   event_render_mode_change( int  delta )
   {
 
     if ( delta )
     {
       status.render_mode = ( status.render_mode + delta ) % N_RENDER_MODES;
 
       if ( status.render_mode < 0 )
         status.render_mode += N_RENDER_MODES;
     }
 
     switch ( status.render_mode )
     {
     case RENDER_MODE_ALL:
       status.header = (char *)"rendering all glyphs in font";
       break;
     case RENDER_MODE_EMBOLDEN:
       status.header = (char *)"rendering emboldened text";
       break;
     case RENDER_MODE_SLANTED:
       status.header = (char *)"rendering slanted text";
       break;
     case RENDER_MODE_STROKE:
       status.header = (char *)"rendering stroked text";
       break;
     case RENDER_MODE_TEXT:
       status.header = (char *)"rendering test text string";
       break;
     case RENDER_MODE_WATERFALL:
       status.header = (char *)"rendering glyph waterfall";
       break;
     }
   }
 
 
   static void
   event_font_change( int  delta )
   {
     int  num_indices;
 
 
     if ( status.font_index + delta >= handle->num_fonts ||
          status.font_index + delta < 0                  )
       return;
 
     status.font_index += delta;
 
     FTDemo_Set_Current_Font( handle, handle->fonts[status.font_index] );
     FTDemo_Set_Current_Charsize( handle, status.ptsize, status.res );
     FTDemo_Update_Current_Flags( handle );
 
     num_indices = handle->current_font->num_indices;
 
     if ( status.Num >= num_indices )
       status.Num = num_indices - 1;
   }
 
 
   static int
   Process_Event( grEvent*  event )
   {
     int  ret = 0;
 
 
     if ( event->key >= '1' && event->key < '1' + N_RENDER_MODES )
     {
       status.render_mode = event->key - '1';
       event_render_mode_change( 0 );
 
       return ret;
     }
 
     switch ( event->key )
     {
     case grKeyEsc:
     case grKEY( 'q' ):
       ret = 1;
       break;
 
     case grKeyF1:
     case grKEY( '?' ):
       event_help();
       break;
 
     case grKEY( 'a' ):
       handle->antialias = !handle->antialias;
       status.header     = handle->antialias
                            ? (char *)"anti-aliasing is now on"
                            : (char *)"anti-aliasing is now off";
 
       FTDemo_Update_Current_Flags( handle );
       break;
 
     case grKEY( 'b' ):
       handle->use_sbits = !handle->use_sbits;
       status.header     = handle->use_sbits
                            ? (char *)"now using embedded bitmaps (if available)"
                            : (char *)"now ignoring embedded bitmaps";
 
       FTDemo_Update_Current_Flags( handle );
       break;
 
     case grKEY( 'c' ):
       handle->use_sbits_cache = !handle->use_sbits_cache;
       status.header           = handle->use_sbits_cache
                                  ? (char *)"now using sbits cache"
                                  : (char *)"now using normal cache";
       break;
 
     case grKEY( 'f' ):
       handle->autohint = !handle->autohint;
       status.header    = handle->autohint
                           ? (char *)"forced auto-hinting is now on"
                           : (char *)"forced auto-hinting is now off";
 
       FTDemo_Update_Current_Flags( handle );
       break;
 
     case grKEY( 'h' ):
       handle->hinted = !handle->hinted;
       status.header  = handle->hinted
                         ? (char *)"glyph hinting is now active"
                         : (char *)"glyph hinting is now ignored";
 
       FTDemo_Update_Current_Flags( handle );
       break;
 
     case grKEY( 'l' ):
       handle->low_prec = !handle->low_prec;
       status.header    = handle->low_prec
                           ? (char *)"rendering precision is now forced to low"
                           : (char *)"rendering precision is now normal";
 
       FTDemo_Update_Current_Flags( handle );
       break;
 
     case grKEY( 'L' ):
       handle->lcd_mode = ( handle->lcd_mode + 1 ) % N_LCD_MODES;
 
       switch ( handle->lcd_mode )
       {
       case LCD_MODE_AA:
         status.header = (char *)"use normal anti-aliased rendering";
         break;
       case LCD_MODE_LIGHT:
         status.header = (char *)"use light anti-aliased rendering";
         break;
       case LCD_MODE_RGB:
         status.header = (char *)"use horizontal LCD-optimized rendering (RGB)";
         break;
       case LCD_MODE_BGR:
         status.header = (char *)"use horizontal LCD-optimized rendering (BGR)";
         break;
       case LCD_MODE_VRGB:
         status.header = (char *)"use vertical LCD-optimized rendering (RGB)";
         break;
       case LCD_MODE_VBGR:
         status.header = (char *)"use vertical LCD-optimized rendering (BGR)";
         break;
       }
 
       FTDemo_Update_Current_Flags( handle );
       break;
 
     case grKEY( ' ' ):
       event_render_mode_change( 1 );
       break;
 
     case grKEY( 'G' ):
       event_gamma_grid();
       break;
 
     case grKEY( 's' ):
       event_slant_change( 0.02 );
       break;
 
     case grKEY( 'S' ):
       event_slant_change( -0.02 );
       break;
 
     case grKEY( 'e' ):
       event_bold_change( 0.002 );
       break;
 
     case grKEY( 'E' ):
       event_bold_change( -0.002 );
       break;
 
     case grKEY( 'g' ):
       event_gamma_change( 0.1 );
       break;
 
     case grKEY( 'v' ):
       event_gamma_change( -0.1 );
       break;
 
     case grKEY( 'n' ):
       event_font_change( 1 );
       break;
 
     case grKEY( 'p' ):
       event_font_change( -1 );
       break;
 
     case grKeyUp:       event_size_change(   64 ); break;
     case grKeyDown:     event_size_change(  -64 ); break;
     case grKeyPageUp:   event_size_change(  640 ); break;
     case grKeyPageDown: event_size_change( -640 ); break;
 
     case grKeyLeft:  event_index_change(    -1 ); break;
     case grKeyRight: event_index_change(     1 ); break;
     case grKeyF7:    event_index_change(   -10 ); break;
     case grKeyF8:    event_index_change(    10 ); break;
     case grKeyF9:    event_index_change(  -100 ); break;
     case grKeyF10:   event_index_change(   100 ); break;
     case grKeyF11:   event_index_change( -1000 ); break;
     case grKeyF12:   event_index_change(  1000 ); break;
 
     case grKEY( 'F' ):
       FTC_Manager_RemoveFaceID( handle->cache_manager,
                                 handle->scaler.face_id );
 
       status.use_custom_lcd_filter = !status.use_custom_lcd_filter;
       if ( status.use_custom_lcd_filter )
         FT_Library_SetLcdFilterWeights( handle->library,
                                         status.filter_weights );
       else
         FT_Library_SetLcdFilterWeights( handle->library,
                                         (unsigned char*)"\x10\x40\x70\x40\x10" );
       status.header = status.use_custom_lcd_filter
                       ? (char *)"using custom LCD filter weights"
                       : (char *)"using default LCD filter";
       break;
 
     case grKEY( '[' ):
       if ( !status.use_custom_lcd_filter )
         break;
 
       status.fw_index--;
       if ( status.fw_index < 0 )
         status.fw_index = 4;
       break;
 
     case grKEY( ']' ):
       if ( !status.use_custom_lcd_filter )
         break;
 
       status.fw_index++;
       if ( status.fw_index > 4 )
         status.fw_index = 0;
       break;
 
     case grKEY( '-' ):
       if ( !status.use_custom_lcd_filter )
         break;
 
       FTC_Manager_RemoveFaceID( handle->cache_manager,
                                 handle->scaler.face_id );
 
       status.filter_weights[status.fw_index]--;
       FT_Library_SetLcdFilterWeights( handle->library,
                                       status.filter_weights );
       break;
 
     case grKEY( '+' ):
     case grKEY( '=' ):
       if ( !status.use_custom_lcd_filter )
         break;
 
       FTC_Manager_RemoveFaceID( handle->cache_manager,
                                 handle->scaler.face_id );
 
       status.filter_weights[status.fw_index]++;
       FT_Library_SetLcdFilterWeights( handle->library,
                                       status.filter_weights );
       break;
 
     default:
       break;
     }
 
     return ret;
   }
 
 
   static void
   write_header( FT_Error  error_code )
   {
     FT_Face      face;
     const char*  basename;
     const char*  format;
 
 
     error = FTC_Manager_LookupFace( handle->cache_manager,
                                     handle->scaler.face_id, &face );
     if ( error )
       Fatal( "can't access font file" );
 
     if ( !status.header )
     {
       basename = ft_basename( handle->current_font->filepathname );
 
       switch ( error_code )
       {
       case FT_Err_Ok:
-        sprintf( status.header_buffer, "%s %s (file `%s')",
+        sprintf( status.header_buffer, "%.50s %.50s (file `%.100s')",
                  face->family_name, face->style_name, basename );
         break;
       case FT_Err_Invalid_Pixel_Size:
-        sprintf( status.header_buffer, "Invalid pixel size (file `%s')",
+        sprintf( status.header_buffer, "Invalid pixel size (file `%.100s')",
                  basename );
         break;
       case FT_Err_Invalid_PPem:
-        sprintf( status.header_buffer, "Invalid ppem value (file `%s')",
+        sprintf( status.header_buffer, "Invalid ppem value (file `%.100s')",
                  basename );
         break;
       default:
-        sprintf( status.header_buffer, "File `%s': error 0x%04x",
+        sprintf( status.header_buffer, "File `%.100s': error 0x%04x",
                  basename, (FT_UShort)error_code );
         break;
       }
 
       status.header = status.header_buffer;
     }
 
     grWriteCellString( display->bitmap, 0, 0,
                        status.header, display->fore_color );
 
     format = status.encoding != FT_ENCODING_NONE
              ? "at %g points, first char code = 0x%x"
              : "at %g points, first glyph index = %d";
 
     snprintf( status.header_buffer, 256, format,
               status.ptsize / 64.0, status.Num );
 
     if ( FT_HAS_GLYPH_NAMES( face ) )
     {
       char*  p;
       int    format_len, gindex, size;
 
 
       size = strlen( status.header_buffer );
       p    = status.header_buffer + size;
       size = 256 - size;
 
       format = ", name = ";
       format_len = strlen( format );
 
       if ( size >= format_len + 2 )
       {
         gindex = status.Num;
         if ( status.encoding != FT_ENCODING_NONE )
           gindex = FTDemo_Get_Index( handle, status.Num );
 
         strcpy( p, format );
         if ( FT_Get_Glyph_Name( face, gindex,
                                 p + format_len, size - format_len ) )
           *p = '\0';
       }
     }
 
     status.header = status.header_buffer;
     grWriteCellString( display->bitmap, 0, HEADER_HEIGHT,
                        status.header_buffer, display->fore_color );
 
     if ( status.use_custom_lcd_filter )
     {
       int             fwi = status.fw_index;
       unsigned char  *fw  = status.filter_weights;
 
 
       sprintf( status.header_buffer,
                "%s0x%02X%s%s0x%02X%s%s0x%02X%s%s0x%02X%s%s0x%02X%s",
                fwi == 0 ? "[" : " ", fw[0], fwi == 0 ? "]" : " ",
                fwi == 1 ? "[" : " ", fw[1], fwi == 1 ? "]" : " ",
                fwi == 2 ? "[" : " ", fw[2], fwi == 2 ? "]" : " ",
                fwi == 3 ? "[" : " ", fw[3], fwi == 3 ? "]" : " ",
                fwi == 4 ? "[" : " ", fw[4], fwi == 4 ? "]" : " " );
       grWriteCellString( display->bitmap, 0, 2 * HEADER_HEIGHT,
                          status.header_buffer, display->fore_color );
     }
 
     grRefreshSurface( display->surface );
   }
 
 
   static void
   usage( char*  execname )
   {
     fprintf( stderr,  "\n" );
     fprintf( stderr,  "ftview: simple glyph viewer -- part of the FreeType project\n" );
     fprintf( stderr,  "-----------------------------------------------------------\n" );
     fprintf( stderr,  "\n" );
     fprintf( stderr,  "Usage: %s [options] pt font ...\n",
              execname );
     fprintf( stderr,  "\n" );
     fprintf( stderr,  "  pt        The point size for the given resolution.\n" );
     fprintf( stderr,  "            If resolution = 72 dpi, this directly gives the\n" );
     fprintf( stderr,  "            ppem value (pixels per EM).\n" );
     fprintf( stderr,  "  font      The font file(s) to display; if no extension is given,\n" );
     fprintf( stderr,  "            ftview tries to append one of the following suffixes:\n" );
     fprintf( stderr,  "            `.ttf', `.ttc', `.otf', `.pfa', `.pfb'.\n" );
     fprintf( stderr,  "            For `.pfa' and `.pfb' files, ftview also tries to\n" );
     fprintf( stderr,  "            attach the corresponding metrics file (with extension\n" );
     fprintf( stderr,  "            `.afm' or `.pfm').\n" );
     fprintf( stderr,  "\n" );
     fprintf( stderr,  "  -r R      Use resolution R dpi (default: 72 dpi).\n" );
     fprintf( stderr,  "  -f index  Specify first index to display.\n" );
     fprintf( stderr,  "  -e enc    Specify encoding tag (default: no encoding).\n" );
     fprintf( stderr,  "  -D        Dump cache usage statistics.\n" );
     fprintf( stderr,  "  -m text   Use `text' for rendering.\n" );
     fprintf( stderr,  "  -l nn     Change rendering mode (0 <= nn <= %d).\n",
              N_LCD_MODES );
     fprintf( stderr,  "  -p        Preload file in memory to simulate memory-mapping.\n" );
     fprintf( stderr,  "\n" );
 
     exit( 1 );
   }
 
 
   static void
   parse_cmdline( int*    argc,
                  char**  argv[] )
   {
     char*  execname;
     int    option;
 
 
     execname = ft_basename( (*argv)[0] );
 
     while ( 1 )
     {
       option = getopt( *argc, *argv, "Dde:f:L:l:r:m:p" );
 
       if ( option == -1 )
         break;
 
       switch ( option )
       {
       case 'd':
         status.debug = 1;
         break;
 
       case 'D':
         status.dump_cache_stats = 1;
         break;
 
       case 'e':
         status.encoding = FTDemo_Make_Encoding_Tag( optarg );
         break;
 
       case 'f':
         status.Num  = atoi( optarg );
         break;
 
       case 'L':
         status.trace_level = atoi( optarg );
         if ( status.trace_level < 1 || status.trace_level > 7 )
           usage( execname );
         break;
 
       case 'l':
         status.lcd_mode = atoi( optarg );
         if ( status.lcd_mode < 0 || status.lcd_mode > N_LCD_MODES )
         {
           fprintf( stderr, "argument to `l' must be between 0 and %d\n",
                    N_LCD_MODES );
           exit( 3 );
         }
         break;
 
       case 'm':
         Text               = (unsigned char*)optarg;
         status.render_mode = RENDER_MODE_TEXT;
         break;
 
       case 'r':
         status.res = atoi( optarg );
         if ( status.res < 1 )
           usage( execname );
         break;
 
       case 'p':
         status.preload = 1;
         break;
 
       default:
         usage( execname );
         break;
       }
     }
 
     *argc -= optind;
     *argv += optind;
 
     if ( *argc <= 1 )
       usage( execname );
 
     status.ptsize = (int)( atof( *argv[0] ) * 64.0 );
     if ( status.ptsize == 0 )
       status.ptsize = 64 * 10;
 
     (*argc)--;
     (*argv)++;
   }
 
 
   int
   main( int    argc,
         char*  argv[] )
   {
     grEvent      event;
 
 
     parse_cmdline( &argc, &argv );
 
 #if FREETYPE_MAJOR == 2 && FREETYPE_MINOR == 0 && FREETYPE_PATCH <= 8
     if ( status.debug )
     {
 #ifdef FT_DEBUG_LEVEL_TRACE
       FT_SetTraceLevel( trace_any, (FT_Byte)status.trace_level );
 #else
       status.trace_level = 0;
 #endif
     }
 #elif 0
        /* `setenv' and `putenv' is not ANSI and I don't want to mess */
        /* with this portability issue right now...                   */
     if ( status.debug )
     {
       char  temp[32];
 
       sprintf( temp, "any=%d", status.trace_level );
       setenv( "FT2_DEBUG", temp );
     }
 #endif
 
     /* Initialize engine */
     handle = FTDemo_New( status.encoding );
 
     FT_Library_SetLcdFilter( handle->library, FT_LCD_FILTER_DEFAULT );
 
     if ( status.preload )
       FTDemo_Set_Preload( handle, 1 );
 
     for ( ; argc > 0; argc--, argv++ )
       FTDemo_Install_Font( handle, argv[0] );
 
     if ( handle->num_fonts == 0 )
       Fatal( "could not find/open any font file" );
 
     display = FTDemo_Display_New( gr_pixel_mode_rgb24 );
     if ( !display )
       Fatal( "could not allocate display surface" );
 
     memset( display->fore_color.chroma, 0, 4 );
     memset( display->back_color.chroma, 0xff, 4 );
     grSetTitle( display->surface,
                 "FreeType Glyph Viewer - press F1 for help" );
 
     status.Fail = 0;
 
     event_font_change( 0 );
 
     if ( status.lcd_mode >= 0 )
       handle->lcd_mode = status.lcd_mode;
 
     FTDemo_Update_Current_Flags( handle );
 
     for ( ;; )
     {
       FTDemo_Display_Clear( display );
 
       switch ( status.render_mode )
       {
       case RENDER_MODE_ALL:
         error = Render_All( handle->current_font->num_indices,
                             status.Num );
         break;
 
       case RENDER_MODE_EMBOLDEN:
         error = Render_Embolden( handle->current_font->num_indices,
                                  status.Num );
         break;
 
       case RENDER_MODE_SLANTED:
         error = Render_Slanted( handle->current_font->num_indices,
                                 status.Num );
         break;
 
       case RENDER_MODE_STROKE:
         error = Render_Stroke( handle->current_font->num_indices,
                                status.Num );
         break;
 
       case RENDER_MODE_TEXT:
         error = Render_Text( -1, status.Num );
         break;
 
       case RENDER_MODE_WATERFALL:
         error = Render_Waterfall( status.ptsize );
         break;
       }
 
       write_header( error );
 
 #if FREETYPE_MAJOR == 2 && FREETYPE_MINOR < 2
       if ( status.dump_cache_stats )
       {
         /* dump simple cache manager statistics */
         fprintf( stderr, "cache manager [ nodes, bytes, average ] = "
                          " [ %d, %ld, %f ]\n",
                          handle->cache_manager->num_nodes,
                          handle->cache_manager->cur_weight,
                          handle->cache_manager->num_nodes > 0
                            ? handle->cache_manager->cur_weight * 1.0 /
                                handle->cache_manager->num_nodes
                            : 0.0 );
       }
 #endif
 
       status.header = 0;
       grListenSurface( display->surface, 0, &event );
       if ( Process_Event( &event ) )
         break;
     }
 
     printf( "Execution completed successfully.\n" );
     printf( "Fails = %d\n", status.Fail );
 
     FTDemo_Display_Done( display );
     FTDemo_Done( handle );
     exit( 0 );      /* for safety reasons */
 
     return 0;       /* never reached */
   }
 
 
 /* End */
