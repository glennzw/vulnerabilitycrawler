   compat: Make compat_alloc_user_space() incorporate the access_ok()
   
   compat_alloc_user_space() expects the caller to independently call
   access_ok() to verify the returned area.  A missing call could
   introduce problems on some architectures.
   
   This patch incorporates the access_ok() check into
   compat_alloc_user_space() and also adds a sanity check on the length.
   The existing compat_alloc_user_space() implementations are renamed
   arch_compat_alloc_user_space() and are used as part of the
   implementation of the new global function.
   
   This patch assumes NULL will cause __get_user()/__put_user() to either
   fail or access userspace on all architectures.  This should be
   followed by checking the return value of compat_access_user_space()
   for NULL in the callers, at which time the access_ok() in the callers
   can also be removed.
   
   Reported-by: Ben Hawkes <hawkes@sota.gen.nz>
   Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
   Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
   Acked-by: Chris Metcalf <cmetcalf@tilera.com>
   Acked-by: David S. Miller <davem@davemloft.net>
   Acked-by: Ingo Molnar <mingo@elte.hu>
   Acked-by: Thomas Gleixner <tglx@linutronix.de>
   Acked-by: Tony Luck <tony.luck@intel.com>
   Cc: Andrew Morton <akpm@linux-foundation.org>
   Cc: Arnd Bergmann <arnd@arndb.de>
   Cc: Fenghua Yu <fenghua.yu@intel.com>
   Cc: H. Peter Anvin <hpa@zytor.com>
   Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
   Cc: Helge Deller <deller@gmx.de>
   Cc: James Bottomley <jejb@parisc-linux.org>
   Cc: Kyle McMartin <kyle@mcmartin.ca>
   Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
   Cc: Paul Mackerras <paulus@samba.org>
   Cc: Ralf Baechle <ralf@linux-mips.org>
   Cc: <stable@kernel.org>
}

static __inline__ void __user *
compat_alloc_user_space (long len)
{
	struct pt_regs *regs = task_pt_regs(current);
	return (void __user *) (((regs->r12 & 0xffffffff) & -16) - len);
	return (u32)(unsigned long)uptr;
}

static inline void __user *compat_alloc_user_space(long len)
{
	struct pt_regs *regs = (struct pt_regs *)
		((unsigned long) current_thread_info() + THREAD_SIZE - 32) - 1;
	return (u32)(unsigned long)uptr;
}

static __inline__ void __user *compat_alloc_user_space(long len)
{
	struct pt_regs *regs = &current->thread.regs;
	return (void __user *)regs->gr[30];
	return (u32)(unsigned long)uptr;
}

static inline void __user *compat_alloc_user_space(long len)
{
	struct pt_regs *regs = current->thread.regs;
	unsigned long usp = regs->gpr[1];

#endif

static inline void __user *compat_alloc_user_space(long len)
{
	unsigned long stack;

	return (u32)(unsigned long)uptr;
}

static inline void __user *compat_alloc_user_space(long len)
{
	struct pt_regs *regs = current_thread_info()->kregs;
	unsigned long usp = regs->u_regs[UREG_I6];
	return (long)(int)(long __force)uptr;
}

static inline void __user *compat_alloc_user_space(long len)
{
	struct pt_regs *regs = task_pt_regs(current);
	return (void __user *)regs->sp - len;
	return (u32)(unsigned long)uptr;
}

static inline void __user *compat_alloc_user_space(long len)
{
	struct pt_regs *regs = task_pt_regs(current);
	return (void __user *)regs->sp - len;
		const struct compat_iovec __user *uvector, unsigned long nr_segs,
		unsigned long fast_segs, struct iovec *fast_pointer,
		struct iovec **ret_pointer);
#endif /* CONFIG_COMPAT */
#endif /* _LINUX_COMPAT_H */

	return 0;
}
