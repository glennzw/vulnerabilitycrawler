commit 1eafbfeb7bdf59cfe173304c76188f3fd5f1fd05
Author: Timo Warns <Warns@pre-sense.de>
Date:   Mon Mar 14 14:59:33 2011 +0100

    Fix corrupted OSF partition table parsing
    
    The kernel automatically evaluates partition tables of storage devices.
    The code for evaluating OSF partitions contains a bug that leaks data
    from kernel heap memory to userspace for certain corrupted OSF
    partitions.
    
    In more detail:
    
      for (i = 0 ; i < le16_to_cpu(label->d_npartitions); i++, partition++) {
    
    iterates from 0 to d_npartitions - 1, where d_npartitions is read from
    the partition table without validation and partition is a pointer to an
    array of at most 8 d_partitions.
    
    Add the proper and obvious validation.
    
    Signed-off-by: Timo Warns <warns@pre-sense.de>
    Cc: stable@kernel.org
    [ Changed the patch trivially to not repeat the whole le16_to_cpu()
      thing, and to use an explicit constant for the magic value '8' ]
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/partitions/osf.c b/fs/partitions/osf.c
index 48cec7c..be03a0b 100644
--- a/fs/partitions/osf.c
+++ b/fs/partitions/osf.c
@@ -10,69 +10,77 @@
 #include "check.h"
 #include "osf.h"
 
+#define MAX_OSF_PARTITIONS 8
+
 int osf_partition(struct parsed_partitions *state)
 {
 	int i;
 	int slot = 1;
+	unsigned int npartitions;
 	Sector sect;
 	unsigned char *data;
 	struct disklabel {
 		__le32 d_magic;
 		__le16 d_type,d_subtype;
 		u8 d_typename[16];
 		u8 d_packname[16];
 		__le32 d_secsize;
 		__le32 d_nsectors;
 		__le32 d_ntracks;
 		__le32 d_ncylinders;
 		__le32 d_secpercyl;
 		__le32 d_secprtunit;
 		__le16 d_sparespertrack;
 		__le16 d_sparespercyl;
 		__le32 d_acylinders;
 		__le16 d_rpm, d_interleave, d_trackskew, d_cylskew;
 		__le32 d_headswitch, d_trkseek, d_flags;
 		__le32 d_drivedata[5];
 		__le32 d_spare[5];
 		__le32 d_magic2;
 		__le16 d_checksum;
 		__le16 d_npartitions;
 		__le32 d_bbsize, d_sbsize;
 		struct d_partition {
 			__le32 p_size;
 			__le32 p_offset;
 			__le32 p_fsize;
 			u8  p_fstype;
 			u8  p_frag;
 			__le16 p_cpg;
-		} d_partitions[8];
+		} d_partitions[MAX_OSF_PARTITIONS];
 	} * label;
 	struct d_partition * partition;
 
 	data = read_part_sector(state, 0, &sect);
 	if (!data)
 		return -1;
 
 	label = (struct disklabel *) (data+64);
 	partition = label->d_partitions;
 	if (le32_to_cpu(label->d_magic) != DISKLABELMAGIC) {
 		put_dev_sector(sect);
 		return 0;
 	}
 	if (le32_to_cpu(label->d_magic2) != DISKLABELMAGIC) {
 		put_dev_sector(sect);
 		return 0;
 	}
-	for (i = 0 ; i < le16_to_cpu(label->d_npartitions); i++, partition++) {
+	npartitions = le16_to_cpu(label->d_npartitions);
+	if (npartitions > MAX_OSF_PARTITIONS) {
+		put_dev_sector(sect);
+		return 0;
+	}
+	for (i = 0 ; i < npartitions; i++, partition++) {
 		if (slot == state->limit)
 		        break;
 		if (le32_to_cpu(partition->p_size))
 			put_partition(state, slot,
 				le32_to_cpu(partition->p_offset),
 				le32_to_cpu(partition->p_size));
 		slot++;
 	}
 	strlcat(state->pp_buf, "\n", PAGE_SIZE);
 	put_dev_sector(sect);
 	return 1;
 }
