commit ab08cc93f2dc6223c8c00bfa1ca4f2d89069dbe0
Author: Chris Coulson <chriscoulson@googlemail.com>
Date:   Thu Jan 28 21:29:17 2010 -0500

    Work around x errors by asking dialog to die on cancel
    
    Basically, what is happening is that gnome-screensaver-dialog exits after the
    5th failed attempt at unlocking the screen, but before the shake animation
    finishes. If the timing is slightly unlucky, this results in gnome-screensaver
    accessing X resources that have already been destroyed (I ran it through
    xtrace, and that showed this happening)
    
    My patch fixes this by making gnome-screensaver-dialog request to
    gnome-screensaver that it be terminated after the 5th failed attempt (rather
    than exitting straight away, although there is a fallback timeout too).
    gnome-screensaver then terminates the dialog after it is finished with the
    shake animation, to avoid the race condition that is currently making it crash.

diff --git a/src/gnome-screensaver-dialog.c b/src/gnome-screensaver-dialog.c
index 88d14a0..9d72fcb 100644
--- a/src/gnome-screensaver-dialog.c
+++ b/src/gnome-screensaver-dialog.c
@@ -1,45 +1,46 @@
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
  *
  * Copyright (C) 2004-2006 William Jon McCann <mccann@jhu.edu>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
  * published by the Free Software Foundation; either version 2 of the
  * License, or (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
  * 02111-1307, USA.
  *
  * Authors: William Jon McCann <mccann@jhu.edu>
  *
  */
 
 #include "config.h"
 
 #include <stdlib.h>
 #include <string.h>
 #include <sys/time.h>
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <unistd.h>
+#include <signal.h>
 
 #include <glib/gi18n.h>
 #include <gdk/gdkx.h>
 #include <gtk/gtk.h>
 
 #include "gs-lock-plug.h"
 
 #include "gs-auth.h"
 #include "setuid.h"
 
 #include "gs-debug.h"
 
 #define MAX_FAILURES 5
 
@@ -326,31 +327,50 @@ response_cb (GSLockPlug *plug,
 }
 
 static gboolean
+response_request_quit (void)
+{
+        printf ("REQUEST QUIT\n");
+        fflush (stdout);
+        return FALSE;
+}
+
+static gboolean
+quit_timeout_cb (gpointer data)
+{
+        gtk_main_quit ();
+        return FALSE;
+}
+
+static gboolean
 auth_check_idle (GSLockPlug *plug)
 {
         gboolean     res;
         gboolean     again;
         static guint loop_counter = 0;
 
         again = TRUE;
         res = do_auth_check (plug);
 
         if (res) {
                 again = FALSE;
                 g_idle_add ((GSourceFunc)quit_response_ok, NULL);
         } else {
                 loop_counter++;
 
                 if (loop_counter < MAX_FAILURES) {
                         gs_debug ("Authentication failed, retrying (%u)", loop_counter);
                         g_timeout_add (3000, (GSourceFunc)reset_idle_cb, plug);
                 } else {
                         gs_debug ("Authentication failed, quitting (max failures)");
                         again = FALSE;
-                        gtk_main_quit ();
+                        /* Don't quit immediately, but rather request that gnome-screensaver
+                         * terminates us after it has finished the dialog shake. Time out
+                         * after 5 seconds and quit anyway if this doesn't happen though */
+                        g_idle_add ((GSourceFunc)response_request_quit, NULL);
+                        g_timeout_add (5000, (GSourceFunc)quit_timeout_cb, NULL);
                 }
         }
 
         return again;
 }
 
diff --git a/src/gs-window-x11.c b/src/gs-window-x11.c
index 5e0ebe5..64428e3 100644
--- a/src/gs-window-x11.c
+++ b/src/gs-window-x11.c
@@ -59,55 +59,57 @@ enum {
 struct GSWindowPrivate
 {
         int        monitor;
 
         GdkRectangle geometry;
         guint      obscured : 1;
 
         guint      lock_enabled : 1;
         guint      user_switch_enabled : 1;
         guint      logout_enabled : 1;
         guint      keyboard_enabled : 1;
 
         guint64    logout_timeout;
         char      *logout_command;
         char      *keyboard_command;
         char      *status_message;
 
         GtkWidget *vbox;
         GtkWidget *drawing_area;
         GtkWidget *lock_box;
         GtkWidget *lock_socket;
         GtkWidget *keyboard_socket;
         GtkWidget *info_bar;
         GtkWidget *info_content;
 
         GdkPixmap *background_pixmap;
 
         guint      popup_dialog_idle_id;
 
         guint      dialog_map_signal_id;
         guint      dialog_unmap_signal_id;
         guint      dialog_response_signal_id;
 
         guint      watchdog_timer_id;
         guint      info_bar_timer_id;
 
         gint       lock_pid;
         gint       lock_watch_id;
         gint       dialog_response;
+        gboolean   dialog_quit_requested;
+        gboolean   dialog_shake_in_progress;
 
         gint       keyboard_pid;
         gint       keyboard_watch_id;
 
         GList     *key_events;
 
         gdouble    last_x;
         gdouble    last_y;
 
         GTimer    *timer;
 
 #ifdef HAVE_SHAPE_EXT
         int        shape_event_base;
 #endif
 };
 
@@ -1455,144 +1457,163 @@ static void
 gs_window_dialog_finish (GSWindow *window)
 {
         g_return_if_fail (GS_IS_WINDOW (window));
 
         gs_debug ("Dialog finished");
 
         /* make sure we finish the keyboard thing too */
         keyboard_command_finish (window);
 
         /* send a signal just in case */
         kill_dialog_command (window);
 
         if (window->priv->lock_pid > 0) {
                 int exit_status;
 
                 exit_status = wait_on_child (window->priv->lock_pid);
 
                 g_spawn_close_pid (window->priv->lock_pid);
                 window->priv->lock_pid = 0;
         }
 
         /* remove events for the case were we failed to show socket */
         remove_key_events (window);
 }
 
+static void
+maybe_kill_dialog (GSWindow *window)
+{
+        if (!window->priv->dialog_shake_in_progress
+            && window->priv->dialog_quit_requested
+            && window->priv->lock_pid > 0) {
+                kill (window->priv->lock_pid, SIGTERM);
+        }
+}
+
 /* very rudimentary animation for indicating an auth failure */
 static void
 shake_dialog (GSWindow *window)
 {
         int   i;
         guint left;
         guint right;
 
+        window->priv->dialog_shake_in_progress = TRUE;
+
         for (i = 0; i < 9; i++) {
                 if (i % 2 == 0) {
                         left = 30;
                         right = 0;
                 } else {
                         left = 0;
                         right = 30;
                 }
 
                 if (! window->priv->lock_box) {
                         break;
                 }
 
                 gtk_alignment_set_padding (GTK_ALIGNMENT (window->priv->lock_box),
                                            0, 0,
                                            left,
                                            right);
 
                 while (gtk_events_pending ()) {
                         gtk_main_iteration ();
                 }
 
                 g_usleep (10000);
         }
+
+        window->priv->dialog_shake_in_progress = FALSE;
+        maybe_kill_dialog (window);
 }
 
 static gboolean
 lock_command_watch (GIOChannel   *source,
                     GIOCondition  condition,
                     GSWindow     *window)
 {
         gboolean finished = FALSE;
 
         g_return_val_if_fail (GS_IS_WINDOW (window), FALSE);
 
         if (condition & G_IO_IN) {
                 GIOStatus status;
                 GError   *error = NULL;
                 char     *line;
 
                 line = NULL;
                 status = g_io_channel_read_line (source, &line, NULL, NULL, &error);
 
                 switch (status) {
                 case G_IO_STATUS_NORMAL:
                         gs_debug ("command output: %s", line);
 
                         if (strstr (line, "WINDOW ID=") != NULL) {
                                 guint32 id;
                                 char    c;
                                 if (1 == sscanf (line, " WINDOW ID= %" G_GUINT32_FORMAT " %c", &id, &c)) {
                                         create_lock_socket (window, id);
                                 }
                         } else if (strstr (line, "NOTICE=") != NULL) {
                                 if (strstr (line, "NOTICE=AUTH FAILED") != NULL) {
                                         shake_dialog (window);
                                 }
                         } else if (strstr (line, "RESPONSE=") != NULL) {
                                 if (strstr (line, "RESPONSE=OK") != NULL) {
                                         gs_debug ("Got OK response");
                                         window->priv->dialog_response = DIALOG_RESPONSE_OK;
                                 } else {
                                         gs_debug ("Got CANCEL response");
                                         window->priv->dialog_response = DIALOG_RESPONSE_CANCEL;
                                 }
                                 finished = TRUE;
+                        } else if (strstr (line, "REQUEST QUIT") != NULL) {
+                                gs_debug ("Got request for quit");
+                                window->priv->dialog_quit_requested = TRUE;
+                                maybe_kill_dialog (window);
                         }
                         break;
                 case G_IO_STATUS_EOF:
                         finished = TRUE;
                         break;
                 case G_IO_STATUS_ERROR:
                         finished = TRUE;
                         gs_debug ("Error reading from child: %s\n", error->message);
                         g_error_free (error);
                         return FALSE;
                 case G_IO_STATUS_AGAIN:
                 default:
                         break;
                 }
 
                 g_free (line);
         } else if (condition & G_IO_HUP) {
                 finished = TRUE;
         }
 
         if (finished) {
                 gs_window_dialog_finish (window);
 
                 if (window->priv->dialog_response == DIALOG_RESPONSE_OK) {
                         add_emit_deactivated_idle (window);
                 }
 
                 gtk_widget_show (window->priv->drawing_area);
 
                 gs_window_clear (window);
                 set_invisible_cursor (GTK_WIDGET (window)->window, TRUE);
                 g_signal_emit (window, signals [DIALOG_DOWN], 0);
 
                 /* reset the pointer positions */
                 window->priv->last_x = -1;
                 window->priv->last_y = -1;
 
                 window->priv->lock_watch_id = 0;
 
                 return FALSE;
         }
 
         return TRUE;
 }
 
@@ -1628,56 +1649,59 @@ static gboolean
 popup_dialog_idle (GSWindow *window)
 {
         gboolean  result;
         char     *tmp;
         GString  *command;
 
         gs_debug ("Popping up dialog");
 
         tmp = g_build_filename (LIBEXECDIR, "gnome-screensaver-dialog", NULL);
         command = g_string_new (tmp);
         g_free (tmp);
 
         if (is_logout_enabled (window)) {
                 command = g_string_append (command, " --enable-logout");
                 g_string_append_printf (command, " --logout-command='%s'", window->priv->logout_command);
         }
 
         if (window->priv->status_message) {
                 char *quoted;
 
                 quoted = g_shell_quote (window->priv->status_message);
                 g_string_append_printf (command, " --status-message=%s", quoted);
                 g_free (quoted);
         }
 
         if (is_user_switch_enabled (window)) {
                 command = g_string_append (command, " --enable-switch");
         }
 
         if (gs_debug_enabled ()) {
                 command = g_string_append (command, " --verbose");
         }
 
         gtk_widget_hide (window->priv->drawing_area);
 
         gs_window_clear_to_background_pixmap (window);
 
         set_invisible_cursor (GTK_WIDGET (window)->window, FALSE);
 
+        window->priv->dialog_quit_requested = FALSE;
+        window->priv->dialog_shake_in_progress = FALSE;
+
         result = spawn_on_window (window,
                                   command->str,
                                   &window->priv->lock_pid,
                                   (GIOFunc)lock_command_watch,
                                   window,
                                   &window->priv->lock_watch_id);
         if (! result) {
                 gs_debug ("Could not start command: %s", command->str);
         }
 
         g_string_free (command, TRUE);
 
         window->priv->popup_dialog_idle_id = 0;
 
         return FALSE;
 }
 
