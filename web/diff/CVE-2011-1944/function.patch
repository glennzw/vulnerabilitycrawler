commit d7958b21e7f8c447a26bb2436f08402b2c308be4
Author: Chris Evans <scarybeasts@gmail.com>
Date:   Wed Mar 23 08:13:06 2011 +0800

    Fix some potential problems on reallocation failures
    
    The count was incremented before the allocation
    and not fixed in case of failure
    * xpath.c: corrects a few instances where the available count of some
               structure is updated before we know the allocation actually
               succeeds

diff --git a/xpath.c b/xpath.c
index 8b56189..608fe00 100644
--- a/xpath.c
+++ b/xpath.c
@@ -3488,56 +3488,56 @@ void
 xmlXPathNodeSetAddNs(xmlNodeSetPtr cur, xmlNodePtr node, xmlNsPtr ns) {
     int i;
 
 
     if ((cur == NULL) || (ns == NULL) || (node == NULL) ||
         (ns->type != XML_NAMESPACE_DECL) ||
 	(node->type != XML_ELEMENT_NODE))
 	return;
 
     /* @@ with_ns to check whether namespace nodes should be looked at @@ */
     /*
      * prevent duplicates
      */
     for (i = 0;i < cur->nodeNr;i++) {
         if ((cur->nodeTab[i] != NULL) &&
 	    (cur->nodeTab[i]->type == XML_NAMESPACE_DECL) &&
 	    (((xmlNsPtr)cur->nodeTab[i])->next == (xmlNsPtr) node) &&
 	    (xmlStrEqual(ns->prefix, ((xmlNsPtr)cur->nodeTab[i])->prefix)))
 	    return;
     }
 
     /*
      * grow the nodeTab if needed
      */
     if (cur->nodeMax == 0) {
         cur->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *
 					     sizeof(xmlNodePtr));
 	if (cur->nodeTab == NULL) {
 	    xmlXPathErrMemory(NULL, "growing nodeset\n");
 	    return;
 	}
 	memset(cur->nodeTab, 0 ,
 	       XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));
         cur->nodeMax = XML_NODESET_DEFAULT;
     } else if (cur->nodeNr == cur->nodeMax) {
         xmlNodePtr *temp;
 
-        cur->nodeMax *= 2;
-	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *
+	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *
 				      sizeof(xmlNodePtr));
 	if (temp == NULL) {
 	    xmlXPathErrMemory(NULL, "growing nodeset\n");
 	    return;
 	}
+        cur->nodeMax *= 2;
 	cur->nodeTab = temp;
     }
     cur->nodeTab[cur->nodeNr++] = xmlXPathNodeSetDupNs(node, ns);
 }
 
 /**
  * xmlXPathNodeSetAdd:
  * @cur:  the initial node set
  * @val:  a new xmlNodePtr
  *
  * add a new xmlNodePtr to an existing NodeSet
  */
@@ -3605,53 +3605,53 @@ void
 xmlXPathNodeSetAddUnique(xmlNodeSetPtr cur, xmlNodePtr val) {
     if ((cur == NULL) || (val == NULL)) return;
 
 #if 0
     if ((val->type == XML_ELEMENT_NODE) && (val->name[0] == ' '))
 	return;	/* an XSLT fake node */
 #endif
 
     /* @@ with_ns to check whether namespace nodes should be looked at @@ */
     /*
      * grow the nodeTab if needed
      */
     if (cur->nodeMax == 0) {
         cur->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *
 					     sizeof(xmlNodePtr));
 	if (cur->nodeTab == NULL) {
 	    xmlXPathErrMemory(NULL, "growing nodeset\n");
 	    return;
 	}
 	memset(cur->nodeTab, 0 ,
 	       XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));
         cur->nodeMax = XML_NODESET_DEFAULT;
     } else if (cur->nodeNr == cur->nodeMax) {
         xmlNodePtr *temp;
 
-        cur->nodeMax *= 2;
-	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *
+	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *
 				      sizeof(xmlNodePtr));
 	if (temp == NULL) {
 	    xmlXPathErrMemory(NULL, "growing nodeset\n");
 	    return;
 	}
 	cur->nodeTab = temp;
+        cur->nodeMax *= 2;
     }
     if (val->type == XML_NAMESPACE_DECL) {
 	xmlNsPtr ns = (xmlNsPtr) val;
 
 	cur->nodeTab[cur->nodeNr++] =
 	    xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);
     } else
 	cur->nodeTab[cur->nodeNr++] = val;
 }
 
 /**
  * xmlXPathNodeSetMerge:
  * @val1:  the first NodeSet or NULL
  * @val2:  the second NodeSet
  *
  * Merges two nodesets, all nodes from @val2 are added to @val1
  * if @val1 is NULL, a new set is created and copied from @val2
  *
  * Returns @val1 once extended or NULL in case of error.
  */
@@ -3659,114 +3659,114 @@ xmlNodeSetPtr
 xmlXPathNodeSetMerge(xmlNodeSetPtr val1, xmlNodeSetPtr val2) {
     int i, j, initNr, skip;
     xmlNodePtr n1, n2;
 
     if (val2 == NULL) return(val1);
     if (val1 == NULL) {
 	val1 = xmlXPathNodeSetCreate(NULL);
     if (val1 == NULL)
         return (NULL);
 #if 0
 	/*
 	* TODO: The optimization won't work in every case, since
 	*  those nasty namespace nodes need to be added with
 	*  xmlXPathNodeSetDupNs() to the set; thus a pure
 	*  memcpy is not possible.
 	*  If there was a flag on the nodesetval, indicating that
 	*  some temporary nodes are in, that would be helpfull.
 	*/
 	/*
 	* Optimization: Create an equally sized node-set
 	* and memcpy the content.
 	*/
 	val1 = xmlXPathNodeSetCreateSize(val2->nodeNr);
 	if (val1 == NULL)
 	    return(NULL);
 	if (val2->nodeNr != 0) {
 	    if (val2->nodeNr == 1)
 		*(val1->nodeTab) = *(val2->nodeTab);
 	    else {
 		memcpy(val1->nodeTab, val2->nodeTab,
 		    val2->nodeNr * sizeof(xmlNodePtr));
 	    }
 	    val1->nodeNr = val2->nodeNr;
 	}
 	return(val1);
 #endif
     }
 
     /* @@ with_ns to check whether namespace nodes should be looked at @@ */
     initNr = val1->nodeNr;
 
     for (i = 0;i < val2->nodeNr;i++) {
 	n2 = val2->nodeTab[i];
 	/*
 	 * check against duplicates
 	 */
 	skip = 0;
 	for (j = 0; j < initNr; j++) {
 	    n1 = val1->nodeTab[j];
 	    if (n1 == n2) {
 		skip = 1;
 		break;
 	    } else if ((n1->type == XML_NAMESPACE_DECL) &&
 		       (n2->type == XML_NAMESPACE_DECL)) {
 		if ((((xmlNsPtr) n1)->next == ((xmlNsPtr) n2)->next) &&
 		    (xmlStrEqual(((xmlNsPtr) n1)->prefix,
 			((xmlNsPtr) n2)->prefix)))
 		{
 		    skip = 1;
 		    break;
 		}
 	    }
 	}
 	if (skip)
 	    continue;
 
 	/*
 	 * grow the nodeTab if needed
 	 */
 	if (val1->nodeMax == 0) {
 	    val1->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *
 						    sizeof(xmlNodePtr));
 	    if (val1->nodeTab == NULL) {
 	        xmlXPathErrMemory(NULL, "merging nodeset\n");
 		return(NULL);
 	    }
 	    memset(val1->nodeTab, 0 ,
 		   XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));
 	    val1->nodeMax = XML_NODESET_DEFAULT;
 	} else if (val1->nodeNr == val1->nodeMax) {
 	    xmlNodePtr *temp;
 
-	    val1->nodeMax *= 2;
-	    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax *
+	    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax * 2 *
 					     sizeof(xmlNodePtr));
 	    if (temp == NULL) {
 	        xmlXPathErrMemory(NULL, "merging nodeset\n");
 		return(NULL);
 	    }
 	    val1->nodeTab = temp;
+	    val1->nodeMax *= 2;
 	}
 	if (n2->type == XML_NAMESPACE_DECL) {
 	    xmlNsPtr ns = (xmlNsPtr) n2;
 
 	    val1->nodeTab[val1->nodeNr++] =
 		xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);
 	} else
 	    val1->nodeTab[val1->nodeNr++] = n2;
     }
 
     return(val1);
 }
 
 #if 0 /* xmlXPathNodeSetMergeUnique() is currently not used anymore */
 /**
  * xmlXPathNodeSetMergeUnique:
  * @val1:  the first NodeSet or NULL
  * @val2:  the second NodeSet
  *
  * Merges two nodesets, all nodes from @val2 are added to @val1
  * if @val1 is NULL, a new set is created and copied from @val2
  *
  * Returns @val1 once extended or NULL in case of error.
  */
@@ -3838,88 +3838,88 @@ static xmlNodeSetPtr
 xmlXPathNodeSetMergeAndClear(xmlNodeSetPtr set1, xmlNodeSetPtr set2,
 			     int hasNullEntries)
 {
     if ((set1 == NULL) && (hasNullEntries == 0)) {
 	/*
 	* Note that doing a memcpy of the list, namespace nodes are
 	* just assigned to set1, since set2 is cleared anyway.
 	*/
 	set1 = xmlXPathNodeSetCreateSize(set2->nodeNr);
 	if (set1 == NULL)
 	    return(NULL);
 	if (set2->nodeNr != 0) {
 	    memcpy(set1->nodeTab, set2->nodeTab,
 		set2->nodeNr * sizeof(xmlNodePtr));
 	    set1->nodeNr = set2->nodeNr;
 	}
     } else {
 	int i, j, initNbSet1;
 	xmlNodePtr n1, n2;
 
 	if (set1 == NULL)
             set1 = xmlXPathNodeSetCreate(NULL);
         if (set1 == NULL)
             return (NULL);
 
 	initNbSet1 = set1->nodeNr;
 	for (i = 0;i < set2->nodeNr;i++) {
 	    n2 = set2->nodeTab[i];
 	    /*
 	    * Skip NULLed entries.
 	    */
 	    if (n2 == NULL)
 		continue;
 	    /*
 	    * Skip duplicates.
 	    */
 	    for (j = 0; j < initNbSet1; j++) {
 		n1 = set1->nodeTab[j];
 		if (n1 == n2) {
 		    goto skip_node;
 		} else if ((n1->type == XML_NAMESPACE_DECL) &&
 		    (n2->type == XML_NAMESPACE_DECL))
 		{
 		    if ((((xmlNsPtr) n1)->next == ((xmlNsPtr) n2)->next) &&
 			(xmlStrEqual(((xmlNsPtr) n1)->prefix,
 			((xmlNsPtr) n2)->prefix)))
 		    {
 			/*
 			* Free the namespace node.
 			*/
 			set2->nodeTab[i] = NULL;
 			xmlXPathNodeSetFreeNs((xmlNsPtr) n2);
 			goto skip_node;
 		    }
 		}
 	    }
 	    /*
 	    * grow the nodeTab if needed
 	    */
 	    if (set1->nodeMax == 0) {
 		set1->nodeTab = (xmlNodePtr *) xmlMalloc(
 		    XML_NODESET_DEFAULT * sizeof(xmlNodePtr));
 		if (set1->nodeTab == NULL) {
 		    xmlXPathErrMemory(NULL, "merging nodeset\n");
 		    return(NULL);
 		}
 		memset(set1->nodeTab, 0,
 		    XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));
 		set1->nodeMax = XML_NODESET_DEFAULT;
 	    } else if (set1->nodeNr >= set1->nodeMax) {
 		xmlNodePtr *temp;
 
-		set1->nodeMax *= 2;
 		temp = (xmlNodePtr *) xmlRealloc(
-		    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));
+		    set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));
 		if (temp == NULL) {
 		    xmlXPathErrMemory(NULL, "merging nodeset\n");
 		    return(NULL);
 		}
 		set1->nodeTab = temp;
+		set1->nodeMax *= 2;
 	    }
 	    if (n2->type == XML_NAMESPACE_DECL) {
 		xmlNsPtr ns = (xmlNsPtr) n2;
 
 		set1->nodeTab[set1->nodeNr++] =
 		    xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);
 	    } else
 		set1->nodeTab[set1->nodeNr++] = n2;
@@ -3947,70 +3947,70 @@ static xmlNodeSetPtr
 xmlXPathNodeSetMergeAndClearNoDupls(xmlNodeSetPtr set1, xmlNodeSetPtr set2,
 				    int hasNullEntries)
 {
     if (set2 == NULL)
 	return(set1);
     if ((set1 == NULL) && (hasNullEntries == 0)) {
 	/*
 	* Note that doing a memcpy of the list, namespace nodes are
 	* just assigned to set1, since set2 is cleared anyway.
 	*/
 	set1 = xmlXPathNodeSetCreateSize(set2->nodeNr);
 	if (set1 == NULL)
 	    return(NULL);
 	if (set2->nodeNr != 0) {
 	    memcpy(set1->nodeTab, set2->nodeTab,
 		set2->nodeNr * sizeof(xmlNodePtr));
 	    set1->nodeNr = set2->nodeNr;
 	}
     } else {
 	int i;
 	xmlNodePtr n2;
 
 	if (set1 == NULL)
 	    set1 = xmlXPathNodeSetCreate(NULL);
         if (set1 == NULL)
             return (NULL);
 
 	for (i = 0;i < set2->nodeNr;i++) {
 	    n2 = set2->nodeTab[i];
 	    /*
 	    * Skip NULLed entries.
 	    */
 	    if (n2 == NULL)
 		continue;
 	    if (set1->nodeMax == 0) {
 		set1->nodeTab = (xmlNodePtr *) xmlMalloc(
 		    XML_NODESET_DEFAULT * sizeof(xmlNodePtr));
 		if (set1->nodeTab == NULL) {
 		    xmlXPathErrMemory(NULL, "merging nodeset\n");
 		    return(NULL);
 		}
 		memset(set1->nodeTab, 0,
 		    XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));
 		set1->nodeMax = XML_NODESET_DEFAULT;
 	    } else if (set1->nodeNr >= set1->nodeMax) {
 		xmlNodePtr *temp;
 
-		set1->nodeMax *= 2;
 		temp = (xmlNodePtr *) xmlRealloc(
-		    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));
+		    set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));
 		if (temp == NULL) {
 		    xmlXPathErrMemory(NULL, "merging nodeset\n");
 		    return(NULL);
 		}
 		set1->nodeTab = temp;
+		set1->nodeMax *= 2;
 	    }
 	    set1->nodeTab[set1->nodeNr++] = n2;
 	}
     }
     set2->nodeNr = 0;
     return(set1);
 }
 
 /**
  * xmlXPathNodeSetDel:
  * @cur:  the initial node set
  * @val:  an xmlNodePtr
  *
  * Removes an xmlNodePtr from an existing NodeSet
  */
