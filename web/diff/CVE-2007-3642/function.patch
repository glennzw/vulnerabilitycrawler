commit 25845b5155b55cd77e42655ec24161ba3feffa47
Author: Jing Min Zhao <zhaojingmin@vivecode.com>
Date:   Thu Jul 5 17:05:01 2007 -0700

    [NETFILTER]: nf_conntrack_h323: add checking of out-of-range on choices' index values
    
    Choices' index values may be out of range while still encoded in the fixed
    length bit-field. This bug may cause access to undefined types (NULL
    pointers) and thus crashes (Reported by Zhongling Wen).
    
    This patch also adds checking of decode flag when decoding SEQUENCEs.
    
    Signed-off-by: Jing Min Zhao <zhaojingmin@vivecode.com>
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/netfilter/nf_conntrack_h323_asn1.c b/net/netfilter/nf_conntrack_h323_asn1.c
index f6fad71..6b7eaa0 100644
--- a/net/netfilter/nf_conntrack_h323_asn1.c
+++ b/net/netfilter/nf_conntrack_h323_asn1.c
@@ -483,116 +483,116 @@ int decode_bmpstr(bitstr_t * bs, field_t * f, char *base, int level)
 int decode_seq(bitstr_t * bs, field_t * f, char *base, int level)
 {
 	unsigned ext, bmp, i, opt, len = 0, bmp2, bmp2_len;
 	int err;
 	field_t *son;
 	unsigned char *beg = NULL;
 
 	PRINT("%*.s%s\n", level * TAB_SIZE, " ", f->name);
 
 	/* Decode? */
 	base = (base && (f->attr & DECODE)) ? base + f->offset : NULL;
 
 	/* Extensible? */
 	ext = (f->attr & EXT) ? get_bit(bs) : 0;
 
 	/* Get fields bitmap */
 	bmp = get_bitmap(bs, f->sz);
 	if (base)
 		*(unsigned *) base = bmp;
 
 	/* Decode the root components */
 	for (i = opt = 0, son = f->fields; i < f->lb; i++, son++) {
 		if (son->attr & STOP) {
 			PRINT("%*.s%s\n", (level + 1) * TAB_SIZE, " ",
 			      son->name);
 			return H323_ERROR_STOP;
 		}
 
 		if (son->attr & OPT) {	/* Optional component */
 			if (!((0x80000000U >> (opt++)) & bmp))	/* Not exist */
 				continue;
 		}
 
 		/* Decode */
 		if (son->attr & OPEN) {	/* Open field */
 			CHECK_BOUND(bs, 2);
 			len = get_len(bs);
 			CHECK_BOUND(bs, len);
-			if (!base) {
+			if (!base || !(son->attr & DECODE)) {
 				PRINT("%*.s%s\n", (level + 1) * TAB_SIZE,
 				      " ", son->name);
 				bs->cur += len;
 				continue;
 			}
 			beg = bs->cur;
 
 			/* Decode */
 			if ((err = (Decoders[son->type]) (bs, son, base,
 							  level + 1)) <
 			    H323_ERROR_NONE)
 				return err;
 
 			bs->cur = beg + len;
 			bs->bit = 0;
 		} else if ((err = (Decoders[son->type]) (bs, son, base,
 							 level + 1)) <
 			   H323_ERROR_NONE)
 			return err;
 	}
 
 	/* No extension? */
 	if (!ext)
 		return H323_ERROR_NONE;
 
 	/* Get the extension bitmap */
 	bmp2_len = get_bits(bs, 7) + 1;
 	CHECK_BOUND(bs, (bmp2_len + 7) >> 3);
 	bmp2 = get_bitmap(bs, bmp2_len);
 	bmp |= bmp2 >> f->sz;
 	if (base)
 		*(unsigned *) base = bmp;
 	BYTE_ALIGN(bs);
 
 	/* Decode the extension components */
 	for (opt = 0; opt < bmp2_len; opt++, i++, son++) {
 		if (i < f->ub && son->attr & STOP) {
 			PRINT("%*.s%s\n", (level + 1) * TAB_SIZE, " ",
 			      son->name);
 			return H323_ERROR_STOP;
 		}
 
 		if (!((0x80000000 >> opt) & bmp2))	/* Not present */
 			continue;
 
 		/* Check Range */
 		if (i >= f->ub) {	/* Newer Version? */
 			CHECK_BOUND(bs, 2);
 			len = get_len(bs);
 			CHECK_BOUND(bs, len);
 			bs->cur += len;
 			continue;
 		}
 
 		CHECK_BOUND(bs, 2);
 		len = get_len(bs);
 		CHECK_BOUND(bs, len);
 		if (!base || !(son->attr & DECODE)) {
 			PRINT("%*.s%s\n", (level + 1) * TAB_SIZE, " ",
 			      son->name);
 			bs->cur += len;
 			continue;
 		}
 		beg = bs->cur;
 
 		if ((err = (Decoders[son->type]) (bs, son, base,
 						  level + 1)) <
 		    H323_ERROR_NONE)
 			return err;
 
 		bs->cur = beg + len;
 		bs->bit = 0;
 	}
 	return H323_ERROR_NONE;
 }
 
 /****************************************************************************/
@@ -688,67 +688,69 @@ int decode_seqof(bitstr_t * bs, field_t * f, char *base, int level)
 int decode_choice(bitstr_t * bs, field_t * f, char *base, int level)
 {
 	unsigned type, ext, len = 0;
 	int err;
 	field_t *son;
 	unsigned char *beg = NULL;
 
 	PRINT("%*.s%s\n", level * TAB_SIZE, " ", f->name);
 
 	/* Decode? */
 	base = (base && (f->attr & DECODE)) ? base + f->offset : NULL;
 
 	/* Decode the choice index number */
 	if ((f->attr & EXT) && get_bit(bs)) {
 		ext = 1;
 		type = get_bits(bs, 7) + f->lb;
 	} else {
 		ext = 0;
 		type = get_bits(bs, f->sz);
+		if (type >= f->lb)
+			return H323_ERROR_RANGE;
 	}
 
 	/* Write Type */
 	if (base)
 		*(unsigned *) base = type;
 
 	/* Check Range */
 	if (type >= f->ub) {	/* Newer version? */
 		BYTE_ALIGN(bs);
 		len = get_len(bs);
 		CHECK_BOUND(bs, len);
 		bs->cur += len;
 		return H323_ERROR_NONE;
 	}
 
 	/* Transfer to son level */
 	son = &f->fields[type];
 	if (son->attr & STOP) {
 		PRINT("%*.s%s\n", (level + 1) * TAB_SIZE, " ", son->name);
 		return H323_ERROR_STOP;
 	}
 
 	if (ext || (son->attr & OPEN)) {
 		BYTE_ALIGN(bs);
 		len = get_len(bs);
 		CHECK_BOUND(bs, len);
 		if (!base || !(son->attr & DECODE)) {
 			PRINT("%*.s%s\n", (level + 1) * TAB_SIZE, " ",
 			      son->name);
 			bs->cur += len;
 			return H323_ERROR_NONE;
 		}
 		beg = bs->cur;
 
 		if ((err = (Decoders[son->type]) (bs, son, base, level + 1)) <
 		    H323_ERROR_NONE)
 			return err;
 
 		bs->cur = beg + len;
 		bs->bit = 0;
 	} else if ((err = (Decoders[son->type]) (bs, son, base, level + 1)) <
 		   H323_ERROR_NONE)
 		return err;
 
 	return H323_ERROR_NONE;
 }
 
 /****************************************************************************/
