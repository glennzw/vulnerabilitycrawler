commit d859e6b9537af2d7326276f70de25a840f554dc3
Author: RÃ©mi Denis-Courmont <rdenis@simphalempin.com>
Date:   Sun Oct 19 12:26:23 2008 +0300

    Fix some integer overflows and a stupid memset() invocation

diff --git a/modules/demux/ty.c b/modules/demux/ty.c
index 49d7ab6..11511b4 100644
--- a/modules/demux/ty.c
+++ b/modules/demux/ty.c
@@ -216,44 +216,44 @@ typedef struct
 struct demux_sys_t
 {
   es_out_id_t *p_video;               /* ptr to video codec */
   es_out_id_t *p_audio;               /* holds either ac3 or mpeg codec ptr */
 
   cc_data_t   cc;
   es_out_id_t *p_cc[4];
 
   xds_t       xds;
 
   int             i_cur_chunk;
   int             i_stuff_cnt;
   size_t          i_stream_size;      /* size of input stream (if known) */
   //uint64_t        l_program_len;      /* length of this stream in msec */
   bool      b_seekable;         /* is this stream seekable? */
   bool      b_have_master;      /* are master chunks present? */
   tivo_type_t     tivo_type;          /* tivo type (SA / DTiVo) */
   tivo_series_t   tivo_series;        /* Series1 or Series2 */
   tivo_audio_t    audio_type;         /* AC3 or MPEG */
   int             i_Pes_Length;       /* Length of Audio PES header */
   int             i_Pts_Offset;       /* offset into audio PES of PTS */
   uint8_t         pes_buffer[20];     /* holds incomplete pes headers */
   int             i_pes_buf_cnt;      /* how many bytes in our buffer */
   size_t          l_ac3_pkt_size;     /* len of ac3 pkt we've seen so far */
   uint64_t        l_last_ty_pts;      /* last TY timestamp we've seen */
   //mtime_t         l_last_ty_pts_sync; /* audio PTS at time of last TY PTS */
   uint64_t        l_first_ty_pts;     /* first TY PTS in this master chunk */
   uint64_t        l_final_ty_pts;     /* final TY PTS in this master chunk */
-  int             i_seq_table_size;   /* number of entries in SEQ table */
-  int             i_bits_per_seq_entry; /* # of bits in SEQ table bitmask */
+  unsigned        i_seq_table_size;   /* number of entries in SEQ table */
+  unsigned        i_bits_per_seq_entry; /* # of bits in SEQ table bitmask */
 
   mtime_t         firstAudioPTS;
   mtime_t         lastAudioPTS;
   mtime_t         lastVideoPTS;
 
   ty_rec_hdr_t    *rec_hdrs;          /* record headers array */
   int             i_cur_rec;          /* current record in this chunk */
   int             i_num_recs;         /* number of recs in this chunk */
   int             i_seq_rec;          /* record number where seq start is */
   ty_seq_table_t  *seq_table;         /* table of SEQ entries from mstr chk */
   bool      eof;
   bool      b_first_chunk;
 };
 
@@ -1050,55 +1050,56 @@ static int DemuxRecCc( demux_t *p_demux, ty_rec_hdr_t *rec_hdr, block_t *p_block
 static int ty_stream_seek_pct(demux_t *p_demux, double seek_pct)
 {
     demux_sys_t *p_sys = p_demux->p_sys;
     int64_t seek_pos = p_sys->i_stream_size * seek_pct;
-    int i, i_cur_part;
     long l_skip_amt;
+    int i;
+    unsigned i_cur_part;
 
     /* if we're not seekable, there's nothing to do */
     if (!p_sys->b_seekable)
         return VLC_EGENERIC;
 
     /* figure out which part & chunk we want & go there */
     i_cur_part = seek_pos / TIVO_PART_LENGTH;
     p_sys->i_cur_chunk = seek_pos / CHUNK_SIZE;
     
     /* try to read the part header (master chunk) if it's there */
     if ( stream_Seek( p_demux->s, i_cur_part * TIVO_PART_LENGTH ))
     {
         /* can't seek stream */
         return VLC_EGENERIC;
     }
     parse_master(p_demux);
 
     /* now for the actual chunk */
     if ( stream_Seek( p_demux->s, p_sys->i_cur_chunk * CHUNK_SIZE))
     {
         /* can't seek stream */
         return VLC_EGENERIC;
     }
     /* load the chunk */
     p_sys->i_stuff_cnt = 0;
     get_chunk_header(p_demux);
   
     /* seek within the chunk to get roughly to where we want */
     p_sys->i_cur_rec = (int)
       ((double) ((seek_pos % CHUNK_SIZE) / (double) (CHUNK_SIZE)) * p_sys->i_num_recs);
     msg_Dbg(p_demux, "Seeked to file pos %"PRId64, seek_pos);
     msg_Dbg(p_demux, " (chunk %d, record %d)",
              p_sys->i_cur_chunk - 1, p_sys->i_cur_rec);
 
     /* seek to the start of this record's data.
      * to do that, we have to skip past all prior records */
     l_skip_amt = 0;
     for (i=0; i<p_sys->i_cur_rec; i++)
         l_skip_amt += p_sys->rec_hdrs[i].l_rec_size;
     stream_Seek(p_demux->s, ((p_sys->i_cur_chunk-1) * CHUNK_SIZE) +
                  (p_sys->i_num_recs * 16) + l_skip_amt + 4);
 
     /* to hell with syncing any audio or video, just start reading records... :) */
     /*p_sys->lastAudioPTS = p_sys->lastVideoPTS = 0;*/
     return VLC_SUCCESS;
 }
 
 /* XDS decoder */
 //#define TY_XDS_DEBUG
@@ -1472,208 +1473,213 @@ static void DemuxDecodeXds( demux_t *p_demux, uint8_t d1, uint8_t d2 )
 static int ty_stream_seek_time(demux_t *p_demux, uint64_t l_seek_time)
 {
     demux_sys_t *p_sys = p_demux->p_sys;
-    int i, i_seq_entry = 0;
+    int i_seq_entry = 0;
     int i_skip_cnt;
+    unsigned i;
     long l_cur_pos = stream_Tell(p_demux->s);
-    int i_cur_part = l_cur_pos / TIVO_PART_LENGTH;
+    unsigned i_cur_part = l_cur_pos / TIVO_PART_LENGTH;
     long l_seek_secs = l_seek_time / 1000000000;
     uint64_t l_fwd_stamp = 1;
 
     /* if we're not seekable, there's nothing to do */
     if (!p_sys->b_seekable || !p_sys->b_have_master)
         return VLC_EGENERIC;
 
     msg_Dbg(p_demux, "Skipping to time %02ld:%02ld:%02ld",
             l_seek_secs / 3600, (l_seek_secs / 60) % 60, l_seek_secs % 60);
 
     /* seek to the proper segment if necessary */
     /* first see if we need to go back */
     while (l_seek_time < p_sys->l_first_ty_pts) {
         msg_Dbg(p_demux, "skipping to prior segment.");
         /* load previous part */
         if (i_cur_part == 0) {
             stream_Seek(p_demux->s, l_cur_pos);
             msg_Err(p_demux, "Attempt to seek past BOF");
             return VLC_EGENERIC;
         }
         stream_Seek(p_demux->s, (i_cur_part - 1) * TIVO_PART_LENGTH);
         i_cur_part--;
         parse_master(p_demux);
     }
     /* maybe we need to go forward */
     while (l_seek_time > p_sys->l_final_ty_pts) {
         msg_Dbg(p_demux, "skipping to next segment.");
         /* load next part */
         if ((i_cur_part + 1) * TIVO_PART_LENGTH > p_sys->i_stream_size) {
             /* error; restore previous file position */
             stream_Seek(p_demux->s, l_cur_pos);
             msg_Err(p_demux, "seek error");
             return VLC_EGENERIC;
         }
         stream_Seek(p_demux->s, (i_cur_part + 1) * TIVO_PART_LENGTH);
         i_cur_part++;
         parse_master(p_demux);
     }
 
     /* our target is somewhere within this part;
        find the proper chunk using seq_table */
     for (i=1; i<p_sys->i_seq_table_size; i++) {
         if (p_sys->seq_table[i].l_timestamp > l_seek_time) {
             /* i-1 is the section we want; remember the next timestamp in case
                we have to use it (this section may not have a proper SEQ hdr
                for the time we're seeking) */
             msg_Dbg(p_demux, "stopping at seq entry %d.", i);
             l_fwd_stamp = p_sys->seq_table[i].l_timestamp;
             i_seq_entry = i-1;
             break;
         }
     }
     
     /* if we went through the entire last loop and didn't find our target,
        then we skip to the next part.  What has happened is that the actual
        time we're seeking is within this part, but there isn't a SEQ hdr
        for it here.  So we skip to the next part */
     if (i == p_sys->i_seq_table_size) {
         if ((i_cur_part + 1) * TIVO_PART_LENGTH > p_sys->i_stream_size) {
             /* error; restore previous file position */
             stream_Seek(p_demux->s, l_cur_pos);
             msg_Err(p_demux, "seek error");
             return VLC_EGENERIC;
         }
         stream_Seek(p_demux->s, (i_cur_part + 1) * TIVO_PART_LENGTH);
         i_cur_part++;
         parse_master(p_demux);
         i_seq_entry = 0;
     }     
      
     /* determine which chunk has our seek_time */
     for (i=0; i<p_sys->i_bits_per_seq_entry; i++) {
         long l_chunk_nr = i_seq_entry * p_sys->i_bits_per_seq_entry + i;
         long l_chunk_offset = (l_chunk_nr + 1) * CHUNK_SIZE;
         msg_Dbg(p_demux, "testing part %d chunk %ld mask 0x%02X bit %d",
             i_cur_part, l_chunk_nr,
             p_sys->seq_table[i_seq_entry].chunk_bitmask[i/8], i%8);
         if (p_sys->seq_table[i_seq_entry].chunk_bitmask[i/8] & (1 << (i%8))) {
             /* check this chunk's SEQ header timestamp */
             msg_Dbg(p_demux, "has SEQ. seeking to chunk at 0x%lX",
                 (i_cur_part * TIVO_PART_LENGTH) + l_chunk_offset);
             stream_Seek(p_demux->s, (i_cur_part * TIVO_PART_LENGTH) +
                 l_chunk_offset);
             // TODO: we don't have to parse the full header set;
             // just test the seq_rec entry for its timestamp
             p_sys->i_stuff_cnt = 0;
             get_chunk_header(p_demux);
             // check ty PTS for the SEQ entry in this chunk
             if (p_sys->i_seq_rec < 0 || p_sys->i_seq_rec > p_sys->i_num_recs) {
                 msg_Err(p_demux, "no SEQ hdr in chunk; table had one.");
                 /* Seek to beginning of original chunk & reload it */
                 stream_Seek(p_demux->s, (l_cur_pos / CHUNK_SIZE) * CHUNK_SIZE);
                 p_sys->i_stuff_cnt = 0;
                 get_chunk_header(p_demux);
                 return VLC_EGENERIC;
             }
             l_seek_secs = p_sys->rec_hdrs[p_sys->i_seq_rec].l_ty_pts /
                 1000000000;
             msg_Dbg(p_demux, "found SEQ hdr for timestamp %02ld:%02ld:%02ld",
                 l_seek_secs / 3600,
                 (l_seek_secs / 60) % 60, l_seek_secs % 60);
             if (p_sys->rec_hdrs[p_sys->i_seq_rec].l_ty_pts >= l_seek_time) {
                 // keep this one?  go back?
                 /* for now, we take this one.  it's the first SEQ hdr AFTER
                    the time we were searching for. */
                 msg_Dbg(p_demux, "seek target found.");
                 break;
             }
             msg_Dbg(p_demux, "timestamp too early. still scanning.");
         }
     }
     /* if we made it through this entire loop without finding our target,
        then we skip to the next section.  What has happened is that the actual
        time we're seeking is within this section, but there isn't a SEQ hdr
        for it here.  So we skip to the next closest one (l_fwd_stamp) */
     if (i == p_sys->i_bits_per_seq_entry)
         return ty_stream_seek_time(p_demux, l_fwd_stamp);
 
     /* current stream ptr is at beginning of data for this chunk,
        so we need to skip past any stream data prior to the seq_rec
        in this chunk */
     i_skip_cnt = 0;
-    for (i=0; i<p_sys->i_seq_rec; i++)
-        i_skip_cnt += p_sys->rec_hdrs[i].l_rec_size;
+    for (int j=0; j<p_sys->i_seq_rec; j++)
+        i_skip_cnt += p_sys->rec_hdrs[j].l_rec_size;
     stream_Read(p_demux->s, NULL, i_skip_cnt);
     p_sys->i_cur_rec = p_sys->i_seq_rec;
     //p_sys->l_last_ty_pts = p_sys->rec_hdrs[p_sys->i_seq_rec].l_ty_pts;
     //p_sys->l_last_ty_pts_sync = p_sys->lastAudioPTS;
 
     return VLC_SUCCESS;
 }
 
 
 /* parse a master chunk, filling the SEQ table and other variables.
  * We assume the stream is currently pointing to it.
  */
 static void parse_master(demux_t *p_demux)
 {
     demux_sys_t *p_sys = p_demux->p_sys;
     uint8_t mst_buf[32];
-    int i, i_map_size;
+    uint32_t i, i_map_size;
     int64_t i_save_pos = stream_Tell(p_demux->s);
     int64_t i_pts_secs;
 
     /* Note that the entries in the SEQ table in the stream may have
        different sizes depending on the bits per entry.  We store them
        all in the same size structure, so we have to parse them out one
        by one.  If we had a dynamic structure, we could simply read the
        entire table directly from the stream into memory in place. */
 
     /* clear the SEQ table */
     free(p_sys->seq_table);
     
     /* parse header info */
     stream_Read(p_demux->s, mst_buf, 32);
     i_map_size = U32_AT(&mst_buf[20]);  /* size of bitmask, in bytes */
     p_sys->i_bits_per_seq_entry = i_map_size * 8;
     i = U32_AT(&mst_buf[28]);   /* size of SEQ table, in bytes */
     p_sys->i_seq_table_size = i / (8 + i_map_size);
 
     /* parse all the entries */
-    p_sys->seq_table = malloc(p_sys->i_seq_table_size * sizeof(ty_seq_table_t));
-    for (i=0; i<p_sys->i_seq_table_size; i++) {
+    p_sys->seq_table = calloc(p_sys->i_seq_table_size, sizeof(ty_seq_table_t));
+    if (p_sys->seq_table == NULL)
+    {
+        p_sys->i_seq_table_size = 0;
+        return;
+    }
+    for (unsigned i=0; i<p_sys->i_seq_table_size; i++) {
         stream_Read(p_demux->s, mst_buf, 8);
         p_sys->seq_table[i].l_timestamp = U64_AT(&mst_buf[0]);
         if (i_map_size > 8) {
             msg_Err(p_demux, "Unsupported SEQ bitmap size in master chunk");
             stream_Read(p_demux->s, NULL, i_map_size);
-            memset(p_sys->seq_table[i].chunk_bitmask, i_map_size, 0);
         } else {
             stream_Read(p_demux->s, mst_buf + 8, i_map_size);
             memcpy(p_sys->seq_table[i].chunk_bitmask, &mst_buf[8], i_map_size);
         }
     }
 
     /* set up a few of our variables */
     p_sys->l_first_ty_pts = p_sys->seq_table[0].l_timestamp;
     p_sys->l_final_ty_pts =
         p_sys->seq_table[p_sys->i_seq_table_size - 1].l_timestamp;
     p_sys->b_have_master = true;
 
     i_pts_secs = p_sys->l_first_ty_pts / 1000000000;
     msg_Dbg( p_demux,
              "first TY pts in master is %02"PRId64":%02"PRId64":%02"PRId64,
              i_pts_secs / 3600, (i_pts_secs / 60) % 60, i_pts_secs % 60 );
     i_pts_secs = p_sys->l_final_ty_pts / 1000000000;
     msg_Dbg( p_demux,
              "final TY pts in master is %02"PRId64":%02"PRId64":%02"PRId64,
              i_pts_secs / 3600, (i_pts_secs / 60) % 60, i_pts_secs % 60 );
 
     /* seek past this chunk */
     stream_Seek(p_demux->s, i_save_pos + CHUNK_SIZE);
 }
 
 
 /* ======================================================================== */
 /* "Peek" at some chunks.  Skip over the Part header if we find it.
  * We parse the peeked data and determine audio type,
  * SA vs. DTivo, & Tivo Series.
  * Set global vars i_Pes_Length, i_Pts_Offset,
  * p_sys->tivo_series, p_sys->tivo_type, p_sys->audio_type */
