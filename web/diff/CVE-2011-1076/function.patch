commit 1362fa078dae16776cd439791c6605b224ea6171
Author: David Howells <dhowells@redhat.com>
Date:   Thu Mar 3 11:28:58 2011 +0000

    DNS: Fix a NULL pointer deref when trying to read an error key [CVE-2011-1076]
    
    When a DNS resolver key is instantiated with an error indication, attempts to
    read that key will result in an oops because user_read() is expecting there to
    be a payload - and there isn't one [CVE-2011-1076].
    
    Give the DNS resolver key its own read handler that returns the error cached in
    key->type_data.x[0] as an error rather than crashing.
    
    Also make the kenter() at the beginning of dns_resolver_instantiate() limit the
    amount of data it prints, since the data is not necessarily NUL-terminated.
    
    The buggy code was added in:
    
    	commit 4a2d789267e00b5a1175ecd2ddefcc78b83fbf09
    	Author: Wang Lei <wang840925@gmail.com>
    	Date:   Wed Aug 11 09:37:58 2010 +0100
    	Subject: DNS: If the DNS server returns an error, allow that to be cached [ver #2]
    
    This can trivially be reproduced by any user with the following program
    compiled with -lkeyutils:
    
    	#include <stdlib.h>
    	#include <keyutils.h>
    	#include <err.h>
    	static char payload[] = "#dnserror=6";
    	int main()
    	{
    		key_serial_t key;
    		key = add_key("dns_resolver", "a", payload, sizeof(payload),
    			      KEY_SPEC_SESSION_KEYRING);
    		if (key == -1)
    			err(1, "add_key");
    		if (keyctl_read(key, NULL, 0) == -1)
    			err(1, "read_key");
    		return 0;
    	}
    
    What should happen is that keyctl_read() reports error 6 (ENXIO) to the user:
    
    	dns-break: read_key: No such device or address
    
    but instead the kernel oopses.
    
    This cannot be reproduced with the 'keyutils add' or 'keyutils padd' commands
    as both of those cut the data down below the NUL termination that must be
    included in the data.  Without this dns_resolver_instantiate() will return
    -EINVAL and the key will not be instantiated such that it can be read.
    
    The oops looks like:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000010
    IP: [<ffffffff811b99f7>] user_read+0x4f/0x8f
    PGD 3bdf8067 PUD 385b9067 PMD 0
    Oops: 0000 [#1] SMP
    last sysfs file: /sys/devices/pci0000:00/0000:00:19.0/irq
    CPU 0
    Modules linked in:
    
    Pid: 2150, comm: dns-break Not tainted 2.6.38-rc7-cachefs+ #468                  /DG965RY
    RIP: 0010:[<ffffffff811b99f7>]  [<ffffffff811b99f7>] user_read+0x4f/0x8f
    RSP: 0018:ffff88003bf47f08  EFLAGS: 00010246
    RAX: 0000000000000001 RBX: ffff88003b5ea378 RCX: ffffffff81972368
    RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff88003b5ea378
    RBP: ffff88003bf47f28 R08: ffff88003be56620 R09: 0000000000000000
    R10: 0000000000000395 R11: 0000000000000002 R12: 0000000000000000
    R13: 0000000000000000 R14: 0000000000000000 R15: ffffffffffffffa1
    FS:  00007feab5751700(0000) GS:ffff88003e000000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 0000000000000010 CR3: 000000003de40000 CR4: 00000000000006f0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    Process dns-break (pid: 2150, threadinfo ffff88003bf46000, task ffff88003be56090)
    Stack:
     ffff88003b5ea378 ffff88003b5ea3a0 0000000000000000 0000000000000000
     ffff88003bf47f68 ffffffff811b708e ffff88003c442bc8 0000000000000000
     00000000004005a0 00007fffba368060 0000000000000000 0000000000000000
    Call Trace:
     [<ffffffff811b708e>] keyctl_read_key+0xac/0xcf
     [<ffffffff811b7c07>] sys_keyctl+0x75/0xb6
     [<ffffffff81001f7b>] system_call_fastpath+0x16/0x1b
    Code: 75 1f 48 83 7b 28 00 75 18 c6 05 58 2b fb 00 01 be bb 00 00 00 48 c7 c7 76 1c 75 81 e8 13 c2 e9 ff 4c 8b b3 e0 00 00 00 4d 85 ed <41> 0f b7 5e 10 74 2d 4d 85 e4 74 28 e8 98 79 ee ff 49 39 dd 48
    RIP  [<ffffffff811b99f7>] user_read+0x4f/0x8f
     RSP <ffff88003bf47f08>
    CR2: 0000000000000010
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Jeff Layton <jlayton@redhat.com>
    cc: Wang Lei <wang840925@gmail.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/Documentation/networking/dns_resolver.txt b/Documentation/networking/dns_resolver.txt
index aefd1e6..04ca0632 100644
--- a/Documentation/networking/dns_resolver.txt
+++ b/Documentation/networking/dns_resolver.txt
@@ -59,9 +59,8 @@ To direct a query for query type 'foo', a line of the following should be added
 before the more general line given above as the first match is the one taken.
 
 	create	dns_resolver  	foo:*	*	/usr/sbin/dns.foo %k
 
 
-
 =====
 USAGE
 =====
@@ -70,40 +69,48 @@ To make use of this facility, one of the following functions that are
 implemented in the module can be called after doing:
 
 	#include <linux/dns_resolver.h>
 
  (1) int dns_query(const char *type, const char *name, size_t namelen,
 		   const char *options, char **_result, time_t *_expiry);
 
      This is the basic access function.  It looks for a cached DNS query and if
      it doesn't find it, it upcalls to userspace to make a new DNS query, which
      may then be cached.  The key description is constructed as a string of the
      form:
 
 		[<type>:]<name>
 
      where <type> optionally specifies the particular upcall program to invoke,
      and thus the type of query to do, and <name> specifies the string to be
      looked up.  The default query type is a straight hostname to IP address
      set lookup.
 
      The name parameter is not required to be a NUL-terminated string, and its
      length should be given by the namelen argument.
 
      The options parameter may be NULL or it may be a set of options
      appropriate to the query type.
 
      The return value is a string appropriate to the query type.  For instance,
      for the default query type it is just a list of comma-separated IPv4 and
      IPv6 addresses.  The caller must free the result.
 
      The length of the result string is returned on success, and a negative
      error code is returned otherwise.  -EKEYREJECTED will be returned if the
      DNS lookup failed.
 
      If _expiry is non-NULL, the expiry time (TTL) of the result will be
      returned also.
 
 
+===============================
+READING DNS KEYS FROM USERSPACE
+===============================
+
+Keys of dns_resolver type can be read from userspace using keyctl_read() or
+"keyctl read/print/pipe".
+
+
 =========
 MECHANISM
 =========
diff --git a/net/dns_resolver/dns_key.c b/net/dns_resolver/dns_key.c
index 739435a..cfa7a5e 100644
--- a/net/dns_resolver/dns_key.c
+++ b/net/dns_resolver/dns_key.c
@@ -62,112 +62,113 @@ static int
 dns_resolver_instantiate(struct key *key, const void *_data, size_t datalen)
 {
 	struct user_key_payload *upayload;
 	unsigned long derrno;
 	int ret;
 	size_t result_len = 0;
 	const char *data = _data, *end, *opt;
 
-	kenter("%%%d,%s,'%s',%zu",
-	       key->serial, key->description, data, datalen);
+	kenter("%%%d,%s,'%*.*s',%zu",
+	       key->serial, key->description,
+	       (int)datalen, (int)datalen, data, datalen);
 
 	if (datalen <= 1 || !data || data[datalen - 1] != '\0')
 		return -EINVAL;
 	datalen--;
 
 	/* deal with any options embedded in the data */
 	end = data + datalen;
 	opt = memchr(data, '#', datalen);
 	if (!opt) {
 		/* no options: the entire data is the result */
 		kdebug("no options");
 		result_len = datalen;
 	} else {
 		const char *next_opt;
 
 		result_len = opt - data;
 		opt++;
 		kdebug("options: '%s'", opt);
 		do {
 			const char *eq;
 			int opt_len, opt_nlen, opt_vlen, tmp;
 
 			next_opt = memchr(opt, '#', end - opt) ?: end;
 			opt_len = next_opt - opt;
 			if (!opt_len) {
 				printk(KERN_WARNING
 				       "Empty option to dns_resolver key %d\n",
 				       key->serial);
 				return -EINVAL;
 			}
 
 			eq = memchr(opt, '=', opt_len) ?: end;
 			opt_nlen = eq - opt;
 			eq++;
 			opt_vlen = next_opt - eq; /* will be -1 if no value */
 
 			tmp = opt_vlen >= 0 ? opt_vlen : 0;
 			kdebug("option '%*.*s' val '%*.*s'",
 			       opt_nlen, opt_nlen, opt, tmp, tmp, eq);
 
 			/* see if it's an error number representing a DNS error
 			 * that's to be recorded as the result in this key */
 			if (opt_nlen == sizeof(DNS_ERRORNO_OPTION) - 1 &&
 			    memcmp(opt, DNS_ERRORNO_OPTION, opt_nlen) == 0) {
 				kdebug("dns error number option");
 				if (opt_vlen <= 0)
 					goto bad_option_value;
 
 				ret = strict_strtoul(eq, 10, &derrno);
 				if (ret < 0)
 					goto bad_option_value;
 
 				if (derrno < 1 || derrno > 511)
 					goto bad_option_value;
 
 				kdebug("dns error no. = %lu", derrno);
 				key->type_data.x[0] = -derrno;
 				continue;
 			}
 
 		bad_option_value:
 			printk(KERN_WARNING
 			       "Option '%*.*s' to dns_resolver key %d:"
 			       " bad/missing value\n",
 			       opt_nlen, opt_nlen, opt, key->serial);
 			return -EINVAL;
 		} while (opt = next_opt + 1, opt < end);
 	}
 
 	/* don't cache the result if we're caching an error saying there's no
 	 * result */
 	if (key->type_data.x[0]) {
 		kleave(" = 0 [h_error %ld]", key->type_data.x[0]);
 		return 0;
 	}
 
 	kdebug("store result");
 	ret = key_payload_reserve(key, result_len);
 	if (ret < 0)
 		return -EINVAL;
 
 	upayload = kmalloc(sizeof(*upayload) + result_len + 1, GFP_KERNEL);
 	if (!upayload) {
 		kleave(" = -ENOMEM");
 		return -ENOMEM;
 	}
 
 	upayload->datalen = result_len;
 	memcpy(upayload->data, data, result_len);
 	upayload->data[result_len] = '\0';
 	rcu_assign_pointer(key->payload.data, upayload);
 
 	kleave(" = 0");
 	return 0;
 }
 
 /*
  * The description is of the form "[<type>:]<domain_name>"
  *
  * The domain name may be a simple name or an absolute domain name (which
  * should end with a period).  The domain name is case-independent.
  */
@@ -217,14 +218,27 @@ static void dns_resolver_describe(const struct key *key, struct seq_file *m)
 		seq_printf(m, ": %u", key->datalen);
 }
 
+/*
+ * read the DNS data
+ * - the key's semaphore is read-locked
+ */
+static long dns_resolver_read(const struct key *key,
+			      char __user *buffer, size_t buflen)
+{
+	if (key->type_data.x[0])
+		return key->type_data.x[0];
+
+	return user_read(key, buffer, buflen);
+}
+
 struct key_type key_type_dns_resolver = {
 	.name		= "dns_resolver",
 	.instantiate	= dns_resolver_instantiate,
 	.match		= dns_resolver_match,
 	.revoke		= user_revoke,
 	.destroy	= user_destroy,
 	.describe	= dns_resolver_describe,
-	.read		= user_read,
+	.read		= dns_resolver_read,
 };
 
 static int __init init_dns_resolver(void)
