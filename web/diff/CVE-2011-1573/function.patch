commit a8170c35e738d62e9919ce5b109cf4ed66e95bde
Author: Wei Yongjun <yjwei@cn.fujitsu.com>
Date:   Wed Apr 28 08:47:21 2010 +0000

    sctp: fix to calc the INIT/INIT-ACK chunk length correctly is set
    
    When calculating the INIT/INIT-ACK chunk length, we should not
    only account the length of parameters, but also the parameters
    zero padding length, such as AUTH HMACS parameter and CHUNKS
    parameter. Without the parameters zero padding length we may get
    following oops.
    
    skb_over_panic: text:ce2068d2 len:130 put:6 head:cac3fe00 data:cac3fe00 tail:0xcac3fe82 end:0xcac3fe80 dev:<NULL>
    ------------[ cut here ]------------
    kernel BUG at net/core/skbuff.c:127!
    invalid opcode: 0000 [#2] SMP
    last sysfs file: /sys/module/aes_generic/initstate
    Modules linked in: authenc ......
    
    Pid: 4102, comm: sctp_darn Tainted: G      D    2.6.34-rc2 #6
    EIP: 0060:[<c0607630>] EFLAGS: 00010282 CPU: 0
    EIP is at skb_over_panic+0x37/0x3e
    EAX: 00000078 EBX: c07c024b ECX: c07c02b9 EDX: cb607b78
    ESI: 00000000 EDI: cac3fe7a EBP: 00000002 ESP: cb607b74
     DS: 007b ES: 007b FS: 00d8 GS: 0033 SS: 0068
    Process sctp_darn (pid: 4102, ti=cb607000 task=cabdc990 task.ti=cb607000)
    Stack:
     c07c02b9 ce2068d2 00000082 00000006 cac3fe00 cac3fe00 cac3fe82 cac3fe80
    <0> c07c024b cac3fe7c cac3fe7a c0608dec ca986e80 ce2068d2 00000006 0000007a
    <0> cb8120ca ca986e80 cb812000 00000003 cb8120c4 ce208a25 cb8120ca cadd9400
    Call Trace:
     [<ce2068d2>] ? sctp_addto_chunk+0x45/0x85 [sctp]
     [<c0608dec>] ? skb_put+0x2e/0x32
     [<ce2068d2>] ? sctp_addto_chunk+0x45/0x85 [sctp]
     [<ce208a25>] ? sctp_make_init+0x279/0x28c [sctp]
     [<c0686a92>] ? apic_timer_interrupt+0x2a/0x30
     [<ce1fdc0b>] ? sctp_sf_do_prm_asoc+0x2b/0x7b [sctp]
     [<ce202823>] ? sctp_do_sm+0xa0/0x14a [sctp]
     [<ce2133b9>] ? sctp_pname+0x0/0x14 [sctp]
     [<ce211d72>] ? sctp_primitive_ASSOCIATE+0x2b/0x31 [sctp]
     [<ce20f3cf>] ? sctp_sendmsg+0x7a0/0x9eb [sctp]
     [<c064eb1e>] ? inet_sendmsg+0x3b/0x43
     [<c04244b7>] ? task_tick_fair+0x2d/0xd9
     [<c06031e1>] ? sock_sendmsg+0xa7/0xc1
     [<c0416afe>] ? smp_apic_timer_interrupt+0x6b/0x75
     [<c0425123>] ? dequeue_task_fair+0x34/0x19b
     [<c0446abb>] ? sched_clock_local+0x17/0x11e
     [<c052ea87>] ? _copy_from_user+0x2b/0x10c
     [<c060ab3a>] ? verify_iovec+0x3c/0x6a
     [<c06035ca>] ? sys_sendmsg+0x186/0x1e2
     [<c042176b>] ? __wake_up_common+0x34/0x5b
     [<c04240c2>] ? __wake_up+0x2c/0x3b
     [<c057e35c>] ? tty_wakeup+0x43/0x47
     [<c04430f2>] ? remove_wait_queue+0x16/0x24
     [<c0580c94>] ? n_tty_read+0x5b8/0x65e
     [<c042be02>] ? default_wake_function+0x0/0x8
     [<c0604e0e>] ? sys_socketcall+0x17f/0x1cd
     [<c040264c>] ? sysenter_do_call+0x12/0x22
    Code: 0f 45 de 53 ff b0 98 00 00 00 ff b0 94 ......
    EIP: [<c0607630>] skb_over_panic+0x37/0x3e SS:ESP 0068:cb607b74
    
    To reproduce:
    
    # modprobe sctp
    # echo 1 > /proc/sys/net/sctp/addip_enable
    # echo 1 > /proc/sys/net/sctp/auth_enable
    # sctp_test -H 3ffe:501:ffff:100:20c:29ff:fe4d:f37e -P 800 -l
    # sctp_darn -H 3ffe:501:ffff:100:20c:29ff:fe4d:f37e -P 900 -h 192.168.0.21 -p 800 -I -s -t
    sctp_darn ready to send...
    3ffe:501:ffff:100:20c:29ff:fe4d:f37e:900-192.168.0.21:800 Interactive mode> bindx-add=192.168.0.21
    3ffe:501:ffff:100:20c:29ff:fe4d:f37e:900-192.168.0.21:800 Interactive mode> bindx-add=192.168.1.21
    3ffe:501:ffff:100:20c:29ff:fe4d:f37e:900-192.168.0.21:800 Interactive mode> snd=10
    
    ------------------------------------------------------------------
    eth0 has addresses: 3ffe:501:ffff:100:20c:29ff:fe4d:f37e and 192.168.0.21
    eth1 has addresses: 192.168.1.21
    ------------------------------------------------------------------
    
    Reported-by: George Cheimonidis <gchimon@gmail.com>
    Signed-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/sctp/sm_make_chunk.c b/net/sctp/sm_make_chunk.c
index 17cb400e..f6fc5c1 100644
--- a/net/sctp/sm_make_chunk.c
+++ b/net/sctp/sm_make_chunk.c
@@ -172,156 +172,158 @@ void  sctp_init_cause(struct sctp_chunk *chunk, __be16 cause_code,
 struct sctp_chunk *sctp_make_init(const struct sctp_association *asoc,
 			     const struct sctp_bind_addr *bp,
 			     gfp_t gfp, int vparam_len)
 {
 	sctp_inithdr_t init;
 	union sctp_params addrs;
 	size_t chunksize;
 	struct sctp_chunk *retval = NULL;
 	int num_types, addrs_len = 0;
 	struct sctp_sock *sp;
 	sctp_supported_addrs_param_t sat;
 	__be16 types[2];
 	sctp_adaptation_ind_param_t aiparam;
 	sctp_supported_ext_param_t ext_param;
 	int num_ext = 0;
 	__u8 extensions[3];
 	sctp_paramhdr_t *auth_chunks = NULL,
 			*auth_hmacs = NULL;
 
 	/* RFC 2960 3.3.2 Initiation (INIT) (1)
 	 *
 	 * Note 1: The INIT chunks can contain multiple addresses that
 	 * can be IPv4 and/or IPv6 in any combination.
 	 */
 	retval = NULL;
 
 	/* Convert the provided bind address list to raw format. */
 	addrs = sctp_bind_addrs_to_raw(bp, &addrs_len, gfp);
 
 	init.init_tag		   = htonl(asoc->c.my_vtag);
 	init.a_rwnd		   = htonl(asoc->rwnd);
 	init.num_outbound_streams  = htons(asoc->c.sinit_num_ostreams);
 	init.num_inbound_streams   = htons(asoc->c.sinit_max_instreams);
 	init.initial_tsn	   = htonl(asoc->c.initial_tsn);
 
 	/* How many address types are needed? */
 	sp = sctp_sk(asoc->base.sk);
 	num_types = sp->pf->supported_addrs(sp, types);
 
-	chunksize = sizeof(init) + addrs_len + SCTP_SAT_LEN(num_types);
+	chunksize = sizeof(init) + addrs_len;
+	chunksize += WORD_ROUND(SCTP_SAT_LEN(num_types));
 	chunksize += sizeof(ecap_param);
 
 	if (sctp_prsctp_enable)
 		chunksize += sizeof(prsctp_param);
 
 	/* ADDIP: Section 4.2.7:
 	 *  An implementation supporting this extension [ADDIP] MUST list
 	 *  the ASCONF,the ASCONF-ACK, and the AUTH  chunks in its INIT and
 	 *  INIT-ACK parameters.
 	 */
 	if (sctp_addip_enable) {
 		extensions[num_ext] = SCTP_CID_ASCONF;
 		extensions[num_ext+1] = SCTP_CID_ASCONF_ACK;
 		num_ext += 2;
 	}
 
 	if (sp->adaptation_ind)
 		chunksize += sizeof(aiparam);
 
 	chunksize += vparam_len;
 
 	/* Account for AUTH related parameters */
 	if (sctp_auth_enable) {
 		/* Add random parameter length*/
 		chunksize += sizeof(asoc->c.auth_random);
 
 		/* Add HMACS parameter length if any were defined */
 		auth_hmacs = (sctp_paramhdr_t *)asoc->c.auth_hmacs;
 		if (auth_hmacs->length)
-			chunksize += ntohs(auth_hmacs->length);
+			chunksize += WORD_ROUND(ntohs(auth_hmacs->length));
 		else
 			auth_hmacs = NULL;
 
 		/* Add CHUNKS parameter length */
 		auth_chunks = (sctp_paramhdr_t *)asoc->c.auth_chunks;
 		if (auth_chunks->length)
-			chunksize += ntohs(auth_chunks->length);
+			chunksize += WORD_ROUND(ntohs(auth_chunks->length));
 		else
 			auth_chunks = NULL;
 
 		extensions[num_ext] = SCTP_CID_AUTH;
 		num_ext += 1;
 	}
 
 	/* If we have any extensions to report, account for that */
 	if (num_ext)
-		chunksize += sizeof(sctp_supported_ext_param_t) + num_ext;
+		chunksize += WORD_ROUND(sizeof(sctp_supported_ext_param_t) +
+					num_ext);
 
 	/* RFC 2960 3.3.2 Initiation (INIT) (1)
 	 *
 	 * Note 3: An INIT chunk MUST NOT contain more than one Host
 	 * Name address parameter. Moreover, the sender of the INIT
 	 * MUST NOT combine any other address types with the Host Name
 	 * address in the INIT. The receiver of INIT MUST ignore any
 	 * other address types if the Host Name address parameter is
 	 * present in the received INIT chunk.
 	 *
 	 * PLEASE DO NOT FIXME [This version does not support Host Name.]
 	 */
 
 	retval = sctp_make_chunk(asoc, SCTP_CID_INIT, 0, chunksize);
 	if (!retval)
 		goto nodata;
 
 	retval->subh.init_hdr =
 		sctp_addto_chunk(retval, sizeof(init), &init);
 	retval->param_hdr.v =
 		sctp_addto_chunk(retval, addrs_len, addrs.v);
 
 	/* RFC 2960 3.3.2 Initiation (INIT) (1)
 	 *
 	 * Note 4: This parameter, when present, specifies all the
 	 * address types the sending endpoint can support. The absence
 	 * of this parameter indicates that the sending endpoint can
 	 * support any address type.
 	 */
 	sat.param_hdr.type = SCTP_PARAM_SUPPORTED_ADDRESS_TYPES;
 	sat.param_hdr.length = htons(SCTP_SAT_LEN(num_types));
 	sctp_addto_chunk(retval, sizeof(sat), &sat);
 	sctp_addto_chunk(retval, num_types * sizeof(__u16), &types);
 
 	sctp_addto_chunk(retval, sizeof(ecap_param), &ecap_param);
 
 	/* Add the supported extensions parameter.  Be nice and add this
 	 * fist before addiding the parameters for the extensions themselves
 	 */
 	if (num_ext) {
 		ext_param.param_hdr.type = SCTP_PARAM_SUPPORTED_EXT;
 		ext_param.param_hdr.length =
 			    htons(sizeof(sctp_supported_ext_param_t) + num_ext);
 		sctp_addto_chunk(retval, sizeof(sctp_supported_ext_param_t),
 				&ext_param);
 		sctp_addto_param(retval, num_ext, extensions);
 	}
 
 	if (sctp_prsctp_enable)
 		sctp_addto_chunk(retval, sizeof(prsctp_param), &prsctp_param);
 
 	if (sp->adaptation_ind) {
 		aiparam.param_hdr.type = SCTP_PARAM_ADAPTATION_LAYER_IND;
 		aiparam.param_hdr.length = htons(sizeof(aiparam));
 		aiparam.adaptation_ind = htonl(sp->adaptation_ind);
 		sctp_addto_chunk(retval, sizeof(aiparam), &aiparam);
 	}
 
 	/* Add SCTP-AUTH chunks to the parameter list */
 	if (sctp_auth_enable) {
 		sctp_addto_chunk(retval, sizeof(asoc->c.auth_random),
 				 asoc->c.auth_random);
 		if (auth_hmacs)
 			sctp_addto_chunk(retval, ntohs(auth_hmacs->length),
 					auth_hmacs);
 		if (auth_chunks)
 			sctp_addto_chunk(retval, ntohs(auth_chunks->length),
 					auth_chunks);
 	}
@@ -333,143 +335,144 @@ nodata:
 struct sctp_chunk *sctp_make_init_ack(const struct sctp_association *asoc,
 				 const struct sctp_chunk *chunk,
 				 gfp_t gfp, int unkparam_len)
 {
 	sctp_inithdr_t initack;
 	struct sctp_chunk *retval;
 	union sctp_params addrs;
 	struct sctp_sock *sp;
 	int addrs_len;
 	sctp_cookie_param_t *cookie;
 	int cookie_len;
 	size_t chunksize;
 	sctp_adaptation_ind_param_t aiparam;
 	sctp_supported_ext_param_t ext_param;
 	int num_ext = 0;
 	__u8 extensions[3];
 	sctp_paramhdr_t *auth_chunks = NULL,
 			*auth_hmacs = NULL,
 			*auth_random = NULL;
 
 	retval = NULL;
 
 	/* Note: there may be no addresses to embed. */
 	addrs = sctp_bind_addrs_to_raw(&asoc->base.bind_addr, &addrs_len, gfp);
 
 	initack.init_tag	        = htonl(asoc->c.my_vtag);
 	initack.a_rwnd			= htonl(asoc->rwnd);
 	initack.num_outbound_streams	= htons(asoc->c.sinit_num_ostreams);
 	initack.num_inbound_streams	= htons(asoc->c.sinit_max_instreams);
 	initack.initial_tsn		= htonl(asoc->c.initial_tsn);
 
 	/* FIXME:  We really ought to build the cookie right
 	 * into the packet instead of allocating more fresh memory.
 	 */
 	cookie = sctp_pack_cookie(asoc->ep, asoc, chunk, &cookie_len,
 				  addrs.v, addrs_len);
 	if (!cookie)
 		goto nomem_cookie;
 
 	/* Calculate the total size of allocation, include the reserved
 	 * space for reporting unknown parameters if it is specified.
 	 */
 	sp = sctp_sk(asoc->base.sk);
 	chunksize = sizeof(initack) + addrs_len + cookie_len + unkparam_len;
 
 	/* Tell peer that we'll do ECN only if peer advertised such cap.  */
 	if (asoc->peer.ecn_capable)
 		chunksize += sizeof(ecap_param);
 
 	if (asoc->peer.prsctp_capable)
 		chunksize += sizeof(prsctp_param);
 
 	if (asoc->peer.asconf_capable) {
 		extensions[num_ext] = SCTP_CID_ASCONF;
 		extensions[num_ext+1] = SCTP_CID_ASCONF_ACK;
 		num_ext += 2;
 	}
 
 	if (sp->adaptation_ind)
 		chunksize += sizeof(aiparam);
 
 	if (asoc->peer.auth_capable) {
 		auth_random = (sctp_paramhdr_t *)asoc->c.auth_random;
 		chunksize += ntohs(auth_random->length);
 
 		auth_hmacs = (sctp_paramhdr_t *)asoc->c.auth_hmacs;
 		if (auth_hmacs->length)
-			chunksize += ntohs(auth_hmacs->length);
+			chunksize += WORD_ROUND(ntohs(auth_hmacs->length));
 		else
 			auth_hmacs = NULL;
 
 		auth_chunks = (sctp_paramhdr_t *)asoc->c.auth_chunks;
 		if (auth_chunks->length)
-			chunksize += ntohs(auth_chunks->length);
+			chunksize += WORD_ROUND(ntohs(auth_chunks->length));
 		else
 			auth_chunks = NULL;
 
 		extensions[num_ext] = SCTP_CID_AUTH;
 		num_ext += 1;
 	}
 
 	if (num_ext)
-		chunksize += sizeof(sctp_supported_ext_param_t) + num_ext;
+		chunksize += WORD_ROUND(sizeof(sctp_supported_ext_param_t) +
+					num_ext);
 
 	/* Now allocate and fill out the chunk.  */
 	retval = sctp_make_chunk(asoc, SCTP_CID_INIT_ACK, 0, chunksize);
 	if (!retval)
 		goto nomem_chunk;
 
 	/* Per the advice in RFC 2960 6.4, send this reply to
 	 * the source of the INIT packet.
 	 */
 	retval->transport = chunk->transport;
 	retval->subh.init_hdr =
 		sctp_addto_chunk(retval, sizeof(initack), &initack);
 	retval->param_hdr.v = sctp_addto_chunk(retval, addrs_len, addrs.v);
 	sctp_addto_chunk(retval, cookie_len, cookie);
 	if (asoc->peer.ecn_capable)
 		sctp_addto_chunk(retval, sizeof(ecap_param), &ecap_param);
 	if (num_ext) {
 		ext_param.param_hdr.type = SCTP_PARAM_SUPPORTED_EXT;
 		ext_param.param_hdr.length =
 			    htons(sizeof(sctp_supported_ext_param_t) + num_ext);
 		sctp_addto_chunk(retval, sizeof(sctp_supported_ext_param_t),
 				 &ext_param);
 		sctp_addto_param(retval, num_ext, extensions);
 	}
 	if (asoc->peer.prsctp_capable)
 		sctp_addto_chunk(retval, sizeof(prsctp_param), &prsctp_param);
 
 	if (sp->adaptation_ind) {
 		aiparam.param_hdr.type = SCTP_PARAM_ADAPTATION_LAYER_IND;
 		aiparam.param_hdr.length = htons(sizeof(aiparam));
 		aiparam.adaptation_ind = htonl(sp->adaptation_ind);
 		sctp_addto_chunk(retval, sizeof(aiparam), &aiparam);
 	}
 
 	if (asoc->peer.auth_capable) {
 		sctp_addto_chunk(retval, ntohs(auth_random->length),
 				 auth_random);
 		if (auth_hmacs)
 			sctp_addto_chunk(retval, ntohs(auth_hmacs->length),
 					auth_hmacs);
 		if (auth_chunks)
 			sctp_addto_chunk(retval, ntohs(auth_chunks->length),
 					auth_chunks);
 	}
 
 	/* We need to remove the const qualifier at this point.  */
 	retval->asoc = (struct sctp_association *) asoc;
 
 	/* RFC 2960 6.4 Multi-homed SCTP Endpoints
 	 *
 	 * An endpoint SHOULD transmit reply chunks (e.g., SACK,
 	 * HEARTBEAT ACK, * etc.) to the same destination transport
 	 * address from which it received the DATA or control chunk
 	 * to which it is replying.
 	 *
 	 * [INIT ACK back to where the INIT came from.]
 	 */
 	if (chunk)
 		retval->transport = chunk->transport;
 
