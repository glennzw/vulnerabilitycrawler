commit f95c81bf21c177f7e6a2c53ea0613034326329bd
Author: Iustin Pop <iustin@google.com>
Date:   Tue Dec 1 15:08:29 2009 +0100

    Security issue: add validation of script names
    
    This patch unifies the search for external script to always go through
    utils.FindFile and implements in that function a restriction on valid
    chars in file names and (additionally) that the passed name is the
    basename of the final (absolute) name.
    
    Signed-off-by: Iustin Pop <iustin@google.com>
    Reviewed-by: Michael Hanselmann <hansmi@google.com>

diff --git a/lib/backend.py b/lib/backend.py
index 44e45f6..30984b3 100644
--- a/lib/backend.py
+++ b/lib/backend.py
@@ -1644,57 +1644,58 @@ def DiagnoseOS(top_dirs=None):
 def OSFromDisk(name, base_dir=None):
   """Create an OS instance from disk.
 
   This function will return an OS instance if the given name is a
   valid OS name. Otherwise, it will raise an appropriate
   L{errors.InvalidOS} exception, detailing why this is not a valid OS.
 
   @type base_dir: string
   @keyword base_dir: Base directory containing OS installations.
                      Defaults to a search in all the OS_SEARCH_PATH dirs.
   @rtype: L{objects.OS}
   @return: the OS instance if we find a valid one
   @raise errors.InvalidOS: if we don't find a valid OS
 
   """
   if base_dir is None:
     os_dir = utils.FindFile(name, constants.OS_SEARCH_PATH, os.path.isdir)
-    if os_dir is None:
-      raise errors.InvalidOS(name, None, "OS dir not found in search path")
   else:
-    os_dir = os.path.sep.join([base_dir, name])
+    os_dir = utils.FindFile(name, [base_dir], os.path.isdir)
+
+  if os_dir is None:
+    raise errors.InvalidOS(name, None, "OS dir not found in search path")
 
   api_versions = _OSOndiskVersion(name, os_dir)
 
   if constants.OS_API_VERSION not in api_versions:
     raise errors.InvalidOS(name, os_dir, "API version mismatch"
                            " (found %s want %s)"
                            % (api_versions, constants.OS_API_VERSION))
 
   # OS Scripts dictionary, we will populate it with the actual script names
   os_scripts = dict.fromkeys(constants.OS_SCRIPTS)
 
   for script in os_scripts:
     os_scripts[script] = os.path.sep.join([os_dir, script])
 
     try:
       st = os.stat(os_scripts[script])
     except EnvironmentError, err:
       raise errors.InvalidOS(name, os_dir, "'%s' script missing (%s)" %
                              (script, _ErrnoOrStr(err)))
 
     if stat.S_IMODE(st.st_mode) & stat.S_IXUSR != stat.S_IXUSR:
       raise errors.InvalidOS(name, os_dir, "'%s' script not executable" %
                              script)
 
     if not stat.S_ISREG(stat.S_IFMT(st.st_mode)):
       raise errors.InvalidOS(name, os_dir, "'%s' is not a regular file" %
                              script)
 
 
   return objects.OS(name=name, path=os_dir, status=constants.OS_VALID_STATUS,
                     create_script=os_scripts[constants.OS_SCRIPT_CREATE],
                     export_script=os_scripts[constants.OS_SCRIPT_EXPORT],
                     import_script=os_scripts[constants.OS_SCRIPT_IMPORT],
                     rename_script=os_scripts[constants.OS_SCRIPT_RENAME],
                     api_versions=api_versions)
 
diff --git a/lib/utils.py b/lib/utils.py
index df2d180..bcd8e10 100644
--- a/lib/utils.py
+++ b/lib/utils.py
@@ -1618,25 +1618,33 @@ def KillProcess(pid, signal_=signal.SIGTERM, timeout=30,
 def FindFile(name, search_path, test=os.path.exists):
   """Look for a filesystem object in a given path.
 
   This is an abstract method to search for filesystem object (files,
   dirs) under a given search path.
 
   @type name: str
   @param name: the name to look for
   @type search_path: str
   @param search_path: location to start at
   @type test: callable
   @param test: a function taking one argument that should return True
       if the a given object is valid; the default value is
       os.path.exists, causing only existing files to be returned
   @rtype: str or None
   @return: full path to the object if found, None otherwise
 
   """
+  # validate the filename mask
+  if constants.EXT_PLUGIN_MASK.match(name) is None:
+    logging.critical("Invalid value passed for external script name: '%s'",
+                     name)
+    return None
+
   for dir_name in search_path:
     item_name = os.path.sep.join([dir_name, name])
-    if test(item_name):
+    # check the user test and that we're indeed resolving to the given
+    # basename
+    if test(item_name) and os.path.basename(item_name) == name:
       return item_name
   return None
 
 
