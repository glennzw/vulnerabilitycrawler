commit d4139205b010ed06310d14284e63114e88ec6de2
Author: Jos√© Aliste <jaliste@src.gnome.org>
Date:   Tue Dec 7 15:56:47 2010 -0300

    backends: Fix several security issues in the dvi-backend.
    
    See CVE-2010-2640, CVE-2010-2641, CVE-2010-2642 and  CVE-2010-2643.

diff --git a/backend/dvi/mdvi-lib/afmparse.c b/backend/dvi/mdvi-lib/afmparse.c
index 164366b..361e23d 100644
--- a/backend/dvi/mdvi-lib/afmparse.c
+++ b/backend/dvi/mdvi-lib/afmparse.c
@@ -153,33 +153,33 @@ static char *keyStrings[] = {
 static char *token(FILE *stream)
 {
     int ch, idx;
 
     /* skip over white space */
     while ((ch = fgetc(stream)) == ' ' || ch == lineterm || 
             ch == ',' || ch == '\t' || ch == ';');
     
     idx = 0;
     while (ch != EOF && ch != ' ' && ch != lineterm 
-           && ch != '\t' && ch != ':' && ch != ';') 
+           && ch != '\t' && ch != ':' && ch != ';' && idx < MAX_NAME)
     {
         ident[idx++] = ch;
         ch = fgetc(stream);
     } /* while */
 
     if (ch == EOF && idx < 1) return ((char *)NULL);
     if (idx >= 1 && ch != ':' ) ungetc(ch, stream);
     if (idx < 1 ) ident[idx++] = ch;	/* single-character token */
     ident[idx] = 0;
     
     return(ident);	/* returns pointer to the token */
 
 } /* token */
 
 
 /*************************** linetoken *************************/
 
 /*  "linetoken" will get read all tokens until the EOL character from
  *  the given stream.  This is used to get any arguments that can be
  *  more than one word (like Comment lines and FullName).
  */
 
diff --git a/backend/dvi/mdvi-lib/dviread.c b/backend/dvi/mdvi-lib/dviread.c
index cd8cfa9..d014320 100644
--- a/backend/dvi/mdvi-lib/dviread.c
+++ b/backend/dvi/mdvi-lib/dviread.c
@@ -1504,16 +1504,20 @@ int	sel_fontn(DviContext *dvi, int opcode)
 int	special(DviContext *dvi, int opcode)
 {
 	char	*s;
 	Int32	arg;
 	
 	arg = dugetn(dvi, opcode - DVI_XXX1 + 1);
+	if (arg <= 0) {
+		dvierr(dvi, _("malformed special length\n"));
+		return -1;
+	}
 	s = mdvi_malloc(arg + 1);
 	dread(dvi, s, arg);
 	s[arg] = 0;
 	mdvi_do_special(dvi, s);
 	SHOWCMD((dvi, "XXXX", opcode - DVI_XXX1 + 1,
 		"[%s]", s));
 	mdvi_free(s);
 	return 0;
 }
 
diff --git a/backend/dvi/mdvi-lib/pk.c b/backend/dvi/mdvi-lib/pk.c
index a579186..08377e6 100644
--- a/backend/dvi/mdvi-lib/pk.c
+++ b/backend/dvi/mdvi-lib/pk.c
@@ -327,198 +327,207 @@ static BITMAP *get_char(FILE *p, int w, int h, int flags)
 static int pk_load_font(DviParams *unused, DviFont *font)
 {
 	int	i;
 	int	flag_byte;
 	int	loc, hic, maxch;
 	Int32	checksum;
 	FILE	*p;
 #ifndef NODEBUG
 	char	s[256];
 #endif
 	long	alpha, beta, z;
 
 	font->chars = xnalloc(DviFontChar, 256);
 	p = font->in;
 	memzero(font->chars, 256 * sizeof(DviFontChar));
 	for(i = 0; i < 256; i++)
 		font->chars[i].offset = 0;
 
 	/* check the preamble */
 	loc = fuget1(p); hic = fuget1(p);
 	if(loc != PK_PRE || hic != PK_ID)
 		goto badpk;
 	i = fuget1(p);
 #ifndef NODEBUG
 	for(loc = 0; loc < i; loc++)
 		s[loc] = fuget1(p);
 	s[loc] = 0;
 	DEBUG((DBG_FONTS, "(pk) %s: %s\n", font->fontname, s));
 #else
 	fseek(in, (long)i, SEEK_CUR);
 #endif
 	/* get the design size */
 	font->design = fuget4(p);
 	/* get the checksum */
 	checksum = fuget4(p);
 	if(checksum && font->checksum && font->checksum != checksum) {
 		mdvi_warning(_("%s: checksum mismatch (expected %u, got %u)\n"),
 			     font->fontname, font->checksum, checksum);
 	} else if(!font->checksum)
 		font->checksum = checksum;
 	/* skip pixel per point ratios */
 	fuget4(p);
 	fuget4(p);
 	if(feof(p))
 		goto badpk;	
 
 	/* now start reading the font */
 	loc = 256; hic = -1; maxch = 256;
 	
 	/* initialize alpha and beta for TFM width computation */
 	TFMPREPARE(font->scale, z, alpha, beta);
 
 	while((flag_byte = fuget1(p)) != PK_POST) {
 		if(feof(p))
 			break;
 		if(flag_byte >= PK_CMD_START) {
 			switch(flag_byte) {
 			case PK_X1:
 			case PK_X2:
 			case PK_X3:
 			case PK_X4: {
 #ifndef NODEBUG
 				char	*t;
 				int	n;
 				
 				i = fugetn(p, flag_byte - PK_X1 + 1);
 				if(i < 256)
 					t = &s[0];
 				else
 					t = mdvi_malloc(i + 1);
 				for(n = 0; n < i; n++)
 					t[n] = fuget1(p);
 				t[n] = 0;
 				DEBUG((DBG_SPECIAL, "(pk) %s: Special \"%s\"\n",
 					font->fontname, t));
 				if(t != &s[0])
 					mdvi_free(t);
 #else
 				i = fugetn(p, flag_byte - PK_X1 + 1);
 				while(i-- > 0)
 					fuget1(p);
 #endif
 				break;
 			}
 			case PK_Y:
 				i = fuget4(p);
 				DEBUG((DBG_SPECIAL, "(pk) %s: MF special %u\n",
 					font->fontname, (unsigned)i));
 				break;
 			case PK_POST:
 			case PK_NOOP:
 				break;
 			case PK_PRE:
 				mdvi_error(_("%s: unexpected preamble\n"), font->fontname);
 				goto error;
 			}
 		} else {
 			int	pl;
 			int	cc;
 			int	w, h;
 			int	x, y;
 			int	offset;
 			long	tfm;
 			
 			switch(flag_byte & 0x7) {
 			case 7:
 				pl = fuget4(p);
 				cc = fuget4(p);
 				offset = ftell(p) + pl;
 				tfm = fuget4(p);
 				fsget4(p); /* skip dx */
 				fsget4(p); /* skip dy */
 				w  = fuget4(p);
 				h  = fuget4(p); 
 				x  = fsget4(p);
 				y  = fsget4(p);
 				break;
 			case 4:
 			case 5:
 			case 6:				
 				pl = (flag_byte % 4) * 65536 + fuget2(p);
 				cc = fuget1(p);
 				offset = ftell(p) + pl;
 				tfm = fuget3(p);
 				fsget2(p); /* skip dx */
 				           /* dy assumed 0 */
 				w = fuget2(p);
 				h = fuget2(p);
 				x = fsget2(p);
 				y = fsget2(p);
 				break;
 			default:
 				pl = (flag_byte % 4) * 256 + fuget1(p);
 				cc = fuget1(p);
 				offset = ftell(p) + pl;
 				tfm = fuget3(p);
 				fsget1(p); /* skip dx */
 				           /* dy assumed 0 */
 				w = fuget1(p);
 				h = fuget1(p);
 				x = fsget1(p);
 				y = fsget1(p);
 			}
 			if(feof(p))
 				break;
+
+			/* Although the PK format support bigger char codes,
+                         * XeTeX and other extended TeX engines support charcodes up to
+                         * 65536, while normal TeX engine supports only charcode up to 255.*/
+			if (cc < 0 || cc > 65536) {
+				mdvi_error (_("%s: unexpected charcode (%d)\n"),
+					    font->fontname,cc);
+				goto error;
+			} 
 			if(cc < loc)
 				loc = cc;
 			if(cc > hic)
 				hic = cc;
 			if(cc > maxch) {
 				font->chars = xresize(font->chars, 
 					DviFontChar, cc + 16);
 				for(i = maxch; i < cc + 16; i++)
 					font->chars[i].offset = 0;
 				maxch = cc + 16;
 			}
 			font->chars[cc].code = cc;
 			font->chars[cc].flags = flag_byte;
 			font->chars[cc].offset = ftell(p);
 			font->chars[cc].width = w;
 			font->chars[cc].height = h;
 			font->chars[cc].glyph.data = NULL;
 			font->chars[cc].x = x;
 			font->chars[cc].y = y;
 			font->chars[cc].glyph.x = x;
 			font->chars[cc].glyph.y = y;
 			font->chars[cc].glyph.w = w;
 			font->chars[cc].glyph.h = h;
 			font->chars[cc].grey.data = NULL;
 			font->chars[cc].shrunk.data = NULL;
 			font->chars[cc].tfmwidth = TFMSCALE(z, tfm, alpha, beta);
 			font->chars[cc].loaded = 0;
 			fseek(p, (long)offset, SEEK_SET);
 		}
 	}
 	if(flag_byte != PK_POST) {
 		mdvi_error(_("%s: unexpected end of file (no postamble)\n"),
 			   font->fontname);
 		goto error;
 	}
 	while((flag_byte = fuget1(p)) != EOF) {
 		if(flag_byte != PK_NOOP) {
 			mdvi_error(_("invalid PK file! (junk in postamble)\n"));
 			goto error;
 		}
 	}
 
 	/* resize font char data */
-	if(loc > 0 || hic < maxch-1) {
+	if(loc > 0 && hic < maxch-1) {
 		memmove(font->chars, font->chars + loc, 
 			(hic - loc + 1) * sizeof(DviFontChar));
 		font->chars = xresize(font->chars,
 			DviFontChar, hic - loc + 1);
 	}
 	font->loc = loc;
 	font->hic = hic;		
 	return 0;
 
diff --git a/backend/dvi/mdvi-lib/tfmfile.c b/backend/dvi/mdvi-lib/tfmfile.c
index 73ebf26..8c2a30b 100644
--- a/backend/dvi/mdvi-lib/tfmfile.c
+++ b/backend/dvi/mdvi-lib/tfmfile.c
@@ -149,141 +149,142 @@ int	afm_load_file(const char *filename, TFMInfo *info)
 int	tfm_load_file(const char *filename, TFMInfo *info)
 {
 	int	lf, lh, bc, ec, nw, nh, nd, ne;
 	int	i, n;
 	Uchar	*tfm;
 	Uchar	*ptr;
 	struct stat st;
 	int	size;
 	FILE	*in;
 	Int32	*cb;
 	Int32	*charinfo;
 	Int32	*widths;
 	Int32	*heights;
 	Int32	*depths;
 	Uint32	checksum;
 
 	in = fopen(filename, "rb");
 	if(in == NULL)
 		return -1;
 	tfm = NULL;
 
 	DEBUG((DBG_FONTS, "(mt) reading TFM file `%s'\n",
 		filename));
 	/* We read the entire TFM file into core */
 	if(fstat(fileno(in), &st) < 0)
 		return -1;
-	if(st.st_size == 0)
+	/* according to the spec, TFM files are smaller than 16K */
+	if(st.st_size == 0 || st.st_size >= 16384)
 		goto bad_tfm;
 
 	/* allocate a word-aligned buffer to hold the file */
 	size = 4 * ROUND(st.st_size, 4);
 	if(size != st.st_size)
 		mdvi_warning(_("Warning: TFM file `%s' has suspicious size\n"), 
 			     filename);
 	tfm = (Uchar *)mdvi_malloc(size);
 	if(fread(tfm, st.st_size, 1, in) != 1)
 		goto error;
 	/* we don't need this anymore */
 	fclose(in);
 	in = NULL;
 
 	/* not a checksum, but serves a similar purpose */
 	checksum = 0;
 	
 	ptr = tfm;
 	/* get the counters */
 	lf = muget2(ptr);
 	lh = muget2(ptr); checksum += 6 + lh;
 	bc = muget2(ptr); 
 	ec = muget2(ptr); checksum += ec - bc + 1;
 	nw = muget2(ptr); checksum += nw;
 	nh = muget2(ptr); checksum += nh;
 	nd = muget2(ptr); checksum += nd;
 	checksum += muget2(ptr); /* skip italics correction count */
 	checksum += muget2(ptr); /* skip lig/kern table size */
 	checksum += muget2(ptr); /* skip kern table size */
 	ne = muget2(ptr); checksum += ne;
 	checksum += muget2(ptr); /* skip # of font parameters */
 
 	size = ec - bc + 1;
 	cb = (Int32 *)tfm; cb += 6 + lh;
 	charinfo    = cb;  cb += size;
 	widths      = cb;  cb += nw;
 	heights     = cb;  cb += nh;
 	depths      = cb;
 
 	if(widths[0] || heights[0] || depths[0] || 
 	   checksum != lf || bc - 1 > ec || ec > 255 || ne > 256)
 		goto bad_tfm;
 
 	/* from this point on, no error checking is done */
 
 	/* now we're at the header */
 	/* get the checksum */
 	info->checksum = muget4(ptr);
 	/* get the design size */
 	info->design = muget4(ptr);
 	/* get the coding scheme */
 	if(lh > 2) {
 		/* get the coding scheme */
 		i = n = msget1(ptr);
 		if(n < 0 || n > 39) {
 			mdvi_warning(_("%s: font coding scheme truncated to 40 bytes\n"),
 				     filename);
 			n = 39;
 		}
 		memcpy(info->coding, ptr, n);
 		info->coding[n] = 0;
 		ptr += i;
 	} else
 		strcpy(info->coding, "FontSpecific");
 	/* get the font family */
 	if(lh > 12) {
 		n = msget1(ptr);
 		if(n > 0) {
 			i = Max(n, 63);
 			memcpy(info->family, ptr, i);
 			info->family[i] = 0;
 		} else
 			strcpy(info->family, "unspecified");
 		ptr += n;
 	}
 	/* now we don't read from `ptr' anymore */
 	
 	info->loc = bc;
 	info->hic = ec;
 	info->type = DviFontTFM;
 
 	/* allocate characters */
 	info->chars = xnalloc(TFMChar, size);
 
 
 #ifdef WORD_LITTLE_ENDIAN
 	/* byte-swap the three arrays at once (they are consecutive in memory) */
 	swap_array((Uint32 *)widths, nw + nh + nd);
 #endif
 
 	/* get the relevant data */
 	ptr = (Uchar *)charinfo;
 	for(i = bc; i <= ec; ptr += 3, i++) {
 		int	ndx;
 
 		ndx = (int)*ptr; ptr++;
 		info->chars[i-bc].advance = widths[ndx];
 		/* TFM files lack this information */
 		info->chars[i-bc].left = 0;
 		info->chars[i-bc].right = widths[ndx];
 		info->chars[i-bc].present = (ndx != 0);
 		if(ndx) {
 			ndx = ((*ptr >> 4) & 0xf);
 			info->chars[i-bc].height = heights[ndx];
 			ndx = (*ptr & 0xf);
 			info->chars[i-bc].depth = depths[ndx];
 		}
 	}
 
 	/* free everything */
 	mdvi_free(tfm);
 	
 	return 0;
 
diff --git a/backend/dvi/mdvi-lib/vf.c b/backend/dvi/mdvi-lib/vf.c
index fb49847..a5ae3bb 100644
--- a/backend/dvi/mdvi-lib/vf.c
+++ b/backend/dvi/mdvi-lib/vf.c
@@ -58,170 +58,176 @@ DviFontInfo ovf_font_info = {
 static int vf_load_font(DviParams *params, DviFont *font)
 {
 	FILE	*p;
 	Uchar	*macros;
 	int	msize;
 	int	mlen;
 	Int32	checksum;
 	long	alpha, beta, z;
 	int	op;
 	int	i;
 	int	nchars;
 	int	loc, hic;
 	DviFontRef *last;
 	
 	macros = NULL;
 	msize = mlen = 0;
 	p = font->in;
 	
 	if(fuget1(p) != 247 || fuget1(p) != 202)
 		goto badvf;
 	mlen = fuget1(p);
 	fseek(p, (long)mlen, SEEK_CUR);
 	checksum = fuget4(p);
 	if(checksum && font->checksum && checksum != font->checksum) {
 		mdvi_warning(_("%s: Checksum mismatch (expected %u, got %u)\n"),
 			     font->fontname, font->checksum, checksum);
 	} else if(!font->checksum)
 		font->checksum = checksum;
 	font->design = fuget4(p);
 	
 	/* read all the fonts in the preamble */
 	last = NULL;
 
 	/* initialize alpha, beta and z for TFM width computation */
 	TFMPREPARE(font->scale, z, alpha, beta);
 
 	op = fuget1(p);	
 	while(op >= DVI_FNT_DEF1 && op <= DVI_FNT_DEF4) {
 		DviFontRef *ref;
 		Int32	scale, design;
 		Uint32	checksum;
 		int	id;
 		int	n;
 		int	hdpi;
 		int	vdpi;
 		char	*name;
 		
 		/* process fnt_def commands */
 		
 		id = fugetn(p, op - DVI_FNT_DEF1 + 1);
 		checksum = fuget4(p);
 		scale = fuget4(p);
 		design = fuget4(p);
 
 		/* scale this font according to our parent's scale */
 		scale = TFMSCALE(scale, z, alpha, beta);
 		design = FROUND(params->tfm_conv * design);
 
 		/* compute the resolution */
 		hdpi = FROUND(params->mag * params->dpi * scale / design);
 		vdpi = FROUND(params->mag * params->vdpi * scale / design);
 		n = fuget1(p) + fuget1(p);
 		name = mdvi_malloc(n + 1);
 		fread(name, 1, n, p);
 		name[n] = 0;
 		DEBUG((DBG_FONTS, "(vf) %s: defined font `%s' at %.1fpt (%dx%d dpi)\n",
 			font->fontname, name, 
 			(double)scale / (params->tfm_conv * 0x100000), hdpi, vdpi));
 
 		/* get the font */
 		ref = font_reference(params, id, name, checksum, hdpi, vdpi, scale);
 		if(ref == NULL) {
 			mdvi_error(_("(vf) %s: could not load font `%s'\n"), 
 				   font->fontname, name);
 			goto error;
 		}
 		mdvi_free(name);
 		if(last == NULL)
 			font->subfonts = last = ref;
 		else
 			last->next = ref;
 		ref->next = NULL;
 		op = fuget1(p);
 	}
 	
 	if(op >= DVI_FNT_DEF1 && op <= DVI_FNT_DEF4)
 		goto error;
 
 	/* This function correctly reads both .vf and .ovf files */
 	
 	font->chars = xnalloc(DviFontChar, 256);
 	for(i = 0; i < 256; i++)
 		font->chars[i].offset = 0;
 	nchars = 256;
 	loc = -1; hic = -1;
 	/* now read the characters themselves */
 	while(op <= 242) {
 		int	pl;
 		Int32	cc;
 		Int32	tfm;
 		
 		if(op == 242) {
 			pl = fuget4(p);
 			cc = fuget4(p);
 			tfm = fuget4(p);
 		} else {
 			pl = op;
 			cc = fuget1(p);
 			tfm = fuget3(p);
 		}
+		if (cc < 0 || cc > 65536) {
+			/* TeX engines do not support char codes bigger than 65535 */
+			mdvi_error(_("(vf) %s: unexpected character %d\n"),
+				   font->fontname, cc);
+			goto error;
+		}
 		if(loc < 0 || cc < loc)
 			loc = cc;
 		if(hic < 0 || cc > hic)
 			hic = cc;
 		if(cc >= nchars) {
 			font->chars = xresize(font->chars, 
 				DviFontChar, cc + 16);
 			for(i = nchars; i < cc + 16; i++)
 				font->chars[i].offset = 0;
 			nchars = cc + 16;
 		}
 		if(font->chars[cc].offset) {
 			mdvi_error(_("(vf) %s: character %d redefined\n"),
 				   font->fontname, cc);
 			goto error;
 		}
 				
 		DEBUG((DBG_GLYPHS, "(vf) %s: defined character %d (macro length %d)\n",
 			font->fontname, cc, pl));
 		font->chars[cc].width = pl + 1;
 		font->chars[cc].code = cc;
 		font->chars[cc].tfmwidth = TFMSCALE(tfm, z, alpha, beta);
 		font->chars[cc].offset = mlen;
 		font->chars[cc].loaded = 1;
 		if(mlen + pl + 1 > msize) {
 			msize = mlen + pl + 256;
 			macros = xresize(macros, Uchar, msize);
 		}
 		if(pl && fread(macros + mlen, 1, pl, p) != pl)
 			break;
 		macros[mlen+pl] = DVI_EOP;
 		mlen += pl + 1;
 		op = fuget1(p);
 	}
 	if(op != 248) {
 		mdvi_error(_("(vf) %s: no postamble\n"), font->fontname);
 		goto error;
 	}
 
 	/* make macro memory just big enough */
 	if(msize > mlen) {
 		macros = xresize(macros, Uchar, mlen);
 		msize = mlen;
 	}
 	
 	DEBUG((DBG_FONTS|DBG_GLYPHS, 
 		"(vf) %s: macros use %d bytes\n", font->fontname, msize));
 
 	if(loc > 0 || hic < nchars-1) {
 		memmove(font->chars, font->chars + loc,
 			(hic - loc + 1) * sizeof(DviFontChar));
 		font->chars = xresize(font->chars,
 			DviFontChar, hic - loc + 1);
 	}
 	font->loc = loc;
 	font->hic = hic;
 	font->private = macros;
 
 	return 0;
 	
