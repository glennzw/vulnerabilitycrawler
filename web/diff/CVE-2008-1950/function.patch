commit bc8102405fda11ea00ca3b42acc4f4bce9d6e97b
Author: Simon Josefsson <simon@josefsson.org>
Date:   Mon May 19 10:34:08 2008 +0200

    Fix GNUTLS-SA-2008-1 security vulnerabilities.
    See http://www.gnu.org/software/gnutls/security.html for updates.

diff --git a/lib/ext_server_name.c b/lib/ext_server_name.c
index 72e42ff..a2db949 100644
--- a/lib/ext_server_name.c
+++ b/lib/ext_server_name.c
@@ -42,84 +42,97 @@ int
 _gnutls_server_name_recv_params (gnutls_session_t session,
 				 const opaque * data, size_t _data_size)
 {
   int i;
   const unsigned char *p;
   uint16_t len, type;
   ssize_t data_size = _data_size;
   int server_names = 0;
 
   if (session->security_parameters.entity == GNUTLS_SERVER)
     {
       DECR_LENGTH_RET (data_size, 2, 0);
       len = _gnutls_read_uint16 (data);
 
       if (len != data_size)
 	{
 	  /* This is unexpected packet length, but
 	   * just ignore it, for now.
 	   */
 	  gnutls_assert ();
 	  return 0;
 	}
 
       p = data + 2;
 
       /* Count all server_names in the packet. */
       while (data_size > 0)
 	{
 	  DECR_LENGTH_RET (data_size, 1, 0);
 	  p++;
 
 	  DECR_LEN (data_size, 2);
 	  len = _gnutls_read_uint16 (p);
 	  p += 2;
 
-	  DECR_LENGTH_RET (data_size, len, 0);
-	  server_names++;
+	  if (len > 0)
+	    {
+	      DECR_LENGTH_RET (data_size, len, 0);
+	      server_names++;
+	      p += len;
+	    }
+	  else
+	    _gnutls_handshake_log
+	      ("HSK[%x]: Received zero size server name (under attack?)\n",
+	       session);
 
-	  p += len;
+	}
+
+      /* we cannot accept more server names.
+       */
+      if (server_names > MAX_SERVER_NAME_EXTENSIONS)
+	{
+	  _gnutls_handshake_log
+	    ("HSK[%x]: Too many server names received (under attack?)\n",
+	     session);
+	  server_names = MAX_SERVER_NAME_EXTENSIONS;
 	}
 
       session->security_parameters.extensions.server_names_size =
 	server_names;
       if (server_names == 0)
 	return 0;		/* no names found */
 
-      /* we cannot accept more server names.
-       */
-      if (server_names > MAX_SERVER_NAME_EXTENSIONS)
-	server_names = MAX_SERVER_NAME_EXTENSIONS;
 
       p = data + 2;
       for (i = 0; i < server_names; i++)
 	{
 	  type = *p;
 	  p++;
 
 	  len = _gnutls_read_uint16 (p);
 	  p += 2;
 
 	  switch (type)
 	    {
 	    case 0:		/* NAME_DNS */
 	      if (len <= MAX_SERVER_NAME_SIZE)
 		{
 		  memcpy (session->security_parameters.extensions.
 			  server_names[i].name, p, len);
 		  session->security_parameters.extensions.
 		    server_names[i].name_length = len;
 		  session->security_parameters.extensions.
 		    server_names[i].type = GNUTLS_NAME_DNS;
 		  break;
 		}
 	    }
 
 	  /* move to next record */
 	  p += len;
 	}
     }
   return 0;
 }
 
 /* returns data_size or a negative number on failure
  */
diff --git a/lib/gnutls_cipher.c b/lib/gnutls_cipher.c
index ad192f4..778402a 100644
--- a/lib/gnutls_cipher.c
+++ b/lib/gnutls_cipher.c
@@ -424,167 +424,175 @@ int
 _gnutls_ciphertext2compressed (gnutls_session_t session,
 			       opaque * compress_data,
 			       int compress_size,
 			       gnutls_datum_t ciphertext, uint8_t type)
 {
   uint8_t MAC[MAX_HASH_SIZE];
   uint16_t c_length;
   uint8_t pad;
   int length;
   digest_hd_st td;
   uint16_t blocksize;
   int ret, i, pad_failed = 0;
   uint8_t major, minor;
   gnutls_protocol_t ver;
   int hash_size =
     _gnutls_hash_get_algo_len (session->security_parameters.
 			       read_mac_algorithm);
 
   ver = gnutls_protocol_get_version (session);
   minor = _gnutls_version_get_minor (ver);
   major = _gnutls_version_get_major (ver);
 
   blocksize = _gnutls_cipher_get_block_size (session->security_parameters.
 					     read_bulk_cipher_algorithm);
 
   /* initialize MAC 
    */
   ret = mac_init (&td, session->security_parameters.read_mac_algorithm,
 		 session->connection_state.read_mac_secret.data,
 		 session->connection_state.read_mac_secret.size, ver);
 
   if (ret < 0
       && session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)
     {
       gnutls_assert ();
       return GNUTLS_E_INTERNAL_ERROR;
     }
 
+  if (ciphertext.size < (unsigned) blocksize + hash_size)
+    {
+      _gnutls_record_log
+	("REC[%x]: Short record length %d < %d + %d (under attack?)\n",
+	 session, ciphertext.size, blocksize, hash_size);
+      gnutls_assert ();
+      return GNUTLS_E_DECRYPTION_FAILED;
+    }
 
   /* actual decryption (inplace)
    */
   switch (_gnutls_cipher_is_block
 	  (session->security_parameters.read_bulk_cipher_algorithm))
     {
     case CIPHER_STREAM:
       if ((ret = _gnutls_cipher_decrypt (&session->connection_state.
 					 read_cipher_state,
 					 ciphertext.data,
 					 ciphertext.size)) < 0)
 	{
 	  gnutls_assert ();
 	  return ret;
 	}
 
       length = ciphertext.size - hash_size;
 
       break;
     case CIPHER_BLOCK:
       if ((ciphertext.size < blocksize) || (ciphertext.size % blocksize != 0))
 	{
 	  gnutls_assert ();
 	  return GNUTLS_E_DECRYPTION_FAILED;
 	}
 
       if ((ret = _gnutls_cipher_decrypt (&session->connection_state.
 					 read_cipher_state,
 					 ciphertext.data,
 					 ciphertext.size)) < 0)
 	{
 	  gnutls_assert ();
 	  return ret;
 	}
 
       /* ignore the IV in TLS 1.1.
        */
       if (session->security_parameters.version >= GNUTLS_TLS1_1)
 	{
 	  ciphertext.size -= blocksize;
 	  ciphertext.data += blocksize;
 
 	  if (ciphertext.size == 0)
 	    {
 	      gnutls_assert ();
 	      return GNUTLS_E_DECRYPTION_FAILED;
 	    }
 	}
 
       pad = ciphertext.data[ciphertext.size - 1] + 1;	/* pad */
 
-      length = ciphertext.size - hash_size - pad;
-
-      if (pad > ciphertext.size - hash_size)
+      if ((int)pad > (int)ciphertext.size - hash_size)
 	{
 	  gnutls_assert ();
 	  /* We do not fail here. We check below for the
 	   * the pad_failed. If zero means success.
 	   */
 	  pad_failed = GNUTLS_E_DECRYPTION_FAILED;
 	}
 
+      length = ciphertext.size - hash_size - pad;
+
       /* Check the pading bytes (TLS 1.x)
        */
       if (ver >= GNUTLS_TLS1 && pad_failed == 0)
 	for (i = 2; i < pad; i++)
 	  {
 	    if (ciphertext.data[ciphertext.size - i] !=
 		ciphertext.data[ciphertext.size - 1])
 	      pad_failed = GNUTLS_E_DECRYPTION_FAILED;
 	  }
       break;
     default:
       gnutls_assert ();
       return GNUTLS_E_INTERNAL_ERROR;
     }
 
   if (length < 0)
     length = 0;
   c_length = _gnutls_conv_uint16 ((uint16_t) length);
 
   /* Pass the type, version, length and compressed through
    * MAC.
    */
   if (session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)
     {
       _gnutls_hmac (&td,
 		    UINT64DATA (session->connection_state.
 				read_sequence_number), 8);
 
       _gnutls_hmac (&td, &type, 1);
       if (ver >= GNUTLS_TLS1)
 	{			/* TLS 1.x */
 	  _gnutls_hmac (&td, &major, 1);
 	  _gnutls_hmac (&td, &minor, 1);
 	}
       _gnutls_hmac (&td, &c_length, 2);
 
       if (length > 0)
 	_gnutls_hmac (&td, ciphertext.data, length);
 
       mac_deinit (&td, MAC, ver);
     }
 
   /* This one was introduced to avoid a timing attack against the TLS
    * 1.0 protocol.
    */
   if (pad_failed != 0)
     return pad_failed;
 
   /* HMAC was not the same. 
    */
   if (memcmp (MAC, &ciphertext.data[length], hash_size) != 0)
     {
       gnutls_assert ();
       return GNUTLS_E_DECRYPTION_FAILED;
     }
 
   /* copy the decrypted stuff to compress_data.
    */
   if (compress_size < length)
     {
       gnutls_assert ();
       return GNUTLS_E_DECOMPRESSION_FAILED;
     }
   memcpy (compress_data, ciphertext.data, length);
 
   return length;
 }
diff --git a/lib/gnutls_handshake.c b/lib/gnutls_handshake.c
index 4ab6db6..d798180 100644
--- a/lib/gnutls_handshake.c
+++ b/lib/gnutls_handshake.c
@@ -984,132 +984,140 @@ static int
 _gnutls_recv_handshake_header (gnutls_session_t session,
 			       gnutls_handshake_description_t type,
 			       gnutls_handshake_description_t * recv_type)
 {
   int ret;
   uint32_t length32 = 0;
   uint8_t *dataptr = NULL;	/* for realloc */
   size_t handshake_header_size = HANDSHAKE_HEADER_SIZE;
 
   /* if we have data into the buffer then return them, do not read the next packet.
    * In order to return we need a full TLS handshake header, or in case of a version 2
    * packet, then we return the first byte.
    */
   if (session->internals.handshake_header_buffer.header_size ==
       handshake_header_size || (session->internals.v2_hello != 0
 				&& type == GNUTLS_HANDSHAKE_CLIENT_HELLO
 				&& session->internals.
 				handshake_header_buffer.packet_length > 0))
     {
 
       *recv_type = session->internals.handshake_header_buffer.recv_type;
 
+      if (*recv_type != type)
+	{
+	  gnutls_assert ();
+	  _gnutls_handshake_log
+	    ("HSK[%x]: Handshake type mismatch (under attack?)\n", session);
+	  return GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET;
+	}
+
       return session->internals.handshake_header_buffer.packet_length;
     }
 
   /* Note: SSL2_HEADERS == 1 */
 
   dataptr = session->internals.handshake_header_buffer.header;
 
   /* If we haven't already read the handshake headers.
    */
   if (session->internals.handshake_header_buffer.header_size < SSL2_HEADERS)
     {
       ret =
 	_gnutls_handshake_io_recv_int (session, GNUTLS_HANDSHAKE,
 				       type, dataptr, SSL2_HEADERS);
 
       if (ret < 0)
 	{
 	  gnutls_assert ();
 	  return ret;
 	}
 
       /* The case ret==0 is caught here.
        */
       if (ret != SSL2_HEADERS)
 	{
 	  gnutls_assert ();
 	  return GNUTLS_E_UNEXPECTED_PACKET_LENGTH;
 	}
       session->internals.handshake_header_buffer.header_size = SSL2_HEADERS;
     }
 
   if (session->internals.v2_hello == 0
       || type != GNUTLS_HANDSHAKE_CLIENT_HELLO)
     {
       ret =
 	_gnutls_handshake_io_recv_int (session, GNUTLS_HANDSHAKE,
 				       type,
 				       &dataptr[session->
 						internals.
 						handshake_header_buffer.
 						header_size],
 				       HANDSHAKE_HEADER_SIZE -
 				       session->internals.
 				       handshake_header_buffer.header_size);
       if (ret <= 0)
 	{
 	  gnutls_assert ();
 	  return (ret < 0) ? ret : GNUTLS_E_UNEXPECTED_PACKET_LENGTH;
 	}
       if ((size_t) ret !=
 	  HANDSHAKE_HEADER_SIZE -
 	  session->internals.handshake_header_buffer.header_size)
 	{
 	  gnutls_assert ();
 	  return GNUTLS_E_UNEXPECTED_PACKET_LENGTH;
 	}
       *recv_type = dataptr[0];
 
       /* we do not use DECR_LEN because we know
        * that the packet has enough data.
        */
       length32 = _gnutls_read_uint24 (&dataptr[1]);
       handshake_header_size = HANDSHAKE_HEADER_SIZE;
 
       _gnutls_handshake_log ("HSK[%x]: %s was received [%ld bytes]\n",
 			     session, _gnutls_handshake2str (dataptr[0]),
 			     length32 + HANDSHAKE_HEADER_SIZE);
 
     }
   else
     {				/* v2 hello */
       length32 = session->internals.v2_hello - SSL2_HEADERS;	/* we've read the first byte */
 
       handshake_header_size = SSL2_HEADERS;	/* we've already read one byte */
 
       *recv_type = dataptr[0];
 
       _gnutls_handshake_log ("HSK[%x]: %s(v2) was received [%ld bytes]\n",
 			     session, _gnutls_handshake2str (*recv_type),
 			     length32 + handshake_header_size);
 
       if (*recv_type != GNUTLS_HANDSHAKE_CLIENT_HELLO)
 	{			/* it should be one or nothing */
 	  gnutls_assert ();
 	  return GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET;
 	}
     }
 
   /* put the packet into the buffer */
   session->internals.handshake_header_buffer.header_size =
     handshake_header_size;
   session->internals.handshake_header_buffer.packet_length = length32;
   session->internals.handshake_header_buffer.recv_type = *recv_type;
 
   if (*recv_type != type)
     {
       gnutls_assert ();
       return GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET;
     }
 
   return length32;
 }
 
 #define _gnutls_handshake_header_buffer_clear( session) session->internals.handshake_header_buffer.header_size = 0
 
 
 
 /* This function will hash the handshake headers and the
  * handshake data.
  */
