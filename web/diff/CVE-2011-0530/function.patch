commit 3ef52043861ab16352d49af89e048ba6339d6df8
Author: Wouter Verhelst <w@uter.be>
Date:   Thu Jan 27 22:30:09 2011 +0100

    Fix buffer size checking
    
    Yes, this means we've re-introduced CVE-2005-3534. Sigh.

diff --git a/nbd-server.c b/nbd-server.c
index 820458c..b47da86 100644
--- a/nbd-server.c
+++ b/nbd-server.c
@@ -117,46 +117,46 @@ gchar* rungroup=NULL;
 gboolean do_oldstyle=FALSE;
 
 /** Logging macros, now nothing goes to syslog unless you say ISSERVER */
 #ifdef ISSERVER
 #define msg2(a,b) syslog(a,b)
 #define msg3(a,b,c) syslog(a,b,c)
 #define msg4(a,b,c,d) syslog(a,b,c,d)
 #else
 #define msg2(a,b) g_message(b)
 #define msg3(a,b,c) g_message(b,c)
 #define msg4(a,b,c,d) g_message(b,c,d)
 #endif
 
 /* Debugging macros */
 //#define DODBG
 #ifdef DODBG
 #define DEBUG( a ) printf( a )
 #define DEBUG2( a,b ) printf( a,b )
 #define DEBUG3( a,b,c ) printf( a,b,c )
 #define DEBUG4( a,b,c,d ) printf( a,b,c,d )
 #else
 #define DEBUG( a )
 #define DEBUG2( a,b ) 
 #define DEBUG3( a,b,c ) 
 #define DEBUG4( a,b,c,d ) 
 #endif
 #ifndef PACKAGE_VERSION
 #define PACKAGE_VERSION ""
 #endif
 /**
  * The highest value a variable of type off_t can reach. This is a signed
  * integer, so set all bits except for the leftmost one.
  **/
 #define OFFT_MAX ~((off_t)1<<(sizeof(off_t)*8-1))
 #define LINELEN 256	  /**< Size of static buffer used to read the
 			       authorization file (yuck) */
-#define BUFSIZE (1024*1024) /**< Size of buffer that can hold requests */
+#define BUFSIZE ((1024*1024)+sizeof(struct nbd_reply)) /**< Size of buffer that can hold requests */
 #define DIFFPAGESIZE 4096 /**< diff file uses those chunks */
 #define F_READONLY 1      /**< flag to tell us a file is readonly */
 #define F_MULTIFILE 2	  /**< flag to tell us a file is exported using -m */
 #define F_COPYONWRITE 4	  /**< flag to tell us a file is exported using
 			    copyonwrite */
 #define F_AUTOREADONLY 8  /**< flag to tell us a file is set to autoreadonly */
 #define F_SPARSE 16	  /**< flag to tell us copyronwrite should use a sparse file */
 #define F_SDP 32	  /**< flag to tell us the export should be done using the Socket Direct Protocol for RDMA */
 #define F_SYNC 64	  /**< Whether to fsync() after a write */
@@ -1354,99 +1354,99 @@ CLIENT* negotiate(int net, CLIENT *client, GArray* servers) {
 int mainloop(CLIENT *client) {
 	struct nbd_request request;
 	struct nbd_reply reply;
 	gboolean go_on=TRUE;
 #ifdef DODBG
 	int i = 0;
 #endif
 	negotiate(client->net, client, NULL);
 	DEBUG("Entering request loop!\n");
 	reply.magic = htonl(NBD_REPLY_MAGIC);
 	reply.error = 0;
 	while (go_on) {
 		char buf[BUFSIZE];
 		size_t len;
 #ifdef DODBG
 		i++;
 		printf("%d: ", i);
 #endif
 		readit(client->net, &request, sizeof(request));
 		request.from = ntohll(request.from);
 		request.type = ntohl(request.type);
 
 		if (request.type==NBD_CMD_DISC) {
 			msg2(LOG_INFO, "Disconnect request received.");
                 	if (client->server->flags & F_COPYONWRITE) { 
 				if (client->difmap) g_free(client->difmap) ;
                 		close(client->difffile);
 				unlink(client->difffilename);
 				free(client->difffilename);
 			}
 			go_on=FALSE;
 			continue;
 		}
 
 		len = ntohl(request.len);
 
 		if (request.magic != htonl(NBD_REQUEST_MAGIC))
 			err("Not enough magic.");
-		if (len > BUFSIZE + sizeof(struct nbd_reply))
+		if (len > BUFSIZE - sizeof(struct nbd_reply))
 			err("Request too big!");
 #ifdef DODBG
 		printf("%s from %llu (%llu) len %d, ", request.type ? "WRITE" :
 				"READ", (unsigned long long)request.from,
 				(unsigned long long)request.from / 512, len);
 #endif
 		memcpy(reply.handle, request.handle, sizeof(reply.handle));
 		if ((request.from + len) > (OFFT_MAX)) {
 			DEBUG("[Number too large!]");
 			ERROR(client, reply, EINVAL);
 			continue;
 		}
 
 		if (((ssize_t)((off_t)request.from + len) > client->exportsize)) {
 			DEBUG("[RANGE!]");
 			ERROR(client, reply, EINVAL);
 			continue;
 		}
 
 		if (request.type==NBD_CMD_WRITE) {
 			DEBUG("wr: net->buf, ");
 			readit(client->net, buf, len);
 			DEBUG("buf->exp, ");
 			if ((client->server->flags & F_READONLY) ||
 			    (client->server->flags & F_AUTOREADONLY)) {
 				DEBUG("[WRITE to READONLY!]");
 				ERROR(client, reply, EPERM);
 				continue;
 			}
 			if (expwrite(request.from, buf, len, client)) {
 				DEBUG("Write failed: %m" );
 				ERROR(client, reply, errno);
 				continue;
 			}
 			SEND(client->net, reply);
 			DEBUG("OK!\n");
 			continue;
 		}
 		/* READ */
 
 		DEBUG("exp->buf, ");
 		if (expread(request.from, buf + sizeof(struct nbd_reply), len, client)) {
 			DEBUG("Read failed: %m");
 			ERROR(client, reply, errno);
 			continue;
 		}
 
 		DEBUG("buf->net, ");
 		memcpy(buf, &reply, sizeof(struct nbd_reply));
 		writeit(client->net, buf, len + sizeof(struct nbd_reply));
 		DEBUG("OK!\n");
 	}
 	return 0;
 }
 
 /**
  * Set up client export array, which is an array of FILE_INFO.
  * Also, split a single exportfile into multiple ones, if that was asked.
  * @param client information on the client which we want to setup export for
  **/
