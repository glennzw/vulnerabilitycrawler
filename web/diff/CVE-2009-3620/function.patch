commit 7dc482dfeeeefcfd000d4271c4626937406756d7
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Sun Aug 23 16:59:04 2009 +0100

    drm/r128: Add test for initialisation to all ioctls that require it
    
    Almost all r128's private ioctls require that the CCE state has
    already been initialised.  However, most do not test that this has
    been done, and will proceed to dereference a null pointer.  This may
    result in a security vulnerability, since some ioctls are
    unprivileged.
    
    This adds a macro for the common initialisation test and changes all
    ioctl implementations that require prior initialisation to use that
    macro.
    
    Also, r128_do_init_cce() does not test that the CCE state has not
    been initialised already.  Repeated initialisation may lead to a crash
    or resource leak.  This adds that test.
    
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/r128/r128_cce.c b/drivers/gpu/drm/r128/r128_cce.c
index 15252f6..4c39a40 100644
--- a/drivers/gpu/drm/r128/r128_cce.c
+++ b/drivers/gpu/drm/r128/r128_cce.c
@@ -342,243 +342,248 @@ static void r128_cce_init_ring_buffer(struct drm_device * dev,
 static int r128_do_init_cce(struct drm_device * dev, drm_r128_init_t * init)
 {
 	drm_r128_private_t *dev_priv;
 	int rc;
 
 	DRM_DEBUG("\n");
 
+	if (dev->dev_private) {
+		DRM_DEBUG("called when already initialized\n");
+		return -EINVAL;
+	}
+
 	dev_priv = kzalloc(sizeof(drm_r128_private_t), GFP_KERNEL);
 	if (dev_priv == NULL)
 		return -ENOMEM;
 
 	dev_priv->is_pci = init->is_pci;
 
 	if (dev_priv->is_pci && !dev->sg) {
 		DRM_ERROR("PCI GART memory not allocated!\n");
 		dev->dev_private = (void *)dev_priv;
 		r128_do_cleanup_cce(dev);
 		return -EINVAL;
 	}
 
 	dev_priv->usec_timeout = init->usec_timeout;
 	if (dev_priv->usec_timeout < 1 ||
 	    dev_priv->usec_timeout > R128_MAX_USEC_TIMEOUT) {
 		DRM_DEBUG("TIMEOUT problem!\n");
 		dev->dev_private = (void *)dev_priv;
 		r128_do_cleanup_cce(dev);
 		return -EINVAL;
 	}
 
 	dev_priv->cce_mode = init->cce_mode;
 
 	/* GH: Simple idle check.
 	 */
 	atomic_set(&dev_priv->idle_count, 0);
 
 	/* We don't support anything other than bus-mastering ring mode,
 	 * but the ring can be in either AGP or PCI space for the ring
 	 * read pointer.
 	 */
 	if ((init->cce_mode != R128_PM4_192BM) &&
 	    (init->cce_mode != R128_PM4_128BM_64INDBM) &&
 	    (init->cce_mode != R128_PM4_64BM_128INDBM) &&
 	    (init->cce_mode != R128_PM4_64BM_64VCBM_64INDBM)) {
 		DRM_DEBUG("Bad cce_mode!\n");
 		dev->dev_private = (void *)dev_priv;
 		r128_do_cleanup_cce(dev);
 		return -EINVAL;
 	}
 
 	switch (init->cce_mode) {
 	case R128_PM4_NONPM4:
 		dev_priv->cce_fifo_size = 0;
 		break;
 	case R128_PM4_192PIO:
 	case R128_PM4_192BM:
 		dev_priv->cce_fifo_size = 192;
 		break;
 	case R128_PM4_128PIO_64INDBM:
 	case R128_PM4_128BM_64INDBM:
 		dev_priv->cce_fifo_size = 128;
 		break;
 	case R128_PM4_64PIO_128INDBM:
 	case R128_PM4_64BM_128INDBM:
 	case R128_PM4_64PIO_64VCBM_64INDBM:
 	case R128_PM4_64BM_64VCBM_64INDBM:
 	case R128_PM4_64PIO_64VCPIO_64INDPIO:
 		dev_priv->cce_fifo_size = 64;
 		break;
 	}
 
 	switch (init->fb_bpp) {
 	case 16:
 		dev_priv->color_fmt = R128_DATATYPE_RGB565;
 		break;
 	case 32:
 	default:
 		dev_priv->color_fmt = R128_DATATYPE_ARGB8888;
 		break;
 	}
 	dev_priv->front_offset = init->front_offset;
 	dev_priv->front_pitch = init->front_pitch;
 	dev_priv->back_offset = init->back_offset;
 	dev_priv->back_pitch = init->back_pitch;
 
 	switch (init->depth_bpp) {
 	case 16:
 		dev_priv->depth_fmt = R128_DATATYPE_RGB565;
 		break;
 	case 24:
 	case 32:
 	default:
 		dev_priv->depth_fmt = R128_DATATYPE_ARGB8888;
 		break;
 	}
 	dev_priv->depth_offset = init->depth_offset;
 	dev_priv->depth_pitch = init->depth_pitch;
 	dev_priv->span_offset = init->span_offset;
 
 	dev_priv->front_pitch_offset_c = (((dev_priv->front_pitch / 8) << 21) |
 					  (dev_priv->front_offset >> 5));
 	dev_priv->back_pitch_offset_c = (((dev_priv->back_pitch / 8) << 21) |
 					 (dev_priv->back_offset >> 5));
 	dev_priv->depth_pitch_offset_c = (((dev_priv->depth_pitch / 8) << 21) |
 					  (dev_priv->depth_offset >> 5) |
 					  R128_DST_TILE);
 	dev_priv->span_pitch_offset_c = (((dev_priv->depth_pitch / 8) << 21) |
 					 (dev_priv->span_offset >> 5));
 
 	dev_priv->sarea = drm_getsarea(dev);
 	if (!dev_priv->sarea) {
 		DRM_ERROR("could not find sarea!\n");
 		dev->dev_private = (void *)dev_priv;
 		r128_do_cleanup_cce(dev);
 		return -EINVAL;
 	}
 
 	dev_priv->mmio = drm_core_findmap(dev, init->mmio_offset);
 	if (!dev_priv->mmio) {
 		DRM_ERROR("could not find mmio region!\n");
 		dev->dev_private = (void *)dev_priv;
 		r128_do_cleanup_cce(dev);
 		return -EINVAL;
 	}
 	dev_priv->cce_ring = drm_core_findmap(dev, init->ring_offset);
 	if (!dev_priv->cce_ring) {
 		DRM_ERROR("could not find cce ring region!\n");
 		dev->dev_private = (void *)dev_priv;
 		r128_do_cleanup_cce(dev);
 		return -EINVAL;
 	}
 	dev_priv->ring_rptr = drm_core_findmap(dev, init->ring_rptr_offset);
 	if (!dev_priv->ring_rptr) {
 		DRM_ERROR("could not find ring read pointer!\n");
 		dev->dev_private = (void *)dev_priv;
 		r128_do_cleanup_cce(dev);
 		return -EINVAL;
 	}
 	dev->agp_buffer_token = init->buffers_offset;
 	dev->agp_buffer_map = drm_core_findmap(dev, init->buffers_offset);
 	if (!dev->agp_buffer_map) {
 		DRM_ERROR("could not find dma buffer region!\n");
 		dev->dev_private = (void *)dev_priv;
 		r128_do_cleanup_cce(dev);
 		return -EINVAL;
 	}
 
 	if (!dev_priv->is_pci) {
 		dev_priv->agp_textures =
 		    drm_core_findmap(dev, init->agp_textures_offset);
 		if (!dev_priv->agp_textures) {
 			DRM_ERROR("could not find agp texture region!\n");
 			dev->dev_private = (void *)dev_priv;
 			r128_do_cleanup_cce(dev);
 			return -EINVAL;
 		}
 	}
 
 	dev_priv->sarea_priv =
 	    (drm_r128_sarea_t *) ((u8 *) dev_priv->sarea->handle +
 				  init->sarea_priv_offset);
 
 #if __OS_HAS_AGP
 	if (!dev_priv->is_pci) {
 		drm_core_ioremap_wc(dev_priv->cce_ring, dev);
 		drm_core_ioremap_wc(dev_priv->ring_rptr, dev);
 		drm_core_ioremap_wc(dev->agp_buffer_map, dev);
 		if (!dev_priv->cce_ring->handle ||
 		    !dev_priv->ring_rptr->handle ||
 		    !dev->agp_buffer_map->handle) {
 			DRM_ERROR("Could not ioremap agp regions!\n");
 			dev->dev_private = (void *)dev_priv;
 			r128_do_cleanup_cce(dev);
 			return -ENOMEM;
 		}
 	} else
 #endif
 	{
 		dev_priv->cce_ring->handle =
 			(void *)(unsigned long)dev_priv->cce_ring->offset;
 		dev_priv->ring_rptr->handle =
 			(void *)(unsigned long)dev_priv->ring_rptr->offset;
 		dev->agp_buffer_map->handle =
 			(void *)(unsigned long)dev->agp_buffer_map->offset;
 	}
 
 #if __OS_HAS_AGP
 	if (!dev_priv->is_pci)
 		dev_priv->cce_buffers_offset = dev->agp->base;
 	else
 #endif
 		dev_priv->cce_buffers_offset = (unsigned long)dev->sg->virtual;
 
 	dev_priv->ring.start = (u32 *) dev_priv->cce_ring->handle;
 	dev_priv->ring.end = ((u32 *) dev_priv->cce_ring->handle
 			      + init->ring_size / sizeof(u32));
 	dev_priv->ring.size = init->ring_size;
 	dev_priv->ring.size_l2qw = drm_order(init->ring_size / 8);
 
 	dev_priv->ring.tail_mask = (dev_priv->ring.size / sizeof(u32)) - 1;
 
 	dev_priv->ring.high_mark = 128;
 
 	dev_priv->sarea_priv->last_frame = 0;
 	R128_WRITE(R128_LAST_FRAME_REG, dev_priv->sarea_priv->last_frame);
 
 	dev_priv->sarea_priv->last_dispatch = 0;
 	R128_WRITE(R128_LAST_DISPATCH_REG, dev_priv->sarea_priv->last_dispatch);
 
 #if __OS_HAS_AGP
 	if (dev_priv->is_pci) {
 #endif
 		dev_priv->gart_info.table_mask = DMA_BIT_MASK(32);
 		dev_priv->gart_info.gart_table_location = DRM_ATI_GART_MAIN;
 		dev_priv->gart_info.table_size = R128_PCIGART_TABLE_SIZE;
 		dev_priv->gart_info.addr = NULL;
 		dev_priv->gart_info.bus_addr = 0;
 		dev_priv->gart_info.gart_reg_if = DRM_ATI_GART_PCI;
 		if (!drm_ati_pcigart_init(dev, &dev_priv->gart_info)) {
 			DRM_ERROR("failed to init PCI GART!\n");
 			dev->dev_private = (void *)dev_priv;
 			r128_do_cleanup_cce(dev);
 			return -ENOMEM;
 		}
 		R128_WRITE(R128_PCI_GART_PAGE, dev_priv->gart_info.bus_addr);
 #if __OS_HAS_AGP
 	}
 #endif
 
 	r128_cce_init_ring_buffer(dev, dev_priv);
 	rc = r128_cce_load_microcode(dev_priv);
 
 	dev->dev_private = (void *)dev_priv;
 
 	r128_do_engine_reset(dev);
 
 	if (rc) {
 		DRM_ERROR("Failed to load firmware!\n");
 		r128_do_cleanup_cce(dev);
 	}
 
 	return rc;
 }
 
@@ -643,102 +648,107 @@ int r128_cce_init(struct drm_device *dev, void *data, struct drm_file *file_priv
 int r128_cce_start(struct drm_device *dev, void *data, struct drm_file *file_priv)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	DRM_DEBUG("\n");
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
+	DEV_INIT_TEST_WITH_RETURN(dev_priv);
+
 	if (dev_priv->cce_running || dev_priv->cce_mode == R128_PM4_NONPM4) {
 		DRM_DEBUG("while CCE running\n");
 		return 0;
 	}
 
 	r128_do_cce_start(dev_priv);
 
 	return 0;
 }
 
 /* Stop the CCE.  The engine must have been idled before calling this
  * routine.
  */
 int r128_cce_stop(struct drm_device *dev, void *data, struct drm_file *file_priv)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	drm_r128_cce_stop_t *stop = data;
 	int ret;
 	DRM_DEBUG("\n");
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
+	DEV_INIT_TEST_WITH_RETURN(dev_priv);
+
 	/* Flush any pending CCE commands.  This ensures any outstanding
 	 * commands are exectuted by the engine before we turn it off.
 	 */
 	if (stop->flush) {
 		r128_do_cce_flush(dev_priv);
 	}
 
 	/* If we fail to make the engine go idle, we return an error
 	 * code so that the DRM ioctl wrapper can try again.
 	 */
 	if (stop->idle) {
 		ret = r128_do_cce_idle(dev_priv);
 		if (ret)
 			return ret;
 	}
 
 	/* Finally, we can turn off the CCE.  If the engine isn't idle,
 	 * we will get some dropped triangles as they won't be fully
 	 * rendered before the CCE is shut down.
 	 */
 	r128_do_cce_stop(dev_priv);
 
 	/* Reset the engine */
 	r128_do_engine_reset(dev);
 
 	return 0;
 }
 
 /* Just reset the CCE ring.  Called as part of an X Server engine reset.
  */
 int r128_cce_reset(struct drm_device *dev, void *data, struct drm_file *file_priv)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	DRM_DEBUG("\n");
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
-	if (!dev_priv) {
-		DRM_DEBUG("called before init done\n");
-		return -EINVAL;
-	}
+	DEV_INIT_TEST_WITH_RETURN(dev_priv);
 
 	r128_do_cce_reset(dev_priv);
 
 	/* The CCE is no longer running after an engine reset */
 	dev_priv->cce_running = 0;
 
 	return 0;
 }
 
 int r128_cce_idle(struct drm_device *dev, void *data, struct drm_file *file_priv)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	DRM_DEBUG("\n");
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
+	DEV_INIT_TEST_WITH_RETURN(dev_priv);
+
 	if (dev_priv->cce_running) {
 		r128_do_cce_flush(dev_priv);
 	}
 
 	return r128_do_cce_idle(dev_priv);
 }
 
 int r128_engine_reset(struct drm_device *dev, void *data, struct drm_file *file_priv)
 {
 	DRM_DEBUG("\n");
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
+	DEV_INIT_TEST_WITH_RETURN(dev->dev_private);
+
 	return r128_do_engine_reset(dev);
 }
 
diff --git a/drivers/gpu/drm/r128/r128_drv.h b/drivers/gpu/drm/r128/r128_drv.h
index 797a26c..3c60829 100644
--- a/drivers/gpu/drm/r128/r128_drv.h
+++ b/drivers/gpu/drm/r128/r128_drv.h
@@ -413,15 +413,23 @@ do {									\
 static __inline__ void r128_update_ring_snapshot(drm_r128_private_t * dev_priv)
 {
 	drm_r128_ring_buffer_t *ring = &dev_priv->ring;
 	ring->space = (GET_RING_HEAD(dev_priv) - ring->tail) * sizeof(u32);
 	if (ring->space <= 0)
 		ring->space += ring->size;
 }
 
 /* ================================================================
  * Misc helper macros
  */
 
+#define DEV_INIT_TEST_WITH_RETURN(_dev_priv)				\
+do {									\
+	if (!_dev_priv) {						\
+		DRM_ERROR("called with no initialization\n");		\
+		return -EINVAL;						\
+	}								\
+} while (0)
+
 #define RING_SPACE_TEST_WITH_RETURN( dev_priv )				\
 do {									\
 	drm_r128_ring_buffer_t *ring = &dev_priv->ring; int i;		\
diff --git a/drivers/gpu/drm/r128/r128_state.c b/drivers/gpu/drm/r128/r128_state.c
index 026a48c..af2665c 100644
--- a/drivers/gpu/drm/r128/r128_state.c
+++ b/drivers/gpu/drm/r128/r128_state.c
@@ -1244,24 +1244,28 @@ static void r128_cce_dispatch_stipple(struct drm_device * dev, u32 * stipple)
 static int r128_cce_clear(struct drm_device *dev, void *data, struct drm_file *file_priv)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
-	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
+	drm_r128_sarea_t *sarea_priv;
 	drm_r128_clear_t *clear = data;
 	DRM_DEBUG("\n");
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
+	DEV_INIT_TEST_WITH_RETURN(dev_priv);
+
 	RING_SPACE_TEST_WITH_RETURN(dev_priv);
 
+	sarea_priv = dev_priv->sarea_priv;
+
 	if (sarea_priv->nbox > R128_NR_SAREA_CLIPRECTS)
 		sarea_priv->nbox = R128_NR_SAREA_CLIPRECTS;
 
 	r128_cce_dispatch_clear(dev, clear);
 	COMMIT_RING();
 
 	/* Make sure we restore the 3D state next time.
 	 */
 	dev_priv->sarea_priv->dirty |= R128_UPLOAD_CONTEXT | R128_UPLOAD_MASKS;
 
 	return 0;
 }
 
@@ -1308,338 +1312,336 @@ static int r128_do_cleanup_pageflip(struct drm_device * dev)
 static int r128_cce_flip(struct drm_device *dev, void *data, struct drm_file *file_priv)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	DRM_DEBUG("\n");
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
+	DEV_INIT_TEST_WITH_RETURN(dev_priv);
+
 	RING_SPACE_TEST_WITH_RETURN(dev_priv);
 
 	if (!dev_priv->page_flipping)
 		r128_do_init_pageflip(dev);
 
 	r128_cce_dispatch_flip(dev);
 
 	COMMIT_RING();
 	return 0;
 }
 
 static int r128_cce_swap(struct drm_device *dev, void *data, struct drm_file *file_priv)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	drm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;
 	DRM_DEBUG("\n");
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
+	DEV_INIT_TEST_WITH_RETURN(dev_priv);
+
 	RING_SPACE_TEST_WITH_RETURN(dev_priv);
 
 	if (sarea_priv->nbox > R128_NR_SAREA_CLIPRECTS)
 		sarea_priv->nbox = R128_NR_SAREA_CLIPRECTS;
 
 	r128_cce_dispatch_swap(dev);
 	dev_priv->sarea_priv->dirty |= (R128_UPLOAD_CONTEXT |
 					R128_UPLOAD_MASKS);
 
 	COMMIT_RING();
 	return 0;
 }
 
 static int r128_cce_vertex(struct drm_device *dev, void *data, struct drm_file *file_priv)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	struct drm_device_dma *dma = dev->dma;
 	struct drm_buf *buf;
 	drm_r128_buf_priv_t *buf_priv;
 	drm_r128_vertex_t *vertex = data;
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
-	if (!dev_priv) {
-		DRM_ERROR("called with no initialization\n");
-		return -EINVAL;
-	}
+	DEV_INIT_TEST_WITH_RETURN(dev_priv);
 
 	DRM_DEBUG("pid=%d index=%d count=%d discard=%d\n",
 		  DRM_CURRENTPID, vertex->idx, vertex->count, vertex->discard);
 
 	if (vertex->idx < 0 || vertex->idx >= dma->buf_count) {
 		DRM_ERROR("buffer index %d (of %d max)\n",
 			  vertex->idx, dma->buf_count - 1);
 		return -EINVAL;
 	}
 	if (vertex->prim < 0 ||
 	    vertex->prim > R128_CCE_VC_CNTL_PRIM_TYPE_TRI_TYPE2) {
 		DRM_ERROR("buffer prim %d\n", vertex->prim);
 		return -EINVAL;
 	}
 
 	RING_SPACE_TEST_WITH_RETURN(dev_priv);
 	VB_AGE_TEST_WITH_RETURN(dev_priv);
 
 	buf = dma->buflist[vertex->idx];
 	buf_priv = buf->dev_private;
 
 	if (buf->file_priv != file_priv) {
 		DRM_ERROR("process %d using buffer owned by %p\n",
 			  DRM_CURRENTPID, buf->file_priv);
 		return -EINVAL;
 	}
 	if (buf->pending) {
 		DRM_ERROR("sending pending buffer %d\n", vertex->idx);
 		return -EINVAL;
 	}
 
 	buf->used = vertex->count;
 	buf_priv->prim = vertex->prim;
 	buf_priv->discard = vertex->discard;
 
 	r128_cce_dispatch_vertex(dev, buf);
 
 	COMMIT_RING();
 	return 0;
 }
 
 static int r128_cce_indices(struct drm_device *dev, void *data, struct drm_file *file_priv)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	struct drm_device_dma *dma = dev->dma;
 	struct drm_buf *buf;
 	drm_r128_buf_priv_t *buf_priv;
 	drm_r128_indices_t *elts = data;
 	int count;
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
-	if (!dev_priv) {
-		DRM_ERROR("called with no initialization\n");
-		return -EINVAL;
-	}
+	DEV_INIT_TEST_WITH_RETURN(dev_priv);
 
 	DRM_DEBUG("pid=%d buf=%d s=%d e=%d d=%d\n", DRM_CURRENTPID,
 		  elts->idx, elts->start, elts->end, elts->discard);
 
 	if (elts->idx < 0 || elts->idx >= dma->buf_count) {
 		DRM_ERROR("buffer index %d (of %d max)\n",
 			  elts->idx, dma->buf_count - 1);
 		return -EINVAL;
 	}
 	if (elts->prim < 0 ||
 	    elts->prim > R128_CCE_VC_CNTL_PRIM_TYPE_TRI_TYPE2) {
 		DRM_ERROR("buffer prim %d\n", elts->prim);
 		return -EINVAL;
 	}
 
 	RING_SPACE_TEST_WITH_RETURN(dev_priv);
 	VB_AGE_TEST_WITH_RETURN(dev_priv);
 
 	buf = dma->buflist[elts->idx];
 	buf_priv = buf->dev_private;
 
 	if (buf->file_priv != file_priv) {
 		DRM_ERROR("process %d using buffer owned by %p\n",
 			  DRM_CURRENTPID, buf->file_priv);
 		return -EINVAL;
 	}
 	if (buf->pending) {
 		DRM_ERROR("sending pending buffer %d\n", elts->idx);
 		return -EINVAL;
 	}
 
 	count = (elts->end - elts->start) / sizeof(u16);
 	elts->start -= R128_INDEX_PRIM_OFFSET;
 
 	if (elts->start & 0x7) {
 		DRM_ERROR("misaligned buffer 0x%x\n", elts->start);
 		return -EINVAL;
 	}
 	if (elts->start < buf->used) {
 		DRM_ERROR("no header 0x%x - 0x%x\n", elts->start, buf->used);
 		return -EINVAL;
 	}
 
 	buf->used = elts->end;
 	buf_priv->prim = elts->prim;
 	buf_priv->discard = elts->discard;
 
 	r128_cce_dispatch_indices(dev, buf, elts->start, elts->end, count);
 
 	COMMIT_RING();
 	return 0;
 }
 
 static int r128_cce_blit(struct drm_device *dev, void *data, struct drm_file *file_priv)
 {
 	struct drm_device_dma *dma = dev->dma;
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	drm_r128_blit_t *blit = data;
 	int ret;
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
+	DEV_INIT_TEST_WITH_RETURN(dev_priv);
+
 	DRM_DEBUG("pid=%d index=%d\n", DRM_CURRENTPID, blit->idx);
 
 	if (blit->idx < 0 || blit->idx >= dma->buf_count) {
 		DRM_ERROR("buffer index %d (of %d max)\n",
 			  blit->idx, dma->buf_count - 1);
 		return -EINVAL;
 	}
 
 	RING_SPACE_TEST_WITH_RETURN(dev_priv);
 	VB_AGE_TEST_WITH_RETURN(dev_priv);
 
 	ret = r128_cce_dispatch_blit(dev, file_priv, blit);
 
 	COMMIT_RING();
 	return ret;
 }
 
 static int r128_cce_depth(struct drm_device *dev, void *data, struct drm_file *file_priv)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	drm_r128_depth_t *depth = data;
 	int ret;
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
+	DEV_INIT_TEST_WITH_RETURN(dev_priv);
+
 	RING_SPACE_TEST_WITH_RETURN(dev_priv);
 
 	ret = -EINVAL;
 	switch (depth->func) {
 	case R128_WRITE_SPAN:
 		ret = r128_cce_dispatch_write_span(dev, depth);
 		break;
 	case R128_WRITE_PIXELS:
 		ret = r128_cce_dispatch_write_pixels(dev, depth);
 		break;
 	case R128_READ_SPAN:
 		ret = r128_cce_dispatch_read_span(dev, depth);
 		break;
 	case R128_READ_PIXELS:
 		ret = r128_cce_dispatch_read_pixels(dev, depth);
 		break;
 	}
 
 	COMMIT_RING();
 	return ret;
 }
 
 static int r128_cce_stipple(struct drm_device *dev, void *data, struct drm_file *file_priv)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	drm_r128_stipple_t *stipple = data;
 	u32 mask[32];
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
+	DEV_INIT_TEST_WITH_RETURN(dev_priv);
+
 	if (DRM_COPY_FROM_USER(&mask, stipple->mask, 32 * sizeof(u32)))
 		return -EFAULT;
 
 	RING_SPACE_TEST_WITH_RETURN(dev_priv);
 
 	r128_cce_dispatch_stipple(dev, mask);
 
 	COMMIT_RING();
 	return 0;
 }
 
 static int r128_cce_indirect(struct drm_device *dev, void *data, struct drm_file *file_priv)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	struct drm_device_dma *dma = dev->dma;
 	struct drm_buf *buf;
 	drm_r128_buf_priv_t *buf_priv;
 	drm_r128_indirect_t *indirect = data;
 #if 0
 	RING_LOCALS;
 #endif
 
 	LOCK_TEST_WITH_RETURN(dev, file_priv);
 
-	if (!dev_priv) {
-		DRM_ERROR("called with no initialization\n");
-		return -EINVAL;
-	}
+	DEV_INIT_TEST_WITH_RETURN(dev_priv);
 
 	DRM_DEBUG("idx=%d s=%d e=%d d=%d\n",
 		  indirect->idx, indirect->start, indirect->end,
 		  indirect->discard);
 
 	if (indirect->idx < 0 || indirect->idx >= dma->buf_count) {
 		DRM_ERROR("buffer index %d (of %d max)\n",
 			  indirect->idx, dma->buf_count - 1);
 		return -EINVAL;
 	}
 
 	buf = dma->buflist[indirect->idx];
 	buf_priv = buf->dev_private;
 
 	if (buf->file_priv != file_priv) {
 		DRM_ERROR("process %d using buffer owned by %p\n",
 			  DRM_CURRENTPID, buf->file_priv);
 		return -EINVAL;
 	}
 	if (buf->pending) {
 		DRM_ERROR("sending pending buffer %d\n", indirect->idx);
 		return -EINVAL;
 	}
 
 	if (indirect->start < buf->used) {
 		DRM_ERROR("reusing indirect: start=0x%x actual=0x%x\n",
 			  indirect->start, buf->used);
 		return -EINVAL;
 	}
 
 	RING_SPACE_TEST_WITH_RETURN(dev_priv);
 	VB_AGE_TEST_WITH_RETURN(dev_priv);
 
 	buf->used = indirect->end;
 	buf_priv->discard = indirect->discard;
 
 #if 0
 	/* Wait for the 3D stream to idle before the indirect buffer
 	 * containing 2D acceleration commands is processed.
 	 */
 	BEGIN_RING(2);
 	RADEON_WAIT_UNTIL_3D_IDLE();
 	ADVANCE_RING();
 #endif
 
 	/* Dispatch the indirect buffer full of commands from the
 	 * X server.  This is insecure and is thus only available to
 	 * privileged clients.
 	 */
 	r128_cce_dispatch_indirect(dev, buf, indirect->start, indirect->end);
 
 	COMMIT_RING();
 	return 0;
 }
 
 static int r128_getparam(struct drm_device *dev, void *data, struct drm_file *file_priv)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	drm_r128_getparam_t *param = data;
 	int value;
 
-	if (!dev_priv) {
-		DRM_ERROR("called with no initialization\n");
-		return -EINVAL;
-	}
+	DEV_INIT_TEST_WITH_RETURN(dev_priv);
 
 	DRM_DEBUG("pid=%d\n", DRM_CURRENTPID);
 
 	switch (param->param) {
 	case R128_PARAM_IRQ_NR:
 		value = drm_dev_to_irq(dev);
 		break;
 	default:
 		return -EINVAL;
 	}
 
 	if (DRM_COPY_TO_USER(param->value, &value, sizeof(int))) {
 		DRM_ERROR("copy_to_user\n");
 		return -EFAULT;
 	}
 
 	return 0;
 }
 
