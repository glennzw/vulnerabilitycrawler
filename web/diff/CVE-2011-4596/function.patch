commit ad3241929ea00569c74505ed002208ce360c667e
Author: Thierry Carrez <thierry@openstack.org>
Date:   Thu Dec 1 17:54:16 2011 +0100

    Sanitize EC2 manifests and image tarballs
    
    Prevent potential directory traversal with malicious EC2 image tarballs,
    by making sure the tarfile is safe before unpacking it. Fixes bug 894755
    
    Prevent potential directory traversal with malicious file names in
    EC2 image manifests. Fixes bug 885167
    
    Change-Id: If6109047307bd6e654ee9d1254f0d7f31cf741c1

diff --git a/MANIFEST.in b/MANIFEST.in
index b10dafc..2a947f8 100644
--- a/MANIFEST.in
+++ b/MANIFEST.in
@@ -37,6 +37,7 @@ include nova/tests/bundle/1mb.part.0
 include nova/tests/bundle/1mb.part.1
 include nova/tests/api/ec2/public_key/*
 include nova/tests/db/nova.austin.sqlite
+include nova/tests/image/*.tar.gz
 include plugins/xenapi/README
 include plugins/xenapi/etc/xapi.d/plugins/objectstore
 include plugins/xenapi/etc/xapi.d/plugins/pluginlib_nova.py
diff --git a/nova/image/s3.py b/nova/image/s3.py
index ea0882d..46a940a 100644
--- a/nova/image/s3.py
+++ b/nova/image/s3.py
@@ -51,346 +51,357 @@ flags.DEFINE_string('s3_secret_key', 'notchecked',
 class S3ImageService(object):
     """Wraps an existing image service to support s3 based register."""
 
     def __init__(self, service=None, *args, **kwargs):
         self.service = service or image.get_default_image_service()
         self.service.__init__(*args, **kwargs)
 
     def get_image_uuid(self, context, image_id):
         return nova.db.api.s3_image_get(context, image_id)['uuid']
 
     def get_image_id(self, context, image_uuid):
         return nova.db.api.s3_image_get_by_uuid(context, image_uuid)['id']
 
     def _create_image_id(self, context, image_uuid):
         return nova.db.api.s3_image_create(context, image_uuid)['id']
 
     def _translate_uuids_to_ids(self, context, images):
         return [self._translate_uuid_to_id(context, img) for img in images]
 
     def _translate_uuid_to_id(self, context, image):
         def _find_or_create(image_uuid):
             if image_uuid is None:
                 return
             try:
                 return self.get_image_id(context, image_uuid)
             except exception.NotFound:
                 return self._create_image_id(context, image_uuid)
 
         image_copy = image.copy()
 
         try:
             image_id = image_copy['id']
         except KeyError:
             pass
         else:
             image_copy['id'] = _find_or_create(image_id)
 
         for prop in ['kernel_id', 'ramdisk_id']:
             try:
                 image_uuid = image_copy['properties'][prop]
             except (KeyError, ValueError):
                 pass
             else:
                 image_copy['properties'][prop] = _find_or_create(image_uuid)
 
         return image_copy
 
     def create(self, context, metadata, data=None):
         """Create an image.
 
         metadata['properties'] should contain image_location.
 
         """
         image = self._s3_create(context, metadata)
         return image
 
     def delete(self, context, image_id):
         image_uuid = self.get_image_uuid(context, image_id)
         self.service.delete(context, image_uuid)
 
     def update(self, context, image_id, metadata, data=None):
         image_uuid = self.get_image_uuid(context, image_id)
         image = self.service.update(context, image_uuid, metadata, data)
         return self._translate_uuid_to_id(context, image)
 
     def index(self, context):
         #NOTE(bcwaldon): sort asc to make sure we assign lower ids
         # to older images
         images = self.service.index(context, sort_dir='asc')
         return self._translate_uuids_to_ids(context, images)
 
     def detail(self, context):
         #NOTE(bcwaldon): sort asc to make sure we assign lower ids
         # to older images
         images = self.service.detail(context, sort_dir='asc')
         return self._translate_uuids_to_ids(context, images)
 
     def show(self, context, image_id):
         image_uuid = self.get_image_uuid(context, image_id)
         image = self.service.show(context, image_uuid)
         return self._translate_uuid_to_id(context, image)
 
     def show_by_name(self, context, name):
         image = self.service.show_by_name(context, name)
         return self._translate_uuid_to_id(context, image)
 
     def get(self, context, image_id):
         image_uuid = self.get_image_uuid(context, image_id)
         return self.get(self, context, image_uuid)
 
     @staticmethod
     def _conn(context):
         # NOTE(vish): access and secret keys for s3 server are not
         #             checked in nova-objectstore
         access = FLAGS.s3_access_key
         secret = FLAGS.s3_secret_key
         calling = boto.s3.connection.OrdinaryCallingFormat()
         return boto.s3.connection.S3Connection(aws_access_key_id=access,
                                                aws_secret_access_key=secret,
                                                is_secure=False,
                                                calling_format=calling,
                                                port=FLAGS.s3_port,
                                                host=FLAGS.s3_host)
 
     @staticmethod
     def _download_file(bucket, filename, local_dir):
         key = bucket.get_key(filename)
-        local_filename = os.path.join(local_dir, filename)
+        local_filename = os.path.join(local_dir, os.path.basename(filename))
         key.get_contents_to_filename(local_filename)
         return local_filename
 
     def _s3_parse_manifest(self, context, metadata, manifest):
         manifest = ElementTree.fromstring(manifest)
         image_format = 'ami'
         image_type = 'machine'
 
         try:
             kernel_id = manifest.find('machine_configuration/kernel_id').text
             if kernel_id == 'true':
                 image_format = 'aki'
                 image_type = 'kernel'
                 kernel_id = None
         except Exception:
             kernel_id = None
 
         try:
             ramdisk_id = manifest.find('machine_configuration/ramdisk_id').text
             if ramdisk_id == 'true':
                 image_format = 'ari'
                 image_type = 'ramdisk'
                 ramdisk_id = None
         except Exception:
             ramdisk_id = None
 
         try:
             arch = manifest.find('machine_configuration/architecture').text
         except Exception:
             arch = 'x86_64'
 
         # NOTE(yamahata):
         # EC2 ec2-budlne-image --block-device-mapping accepts
         # <virtual name>=<device name> where
         # virtual name = {ami, root, swap, ephemeral<N>}
         #                where N is no negative integer
         # device name = the device name seen by guest kernel.
         # They are converted into
         # block_device_mapping/mapping/{virtual, device}
         #
         # Do NOT confuse this with ec2-register's block device mapping
         # argument.
         mappings = []
         try:
             block_device_mapping = manifest.findall('machine_configuration/'
                                                     'block_device_mapping/'
                                                     'mapping')
             for bdm in block_device_mapping:
                 mappings.append({'virtual': bdm.find('virtual').text,
                                  'device': bdm.find('device').text})
         except Exception:
             mappings = []
 
         properties = metadata['properties']
         properties['project_id'] = context.project_id
         properties['architecture'] = arch
 
         def _translate_dependent_image_id(image_key, image_id):
             image_id = ec2utils.ec2_id_to_id(image_id)
             image_uuid = self.get_image_uuid(context, image_id)
             properties['image_id'] = image_uuid
 
         if kernel_id:
             _translate_dependent_image_id('kernel_id', kernel_id)
 
         if ramdisk_id:
             _translate_dependent_image_id('ramdisk_id', ramdisk_id)
 
         if mappings:
             properties['mappings'] = mappings
 
         metadata.update({'disk_format': image_format,
                          'container_format': image_format,
                          'status': 'queued',
                          'is_public': False,
                          'properties': properties})
         metadata['properties']['image_state'] = 'pending'
 
         #TODO(bcwaldon): right now, this removes user-defined ids.
         # We need to re-enable this.
         image_id = metadata.pop('id', None)
 
         image = self.service.create(context, metadata)
 
         # extract the new uuid and generate an int id to present back to user
         image_uuid = image['id']
         image['id'] = self._create_image_id(context, image_uuid)
 
         # return image_uuid so the caller can still make use of image_service
         return manifest, image, image_uuid
 
     def _s3_create(self, context, metadata):
         """Gets a manifext from s3 and makes an image."""
 
         image_path = tempfile.mkdtemp(dir=FLAGS.image_decryption_dir)
 
         image_location = metadata['properties']['image_location']
         bucket_name = image_location.split('/')[0]
         manifest_path = image_location[len(bucket_name) + 1:]
         bucket = self._conn(context).get_bucket(bucket_name)
         key = bucket.get_key(manifest_path)
         manifest = key.get_contents_as_string()
 
         manifest, image, image_uuid = self._s3_parse_manifest(context,
                                                               metadata,
                                                               manifest)
 
         def delayed_create():
             """This handles the fetching and decrypting of the part files."""
             log_vars = {'image_location': image_location,
                         'image_path': image_path}
             metadata['properties']['image_state'] = 'downloading'
             self.service.update(context, image_uuid, metadata)
 
             try:
                 parts = []
                 elements = manifest.find('image').getiterator('filename')
                 for fn_element in elements:
                     part = self._download_file(bucket,
                                                fn_element.text,
                                                image_path)
                     parts.append(part)
 
                 # NOTE(vish): this may be suboptimal, should we use cat?
                 enc_filename = os.path.join(image_path, 'image.encrypted')
                 with open(enc_filename, 'w') as combined:
                     for filename in parts:
                         with open(filename) as part:
                             shutil.copyfileobj(part, combined)
 
             except Exception:
                 LOG.exception(_("Failed to download %(image_location)s "
                                 "to %(image_path)s"), log_vars)
                 metadata['properties']['image_state'] = 'failed_download'
                 self.service.update(context, image_uuid, metadata)
                 return
 
             metadata['properties']['image_state'] = 'decrypting'
             self.service.update(context, image_uuid, metadata)
 
             try:
                 hex_key = manifest.find('image/ec2_encrypted_key').text
                 encrypted_key = binascii.a2b_hex(hex_key)
                 hex_iv = manifest.find('image/ec2_encrypted_iv').text
                 encrypted_iv = binascii.a2b_hex(hex_iv)
 
                 # FIXME(vish): grab key from common service so this can run on
                 #              any host.
                 cloud_pk = crypto.key_path(context.project_id)
 
                 dec_filename = os.path.join(image_path, 'image.tar.gz')
                 self._decrypt_image(enc_filename, encrypted_key,
                                     encrypted_iv, cloud_pk,
                                     dec_filename)
             except Exception:
                 LOG.exception(_("Failed to decrypt %(image_location)s "
                                 "to %(image_path)s"), log_vars)
                 metadata['properties']['image_state'] = 'failed_decrypt'
                 self.service.update(context, image_uuid, metadata)
                 return
 
             metadata['properties']['image_state'] = 'untarring'
             self.service.update(context, image_uuid, metadata)
 
             try:
                 unz_filename = self._untarzip_image(image_path, dec_filename)
             except Exception:
                 LOG.exception(_("Failed to untar %(image_location)s "
                                 "to %(image_path)s"), log_vars)
                 metadata['properties']['image_state'] = 'failed_untar'
                 self.service.update(context, image_uuid, metadata)
                 return
 
             metadata['properties']['image_state'] = 'uploading'
             self.service.update(context, image_uuid, metadata)
             try:
                 with open(unz_filename) as image_file:
                     self.service.update(context, image_uuid,
                                         metadata, image_file)
             except Exception:
                 LOG.exception(_("Failed to upload %(image_location)s "
                                 "to %(image_path)s"), log_vars)
                 metadata['properties']['image_state'] = 'failed_upload'
                 self.service.update(context, image_uuid, metadata)
                 return
 
             metadata['properties']['image_state'] = 'available'
             metadata['status'] = 'active'
             self.service.update(context, image_uuid, metadata)
 
             shutil.rmtree(image_path)
 
         eventlet.spawn_n(delayed_create)
 
         return image
 
     @staticmethod
     def _decrypt_image(encrypted_filename, encrypted_key, encrypted_iv,
                        cloud_private_key, decrypted_filename):
         key, err = utils.execute('openssl',
                                  'rsautl',
                                  '-decrypt',
                                  '-inkey', '%s' % cloud_private_key,
                                  process_input=encrypted_key,
                                  check_exit_code=False)
         if err:
             raise exception.Error(_('Failed to decrypt private key: %s')
                                   % err)
         iv, err = utils.execute('openssl',
                                 'rsautl',
                                 '-decrypt',
                                 '-inkey', '%s' % cloud_private_key,
                                 process_input=encrypted_iv,
                                 check_exit_code=False)
         if err:
             raise exception.Error(_('Failed to decrypt initialization '
                                     'vector: %s') % err)
 
         _out, err = utils.execute('openssl', 'enc',
                                   '-d', '-aes-128-cbc',
                                   '-in', '%s' % (encrypted_filename,),
                                   '-K', '%s' % (key,),
                                   '-iv', '%s' % (iv,),
                                   '-out', '%s' % (decrypted_filename,),
                                   check_exit_code=False)
         if err:
             raise exception.Error(_('Failed to decrypt image file '
                                     '%(image_file)s: %(err)s') %
                                     {'image_file': encrypted_filename,
                                      'err': err})
 
     @staticmethod
+    def _test_for_malicious_tarball(path, filename):
+        """Raises exception if extracting tarball would escape extract path"""
+        tar_file = tarfile.open(filename, 'r|gz')
+        for n in tar_file.getnames():
+            if not os.path.abspath(os.path.join(path, n)).startswith(path):
+                tar_file.close()
+                raise exception.Error(_('Unsafe filenames in image'))
+        tar_file.close()
+
+    @staticmethod
     def _untarzip_image(path, filename):
+        S3ImageService._test_for_malicious_tarball(path, filename)
         tar_file = tarfile.open(filename, 'r|gz')
         tar_file.extractall(path)
         image_file = tar_file.getnames()[0]
         tar_file.close()
         return os.path.join(path, image_file)
diff --git a/nova/tests/image/abs.tar.gz b/nova/tests/image/abs.tar.gz
new file mode 100644
index 0000000..4d39507
Binary files /dev/null and b/nova/tests/image/abs.tar.gz differ
diff --git a/nova/tests/image/rel.tar.gz b/nova/tests/image/rel.tar.gz
new file mode 100644
index 0000000..b54f55a
Binary files /dev/null and b/nova/tests/image/rel.tar.gz differ
diff --git a/nova/tests/image/test_s3.py b/nova/tests/image/test_s3.py
index 02f66fc..2a9d279 100644
--- a/nova/tests/image/test_s3.py
+++ b/nova/tests/image/test_s3.py
@@ -15,118 +15,128 @@
 #    License for the specific language governing permissions and limitations
 #    under the License.
 
+import os
+
 from nova import context
 import nova.db.api
 from nova import exception
 from nova import test
 from nova.image import s3
 
 
 ami_manifest_xml = """<?xml version="1.0" ?>
 <manifest>
         <version>2011-06-17</version>
         <bundler>
                 <name>test-s3</name>
                 <version>0</version>
                 <release>0</release>
         </bundler>
         <machine_configuration>
                 <architecture>x86_64</architecture>
                 <block_device_mapping>
                         <mapping>
                                 <virtual>ami</virtual>
                                 <device>sda1</device>
                         </mapping>
                         <mapping>
                                 <virtual>root</virtual>
                                 <device>/dev/sda1</device>
                         </mapping>
                         <mapping>
                                 <virtual>ephemeral0</virtual>
                                 <device>sda2</device>
                         </mapping>
                         <mapping>
                                 <virtual>swap</virtual>
                                 <device>sda3</device>
                         </mapping>
                 </block_device_mapping>
                 <kernel_id>aki-00000001</kernel_id>
                 <ramdisk_id>ari-00000001</ramdisk_id>
         </machine_configuration>
 </manifest>
 """
 
 
 class TestS3ImageService(test.TestCase):
     def setUp(self):
         super(TestS3ImageService, self).setUp()
         self.flags(image_service='nova.image.fake.FakeImageService')
         self.image_service = s3.S3ImageService()
         self.context = context.RequestContext(None, None)
 
         # set up one fixture to test shows, should have id '1'
         nova.db.api.s3_image_create(self.context,
                                     '155d900f-4e14-4e4c-a73d-069cbf4541e6')
 
     def _assertEqualList(self, list0, list1, keys):
         self.assertEqual(len(list0), len(list1))
         key = keys[0]
         for x in list0:
             self.assertEqual(len(x), len(keys))
             self.assertTrue(key in x)
             for y in list1:
                 self.assertTrue(key in y)
                 if x[key] == y[key]:
                     for k in keys:
                         self.assertEqual(x[k], y[k])
 
     def test_show_cannot_use_uuid(self):
         self.assertRaises(exception.ImageNotFound,
                           self.image_service.show, self.context,
                           '155d900f-4e14-4e4c-a73d-069cbf4541e6')
 
     def test_show_translates_correctly(self):
         self.image_service.show(self.context, '1')
 
     def test_detail(self):
         self.image_service.detail(self.context)
 
     def test_s3_create(self):
         metadata = {'properties': {
             'root_device_name': '/dev/sda1',
             'block_device_mapping': [
                 {'device_name': '/dev/sda1',
                  'snapshot_id': 'snap-12345678',
                  'delete_on_termination': True},
                 {'device_name': '/dev/sda2',
                  'virutal_name': 'ephemeral0'},
                 {'device_name': '/dev/sdb0',
                  'no_device': True}]}}
         _manifest, image, image_uuid = self.image_service._s3_parse_manifest(
             self.context, metadata, ami_manifest_xml)
 
         ret_image = self.image_service.show(self.context, image['id'])
         self.assertTrue('properties' in ret_image)
         properties = ret_image['properties']
 
         self.assertTrue('mappings' in properties)
         mappings = properties['mappings']
         expected_mappings = [
             {"device": "sda1", "virtual": "ami"},
             {"device": "/dev/sda1", "virtual": "root"},
             {"device": "sda2", "virtual": "ephemeral0"},
             {"device": "sda3", "virtual": "swap"}]
         self._assertEqualList(mappings, expected_mappings,
             ['device', 'virtual'])
 
         self.assertTrue('block_device_mapping', properties)
         block_device_mapping = properties['block_device_mapping']
         expected_bdm = [
             {'device_name': '/dev/sda1',
              'snapshot_id': 'snap-12345678',
              'delete_on_termination': True},
             {'device_name': '/dev/sda2',
              'virutal_name': 'ephemeral0'},
             {'device_name': '/dev/sdb0',
              'no_device': True}]
         self.assertEqual(block_device_mapping, expected_bdm)
+
+    def test_s3_malicious_tarballs(self):
+        self.assertRaises(exception.Error,
+            self.image_service._test_for_malicious_tarball,
+            "/unused", os.path.join(os.path.dirname(__file__), 'abs.tar.gz'))
+        self.assertRaises(exception.Error,
+            self.image_service._test_for_malicious_tarball,
+            "/unused", os.path.join(os.path.dirname(__file__), 'rel.tar.gz'))
