commit 9926e4c74300c4b31dee007298c6475d33369df0
Author: Tom Alsberg <alsbergt@cs.huji.ac.il>
Date:   Tue May 8 00:30:31 2007 -0700

    CPU time limit patch / setrlimit(RLIMIT_CPU, 0) cheat fix
    
    As discovered here today, the change in Kernel 2.6.17 intended to inhibit
    users from setting RLIMIT_CPU to 0 (as that is equivalent to unlimited) by
    "cheating" and setting it to 1 in such a case, does not make a difference,
    as the check is done in the wrong place (too late), and only applies to the
    profiling code.
    
    On all systems I checked running kernels above 2.6.17, no matter what the
    hard and soft CPU time limits were before, a user could escape them by
    issuing in the shell (sh/bash/zsh) "ulimit -t 0", and then the user's
    process was not ever killed.
    
    Attached is a trivial patch to fix that.  Simply moving the check to a
    slightly earlier location (specifically, before the line that actually
    assigns the limit - *old_rlim = new_rlim), does the trick.
    
    Do note that at least the zsh (but not ash, dash, or bash) shell has the
    problem of "caching" the limits set by the ulimit command, so when running
    zsh the fix will not immediately be evident - after entering "ulimit -t 0",
    "ulimit -a" will show "-t: cpu time (seconds) 0", even though the actual
    limit as returned by getrlimit(...) will be 1.  It can be verified by
    opening a subshell (which will not have the values of the parent shell in
    cache) and checking in it, or just by running a CPU intensive command like
    "echo '65536^1048576' | bc" and verifying that it dumps core after one
    second.
    
    Regardless of whether that is a misfeature in the shell, perhaps it would
    be better to return -EINVAL from setrlimit in such a case instead of
    cheating and setting to 1, as that does not really reflect the actual state
    of the process anymore.  I do not however know what the ground for that
    decision was in the original 2.6.17 change, and whether there would be any
    "backward" compatibility issues, so I preferred not to touch that right
    now.
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/sys.c b/kernel/sys.c
index fe1f3ab..926bf9d 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -1903,60 +1903,61 @@ asmlinkage long sys_old_getrlimit(unsigned int resource, struct rlimit __user *r
 asmlinkage long sys_setrlimit(unsigned int resource, struct rlimit __user *rlim)
 {
 	struct rlimit new_rlim, *old_rlim;
 	unsigned long it_prof_secs;
 	int retval;
 
 	if (resource >= RLIM_NLIMITS)
 		return -EINVAL;
 	if (copy_from_user(&new_rlim, rlim, sizeof(*rlim)))
 		return -EFAULT;
 	if (new_rlim.rlim_cur > new_rlim.rlim_max)
 		return -EINVAL;
 	old_rlim = current->signal->rlim + resource;
 	if ((new_rlim.rlim_max > old_rlim->rlim_max) &&
 	    !capable(CAP_SYS_RESOURCE))
 		return -EPERM;
 	if (resource == RLIMIT_NOFILE && new_rlim.rlim_max > NR_OPEN)
 		return -EPERM;
 
 	retval = security_task_setrlimit(resource, &new_rlim);
 	if (retval)
 		return retval;
 
+	if (resource == RLIMIT_CPU && new_rlim.rlim_cur == 0) {
+		/*
+		 * The caller is asking for an immediate RLIMIT_CPU
+		 * expiry.  But we use the zero value to mean "it was
+		 * never set".  So let's cheat and make it one second
+		 * instead
+		 */
+		new_rlim.rlim_cur = 1;
+	}
+
 	task_lock(current->group_leader);
 	*old_rlim = new_rlim;
 	task_unlock(current->group_leader);
 
 	if (resource != RLIMIT_CPU)
 		goto out;
 
 	/*
 	 * RLIMIT_CPU handling.   Note that the kernel fails to return an error
 	 * code if it rejected the user's attempt to set RLIMIT_CPU.  This is a
 	 * very long-standing error, and fixing it now risks breakage of
 	 * applications, so we live with it
 	 */
 	if (new_rlim.rlim_cur == RLIM_INFINITY)
 		goto out;
 
 	it_prof_secs = cputime_to_secs(current->signal->it_prof_expires);
 	if (it_prof_secs == 0 || new_rlim.rlim_cur <= it_prof_secs) {
 		unsigned long rlim_cur = new_rlim.rlim_cur;
 		cputime_t cputime;
 
-		if (rlim_cur == 0) {
-			/*
-			 * The caller is asking for an immediate RLIMIT_CPU
-			 * expiry.  But we use the zero value to mean "it was
-			 * never set".  So let's cheat and make it one second
-			 * instead
-			 */
-			rlim_cur = 1;
-		}
 		cputime = secs_to_cputime(rlim_cur);
 		read_lock(&tasklist_lock);
 		spin_lock_irq(&current->sighand->siglock);
 		set_process_cpu_timer(current, CPUCLOCK_PROF, &cputime, NULL);
 		spin_unlock_irq(&current->sighand->siglock);
 		read_unlock(&tasklist_lock);
 	}
