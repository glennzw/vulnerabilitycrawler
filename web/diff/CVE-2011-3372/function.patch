commit 77903669e04c9788460561dd0560b9c916519594
Author: Bron Gondwana <brong@opera.com>
Date:   Tue Oct 4 21:34:59 2011 +0200

    Secunia SA46093 - make sure nntp authentication completes
    
    Discovered by Stefan Cornelius, Secunia Research
    
    The vulnerability is caused due to the access restriction for certain
    commands only checking whether or not variable "nntp_userid" is non-NULL,
    without performing additional checks to verify that a complete, successful
    authentication actually took place. The variable "nntp_userid" can be set to
    point to a string holding the username (changing it to a non-NULL, thus
    allowing attackers to bypass the checks) by sending an "AUTHINFO USER"
    command. The variable is not reset to NULL until e.g. a wrong "AUTHINFO
    PASS" command is received. This can be exploited to bypass the
    authentication mechanism and allows access to e.g. the "NEWNEWS" or the
    "LIST NEWSGROUPS" commands by sending an "AUTHINFO USER" command without a
    following "AUTHINFO PASS" command.

diff --git a/imap/nntpd.c b/imap/nntpd.c
index 619fbab..7524086 100644
--- a/imap/nntpd.c
+++ b/imap/nntpd.c
@@ -824,739 +824,739 @@ static int is_newsgroup(const char *mbox)
 static void cmdloop(void)
 {
     int c, r = 0, mode;
     static struct buf cmd, arg1, arg2, arg3, arg4;
     char *p, *result, buf[1024];
     const char *err;
     uint32_t uid, last;
     struct backend *be;
     char curgroup[MAX_MAILBOX_BUFFER] = "";
 
     allowanonymous = config_getswitch(IMAPOPT_ALLOWANONYMOUSLOGIN);
 
     for (;;) {
 	/* Flush any buffered output */
 	prot_flush(nntp_out);
 	if (backend_current) prot_flush(backend_current->out);
 
 	/* Check for shutdown file */
 	if (shutdown_file(buf, sizeof(buf)) ||
 	    (nntp_userid &&
 	     userdeny(nntp_userid, config_ident, buf, sizeof(buf)))) {
 	    prot_printf(nntp_out, "400 %s\r\n", buf);
 	    shut_down(0);
 	}
 
 	signals_poll();
 
 	if (!proxy_check_input(protin, nntp_in, nntp_out,
 			       backend_current ? backend_current->in : NULL,
 			       NULL, 0)) {
 	    /* No input from client */
 	    continue;
 	}
 
 	if (group_state &&
 	    config_getswitch(IMAPOPT_DISCONNECT_ON_VANISHED_MAILBOX)) {
 	    if (group_state->mailbox->i.options & OPT_MAILBOX_DELETED) {
 		/* Mailbox has been (re)moved */
 		syslog(LOG_WARNING,
 		       "Newsgroup %s has been (re)moved out from under client",
 		       group_state->mailbox->name);
 		prot_printf(nntp_out,
 			    "400 Newsgroup has been (re)moved\r\n");
 		shut_down(0);
 	    }
 	}
 
 	/* Parse command name */
 	c = getword(nntp_in, &cmd);
 	if (c == EOF) {
 	    if ((err = prot_error(nntp_in)) != NULL
 		 && strcmp(err, PROT_EOF_STRING)) {
 		syslog(LOG_WARNING, "%s, closing connection", err);
 		prot_printf(nntp_out, "400 %s\r\n", err);
 	    }
 	    return;
 	}
 	if (!cmd.s[0]) {
 	    prot_printf(nntp_out, "501 Empty command\r\n");
 	    eatline(nntp_in, c);
 	    continue;
 	}
 	if (Uislower(cmd.s[0])) 
 	    cmd.s[0] = toupper((unsigned char) cmd.s[0]);
 	for (p = &cmd.s[1]; *p; p++) {
 	    if (Uisupper(*p)) *p = tolower((unsigned char) *p);
 	}
 
 	/* Ihave/Takethis only allowed for feeders */
 	if (!(nntp_capa & MODE_FEED) &&
 	    strchr("IT", cmd.s[0])) goto noperm;
     
 	/* Body/Date/Group/Newgroups/Newnews/Next/Over/Post/Xhdr/Xover/Xpat
 	   only allowed for readers */
 	if (!(nntp_capa & MODE_READ) &&
 	    strchr("BDGNOPX", cmd.s[0])) goto noperm;
     
 	/* Only Authinfo/Capabilities/Check/Head/Help/Ihave/List Active/
 	   Mode/Quit/Starttls/Stat/Takethis allowed when not logged in */
-	if (!nntp_userid && !allowanonymous &&
+	if (!nntp_authstate && !allowanonymous &&
 	    !strchr("ACHILMQST", cmd.s[0])) goto nologin;
 
 	/* In case a [LIST]GROUP fails or
 	   a retrieval by msgid makes us switch groups */
 	strcpy(curgroup, group_state ? group_state->mailbox->name : "");
 
 	switch (cmd.s[0]) {
 	case 'A':
 	    if (!strcmp(cmd.s, "Authinfo")) {
 		if (c != ' ') goto missingargs;
 		c = getword(nntp_in, &arg1); /* subcommand */
 		if (c == EOF) goto missingargs;
 
 		lcase(arg1.s);
 
 		if (!strcmp(arg1.s, "user") || !strcmp(arg1.s, "pass")) {
 		    if (c != ' ') goto missingargs;
 		    c = getuserpass(nntp_in, &arg2); /* user/pass */
 		    if (c == EOF) goto missingargs;
 
 		    if (c == '\r') c = prot_getc(nntp_in);
 		    if (c != '\n') goto extraargs;
 
 		    if (arg1.s[0] == 'u')
 			cmd_authinfo_user(arg2.s);
 		    else
 			cmd_authinfo_pass(arg2.s);
 		}
 		else if (!strcmp(arg1.s, "sasl") || !strcmp(arg1.s, "generic")) {
 		    arg2.len = arg3.len = 0;
 
 		    /* mech name required for SASL but not GENERIC */
 		    if ((arg1.s[0] == 's') && (c != ' ')) goto missingargs;
 
 		    if (c == ' ') {
 			c = getword(nntp_in, &arg2); /* mech name */
 			if (c == EOF) goto missingargs;
 
 			if (c == ' ') {
 			    c = getword(nntp_in, &arg3); /* init response */
 			    if (c == EOF) goto missingargs;
 			}
 		    }
 
 		    if (c == '\r') c = prot_getc(nntp_in);
 		    if (c != '\n') goto extraargs;
 
 		    cmd_authinfo_sasl(arg1.s, arg2.len ? arg2.s : NULL,
 				      arg3.len ? arg3.s : NULL);
 		}
 		else
 		    prot_printf(nntp_out,
 				"501 Unrecognized AUTHINFO command\r\n");
 	    }
 	    else if (!(nntp_capa & MODE_READ)) goto noperm;
-	    else if (!nntp_userid && !allowanonymous) goto nologin;
+	    else if (!nntp_authstate && !allowanonymous) goto nologin;
 	    else if (!strcmp(cmd.s, "Article")) {
 		char *msgid;
 
 		mode = ARTICLE_ALL;
 
 	      article:
 		if (arg1.s) *arg1.s = 0;
 
 		if (c == ' ') {
 		    c = getword(nntp_in, &arg1); /* number/msgid (optional) */
 		    if (c == EOF) goto missingargs;
 		}
 		if (c == '\r') c = prot_getc(nntp_in);
 		if (c != '\n') goto extraargs;
 
 		if (parserange(arg1.s, &uid, NULL, &msgid, &be) != -1) {
 		    if (be) {
 			if (arg1.s && *arg1.s)
 			    prot_printf(be->out, "%s %s\r\n", cmd.s, arg1.s);
 			else
 			    prot_printf(be->out, "%s\r\n", cmd.s);
 
 			if (be != backend_current) {
 			    r = read_response(be, 0, &result);
 			    if (r) goto noopengroup;
 
 			    prot_printf(nntp_out, "%s", result);
 			    if (!strncmp(result, "22", 2) &&
 				mode != ARTICLE_STAT) {
 				pipe_to_end_of_response(be, 0);
 			    }
 			}
 		    }
 		    else
 			cmd_article(mode, msgid, uid);
 		}
 
 		if (msgid) goto prevgroup;
 	    }
 	    else goto badcmd;
 	    break;
 
 	case 'B':
 	    if (!strcmp(cmd.s, "Body")) {
 		mode = ARTICLE_BODY;
 		goto article;
 	    }
 	    else goto badcmd;
 	    break;
 
 	case 'C':
 	    if (!strcmp(cmd.s, "Capabilities")) {
 		arg1.len = 0;
 
 		if (c == ' ') {
 		    c = getword(nntp_in, &arg1); /* keyword (optional) */
 		    if (c == EOF) goto missingargs;
 		}
 		if (c == '\r') c = prot_getc(nntp_in);
 		if (c != '\n') goto extraargs;
 
 		cmd_capabilities(arg1.s);
 	    }
 	    else if (!(nntp_capa & MODE_FEED)) goto noperm;
 	    else if (!strcmp(cmd.s, "Check")) {
 		mode = POST_CHECK;
 		goto ihave;
 	    }
 	    else goto badcmd;
 	    break;
 
 	case 'D':
 	    if (!strcmp(cmd.s, "Date")) {
 		time_t now = time(NULL);
 		struct tm *my_tm = gmtime(&now);
 		char buf[15];
 
 		if (c == '\r') c = prot_getc(nntp_in);
 		if (c != '\n') goto extraargs;
 
 		strftime(buf, sizeof(buf), "%Y%m%d%H%M%S", my_tm);
 		prot_printf(nntp_out, "111 %s\r\n", buf);
 	    }
 	    else goto badcmd;
 	    break;
 
 	case 'G':
 	    if (!strcmp(cmd.s, "Group")) {
 		arg2.len = 0; /* GROUP command (no range) */
 
 	      group:
 #define LISTGROUP (arg2.len)
 
 		if (!LISTGROUP && c != ' ') goto missingargs;
 		if (c == ' ') {
 		    c = getword(nntp_in, &arg1); /* group */
 		    if (c == EOF) goto missingargs;
 		}
 		if (LISTGROUP && c == ' ') {
 		    c = getword(nntp_in, &arg2); /* range (optional) */
 		    if (c == EOF) goto missingargs;
 		}
 		if (c == '\r') c = prot_getc(nntp_in);
 		if (c != '\n') goto extraargs;
 
 		be = backend_current;
 		if (arg1.len &&
 		    (!is_newsgroup(arg1.s) ||
 		     (r = open_group(arg1.s, 1, &be, NULL)))) goto nogroup;
 		else if (be) {
 		    prot_printf(be->out, "%s", cmd.s);
 		    if (arg1.len) {
 			prot_printf(be->out, " %s", arg1.s);
 			  if (LISTGROUP) prot_printf(be->out, " %s", arg2.s);
 		    }
 		    prot_printf(be->out, "\r\n");
 
 		    r = read_response(be, 0, &result);
 		    if (r) goto nogroup;
 
 		    prot_printf(nntp_out, "%s", result);
 
 		    if (!strncmp(result, "211", 3)) {
 			if (LISTGROUP) pipe_to_end_of_response(be, 0);
 
 			if (backend_current && backend_current != be) {
 			    /* remove backend_current from the protgroup */
 			    protgroup_delete(protin, backend_current->in);
 			}
 			backend_current = be;
 
 			/* add backend_current to the protgroup */
 			protgroup_insert(protin, backend_current->in);
 		    }
 		}
 		else if (!group_state) goto noopengroup;
 		else if (LISTGROUP &&
 			 parserange(arg2.s, &uid, &last, NULL, NULL) != 0) {
 		    /* parserange() will handle error code -- do nothing */
 		}
 		else {
 		    if (backend_current) {
 			/* remove backend_current from the protgroup */
 			protgroup_delete(protin, backend_current->in);
 		    }
 		    backend_current = NULL;
 
 		    nntp_exists = group_state->exists;
 		    nntp_current = nntp_exists > 0;
 
 		    prot_printf(nntp_out, "211 %u %lu %lu %s\r\n",
 				nntp_exists,
 				nntp_exists ? index_getuid(group_state, 1) :
 				group_state->last_uid+1,
 				nntp_exists ? index_getuid(group_state, nntp_exists) :
 				group_state->last_uid,
 				group_state->mailbox->name + strlen(newsprefix));
 
 		    if (LISTGROUP) {
 			int msgno, last_msgno;
 
 			msgno = index_finduid(group_state, uid);
 			if (!msgno || index_getuid(group_state, msgno) != uid) {
 			    msgno++;
 			}
 			last_msgno = index_finduid(group_state, last);
 
 			for (; msgno <= last_msgno; msgno++) {
 			    prot_printf(nntp_out, "%u\r\n",
 					index_getuid(group_state, msgno));
 			}
 			prot_printf(nntp_out, ".\r\n");
 		    }
 		}
 #undef LISTGROUP
 	    }
 	    else goto badcmd;
 	    break;
 
 	case 'H':
 	    if (!strcmp(cmd.s, "Head")) {
 		mode = ARTICLE_HEAD;
 		goto article;
 	    }
 	    else if (!strcmp(cmd.s, "Help")) {
 		if (c == '\r') c = prot_getc(nntp_in);
 		if (c != '\n') goto extraargs;
 
 		cmd_help();
 	    }
 	    else if (!(nntp_capa & MODE_READ)) goto noperm;
-	    else if (!nntp_userid && !allowanonymous) goto nologin;
+	    else if (!nntp_authstate && !allowanonymous) goto nologin;
 	    else if (!strcmp(cmd.s, "Hdr")) {
 		char *msgid;
 
 	      hdr:
 		if (arg2.s) *arg2.s = 0;
 
 		if (c != ' ') goto missingargs;
 		c = getword(nntp_in, &arg1); /* header */
 		if (c == EOF) goto missingargs;
 		if (c == ' ') {
 		    c = getword(nntp_in, &arg2); /* range (optional) */
 		    if (c == EOF) goto missingargs;
 		}
 		if (c == '\r') c = prot_getc(nntp_in);
 		if (c != '\n') goto extraargs;
 
 		if (parserange(arg2.s, &uid, &last, &msgid, &be) != -1) {
 		    if (be) {
 			if (arg2.s && *arg2.s)
 			    prot_printf(be->out, "%s %s %s\r\n",
 					cmd.s, arg1.s, arg2.s);
 			else
 			    prot_printf(be->out, "%s %s\r\n", cmd.s, arg1.s);
 
 			if (be != backend_current) {
 			    r = read_response(be, 0, &result);
 			    if (r) goto noopengroup;
 
 			    prot_printf(nntp_out, "%s", result);
 			    if (!strncmp(result, "22", 2)) { /* 221 or 225 */
 				pipe_to_end_of_response(be, 0);
 			    }
 			}
 		    }
 		    else
 			cmd_hdr(cmd.s, arg1.s, NULL, msgid, uid, last);
 		}
 
 		if (msgid) goto prevgroup;
 	    }
 	    else goto badcmd;
 	    break;
 
 	case 'I':
 	    if (!strcmp(cmd.s, "Ihave")) {
 		mode = POST_IHAVE;
 
 	      ihave:
 		if (c != ' ') goto missingargs;
 		c = getword(nntp_in, &arg1); /* msgid */
 		if (c == EOF) goto missingargs;
 		if (c == '\r') c = prot_getc(nntp_in);
 		if (c != '\n') goto extraargs;
 
 		cmd_post(arg1.s, mode);
 	    }
 	    else goto badcmd;
 	    break;
 
 	case 'L':
 	    if (!strcmp(cmd.s, "List")) {
 		arg1.len = arg2.len = 0;
 		if (c == ' ') {
 		    c = getword(nntp_in, &arg1); /* subcommand (optional) */
 		    if (c == EOF) goto missingargs;
 		    if (c == ' ') {
 			c = getword(nntp_in, &arg2); /* argument (optional) */
 			if (c == EOF) goto missingargs;
 		    }
 		}
 		if (c == '\r') c = prot_getc(nntp_in);
 		if (c != '\n') goto extraargs;
 
 		cmd_list(arg1.len ? arg1.s : NULL, arg2.len ? arg2.s : NULL);
 
 		goto prevgroup;  /* In case we did LIST [ACTIVE] */
 	    }
 	    else if (!(nntp_capa & MODE_READ)) goto noperm;
-	    else if (!nntp_userid && !allowanonymous) goto nologin;
+	    else if (!nntp_authstate && !allowanonymous) goto nologin;
 	    else if (!strcmp(cmd.s, "Last")) {
 		if (c == '\r') c = prot_getc(nntp_in);
 		if (c != '\n') goto extraargs;
 
 		if (backend_current) {
 		    prot_printf(backend_current->out, "LAST\r\n");
 		}
 		else if (!group_state) goto noopengroup;
 		else if (!nntp_current) goto nocurrent;
 		else if (nntp_current == 1) {
 		    prot_printf(nntp_out,
 				"422 No previous article in this group\r\n");
 		}
 		else {
 		    char *msgid = index_get_msgid(group_state, --nntp_current);
 
 		    prot_printf(nntp_out, "223 %u %s\r\n",
 				index_getuid(group_state, nntp_current),
 				msgid ? msgid : "<0>");
 
 		    if (msgid) free(msgid);
 		}
 	    }
 	    else if (!strcmp(cmd.s, "Listgroup")) {
 		arg1.len = 0;   	   /* group is optional */
 		buf_setcstr(&arg2, "1-");  /* default range is all */
 		buf_cstring(&arg2);	   /* appends a '\0' */
 		goto group;
 	    }
 	    else goto badcmd;
 	    break;
 
 	case 'M':
 	    if (!strcmp(cmd.s, "Mode")) {
 		if (c != ' ') goto missingargs;
 		c = getword(nntp_in, &arg1); /* mode */
 		if (c == EOF) goto missingargs;
 		if (c == '\r') c = prot_getc(nntp_in);
 		if (c != '\n') goto extraargs;
 
 		cmd_mode(arg1.s);
 	    }
 	    else goto badcmd;
 	    break;
 
 	case 'N':
 	    if (!strcmp(cmd.s, "Newgroups")) {
 		time_t tstamp;
 
 		arg3.len = 0;
 		if (c != ' ') goto missingargs;
 		c = getword(nntp_in, &arg1); /* date */
 		if (c != ' ') goto missingargs;
 		c = getword(nntp_in, &arg2); /* time */
 		if (c == EOF) goto missingargs;
 		if (c == ' ') {
 		    c = getword(nntp_in, &arg3); /* "GMT" (optional) */
 		    if (c == EOF) goto missingargs;
 		}
 		if (c == '\r') c = prot_getc(nntp_in);
 		if (c != '\n') goto extraargs;
 
 		if ((tstamp = parse_datetime(arg1.s, arg2.s,
 					     arg3.len ? arg3.s : NULL)) < 0)
 		    goto baddatetime;
 
 		cmd_newgroups(tstamp);
 	    }
 	    else if (!strcmp(cmd.s, "Newnews")) {
 		time_t tstamp;
 
 		if (!config_getswitch(IMAPOPT_ALLOWNEWNEWS))
 		    goto cmddisabled;
 
 		arg4.len = 0;
 		if (c != ' ') goto missingargs;
 		c = getword(nntp_in, &arg1); /* wildmat */
 		if (c != ' ') goto missingargs;
 		c = getword(nntp_in, &arg2); /* date */
 		if (c != ' ') goto missingargs;
 		c = getword(nntp_in, &arg3); /* time */
 		if (c == EOF) goto missingargs;
 		if (c == ' ') {
 		    c = getword(nntp_in, &arg4); /* "GMT" (optional) */
 		    if (c == EOF) goto missingargs;
 		}
 		if (c == '\r') c = prot_getc(nntp_in);
 		if (c != '\n') goto extraargs;
 
 		if ((tstamp = parse_datetime(arg2.s, arg3.s,
 					     arg4.len ? arg4.s : NULL)) < 0)
 		    goto baddatetime;
 
 		cmd_newnews(arg1.s, tstamp);
 	    }
 	    else if (!strcmp(cmd.s, "Next")) {
 		if (c == '\r') c = prot_getc(nntp_in);
 		if (c != '\n') goto extraargs;
 
 		if (backend_current) {
 		    prot_printf(backend_current->out, "NEXT\r\n");
 		}
 		else if (!group_state) goto noopengroup;
 		else if (!nntp_current) goto nocurrent;
 		else if (nntp_current == nntp_exists) {
 		    prot_printf(nntp_out,
 				"421 No next article in this group\r\n");
 		}
 		else {
 		    char *msgid = index_get_msgid(group_state, ++nntp_current);
 
 		    prot_printf(nntp_out, "223 %u %s\r\n",
 				index_getuid(group_state, nntp_current),
 				msgid ? msgid : "<0>");
 
 		    if (msgid) free(msgid);
 		}
 	    }
 	    else goto badcmd;
 	    break;
 
 	case 'O':
 	    if (!strcmp(cmd.s, "Over")) {
 		char *msgid;
 
 	      over:
 		if (arg1.s) *arg1.s = 0;
 
 		if (c == ' ') {
 		    c = getword(nntp_in, &arg1); /* range/msgid (optional) */
 		    if (c == EOF) goto missingargs;
 		}
 		if (c == '\r') c = prot_getc(nntp_in);
 		if (c != '\n') goto extraargs;
 
 		msgid = NULL;
 		if (parserange(arg1.s, &uid, &last,
 			       /* XOVER doesn't accept message-id */
 			       (cmd.s[0] == 'X' ? NULL : &msgid), &be) != -1) {
 		    if (be) {
 			if (arg1.s && *arg1.s)
 			    prot_printf(be->out, "%s %s\r\n", cmd.s, arg1.s);
 			else
 			    prot_printf(be->out, "%s\r\n", cmd.s);
 
 			if (be != backend_current) {
 			    r = read_response(be, 0, &result);
 			    if (r) goto noopengroup;
 
 			    prot_printf(nntp_out, "%s", result);
 			    if (!strncmp(result, "224", 3)) {
 				pipe_to_end_of_response(be, 0);
 			    }
 			}
 		    }
 		    else
 			cmd_over(msgid, uid, last);
 		}
 
 		if (msgid) goto prevgroup;
 	    }
 	    else goto badcmd;
 	    break;
 
 	case 'P':
 	    if (!strcmp(cmd.s, "Post")) {
 		if (c == '\r') c = prot_getc(nntp_in);
 		if (c != '\n') goto extraargs;
 
 		cmd_post(NULL, POST_POST);
 	    }
 	    else goto badcmd;
 	    break;
 
 	case 'Q':
 	    if (!strcmp(cmd.s, "Quit")) {
 		if (c == '\r') c = prot_getc(nntp_in);
 		if (c != '\n') goto extraargs;
 
 		prot_printf(nntp_out, "205 Connection closing\r\n");
 		return;
 	    }
 	    else goto badcmd;
 	    break;
 
 	case 'S':
 	    if (!strcmp(cmd.s, "Starttls") && tls_enabled()) {
 		if (c == '\r') c = prot_getc(nntp_in);
 		if (c != '\n') goto extraargs;
 
 		/* XXX  discard any input pipelined after STARTTLS */
 		prot_flush(nntp_in);
 
 		cmd_starttls(0);
 	    }
 	    else if (!strcmp(cmd.s, "Stat")) {
 		mode = ARTICLE_STAT;
 		goto article;
 	    }
-	    else if (!nntp_userid && !allowanonymous) goto nologin;
+	    else if (!nntp_authstate && !allowanonymous) goto nologin;
 	    else if (!strcmp(cmd.s, "Slave")) {	
 		if (c == '\r') c = prot_getc(nntp_in);
 		if (c != '\n') goto extraargs;
 
 		prot_printf(nntp_out, "202 Slave status noted\r\n");
 	    }
 	    else goto badcmd;
 	    break;
 
 	case 'T':
 	    if (!strcmp(cmd.s, "Takethis")) {
 		mode = POST_TAKETHIS;
 		goto ihave;
 	    }
 	    else goto badcmd;
 	    break;
 
 	case 'X':
 	    if (!strcmp(cmd.s, "Xhdr")) {
 		goto hdr;
 	    }
 	    else if (!strcmp(cmd.s, "Xover")) {
 		goto over;
 	    }
 	    else if (!strcmp(cmd.s, "Xpat")) {
 		char *msgid;
 
 		if (c != ' ') goto missingargs;
 		c = getword(nntp_in, &arg1); /* header */
 		if (c != ' ') goto missingargs;
 
 		/* gobble extra whitespace (hack for Mozilla) */
 		while ((c = prot_getc(nntp_in)) == ' ');
 		prot_ungetc(c, nntp_in);
 
 		c = getword(nntp_in, &arg2); /* range */
 		if (c != ' ') goto missingargs;
 		c = getword(nntp_in, &arg3); /* wildmat */
 		if (c == EOF) goto missingargs;
 
 		/* XXX per RFC 2980, we can have multiple patterns */
 
 		if (c == '\r') c = prot_getc(nntp_in);
 		if (c != '\n') goto extraargs;
 
 		if (parserange(arg2.s, &uid, &last, &msgid, &be) != -1) {
 		    if (be) {
 			prot_printf(be->out, "%s %s %s %s\r\n",
 				    cmd.s, arg1.s, arg2.s, arg3.s);
 
 			if (be != backend_current) {
 			    r = read_response(be, 0, &result);
 			    if (r) goto noopengroup;
 
 			    prot_printf(nntp_out, "%s", result);
 			    if (!strncmp(result, "221", 3)) {
 				pipe_to_end_of_response(be, 0);
 			    }
 			}
 		    }
 		    else
 			cmd_hdr(cmd.s, arg1.s, arg3.s, msgid, uid, last);
 		}
 
 		if (msgid) goto prevgroup;
 	    }
 	    else goto badcmd;
 	    break;
 
 	default:
 	  badcmd:
 	    prot_printf(nntp_out, "500 Unrecognized command\r\n");
 	    eatline(nntp_in, c);
 	}
 
 	continue;
 
       noperm:
 	prot_printf(nntp_out, "502 Permission denied\r\n");
 	eatline(nntp_in, c);
 	continue;
 
       nologin:
 	prot_printf(nntp_out, "480 Authentication required\r\n");
 	eatline(nntp_in, c);
 	continue;
 
       cmddisabled:
 	prot_printf(nntp_out, "503 \"%s\" disabled\r\n", cmd.s);
 	eatline(nntp_in, c);
 	continue;
 
       extraargs:
 	prot_printf(nntp_out, "501 Unexpected extra argument\r\n");
 	eatline(nntp_in, c);
 	continue;
 
       missingargs:
 	prot_printf(nntp_out, "501 Missing argument\r\n");
 	eatline(nntp_in, c);
 	continue;
 
       baddatetime:
 	prot_printf(nntp_out, "501 Bad date/time\r\n");
 	continue;
 
       nogroup:
 	prot_printf(nntp_out, "411 No such newsgroup (%s)\r\n",
 		    error_message(r));
 
       prevgroup:
 	/* Return to previously selected group */
 	if (*curgroup &&
 	    (!group_state || strcmp(curgroup, group_state->mailbox->name))) {
 	    open_group(curgroup, 1, NULL, NULL);
 	}
 
 	continue;
 
       noopengroup:
 	prot_printf(nntp_out, "412 No newsgroup selected\r\n");
 	continue;
 
       nocurrent:
 	prot_printf(nntp_out, "420 Current article number is invalid\r\n");
 	continue;
     }
 }
 
 /*
  * duplicate_find() callback function to fetch a message by msgid
  */
@@ -1768,122 +1768,122 @@ static time_t parse_datetime(char *datestr, char *timestr, char *gmt)
 static int open_group(char *name, int has_prefix, struct backend **ret,
 		      int *postable /* used for LIST ACTIVE only */)
 {
     char mailboxname[MAX_MAILBOX_BUFFER];
     int r = 0;
     char *acl, *newserver;
     struct backend *backend_next = NULL;
 
     /* close local group */
     if (group_state) 
 	index_close(&group_state);
 
     if (!has_prefix) {
 	snprintf(mailboxname, sizeof(mailboxname), "%s%s", newsprefix, name);
 	name = mailboxname;
     }
 
     if (!r) r = mlookup(name, &newserver, &acl, NULL);
 
     if (!r && acl) {
 	int myrights = cyrus_acl_myrights(nntp_authstate, acl);
 
 	if (postable) *postable = myrights & ACL_POST;
 	if (!postable && /* allow limited 'r' for LIST ACTIVE */
 	    !(myrights & ACL_READ)) {
 	    r = (myrights & ACL_LOOKUP) ?
 		IMAP_PERMISSION_DENIED : IMAP_MAILBOX_NONEXISTENT;
 	}
     }
 
     if (r) return r;
 
     if (newserver) {
 	/* remote group */
 	backend_next = proxy_findserver(newserver, &nntp_protocol,
-					nntp_userid ? nntp_userid : "anonymous",
+					nntp_authstate ? nntp_userid : "anonymous",
 					&backend_cached, &backend_current,
 					NULL, nntp_in);
 	if (!backend_next) return IMAP_SERVER_UNAVAILABLE;
 
 	*ret = backend_next;
     }
     else {
 	/* local group */
 	struct index_init init;
 	memset(&init, 0, sizeof(struct index_init));
-	init.userid = nntp_userid;
+	init.userid = nntp_authstate ? nntp_userid : NULL;
 	init.authstate = nntp_authstate;
 	r = index_open(name, &init, &group_state);
 	if (r) return r;
 
 	if (ret) *ret = NULL;
     }
 
     syslog(LOG_DEBUG, "open: user %s opened %s",
 	   nntp_userid ? nntp_userid : "anonymous", name);
 
     return 0;
 }
 
 static void cmd_capabilities(char *keyword __attribute__((unused)))
 {
     const char *mechlist;
     int mechcount = 0;
 
     prot_printf(nntp_out, "101 Capability list follows:\r\n");
     prot_printf(nntp_out, "VERSION 2\r\n");
     if (nntp_authstate || (config_serverinfo == IMAP_ENUM_SERVERINFO_ON)) {
 	prot_printf(nntp_out,
 		    "IMPLEMENTATION Cyrus NNTP%s %s\r\n",
 		    config_mupdate_server ? " Murder" : "", cyrus_version());
     }
 
     /* add STARTTLS */
     if (tls_enabled() && !nntp_starttls_done && !nntp_authstate)
 	prot_printf(nntp_out, "STARTTLS\r\n");
 
     /* check for SASL mechs */
     sasl_listmech(nntp_saslconn, NULL, "SASL ", " ", "\r\n",
 		  &mechlist, NULL, &mechcount);
 
     /* add the AUTHINFO variants */
     if (!nntp_authstate) {
 	prot_printf(nntp_out, "AUTHINFO%s%s\r\n",
 		    (nntp_starttls_done || (extprops_ssf > 1) ||
 		     config_getswitch(IMAPOPT_ALLOWPLAINTEXT)) ?
 		    " USER" : "", mechcount ? " SASL" : "");
     }
 
     /* add the SASL mechs */
     if (mechcount) prot_printf(nntp_out, "%s", mechlist);
 
     /* add the reader capabilities/extensions */
-    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {
+    if ((nntp_capa & MODE_READ) && (nntp_authstate || allowanonymous)) {
 	prot_printf(nntp_out, "READER\r\n");
 	prot_printf(nntp_out, "POST\r\n");
 	if (config_getswitch(IMAPOPT_ALLOWNEWNEWS))
 	    prot_printf(nntp_out, "NEWNEWS\r\n");
 	prot_printf(nntp_out, "HDR\r\n");
 	prot_printf(nntp_out, "OVER\r\n");
 	prot_printf(nntp_out, "XPAT\r\n");
     }
 
     /* add the feeder capabilities/extensions */
     if (nntp_capa & MODE_FEED) {
 	prot_printf(nntp_out, "IHAVE\r\n");
 	prot_printf(nntp_out, "STREAMING\r\n");
     }
 
     /* add the LIST variants */
     prot_printf(nntp_out, "LIST ACTIVE%s\r\n",
-		((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) ?
+	        ((nntp_capa & MODE_READ) && (nntp_authstate || allowanonymous)) ?
 		" HEADERS NEWSGROUPS OVERVIEW.FMT" : "");
 
     prot_printf(nntp_out, ".\r\n");
 
     did_capabilities = 1;
 }
 
 /*
  * duplicate_find() callback function to build Xref content
  */
@@ -2354,93 +2354,93 @@ static void cmd_hdr(char *cmd, char *hdr, char *pat, char *msgid,
 static void cmd_help(void)
 {
     prot_printf(nntp_out, "100 Supported commands:\r\n");
 
-    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {
+    if ((nntp_capa & MODE_READ) && (nntp_authstate || allowanonymous)) {
 	prot_printf(nntp_out, "\tARTICLE [ message-id | number ]\r\n"
 		    "\t\tRetrieve entirety of the specified article.\r\n");
     }
     if (!nntp_authstate) {
 	if (!nntp_userid) {
 	    prot_printf(nntp_out, "\tAUTHINFO SASL mechanism [initial-response]\r\n"
 			"\t\tPerform an authentication exchange using the specified\r\n"
 			"\t\tSASL mechanism.\r\n");
 	    prot_printf(nntp_out, "\tAUTHINFO USER username\r\n"
 			"\t\tPresent username for authentication.\r\n");
 	}
 	prot_printf(nntp_out, "\tAUTHINFO PASS password\r\n"
 		    "\t\tPresent clear-text password for authentication.\r\n");
     }
-    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {
+    if ((nntp_capa & MODE_READ) && (nntp_authstate || allowanonymous)) {
 	prot_printf(nntp_out, "\tBODY [ message-id | number ]\r\n"
 		    "\t\tRetrieve body of the specified article.\r\n");
     }
     prot_printf(nntp_out, "\tCAPABILITIES\r\n"
 		"\t\tList the current server capabilities.\r\n");
     if (nntp_capa & MODE_FEED) {
 	prot_printf(nntp_out, "\tCHECK message-id\r\n"
 		    "\t\tCheck if the server wants the specified article.\r\n");
     }
-    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {
+    if ((nntp_capa & MODE_READ) && (nntp_authstate || allowanonymous)) {
 	prot_printf(nntp_out, "\tDATE\r\n"
 		    "\t\tRequest the current server UTC date and time.\r\n");
 	prot_printf(nntp_out, "\tGROUP group\r\n"
 		    "\t\tSelect a newsgroup for article retrieval.\r\n");
 	prot_printf(nntp_out, "\tHDR header [ message-id | range ]\r\n"
 		    "\t\tRetrieve the specified header/metadata from the\r\n"
 		    "\t\tspecified article(s).\r\n");
     }
     prot_printf(nntp_out, "\tHEAD [ message-id | number ]\r\n"
 		"\t\tRetrieve the headers of the specified article.\r\n");
     prot_printf(nntp_out, "\tHELP\r\n"
 		"\t\tRequest command summary (this text).\r\n");
     if (nntp_capa & MODE_FEED) {
 	prot_printf(nntp_out, "\tIHAVE message-id\r\n"
 		    "\t\tPresent/transfer the specified article to the server.\r\n");
     }
-    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {
+    if ((nntp_capa & MODE_READ) && (nntp_authstate || allowanonymous)) {
 	prot_printf(nntp_out, "\tLAST\r\n"
 		    "\t\tSelect the previous article.\r\n");
     }
     prot_printf(nntp_out, "\tLIST [ ACTIVE wildmat ]\r\n"
 		"\t\tList the (subset of) valid newsgroups.\r\n");
-    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {
+    if ((nntp_capa & MODE_READ) && (nntp_authstate || allowanonymous)) {
 	prot_printf(nntp_out, "\tLIST HEADERS [ MSGID | RANGE ]\r\n"
 		    "\t\tList the headers and metadata items available via HDR.\r\n");
 	prot_printf(nntp_out, "\tLIST NEWSGROUPS [wildmat]\r\n"
 		    "\t\tList the descriptions of the specified newsgroups.\r\n");
 	prot_printf(nntp_out, "\tLIST OVERVIEW.FMT\r\n"
 		    "\t\tList the headers and metadata items available via OVER.\r\n");
 	prot_printf(nntp_out, "\tLISTGROUP [group [range]]\r\n"
 		    "\t\tList the article numbers in the specified newsgroup.\r\n");
 	if (config_getswitch(IMAPOPT_ALLOWNEWNEWS))
 	    prot_printf(nntp_out, "\tNEWNEWS wildmat date time [GMT]\r\n"
 			"\t\tList the newly arrived articles in the specified newsgroup(s)\r\n"
 			"\t\tsince the specified date and time.\r\n");
 	prot_printf(nntp_out, "\tNEXT\r\n"
 		    "\t\tSelect the next article.\r\n");
 	prot_printf(nntp_out, "\tOVER [ message-id | range ]\r\n"
 		    "\t\tRetrieve the overview information for the specified article(s).\r\n");
 	prot_printf(nntp_out, "\tPOST\r\n"
 		    "\t\tPost an article to the server.\r\n");
     }
 
     prot_printf(nntp_out, "\tQUIT\r\n"
 		"\t\tTerminate the session.\r\n");
     if (tls_enabled() && !nntp_starttls_done && !nntp_authstate) {
 	prot_printf(nntp_out, "\tSTARTTLS\r\n"
 		    "\t\tStart a TLS negotiation.\r\n");
     }
     prot_printf(nntp_out, "\tSTAT [ message-id | number ]\r\n"
 		"\t\tCheck if the specified article exists.\r\n");
     if (nntp_capa & MODE_FEED) {
 	prot_printf(nntp_out, "\tTAKETHIS message-id\r\n"
 		    "\t\tTransfer the specified article to the server.\r\n");
     }
-    if ((nntp_capa & MODE_READ) && (nntp_userid || allowanonymous)) {
+    if ((nntp_capa & MODE_READ) && (nntp_authstate || allowanonymous)) {
 	prot_printf(nntp_out, "\tXPAT header message-id|range wildmat\r\n"
 		    "\t\tList the specified article(s) in which the contents\r\n"
 		    "\t\tof the specified header/metadata matches the wildmat.\r\n");
     }
     prot_printf(nntp_out, ".\r\n");
 }
 
@@ -2499,25 +2499,25 @@ struct enum_rock {
 void list_proxy(char *server, void *data __attribute__((unused)), void *rock)
 {
     struct enum_rock *erock = (struct enum_rock *) rock;
     struct backend *be;
     int r;
     char *result;
 
     be = proxy_findserver(server, &nntp_protocol,
-			  nntp_userid ? nntp_userid : "anonymous",
+			  nntp_authstate ? nntp_userid : "anonymous",
 			  &backend_cached, &backend_current, NULL, nntp_in);
     if (!be) return;
 
     prot_printf(be->out, "LIST %s %s\r\n", erock->cmd, erock->wild);
 
     r = read_response(be, 0, &result);
     if (!r && !strncmp(result, "215 ", 4)) {
 	while (!(r = read_response(be, 0, &result)) && result[0] != '.') {
 	    prot_printf(nntp_out, "%s", result);
 	}
     }
 }
 
 /*
  * perform LIST ACTIVE (backend) or create a server hash table (proxy)
  */
@@ -2614,141 +2614,143 @@ int newsgroups_cb(const char *mailbox,
 static void cmd_list(char *arg1, char *arg2)
 {
     if (!arg1)
 	arg1 = "active";
     else
 	lcase(arg1);
 
     if (!strcmp(arg1, "active")) {
 	char pattern[MAX_MAILBOX_BUFFER];
 	struct list_rock lrock;
 	struct enum_rock erock;
 
 	if (!arg2) arg2 = "*";
 
 	erock.cmd = "ACTIVE";
 	erock.wild = xstrdup(arg2); /* make a copy before we munge it */
 
 	lrock.proc = do_active;
 	lrock.wild = split_wildmats(arg2); /* split the list of wildmats */
 
 	/* xxx better way to determine a size for this table? */
 	construct_hash_table(&lrock.server_table, 10, 1);
 
 	prot_printf(nntp_out, "215 List of newsgroups follows:\r\n");
 
 	strcpy(pattern, newsprefix);
 	strcat(pattern, "*");
 	list_cb(NULL, 0, 0, NULL);
-	mboxlist_findall(NULL, pattern, 0, nntp_userid, nntp_authstate,
+	mboxlist_findall(NULL, pattern, 0,
+			 nntp_authstate ? nntp_userid : NULL, nntp_authstate,
 			 list_cb, &lrock);
 
 	/* proxy to the backends */
 	hash_enumerate(&lrock.server_table, list_proxy, &erock);
 
 	prot_printf(nntp_out, ".\r\n");
 
 	/* free the hash table */
 	free_hash_table(&lrock.server_table, NULL);
 
 	/* free the wildmats */
 	free_wildmats(lrock.wild);
 	free(erock.wild);
 
 	if (group_state)
 	    index_close(&group_state);
     }
     else if (!(nntp_capa & MODE_READ)) {
 	prot_printf(nntp_out, "502 Permission denied\r\n");
 	return;
     }
-    else if (!nntp_userid && !allowanonymous) {
+    else if (!nntp_authstate && !allowanonymous) {
 	prot_printf(nntp_out, "480 Authentication required\r\n");
 	return;
     }
     else if (!strcmp(arg1, "headers")) {
 	if (arg2 && strcmp(arg2, "msgid") && strcmp(arg2, "range")) {
 	    prot_printf(nntp_out, "501 Unexpected extra argument\r\n");
 	    return;
 	}
 
 	prot_printf(nntp_out, "215 Header and metadata list follows:\r\n");
 	prot_printf(nntp_out, ":\r\n"); /* all headers */
 	prot_printf(nntp_out, ":bytes\r\n");
 	prot_printf(nntp_out, ":lines\r\n");
 	prot_printf(nntp_out, ".\r\n");
     }
     else if (!strcmp(arg1, "newsgroups")) {
 	char pattern[MAX_MAILBOX_BUFFER];
 	struct list_rock lrock;
 	struct enum_rock erock;
 
 	if (!arg2) arg2 = "*";
 
 	erock.cmd = "NEWSGROUPS";
 	erock.wild = xstrdup(arg2); /* make a copy before we munge it */
 
 	lrock.proc = do_newsgroups;
 	lrock.wild = split_wildmats(arg2); /* split the list of wildmats */
 
 	/* xxx better way to determine a size for this table? */
 	construct_hash_table(&lrock.server_table, 10, 1);
 
 	prot_printf(nntp_out, "215 List of newsgroups follows:\r\n");
 
 	strcpy(pattern, newsprefix);
 	strcat(pattern, "*");
 	list_cb(NULL, 0, 0, NULL);
-	mboxlist_findall(NULL, pattern, 0, nntp_userid, nntp_authstate,
+	mboxlist_findall(NULL, pattern, 0,
+			 nntp_authstate ? nntp_userid : NULL, nntp_authstate,
 			 list_cb, &lrock);
 
 	/* proxy to the backends */
 	hash_enumerate(&lrock.server_table, list_proxy, &erock);
 
 	strcpy(pattern, newsprefix);
 	strcat(pattern, "*");
 	annotatemore_findall(pattern, "/comment",
 			     newsgroups_cb, lrock.wild, NULL);
 
 	prot_printf(nntp_out, ".\r\n");
 
 	/* free the hash table */
 	free_hash_table(&lrock.server_table, NULL);
 
 	/* free the wildmats */
 	free_wildmats(lrock.wild);
 	free(erock.wild);
     }
     else if (!strcmp(arg1, "overview.fmt")) {
 	if (arg2) {
 	    prot_printf(nntp_out, "501 Unexpected extra argument\r\n");
 	    return;
 	}
 
 	prot_printf(nntp_out, "215 Order of overview fields follows:\r\n");
 	prot_printf(nntp_out, "Subject:\r\n");
 	prot_printf(nntp_out, "From:\r\n");
 	prot_printf(nntp_out, "Date:\r\n");
 	prot_printf(nntp_out, "Message-ID:\r\n");
 	prot_printf(nntp_out, "References:\r\n");
 	if (did_capabilities) {
 	    /* new OVER format */
 	    prot_printf(nntp_out, ":bytes\r\n");
 	    prot_printf(nntp_out, ":lines\r\n");
 	} else {
 	    /* old XOVER format */
 	    prot_printf(nntp_out, "Bytes:\r\n");
 	    prot_printf(nntp_out, "Lines:\r\n");
 	}
 	prot_printf(nntp_out, "Xref:full\r\n");
 	prot_printf(nntp_out, ".\r\n");
     }
     else if (!strcmp(arg1, "active.times") || !strcmp(arg1, "distributions") ||
 	     !strcmp(arg1, "distrib.pats")) {
 	prot_printf(nntp_out, "503 Unsupported LIST command\r\n");
     }
     else {
 	prot_printf(nntp_out, "501 Unrecognized LIST command\r\n");
     }
     prot_flush(nntp_out);
 }
 
@@ -3267,147 +3269,149 @@ static int savemsg(message_data_t *m, FILE *f)
 static int deliver_remote(message_data_t *msg, struct dest *dlist)
 {
     struct dest *d;
 
     /* run the txns */
     for (d = dlist; d; d = d->next) {
 	struct backend *be;
 	char buf[4096];
 
 	be = proxy_findserver(d->server, &nntp_protocol,
-			      nntp_userid ? nntp_userid : "anonymous",
+			      nntp_authstate ? nntp_userid : "anonymous",
 			      &backend_cached, &backend_current,
 			      NULL, nntp_in);
 	if (!be) return IMAP_SERVER_UNAVAILABLE;
 
 	/* tell the backend about our new article */
 	prot_printf(be->out, "IHAVE %s\r\n", msg->id);
 	prot_flush(be->out);
 
 	if (!prot_fgets(buf, sizeof(buf), be->in) ||
 	    strncmp("335", buf, 3)) {
 	    syslog(LOG_NOTICE, "backend doesn't want article %s", msg->id);
 	    continue;
 	}
 
 	/* send the article */
 	rewind(msg->f);
 	while (fgets(buf, sizeof(buf), msg->f)) {
 	    if (buf[0] == '.') prot_putc('.', be->out);
 	    do {
 		prot_printf(be->out, "%s", buf);
 	    } while (buf[strlen(buf)-1] != '\n' &&
 		     fgets(buf, sizeof(buf), msg->f));
 	}
 
 	/* Protect against messages not ending in CRLF */
 	if (buf[strlen(buf)-1] != '\n') prot_printf(be->out, "\r\n");
 
 	prot_printf(be->out, ".\r\n");
 
 	if (!prot_fgets(buf, sizeof(buf), be->in) ||
 	    strncmp("235", buf, 3)) {
 	    syslog(LOG_WARNING, "article %s transfer to backend failed",
 		   msg->id);
 	    return NNTP_FAIL_TRANSFER;
 	}
     }
 
     return 0;
 }
 
 static int deliver(message_data_t *msg)
 {
     int n, r = 0, myrights;
     char *rcpt = NULL, *local_rcpt = NULL, *server, *acl;
     unsigned long uid;
     struct body *body = NULL;
     struct dest *dlist = NULL;
     duplicate_key_t dkey = {msg->id, NULL, msg->date};
 
     /* check ACLs of all mailboxes */
     for (n = 0; n < msg->rcpt_num; n++) {
 	rcpt = msg->rcpt[n];
 
 	/* look it up */
 	r = mlookup(rcpt, &server, &acl, NULL);
 	dkey.to = rcpt;
 	if (r) return IMAP_MAILBOX_NONEXISTENT;
 
 	if (!(acl && (myrights = cyrus_acl_myrights(nntp_authstate, acl)) &&
 	      (myrights & ACL_POST)))
 	    return IMAP_PERMISSION_DENIED;
 
 	if (server) {
 	    /* remote group */
 	    proxy_adddest(&dlist, NULL, 0, server, "");
 	}
 	else {
 	    /* local group */
 	    struct appendstate as;
 
 	    if (msg->id && 
 		duplicate_check(&dkey)) {
 		/* duplicate message */
 		duplicate_log(&dkey, "nntp delivery");
 		continue;
 	    }
 
-	    r = append_setup(&as, rcpt, nntp_userid, nntp_authstate, ACL_POST, 0);
+	    r = append_setup(&as, rcpt,
+			     nntp_authstate ? nntp_userid : NULL,
+			     nntp_authstate, ACL_POST, 0);
 
 	    if (!r) {
 		prot_rewind(msg->data);
 		if (stage) {
 		    r = append_fromstage(&as, &body, stage, 0,
 					 (const char **) NULL, 0, !singleinstance);
 		} else {
 		    /* XXX should never get here */
 		    r = append_fromstream(&as, &body, msg->data, msg->size, 0,
 					  (const char **) NULL, 0);
 		}
 		if (r || ( msg->id && duplicate_check(&dkey) ) ) {    
 		    append_abort(&as);
                    
 		    if (!r) {
 			/* duplicate message */
 			duplicate_log(&dkey, "nntp delivery");
 			continue;
 		    }            
 		}                
 		else {           
 		    r = append_commit(&as, 0, NULL, &uid, NULL, NULL);
 		}
 	    }
 
 	    if (!r && msg->id)
 		duplicate_mark(&dkey, time(NULL), uid);
 
 	    if (r) return r;
 
 	    local_rcpt = rcpt;
 	}
     }
 
     if (body) {
 	message_free_body(body);
 	free(body);
     }
 
     if (dlist) {
 	struct dest *d;
 
 	/* run the txns */
 	r = deliver_remote(msg, dlist);
 
 	/* free the destination list */
 	d = dlist;
 	while (d) {
 	    struct dest *nextd = d->next;
 	    free(d);
 	    d = nextd;
 	}
     }
 
     return r;
 }
 
 #if 0  /* XXX  Need to review control message auth/authz and implementation */
