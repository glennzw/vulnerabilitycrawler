   Fix Savannah bug #30657.
   
   * src/truetype/ttinterp.c (BOUNDSL): New macro.
   Change `BOUNDS' to `BOUNDSL' where appropriate.
   
   * src/truetype/ttinterp.h (TT_ExecContextRec): Fix type of
   `cvtSize'.
2010-08-05  Werner Lemberg  <wl@gnu.org>

	Fix Savannah bug #30656.

	* src/type42/t42parse.c (t42_parse_sfnts): Protect against negative

  /*************************************************************************/
  /*                                                                       */
  /* A simple bounds-checking macro.                                       */
  /*                                                                       */
#define BOUNDS( x, n )  ( (FT_UInt)(x) >= (FT_UInt)(n) )

#undef  SUCCESS
#define SUCCESS  0
    args[0] = FT_PIX_CEIL( args[0] );


#define DO_RS                          \
   {                                   \
     FT_ULong  I = (FT_ULong)args[0];  \
                                       \
                                       \
     if ( BOUNDS( I, CUR.storeSize ) ) \
     {                                 \
       if ( CUR.pedantic_hinting )     \
       {                               \
         ARRAY_BOUND_ERROR;            \
       }                               \
       else                            \
         args[0] = 0;                  \
     }                                 \
     else                              \
       args[0] = CUR.storage[I];       \
   }


#define DO_WS                          \
   {                                   \
     FT_ULong  I = (FT_ULong)args[0];  \
                                       \
                                       \
     if ( BOUNDS( I, CUR.storeSize ) ) \
     {                                 \
       if ( CUR.pedantic_hinting )     \
       {                               \
         ARRAY_BOUND_ERROR;            \
       }                               \
     }                                 \
     else                              \
       CUR.storage[I] = args[1];       \
   }


     FT_ULong  I = (FT_ULong)args[0];    \
                                         \
                                         \
     if ( BOUNDS( I, CUR.cvtSize ) )     \
     {                                   \
       if ( CUR.pedantic_hinting )       \
       {                                 \
     FT_ULong  I = (FT_ULong)args[0];    \
                                         \
                                         \
     if ( BOUNDS( I, CUR.cvtSize ) )     \
     {                                   \
       if ( CUR.pedantic_hinting )       \
       {                                 \
     FT_ULong  I = (FT_ULong)args[0];                           \
                                                                \
                                                                \
     if ( BOUNDS( I, CUR.cvtSize ) )                            \
     {                                                          \
       if ( CUR.pedantic_hinting )                              \
       {                                                        \
    /* first of all, check the index */

    F = args[0];
    if ( BOUNDS( F, CUR.maxFunc + 1 ) )
      goto Fail;

    /* Except for some old Apple fonts, all functions in a TrueType */

    /* first of all, check the index */
    F = args[1];
    if ( BOUNDS( F, CUR.maxFunc + 1 ) )
      goto Fail;

    /* Except for some old Apple fonts, all functions in a TrueType */

    L = (FT_ULong)args[0];

    if ( BOUNDS( L, CUR.zp2.n_points ) )
    {
      if ( CUR.pedantic_hinting )
      {
    K = (FT_UShort)args[1];
    L = (FT_UShort)args[0];

    if( BOUNDS( L, CUR.zp0.n_points ) ||
        BOUNDS( K, CUR.zp1.n_points ) )
    {
      if ( CUR.pedantic_hinting )
      {
  static void
  Ins_SHZ( INS_ARG )
  {
    TT_GlyphZoneRec zp;
    FT_UShort       refp;
    FT_F26Dot6      dx,
                    dy;

    FT_UShort       last_point, i;


    if ( BOUNDS( args[0], 2 ) )
    cvtEntry = (FT_ULong)args[1];
    point    = (FT_UShort)args[0];

    if ( BOUNDS( point,    CUR.zp0.n_points ) ||
         BOUNDS( cvtEntry, CUR.cvtSize )      )
    {
      if ( CUR.pedantic_hinting )
        CUR.error = TT_Err_Invalid_Reference;
    /* XXX: UNDOCUMENTED! cvt[-1] = 0 always */

    if ( BOUNDS( point,      CUR.zp1.n_points ) ||
         BOUNDS( cvtEntry,   CUR.cvtSize + 1 )  ||
         BOUNDS( CUR.GS.rp0, CUR.zp0.n_points ) )
    {
      if ( CUR.pedantic_hinting )
    p1 = (FT_UShort)args[0];
    p2 = (FT_UShort)args[1];

    if ( BOUNDS( args[0], CUR.zp1.n_points ) ||
         BOUNDS( args[1], CUR.zp0.n_points ) )
    {
      if ( CUR.pedantic_hinting )
        CUR.error = TT_Err_Invalid_Reference;
      A = (FT_ULong)CUR.stack[CUR.args + 1];
      B = CUR.stack[CUR.args];

      if ( BOUNDS( A, CUR.cvtSize ) )
      {
        if ( CUR.pedantic_hinting )
        {

    FT_Bool            step_ins;  /* true if the interpreter must */
                                  /* increment IP after ins. exec */
    FT_Long            cvtSize;
    FT_Long*           cvt;

    FT_UInt            glyphSize; /* glyph instructions buffer size */
