   usb-linux.c: fix buffer overflow
   
   In usb-linux.c:usb_host_handle_control, we pass a 1024-byte buffer and
   length to the kernel.  However, the length was provided by the caller
   of dev->handle_packet, and is not checked, so the kernel might provide
   too much data and overflow our buffer.
   
   For example, hw/usb-uhci.c could set the length to 2047.
   hw/usb-ohci.c looks like it might go up to 4096 or 8192.
   
   This causes a qemu crash, as reported here:
     http://www.mail-archive.com/kvm@vger.kernel.org/msg18447.html
   
   This patch increases the usb-linux.c buffer size to 2048 to fix the
   specific device reported, and adds a check to avoid the overflow in
   any case.
   
   Signed-off-by: Jim Paris <jim@jtan.com>
   Signed-off-by: Anthony Liguori <aliguori@us.ibm.com>
    uint16_t offset;
    uint8_t  state;
    struct   usb_ctrlrequest req;
    uint8_t  buffer[1024];
};

typedef struct USBHostDevice {
    struct usbdevfs_urb *urb;
    AsyncURB *aurb;
    int ret, value, index;

    /* 
     * Process certain standard device requests.

    /* The rest are asynchronous */

    aurb = async_alloc();
    aurb->hdev   = s;
    aurb->packet = p;
    urb->endpoint = p->devep;

    urb->buffer        = &s->ctrl.req;
    urb->buffer_length = 8 + s->ctrl.len;

    urb->usercontext = s;

