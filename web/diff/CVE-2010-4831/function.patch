commit 88f54ea47d4a55bbbf9e34a7a0502f365eb69ae5
Author: Tor Lillqvist <tml@iki.fi>
Date:   Thu Sep 9 19:48:42 2010 +0300

    Avoid potential DLL hijacking in Wintab code
    
    Load Wintab32.dll from an absolute path. A proper Wintab32.dll, if
    present, should be in the Windows system directory, so load it from
    there.

diff --git a/gdk/win32/gdkinput-win32.c b/gdk/win32/gdkinput-win32.c
index d02952d..5dec13c 100644
--- a/gdk/win32/gdkinput-win32.c
+++ b/gdk/win32/gdkinput-win32.c
@@ -1,52 +1,54 @@
 /* GDK - The GIMP Drawing Kit
  * Copyright (C) 1995-1997 Peter Mattis, Spencer Kimball and Josh MacDonald
  * Copyright (C) 1998-2007 Tor Lillqvist
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
  * version 2 of the License, or (at your option) any later version.
  *
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with this library; if not, write to the
  * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
  * Boston, MA 02111-1307, USA.
  */
 
 /*
  * Modified by the GTK+ Team and others 1997-2000.  See the AUTHORS
  * file for a list of people on the GTK+ Team.  See the ChangeLog
  * files for a list of changes.  These files are distributed with
  * GTK+ at ftp://ftp.gtk.org/pub/gtk/. 
  */
 
 #include "config.h"
 
 #include <stdlib.h>
 #include <stdio.h>
 #include <math.h>
 
 #include "gdk.h"
 #include "gdkinput.h"
 #include "gdkinternals.h"
 #include "gdkprivate-win32.h"
 #include "gdkinput-win32.h"
 
+#define WINTAB32_DLL "Wintab32.dll"
+
 #define PACKETDATA (PK_CONTEXT | PK_CURSOR | PK_BUTTONS | PK_X | PK_Y  | PK_NORMAL_PRESSURE | PK_ORIENTATION)
 /* We want everything in absolute mode */
 #define PACKETMODE (0)
 #include <pktdef.h>
 
 #define DEBUG_WINTAB 1		/* Verbose debug messages enabled */
 
 #define PROXIMITY_OUT_DELAY 200 /* In milliseconds, see set_ignore_core */
 
 #define TWOPI (2.*G_PI)
 
 /* Forward declarations */
 
@@ -326,294 +328,314 @@ void
 _gdk_input_wintab_init_check (void)
 {
   static gboolean wintab_initialized = FALSE;
   GdkDevicePrivate *gdkdev;
   GdkWindowAttr wa;
   WORD specversion;
   HCTX *hctx;
   UINT ndevices, ncursors, ncsrtypes, firstcsr, hardware;
   BOOL active;
   DWORD physid;
   AXIS axis_x, axis_y, axis_npressure, axis_or[3];
-  int i, k;
+  int i, k, n;
   int devix, cursorix;
   wchar_t devname[100], csrname[100];
   gchar *devname_utf8, *csrname_utf8;
   BOOL defcontext_done;
   HMODULE wintab32;
+  char *wintab32_dll_path;
+  char dummy;
 
   if (wintab_initialized)
     return;
   
   wintab_initialized = TRUE;
   
   wintab_contexts = NULL;
 
   if (_gdk_input_ignore_wintab)
     return;
 
-  if ((wintab32 = LoadLibrary ("wintab32.dll")) == NULL)
+  n = GetSystemDirectory (&dummy, 0);
+
+  if (n <= 0)
+    return;
+
+  wintab32_dll_path = g_malloc (n + 1 + strlen (WINTAB32_DLL));
+  k = GetSystemDirectory (wintab32_dll_path, n);
+  
+  if (k == 0 || k > n)
+    {
+      g_free (wintab32_dll_path);
+      return;
+    }
+
+  if (!G_IS_DIR_SEPARATOR (wintab32_dll_path[strlen (wintab32_dll_path) -1]))
+    strcat (wintab32_dll_path, G_DIR_SEPARATOR_S);
+  strcat (wintab32_dll_path, WINTAB32_DLL);
+
+  if ((wintab32 = LoadLibrary (wintab32_dll_path)) == NULL)
     return;
 
   if ((p_WTInfoA = (t_WTInfoA) GetProcAddress (wintab32, "WTInfoA")) == NULL)
     return;
   if ((p_WTInfoW = (t_WTInfoW) GetProcAddress (wintab32, "WTInfoW")) == NULL)
     return;
   if ((p_WTEnable = (t_WTEnable) GetProcAddress (wintab32, "WTEnable")) == NULL)
     return;
   if ((p_WTOpenA = (t_WTOpenA) GetProcAddress (wintab32, "WTOpenA")) == NULL)
     return;
   if ((p_WTOverlap = (t_WTOverlap) GetProcAddress (wintab32, "WTOverlap")) == NULL)
     return;
   if ((p_WTPacket = (t_WTPacket) GetProcAddress (wintab32, "WTPacket")) == NULL)
     return;
   if ((p_WTQueueSizeSet = (t_WTQueueSizeSet) GetProcAddress (wintab32, "WTQueueSizeSet")) == NULL)
     return;
     
   if (!(*p_WTInfoA) (0, 0, NULL))
     return;
 
   (*p_WTInfoA) (WTI_INTERFACE, IFC_SPECVERSION, &specversion);
   GDK_NOTE (INPUT, g_print ("Wintab interface version %d.%d\n",
 			    HIBYTE (specversion), LOBYTE (specversion)));
   (*p_WTInfoA) (WTI_INTERFACE, IFC_NDEVICES, &ndevices);
   (*p_WTInfoA) (WTI_INTERFACE, IFC_NCURSORS, &ncursors);
 #if DEBUG_WINTAB
   GDK_NOTE (INPUT, g_print ("NDEVICES: %d, NCURSORS: %d\n",
 			    ndevices, ncursors));
 #endif
   /* Create a dummy window to receive wintab events */
   wa.wclass = GDK_INPUT_OUTPUT;
   wa.event_mask = GDK_ALL_EVENTS_MASK;
   wa.width = 2;
   wa.height = 2;
   wa.x = -100;
   wa.y = -100;
   wa.window_type = GDK_WINDOW_TOPLEVEL;
   if ((wintab_window = gdk_window_new (NULL, &wa, GDK_WA_X|GDK_WA_Y)) == NULL)
     {
       g_warning ("gdk_input_wintab_init: gdk_window_new failed");
       return;
     }
   g_object_ref (wintab_window);
       
   for (devix = 0; devix < ndevices; devix++)
     {
       LOGCONTEXT lc;
       
       /* We open the Wintab device (hmm, what if there are several, or
        * can there even be several, probably not?) as a system
        * pointing device, i.e. it controls the normal Windows
        * cursor. This seems much more natural.
        */
 
       (*p_WTInfoW) (WTI_DEVICES + devix, DVC_NAME, devname);
       devname_utf8 = g_utf16_to_utf8 (devname, -1, NULL, NULL, NULL);
 #ifdef DEBUG_WINTAB
       GDK_NOTE (INPUT, (g_print("Device %d: %s\n", devix, devname_utf8)));
 #endif
       (*p_WTInfoA) (WTI_DEVICES + devix, DVC_NCSRTYPES, &ncsrtypes);
       (*p_WTInfoA) (WTI_DEVICES + devix, DVC_FIRSTCSR, &firstcsr);
       (*p_WTInfoA) (WTI_DEVICES + devix, DVC_HARDWARE, &hardware);
       (*p_WTInfoA) (WTI_DEVICES + devix, DVC_X, &axis_x);
       (*p_WTInfoA) (WTI_DEVICES + devix, DVC_Y, &axis_y);
       (*p_WTInfoA) (WTI_DEVICES + devix, DVC_NPRESSURE, &axis_npressure);
       (*p_WTInfoA) (WTI_DEVICES + devix, DVC_ORIENTATION, axis_or);
 
       defcontext_done = FALSE;
       if (HIBYTE (specversion) > 1 || LOBYTE (specversion) >= 1)
 	{
 	  /* Try to get device-specific default context */
 	  /* Some drivers, e.g. Aiptek, don't provide this info */
 	  if ((*p_WTInfoA) (WTI_DSCTXS + devix, 0, &lc) > 0)
 	    defcontext_done = TRUE;
 #if DEBUG_WINTAB
 	  if (defcontext_done)
 	    GDK_NOTE (INPUT, (g_print("Using device-specific default context\n")));
 	  else
 	    GDK_NOTE (INPUT, (g_print("Note: Driver did not provide device specific default context info despite claiming to support version 1.1\n")));
 #endif
 	}
 
       if (!defcontext_done)
 	(*p_WTInfoA) (WTI_DEFSYSCTX, 0, &lc);
 #if DEBUG_WINTAB
       GDK_NOTE (INPUT, (g_print("Default context:\n"), print_lc(&lc)));
 #endif
       lc.lcOptions |= CXO_MESSAGES;
       lc.lcStatus = 0;
       lc.lcMsgBase = WT_DEFBASE;
       lc.lcPktRate = 0;
       lc.lcPktData = PACKETDATA;
       lc.lcPktMode = PACKETMODE;
       lc.lcMoveMask = PACKETDATA;
       lc.lcBtnUpMask = lc.lcBtnDnMask = ~0;
       lc.lcOutOrgX = axis_x.axMin;
       lc.lcOutOrgY = axis_y.axMin;
       lc.lcOutExtX = axis_x.axMax - axis_x.axMin;
       lc.lcOutExtY = axis_y.axMax - axis_y.axMin;
       lc.lcOutExtY = -lc.lcOutExtY; /* We want Y growing downward */
 #if DEBUG_WINTAB
       GDK_NOTE (INPUT, (g_print("context for device %d:\n", devix),
 			print_lc(&lc)));
 #endif
       hctx = g_new (HCTX, 1);
       if ((*hctx = (*p_WTOpenA) (GDK_WINDOW_HWND (wintab_window), &lc, TRUE)) == NULL)
 	{
 	  g_warning ("gdk_input_wintab_init: WTOpen failed");
 	  return;
 	}
       GDK_NOTE (INPUT, g_print ("opened Wintab device %d %p\n",
 				devix, *hctx));
       
       wintab_contexts = g_list_append (wintab_contexts, hctx);
 #if 0
       (*p_WTEnable) (*hctx, TRUE);
 #endif
       (*p_WTOverlap) (*hctx, TRUE);
 
 #if DEBUG_WINTAB
       GDK_NOTE (INPUT, (g_print("context for device %d after WTOpen:\n", devix),
 			print_lc(&lc)));
 #endif
       /* Increase packet queue size to reduce the risk of lost packets.
        * According to the specs, if the function fails we must try again
        * with a smaller queue size.
        */
       GDK_NOTE (INPUT, g_print("Attempting to increase queue size\n"));
       for (i = 32; i >= 1; i >>= 1)
 	{
 	  if ((*p_WTQueueSizeSet) (*hctx, i))
 	    {
 	      GDK_NOTE (INPUT, g_print("Queue size set to %d\n", i));
 	      break;
 	    }
 	}
       if (!i)
 	GDK_NOTE (INPUT, g_print("Whoops, no queue size could be set\n"));
       for (cursorix = firstcsr; cursorix < firstcsr + ncsrtypes; cursorix++)
 	{
 #ifdef DEBUG_WINTAB
 	  GDK_NOTE (INPUT, (g_print("Cursor %d:\n", cursorix), print_cursor (cursorix)));
 #endif
 	  active = FALSE;
 	  (*p_WTInfoA) (WTI_CURSORS + cursorix, CSR_ACTIVE, &active);
 	  if (!active)
 	    continue;
 
 	  /* Wacom tablets seem to report cursors corresponding to
 	   * nonexistent pens or pucks. At least my ArtPad II reports
 	   * six cursors: a puck, pressure stylus and eraser stylus,
 	   * and then the same three again. I only have a
 	   * pressure-sensitive pen. The puck instances, and the
 	   * second instances of the styluses report physid zero. So
 	   * at least for Wacom, skip cursors with physid zero.
 	   */
 	  (*p_WTInfoA) (WTI_CURSORS + cursorix, CSR_PHYSID, &physid);
 	  if (wcscmp (devname, L"WACOM Tablet") == 0 && physid == 0)
 	    continue;
 
 	  gdkdev = g_object_new (GDK_TYPE_DEVICE, NULL);
 	  (*p_WTInfoW) (WTI_CURSORS + cursorix, CSR_NAME, csrname);
 	  csrname_utf8 = g_utf16_to_utf8 (csrname, -1, NULL, NULL, NULL);
 	  gdkdev->info.name = g_strconcat (devname_utf8, " ", csrname_utf8, NULL);
 	  g_free (csrname_utf8);
 	  gdkdev->info.source = GDK_SOURCE_PEN;
 	  gdkdev->info.mode = GDK_MODE_SCREEN;
 	  gdkdev->info.has_cursor = TRUE;
 	  gdkdev->hctx = *hctx;
 	  gdkdev->cursor = cursorix;
 	  (*p_WTInfoA) (WTI_CURSORS + cursorix, CSR_PKTDATA, &gdkdev->pktdata);
 	  gdkdev->info.num_axes = 0;
 	  if (gdkdev->pktdata & PK_X)
 	    gdkdev->info.num_axes++;
 	  if (gdkdev->pktdata & PK_Y)
 	    gdkdev->info.num_axes++;
 	  if (gdkdev->pktdata & PK_NORMAL_PRESSURE)
 	    gdkdev->info.num_axes++;
 	  /* The wintab driver for the Wacom ArtPad II reports
 	   * PK_ORIENTATION in CSR_PKTDATA, but the tablet doesn't
 	   * actually sense tilt. Catch this by noticing that the
 	   * orientation axis's azimuth resolution is zero.
 	   */
 	  if ((gdkdev->pktdata & PK_ORIENTATION)
 	      && axis_or[0].axResolution == 0)
 	    gdkdev->pktdata &= ~PK_ORIENTATION;
 	  
 	  if (gdkdev->pktdata & PK_ORIENTATION)
 	    gdkdev->info.num_axes += 2; /* x and y tilt */
 
 	  gdkdev->info.axes = g_new (GdkDeviceAxis, gdkdev->info.num_axes);
 	  gdkdev->axes = g_new (GdkAxisInfo, gdkdev->info.num_axes);
 	  gdkdev->last_axis_data = g_new (gint, gdkdev->info.num_axes);
 	  
 	  k = 0;
 	  if (gdkdev->pktdata & PK_X)
 	    {
 	      gdkdev->axes[k].resolution = axis_x.axResolution / 65535.;
 	      gdkdev->axes[k].min_value = axis_x.axMin;
 	      gdkdev->axes[k].max_value = axis_x.axMax;
 	      gdkdev->info.axes[k].use = GDK_AXIS_X;
 	      gdkdev->info.axes[k].min = axis_x.axMin;
 	      gdkdev->info.axes[k].max = axis_x.axMax;
 	      k++;
 	    }
 	  if (gdkdev->pktdata & PK_Y)
 	    {
 	      gdkdev->axes[k].resolution = axis_y.axResolution / 65535.;
 	      gdkdev->axes[k].min_value = axis_y.axMin;
 	      gdkdev->axes[k].max_value = axis_y.axMax;
 	      gdkdev->info.axes[k].use = GDK_AXIS_Y;
 	      gdkdev->info.axes[k].min = axis_y.axMin;
 	      gdkdev->info.axes[k].max = axis_y.axMax;
 	      k++;
 	    }
 	  if (gdkdev->pktdata & PK_NORMAL_PRESSURE)
 	    {
 	      gdkdev->axes[k].resolution = axis_npressure.axResolution / 65535.;
 	      gdkdev->axes[k].min_value = axis_npressure.axMin;
 	      gdkdev->axes[k].max_value = axis_npressure.axMax;
 	      gdkdev->info.axes[k].use = GDK_AXIS_PRESSURE;
 	      /* GIMP seems to expect values in the range 0-1 */
 	      gdkdev->info.axes[k].min = 0.0; /*axis_npressure.axMin;*/
 	      gdkdev->info.axes[k].max = 1.0; /*axis_npressure.axMax;*/
 	      k++;
 	    }
 	  if (gdkdev->pktdata & PK_ORIENTATION)
 	    {
 	      GdkAxisUse axis;
 	      
 	      gdkdev->orientation_axes[0] = axis_or[0];
 	      gdkdev->orientation_axes[1] = axis_or[1];
 	      for (axis = GDK_AXIS_XTILT; axis <= GDK_AXIS_YTILT; axis++)
 		{
 		  /* Wintab gives us aximuth and altitude, which
 		   * we convert to x and y tilt in the -1000..1000 range
 		   */
 		  gdkdev->axes[k].resolution = 1000;
 		  gdkdev->axes[k].min_value = -1000;
 		  gdkdev->axes[k].max_value = 1000;
 		  gdkdev->info.axes[k].use = axis;
 		  gdkdev->info.axes[k].min = -1000;
 		  gdkdev->info.axes[k].max = 1000;
 		  k++;
 		}
 	    }
 	  gdkdev->info.num_keys = 0;
 	  gdkdev->info.keys = NULL;
 	  GDK_NOTE (INPUT, g_print ("device: (%d) %s axes: %d\n",
 				    cursorix,
 				    gdkdev->info.name,
 				    gdkdev->info.num_axes));
 	  for (i = 0; i < gdkdev->info.num_axes; i++)
 	    GDK_NOTE (INPUT, g_print ("... axis %d: %d--%d@%d\n",
 				      i,
 				      gdkdev->axes[i].min_value, 
 				      gdkdev->axes[i].max_value, 
 				      gdkdev->axes[i].resolution));
 	  _gdk_input_devices = g_list_append (_gdk_input_devices,
 					      gdkdev);
 	}
       g_free (devname_utf8);
     }
 }
 
