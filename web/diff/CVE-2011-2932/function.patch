commit bfc432574d0b141fd7fe759edfe9b6771dd306bd
Author: Aaron Patterson <aaron.patterson@gmail.com>
Date:   Tue Aug 16 15:18:53 2011 -0700

    properly escape html to avoid invalid utf8 causing XSS attacks

diff --git a/activesupport/lib/active_support/core_ext/string/output_safety.rb b/activesupport/lib/active_support/core_ext/string/output_safety.rb
index 6d6c491..f111c8e 100644
--- a/activesupport/lib/active_support/core_ext/string/output_safety.rb
+++ b/activesupport/lib/active_support/core_ext/string/output_safety.rb
@@ -4,58 +4,58 @@ require 'active_support/core_ext/kernel/singleton_class'
 class ERB
   module Util
     HTML_ESCAPE = { '&' => '&amp;',  '>' => '&gt;',   '<' => '&lt;', '"' => '&quot;' }
     JSON_ESCAPE = { '&' => '\u0026', '>' => '\u003E', '<' => '\u003C' }
 
     # A utility method for escaping HTML tag characters.
     # This method is also aliased as <tt>h</tt>.
     #
     # In your ERB templates, use this method to escape any unsafe content. For example:
     #   <%=h @person.name %>
     #
     # ==== Example:
     #   puts html_escape("is a > 0 & a < 10?")
     #   # => is a &gt; 0 &amp; a &lt; 10?
     def html_escape(s)
       s = s.to_s
       if s.html_safe?
         s
       else
-        s.gsub(/[&"><]/) { |special| HTML_ESCAPE[special] }.html_safe
+        s.to_s.gsub(/&/, "&amp;").gsub(/\"/, "&quot;").gsub(/>/, "&gt;").gsub(/</, "&lt;").html_safe
       end
     end
 
     # Aliasing twice issues a warning "discarding old...". Remove first to avoid it.
     remove_method(:h)
     alias h html_escape
 
     module_function :h
 
     singleton_class.send(:remove_method, :html_escape)
     module_function :html_escape
 
     # A utility method for escaping HTML entities in JSON strings
     # using \uXXXX JavaScript escape sequences for string literals:
     #
     #   json_escape("is a > 0 & a < 10?")
     #   # => is a \u003E 0 \u0026 a \u003C 10?
     #
     # Note that after this operation is performed the output is not
     # valid JSON. In particular double quotes are removed:
     #
     #   json_escape('{"name":"john","created_at":"2010-04-28T01:39:31Z","id":1}')
     #   # => {name:john,created_at:2010-04-28T01:39:31Z,id:1}
     #
     # This method is also aliased as +j+, and available as a helper
     # in Rails templates:
     #
     #   <%=j @person.to_json %>
     #
     def json_escape(s)
       result = s.to_s.gsub(/[&"><]/) { |special| JSON_ESCAPE[special] }
       s.html_safe? ? result.html_safe : result
     end
 
     alias j json_escape
     module_function :j
     module_function :json_escape
   end
diff --git a/activesupport/test/core_ext/string_ext_test.rb b/activesupport/test/core_ext/string_ext_test.rb
index a4bba05..81a284d 100644
--- a/activesupport/test/core_ext/string_ext_test.rb
+++ b/activesupport/test/core_ext/string_ext_test.rb
@@ -7,281 +7,288 @@ require 'active_support/inflector'
 require 'active_support/core_ext/string'
 require 'active_support/time'
 require 'active_support/core_ext/string/strip'
+require 'active_support/core_ext/string/output_safety'
 
 class StringInflectionsTest < Test::Unit::TestCase
   include InflectorTestCases
 
+  def test_erb_escape
+    string = [192, 60].pack('CC')
+    expected = 192.chr + "&lt;"
+    assert_equal expected, ERB::Util.html_escape(string)
+  end
+
   def test_strip_heredoc_on_an_empty_string
     assert_equal '', ''.strip_heredoc
   end
 
   def test_strip_heredoc_on_a_string_with_no_lines
     assert_equal 'x', 'x'.strip_heredoc
     assert_equal 'x', '    x'.strip_heredoc
   end
 
   def test_strip_heredoc_on_a_heredoc_with_no_margin
     assert_equal "foo\nbar", "foo\nbar".strip_heredoc
     assert_equal "foo\n  bar", "foo\n  bar".strip_heredoc
   end
 
   def test_strip_heredoc_on_a_regular_indented_heredoc
     assert_equal "foo\n  bar\nbaz\n", <<-EOS.strip_heredoc
       foo
         bar
       baz
     EOS
   end
 
   def test_strip_heredoc_on_a_regular_indented_heredoc_with_blank_lines
     assert_equal "foo\n  bar\n\nbaz\n", <<-EOS.strip_heredoc
       foo
         bar
 
       baz
     EOS
   end
 
   def test_pluralize
     SingularToPlural.each do |singular, plural|
       assert_equal(plural, singular.pluralize)
     end
 
     assert_equal("plurals", "plurals".pluralize)
   end
 
   def test_singularize
     SingularToPlural.each do |singular, plural|
       assert_equal(singular, plural.singularize)
     end
   end
 
   def test_titleize
     MixtureToTitleCase.each do |before, titleized|
       assert_equal(titleized, before.titleize)
     end
   end
 
   def test_camelize
     CamelToUnderscore.each do |camel, underscore|
       assert_equal(camel, underscore.camelize)
     end
   end
 
   def test_camelize_lower
     assert_equal('capital', 'Capital'.camelize(:lower))
   end
 
   def test_underscore
     CamelToUnderscore.each do |camel, underscore|
       assert_equal(underscore, camel.underscore)
     end
 
     assert_equal "html_tidy", "HTMLTidy".underscore
     assert_equal "html_tidy_generator", "HTMLTidyGenerator".underscore
   end
 
   def test_underscore_to_lower_camel
     UnderscoreToLowerCamel.each do |underscored, lower_camel|
       assert_equal(lower_camel, underscored.camelize(:lower))
     end
   end
 
   def test_demodulize
     assert_equal "Account", "MyApplication::Billing::Account".demodulize
   end
 
   def test_foreign_key
     ClassNameToForeignKeyWithUnderscore.each do |klass, foreign_key|
       assert_equal(foreign_key, klass.foreign_key)
     end
 
     ClassNameToForeignKeyWithoutUnderscore.each do |klass, foreign_key|
       assert_equal(foreign_key, klass.foreign_key(false))
     end
   end
 
   def test_tableize
     ClassNameToTableName.each do |class_name, table_name|
       assert_equal(table_name, class_name.tableize)
     end
   end
 
   def test_classify
     ClassNameToTableName.each do |class_name, table_name|
       assert_equal(class_name, table_name.classify)
     end
   end
 
   def test_string_parameterized_normal
     StringToParameterized.each do |normal, slugged|
       assert_equal(normal.parameterize, slugged)
     end
   end
 
   def test_string_parameterized_no_separator
     StringToParameterizeWithNoSeparator.each do |normal, slugged|
       assert_equal(normal.parameterize(''), slugged)
     end
   end
 
   def test_string_parameterized_underscore
     StringToParameterizeWithUnderscore.each do |normal, slugged|
       assert_equal(normal.parameterize('_'), slugged)
     end
   end
 
   def test_humanize
     UnderscoreToHuman.each do |underscore, human|
       assert_equal(human, underscore.humanize)
     end
   end
 
   def test_ord
     assert_equal 97, 'a'.ord
     assert_equal 97, 'abc'.ord
   end
 
   if RUBY_VERSION < '1.9'
     def test_getbyte
       assert_equal 97, 'a'.getbyte(0)
       assert_equal 99, 'abc'.getbyte(2)
       assert_nil   'abc'.getbyte(3)
     end
   end
 
   def test_string_to_time
     assert_equal Time.utc(2005, 2, 27, 23, 50), "2005-02-27 23:50".to_time
     assert_equal Time.local(2005, 2, 27, 23, 50), "2005-02-27 23:50".to_time(:local)
     assert_equal Time.utc(2005, 2, 27, 23, 50, 19, 275038), "2005-02-27T23:50:19.275038".to_time
     assert_equal Time.local(2005, 2, 27, 23, 50, 19, 275038), "2005-02-27T23:50:19.275038".to_time(:local)
     assert_equal DateTime.civil(2039, 2, 27, 23, 50), "2039-02-27 23:50".to_time
     assert_equal Time.local_time(2039, 2, 27, 23, 50), "2039-02-27 23:50".to_time(:local)
     assert_equal Time.utc(2011, 2, 27, 23, 50), "2011-02-27 22:50 -0100".to_time
     assert_nil "".to_time
   end
 
   def test_string_to_datetime
     assert_equal DateTime.civil(2039, 2, 27, 23, 50), "2039-02-27 23:50".to_datetime
     assert_equal 0, "2039-02-27 23:50".to_datetime.offset # use UTC offset
     assert_equal ::Date::ITALY, "2039-02-27 23:50".to_datetime.start # use Ruby's default start value
     assert_equal DateTime.civil(2039, 2, 27, 23, 50, 19 + Rational(275038, 1000000), "-04:00"), "2039-02-27T23:50:19.275038-04:00".to_datetime
     assert_nil "".to_datetime
   end
 
   def test_string_to_date
     assert_equal Date.new(2005, 2, 27), "2005-02-27".to_date
     assert_nil "".to_date
   end
 
   def test_access
     s = "hello"
     assert_equal "h", s.at(0)
 
     assert_equal "llo", s.from(2)
     assert_equal "hel", s.to(2)
 
     assert_equal "h", s.first
     assert_equal "he", s.first(2)
     assert_equal "", s.first(0)
 
     assert_equal "o", s.last
     assert_equal "llo", s.last(3)
     assert_equal "hello", s.last(10)
     assert_equal "", s.last(0)
 
     assert_equal 'x', 'x'.first
     assert_equal 'x', 'x'.first(4)
 
     assert_equal 'x', 'x'.last
     assert_equal 'x', 'x'.last(4)
   end
 
   def test_access_returns_a_real_string
     hash = {}
     hash["h"] = true
     hash["hello123".at(0)] = true
     assert_equal %w(h), hash.keys
 
     hash = {}
     hash["llo"] = true
     hash["hello".from(2)] = true
     assert_equal %w(llo), hash.keys
 
     hash = {}
     hash["hel"] = true
     hash["hello".to(2)] = true
     assert_equal %w(hel), hash.keys
 
     hash = {}
     hash["hello"] = true
     hash["123hello".last(5)] = true
     assert_equal %w(hello), hash.keys
 
     hash = {}
     hash["hello"] = true
     hash["hello123".first(5)] = true
     assert_equal %w(hello), hash.keys
   end
 
   def test_starts_ends_with_alias
     s = "hello"
     assert s.starts_with?('h')
     assert s.starts_with?('hel')
     assert !s.starts_with?('el')
 
     assert s.ends_with?('o')
     assert s.ends_with?('lo')
     assert !s.ends_with?('el')
   end
 
   def test_string_squish
     original = %{ A string with tabs(\t\t), newlines(\n\n), and
                   many spaces(  ). }
 
     expected = "A string with tabs( ), newlines( ), and many spaces( )."
 
     # Make sure squish returns what we expect:
     assert_equal original.squish,  expected
     # But doesn't modify the original string:
     assert_not_equal original, expected
 
     # Make sure squish! returns what we expect:
     assert_equal original.squish!, expected
     # And changes the original string:
     assert_equal original, expected
   end
 
   def test_string_inquiry
     assert "production".inquiry.production?
     assert !"production".inquiry.development?
   end
 
   def test_truncate
     assert_equal "Hello World!", "Hello World!".truncate(12)
     assert_equal "Hello Wor...", "Hello World!!".truncate(12)
   end
 
   def test_truncate_with_omission_and_seperator
     assert_equal "Hello[...]", "Hello World!".truncate(10, :omission => "[...]")
     assert_equal "Hello[...]", "Hello Big World!".truncate(13, :omission => "[...]", :separator => ' ')
     assert_equal "Hello Big[...]", "Hello Big World!".truncate(14, :omission => "[...]", :separator => ' ')
     assert_equal "Hello Big[...]", "Hello Big World!".truncate(15, :omission => "[...]", :separator => ' ')
   end
 
   if RUBY_VERSION < '1.9.0'
     def test_truncate_multibyte
       with_kcode 'none' do
         assert_equal "\354\225\210\353\205\225\355...", "\354\225\210\353\205\225\355\225\230\354\204\270\354\232\224".truncate(10)
       end
       with_kcode 'u' do
         assert_equal "\354\225\204\353\246\254\353\236\221 \354\225\204\353\246\254 ...",
           "\354\225\204\353\246\254\353\236\221 \354\225\204\353\246\254 \354\225\204\353\235\274\353\246\254\354\230\244".truncate(10)
       end
     end
   else
     def test_truncate_multibyte
       assert_equal "\354\225\204\353\246\254\353\236\221 \354\225\204\353\246\254 ...".force_encoding('UTF-8'),
         "\354\225\204\353\246\254\353\236\221 \354\225\204\353\246\254 \354\225\204\353\235\274\353\246\254\354\230\244".force_encoding('UTF-8').truncate(10)
     end
   end
