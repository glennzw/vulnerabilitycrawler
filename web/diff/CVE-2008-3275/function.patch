commit d70b67c8bc72ee23b55381bd6a884f4796692f77
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed Jul 2 21:30:15 2008 +0200

    [patch] vfs: fix lookup on deleted directory
    
    Lookup can install a child dentry for a deleted directory.  This keeps
    the directory dentry alive, and the inode pinned in the cache and on
    disk, even after all external references have gone away.
    
    This isn't a big problem normally, since memory pressure or umount
    will clear out the directory dentry and its children, releasing the
    inode.  But for UBIFS this causes problems because its orphan area can
    overflow.
    
    Fix this by returning ENOENT for all lookups on a S_DEAD directory
    before creating a child dentry.
    
    Thanks to Zoltan Sogor for noticing this while testing UBIFS, and
    Artem for the excellent analysis of the problem and testing.
    
    Reported-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Tested-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/namei.c b/fs/namei.c
index 01e67dd..3b26a24 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -500,48 +500,56 @@ ok:
 static struct dentry * real_lookup(struct dentry * parent, struct qstr * name, struct nameidata *nd)
 {
 	struct dentry * result;
 	struct inode *dir = parent->d_inode;
 
 	mutex_lock(&dir->i_mutex);
 	/*
 	 * First re-do the cached lookup just in case it was created
 	 * while we waited for the directory semaphore..
 	 *
 	 * FIXME! This could use version numbering or similar to
 	 * avoid unnecessary cache lookups.
 	 *
 	 * The "dcache_lock" is purely to protect the RCU list walker
 	 * from concurrent renames at this point (we mustn't get false
 	 * negatives from the RCU list walk here, unlike the optimistic
 	 * fast walk).
 	 *
 	 * so doing d_lookup() (with seqlock), instead of lockfree __d_lookup
 	 */
 	result = d_lookup(parent, name);
 	if (!result) {
-		struct dentry * dentry = d_alloc(parent, name);
+		struct dentry *dentry;
+
+		/* Don't create child dentry for a dead directory. */
+		result = ERR_PTR(-ENOENT);
+		if (IS_DEADDIR(dir))
+			goto out_unlock;
+
+		dentry = d_alloc(parent, name);
 		result = ERR_PTR(-ENOMEM);
 		if (dentry) {
 			result = dir->i_op->lookup(dir, dentry, nd);
 			if (result)
 				dput(dentry);
 			else
 				result = dentry;
 		}
+out_unlock:
 		mutex_unlock(&dir->i_mutex);
 		return result;
 	}
 
 	/*
 	 * Uhhuh! Nasty case: the cache was re-populated while
 	 * we waited on the semaphore. Need to revalidate.
 	 */
 	mutex_unlock(&dir->i_mutex);
 	if (result->d_op && result->d_op->d_revalidate) {
 		result = do_revalidate(result, nd);
 		if (!result)
 			result = ERR_PTR(-ENOENT);
 	}
 	return result;
 }
 
@@ -1298,32 +1306,39 @@ int __user_path_lookup_open(const char __user *name, unsigned int lookup_flags,
 static struct dentry *__lookup_hash(struct qstr *name,
 		struct dentry *base, struct nameidata *nd)
 {
 	struct dentry *dentry;
 	struct inode *inode;
 	int err;
 
 	inode = base->d_inode;
 
 	/*
 	 * See if the low-level filesystem might want
 	 * to use its own hash..
 	 */
 	if (base->d_op && base->d_op->d_hash) {
 		err = base->d_op->d_hash(base, name);
 		dentry = ERR_PTR(err);
 		if (err < 0)
 			goto out;
 	}
 
 	dentry = cached_lookup(base, name, nd);
 	if (!dentry) {
-		struct dentry *new = d_alloc(base, name);
+		struct dentry *new;
+
+		/* Don't create child dentry for a dead directory. */
+		dentry = ERR_PTR(-ENOENT);
+		if (IS_DEADDIR(inode))
+			goto out;
+
+		new = d_alloc(base, name);
 		dentry = ERR_PTR(-ENOMEM);
 		if (!new)
 			goto out;
 		dentry = inode->i_op->lookup(inode, new, nd);
 		if (!dentry)
 			dentry = new;
 		else
 			dput(new);
 	}
