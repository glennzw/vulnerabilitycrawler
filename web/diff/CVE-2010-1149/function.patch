commit 0fcc7cb3b66f23fac53ae08647aa0007a2bd56c4
Author: Martin Pitt <martin.pitt@ubuntu.com>
Date:   Wed Apr 7 08:12:42 2010 +0200

    Bug 27494 — publicly exports dm key information
    
    Change udisks-dm-export to only export UDISKS_DM_TARGETS_PARAMS for "linear"
    types. It is the only one we care about for now and know how to interpret.
    "crypto" types have information about the encryption key in the target
    parameters, which we must not leak.
    
    Also add appropriate comments to the two places which currently evaluate
    UDISKS_DM_TARGETS_PARAMS.

diff --git a/src/device.c b/src/device.c
index bac971d..12cab7c 100644
--- a/src/device.c
+++ b/src/device.c
@@ -3320,63 +3320,65 @@ static gboolean
 update_info_partition_on_linux_dmmp (Device *device)
 {
   const gchar *dm_name;
   const gchar* const *targets_type;
   const gchar* const *targets_params;
   gchar *params;
   gint linear_slave_major;
   gint linear_slave_minor;
   guint64 offset_sectors;
   Device *linear_slave;
   gchar *s;
 
   params = NULL;
 
   dm_name = g_udev_device_get_property (device->priv->d, "DM_NAME");
   if (dm_name == NULL)
     goto out;
 
   targets_type = g_udev_device_get_property_as_strv (device->priv->d, "UDISKS_DM_TARGETS_TYPE");
+  /* If we ever need this for other types than "linear", remember to update
+     udisks-dm-export.c as well. */
   if (targets_type == NULL || g_strcmp0 (targets_type[0], "linear") != 0)
     goto out;
 
   targets_params = g_udev_device_get_property_as_strv (device->priv->d, "UDISKS_DM_TARGETS_PARAMS");
   if (targets_params == NULL)
     goto out;
   params = decode_udev_encoded_string (targets_params[0]);
 
   if (sscanf (params,
               "%d:%d %" G_GUINT64_FORMAT,
               &linear_slave_major,
               &linear_slave_minor,
               &offset_sectors) != 3)
     goto out;
 
   linear_slave = daemon_local_find_by_dev (device->priv->daemon,
                                               makedev (linear_slave_major, linear_slave_minor));
   if (linear_slave == NULL)
     goto out;
   if (!linear_slave->priv->device_is_linux_dmmp)
     goto out;
 
   /* The Partition* properties has been set as part of
    * update_info_partition() by reading UDISKS_PARTITION_*
    * properties.. so here we bascially just update the presentation
    * device file name and and whether the device is a drive.
    */
 
   s = g_strdup_printf ("/dev/mapper/%s", dm_name);
   device_set_device_file_presentation (device, s);
   g_free (s);
 
   device_set_device_is_drive (device, FALSE);
 
  out:
   g_free (params);
   return TRUE;
 }
 #endif
 
 /* ---------------------------------------------------------------------------------------------------- */
 
 #ifdef HAVE_DMMP
 /* update device_is_linux_dmmp_component and linux_dmmp_component_* properties */
diff --git a/src/probers/part-id.c b/src/probers/part-id.c
index b61ea07..306eb44 100644
--- a/src/probers/part-id.c
+++ b/src/probers/part-id.c
@@ -177,166 +177,168 @@ static gchar *
 get_part_table_device_file (struct udev_device *given_device,
                             const gchar        *given_device_file,
                             gchar             **out_partition_table_syspath,
                             guint64            *out_offset,
                             guint64            *out_alignment_offset,
                             guint              *out_partition_number)
 {
   gchar *ret;
   guint64 offset;
   guint partition_number;
   const gchar *devpath;
   gchar *partition_table_syspath;
   guint64 alignment_offset;
 
   devpath = NULL;
   offset = 0;
   ret = NULL;
   partition_table_syspath = NULL;
   alignment_offset = 0;
 
   devpath = udev_device_get_syspath (given_device);
   if (devpath == NULL)
     goto out;
 
   partition_number = sysfs_get_int (devpath, "partition");
 
   /* find device file for partition table device */
   if (partition_number > 0)
     {
       struct udev_device *device;
       guint n;
 
       /* partition */
       partition_table_syspath = g_strdup (devpath);
       for (n = strlen (partition_table_syspath) - 1; partition_table_syspath[n] != '/'; n--)
         partition_table_syspath[n] = '\0';
       partition_table_syspath[n] = '\0';
 
       device = udev_device_new_from_syspath (udev_device_get_udev (given_device), partition_table_syspath);
       if (device == NULL)
         {
           g_printerr ("Error getting udev device for syspath %s: %m\n", partition_table_syspath);
           goto out;
         }
       ret = g_strdup (udev_device_get_devnode (device));
       udev_device_unref (device);
       if (ret == NULL)
         {
           /* This Should Not Happen™, but was reported in a distribution upgrade
              scenario, so handle it gracefully */
           g_printerr ("Error getting devnode from udev device path %s: %m\n", partition_table_syspath);
           goto out;
         }
       offset = sysfs_get_uint64 (devpath, "start") * 512;
 
       alignment_offset = sysfs_get_uint64 (devpath, "alignment_offset");
     }
   else
     {
       const char *targets_type;
       const char *encoded_targets_params;
 
       targets_type = g_getenv ("UDISKS_DM_TARGETS_TYPE");
       if (targets_type == NULL)
         targets_type = udev_device_get_property_value (given_device, "UDISKS_DM_TARGETS_TYPE");
       encoded_targets_params = g_getenv ("UDISKS_DM_TARGETS_PARAMS");
       if (encoded_targets_params == NULL)
         encoded_targets_params = udev_device_get_property_value (given_device, "UDISKS_DM_TARGETS_PARAMS");
 
       //g_printerr ("targets_type=`%s'\n", targets_type);
       //g_printerr ("encoded_targets_params=`%s'\n", encoded_targets_params);
 
+      /* If we ever need this for other types than "linear", remember to update
+         udisks-dm-export.c as well. */
       if (g_strcmp0 (targets_type, "linear") == 0)
         {
           gint partition_slave_major;
           gint partition_slave_minor;
           guint64 offset_sectors;
           gchar *targets_params;
 
           targets_params = decode_udev_encoded_string (encoded_targets_params);
           if (targets_params == NULL || sscanf (targets_params,
                                                 "%d:%d\x20%" G_GUINT64_FORMAT,
                                                 &partition_slave_major,
                                                 &partition_slave_minor,
                                                 &offset_sectors) != 3)
             {
               g_printerr ("Error decoding UDISKS_DM_TARGETS_PARAMS=`%s'\n", targets_params);
             }
           else
             {
               struct udev_device *mp_device;
 
               mp_device = udev_device_new_from_devnum (udev_device_get_udev (given_device), 
                                                        'b', makedev (partition_slave_major,
                                                        partition_slave_minor));
               if (mp_device != NULL)
                 {
                   const char *dm_name;
                   gint n;
 
                   /* now figure out the partition number... we infer this from DM_NAME */
                   partition_number = 0;
                   dm_name = g_getenv ("DM_NAME");
                   if (dm_name == NULL)
                     dm_name = udev_device_get_property_value (given_device, "DM_NAME");
                   if (dm_name == NULL || strlen (dm_name) == 0)
                     {
                       g_printerr ("DM_NAME not available\n");
                       goto out;
                     }
                   for (n = strlen (dm_name) - 1; n >= 0; n--)
                     {
                       if (!isdigit (dm_name[n]))
                         break;
                     }
                   if (n < 0 || dm_name[n] != 'p')
                     {
                       g_printerr ("DM_NAME=`%s' is malformed (expected <name>p<number>)\n", dm_name);
                       goto out;
                     }
                   partition_number = atoi (dm_name + n + 1);
                   if (partition_number < 1)
                     {
                       g_printerr ("Error determining partition number from DM_NAME=`%s'\n", dm_name);
                       goto out;
                     }
 
                   ret = g_strdup (udev_device_get_devnode (mp_device));
                   offset = offset_sectors * 512;
 
                   partition_table_syspath = g_strdup (udev_device_get_syspath (mp_device));
 
                   udev_device_unref (mp_device);
                   g_free (targets_params);
 
                   /* TODO: set alignment_offset */
 
                   goto out;
                 }
             }
           g_free (targets_params);
         }
 
       /* not a kernel partition */
       partition_table_syspath = g_strdup (devpath);
       ret = g_strdup (given_device_file);
       partition_number = 0;
     }
 
  out:
   if (out_offset != NULL)
     *out_offset = offset;
   if (out_partition_number != NULL)
     *out_partition_number = partition_number;
   if (out_partition_table_syspath != NULL)
     *out_partition_table_syspath = partition_table_syspath;
   else
     g_free (partition_table_syspath);
   if (out_alignment_offset != NULL)
     *out_alignment_offset = alignment_offset;
 
   return ret;
 }
 
 /* ---------------------------------------------------------------------------------------------------- */
 
diff --git a/src/probers/udisks-dm-export.c b/src/probers/udisks-dm-export.c
index b950c32..8fff4f9 100644
--- a/src/probers/udisks-dm-export.c
+++ b/src/probers/udisks-dm-export.c
@@ -210,121 +210,124 @@ static int
 dm_export (int major, int minor)
 {
   gboolean ret;
   struct dm_task *dmt;
   void *next;
   uint64_t start, length;
   char *target_type;
   char *params;
   const char *name;
   struct dm_info info;
   GString *target_types_str;
   GString *start_str;
   GString *length_str;
   GString *params_str;
   gchar buf[4096];
 
   ret = FALSE;
   dmt = NULL;
 
   dmt = dm_task_create (DM_DEVICE_TABLE);
   if (dmt == NULL)
     {
       perror ("dm_task_create");
       goto out;
     }
 
   if (dm_task_set_major (dmt, major) == 0)
     {
       perror ("dm_task_set_major");
       goto out;
     }
 
   if (dm_task_set_minor (dmt, minor) == 0)
     {
       perror ("dm_task_set_minor");
       goto out;
     }
 
   if (dm_task_run (dmt) == 0)
     {
       perror ("dm_task_run");
       goto out;
     }
 
   if (dm_task_get_info (dmt, &info) == 0 || !info.exists)
     {
       perror ("dm_task_get_info");
       goto out;
     }
 
   name = dm_task_get_name (dmt);
   if (name == NULL)
     {
       perror ("dm_task_get_name");
       goto out;
     }
 
   if (!info.exists)
     {
       goto out;
     }
 
   if (info.target_count != -1)
     g_print ("UDISKS_DM_TARGETS_COUNT=%d\n", info.target_count);
 
   target_types_str = g_string_new (NULL);
   start_str = g_string_new (NULL);
   length_str = g_string_new (NULL);
   params_str = g_string_new (NULL);
 
   /* export all tables */
   next = NULL;
   do
     {
       next = dm_get_next_target (dmt, next, &start, &length, &target_type, &params);
       if (target_type != NULL)
         {
           g_string_append (target_types_str, target_type);
           g_string_append_printf (start_str, "%" G_GUINT64_FORMAT, start);
           g_string_append_printf (length_str, "%" G_GUINT64_FORMAT, length);
-          if (params != NULL && strlen (params) > 0)
+          /* Set target_params for known-safe and known-needed target types only. In particular,
+           * we must not export it for "crypto", since that would expose
+           * information about the key. */
+          if (g_strcmp0 (target_type, "linear") == 0 && params != NULL && strlen (params) > 0)
             {
               _udev_util_encode_string (params, buf, sizeof (buf));
               g_string_append (params_str, buf);
             }
         }
 
       if (next != NULL)
         {
           g_string_append_c (target_types_str, ' ');
           g_string_append_c (start_str, ' ');
           g_string_append_c (length_str, ' ');
           g_string_append_c (params_str, ' ');
         }
     }
   while (next != NULL);
 
   if (target_types_str->len > 0)
       g_print ("UDISKS_DM_TARGETS_TYPE=%s\n", target_types_str->str);
   if (start_str->len > 0)
       g_print ("UDISKS_DM_TARGETS_START=%s\n", start_str->str);
   if (length_str->len > 0)
       g_print ("UDISKS_DM_TARGETS_LENGTH=%s\n", length_str->str);
   if (params_str->len > 0)
       g_print ("UDISKS_DM_TARGETS_PARAMS=%s\n", params_str->str);
 
   g_string_free (target_types_str, TRUE);
   g_string_free (start_str, TRUE);
   g_string_free (length_str, TRUE);
   g_string_free (params_str, TRUE);
 
   ret = TRUE;
 
  out:
   if (dmt != NULL)
     dm_task_destroy(dmt);
   return ret;
 }
 
 /* ---------------------------------------------------------------------------------------------------- */
 
