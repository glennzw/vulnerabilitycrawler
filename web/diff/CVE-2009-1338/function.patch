commit d25141a818383b3c3b09f065698c544a7a0ec6e7
Author: Sukadev Bhattiprolu <sukadev@linux.vnet.ibm.com>
Date:   Wed Oct 29 14:01:11 2008 -0700

    'kill sig -1' must only apply to caller's namespace
    
    Currently "kill <sig> -1" kills processes in all namespaces and breaks the
    isolation of namespaces.  Earlier attempt to fix this was discussed at:
    
    	http://lkml.org/lkml/2008/7/23/148
    
    As suggested by Oleg Nesterov in that thread, use "task_pid_vnr() > 1"
    check since task_pid_vnr() returns 0 if process is outside the caller's
    namespace.
    
    Signed-off-by: Sukadev Bhattiprolu <sukadev@linux.vnet.ibm.com>
    Acked-by: Eric W. Biederman <ebiederm@xmission.com>
    Tested-by: Daniel Hokka Zakrisson <daniel@hozac.com>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/signal.c b/kernel/signal.c
index 105217d..4530fc6 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -1127,41 +1127,42 @@ EXPORT_SYMBOL_GPL(kill_pid_info_as_uid);
 static int kill_something_info(int sig, struct siginfo *info, pid_t pid)
 {
 	int ret;
 
 	if (pid > 0) {
 		rcu_read_lock();
 		ret = kill_pid_info(sig, info, find_vpid(pid));
 		rcu_read_unlock();
 		return ret;
 	}
 
 	read_lock(&tasklist_lock);
 	if (pid != -1) {
 		ret = __kill_pgrp_info(sig, info,
 				pid ? find_vpid(-pid) : task_pgrp(current));
 	} else {
 		int retval = 0, count = 0;
 		struct task_struct * p;
 
 		for_each_process(p) {
-			if (p->pid > 1 && !same_thread_group(p, current)) {
+			if (task_pid_vnr(p) > 1 &&
+					!same_thread_group(p, current)) {
 				int err = group_send_sig_info(sig, info, p);
 				++count;
 				if (err != -EPERM)
 					retval = err;
 			}
 		}
 		ret = count ? retval : -ESRCH;
 	}
 	read_unlock(&tasklist_lock);
 
 	return ret;
 }
 
 /*
  * These are for backward compatibility with the rest of the kernel source.
  */
 
 /*
  * The caller must ensure the task can't exit.
  */
