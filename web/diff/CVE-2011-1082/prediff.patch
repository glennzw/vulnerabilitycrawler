   epoll: prevent creating circular epoll structures
   
   In several places, an epoll fd can call another file's ->f_op->poll()
   method with ep->mtx held.  This is in general unsafe, because that other
   file could itself be an epoll fd that contains the original epoll fd.
   
   The code defends against this possibility in its own ->poll() method using
   ep_call_nested, but there are several other unsafe calls to ->poll
   elsewhere that can be made to deadlock.  For example, the following simple
   program causes the call in ep_insert recursively call the original fd's
   ->poll, leading to deadlock:
   
    #include <unistd.h>
    #include <sys/epoll.h>
   
    int main(void) {
        int e1, e2, p[2];
        struct epoll_event evt = {
            .events = EPOLLIN
        };
   
        e1 = epoll_create(1);
        e2 = epoll_create(2);
        pipe(p);
   
        epoll_ctl(e2, EPOLL_CTL_ADD, e1, &evt);
        epoll_ctl(e1, EPOLL_CTL_ADD, p[0], &evt);
        write(p[1], p, sizeof p);
        epoll_ctl(e1, EPOLL_CTL_ADD, e2, &evt);
   
        return 0;
    }
   
   On insertion, check whether the inserted file is itself a struct epoll,
   and if so, do a recursive walk to detect whether inserting this file would
   create a loop of epoll structures, which could lead to deadlock.
   
   [nelhage@ksplice.com: Use epmutex to serialize concurrent inserts]
   Signed-off-by: Davide Libenzi <davidel@xmailserver.org>
   Signed-off-by: Nelson Elhage <nelhage@ksplice.com>
   Reported-by: Nelson Elhage <nelhage@ksplice.com>
   Tested-by: Nelson Elhage <nelhage@ksplice.com>
   Cc: <stable@kernel.org>		[2.6.34+, possibly earlier]
   Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
   Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
 * cleanup path and it is also acquired by eventpoll_release_file()
 * if a file has been pushed inside an epoll set and it is then
 * close()d without a previous call toepoll_ctl(EPOLL_CTL_DEL).
 * It is possible to drop the "ep->mtx" and to use the global
 * mutex "epmutex" (together with "ep->lock") to have it working,
 * but having "ep->mtx" will make the interface more scalable.
 */
static DEFINE_MUTEX(epmutex);

/* Used for safe wake up implementation */
static struct nested_calls poll_safewake_ncalls;

	return res;
}

/*
 * Open an eventpoll file descriptor.
 */
		struct epoll_event __user *, event)
{
	int error;
	struct file *file, *tfile;
	struct eventpoll *ep;
	struct epitem *epi;
	 */
	ep = file->private_data;

	mutex_lock(&ep->mtx);

	/*
	mutex_unlock(&ep->mtx);

error_tgt_fput:
	fput(tfile);
error_fput:
	fput(file);
		EP_ITEM_COST;
	BUG_ON(max_user_watches < 0);

	/* Initialize the structure used to perform safe poll wait head wake ups */
	ep_nested_calls_init(&poll_safewake_ncalls);

