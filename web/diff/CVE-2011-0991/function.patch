commit 8eb1189099e02372fd45ca1c67230eccf1edddc0
Author: Rodrigo Kumpera <kumpera@gmail.com>
Date:   Tue Feb 1 16:15:59 2011 +0100

    Implement a reference queue API.
    
    	* gc.c: A reference queue allows one to queue
    	callbcks for when objects are collected.
    	It allows for safe cleanup of objects that can
    	only be done when it is effectively collected.
    	The major difference with regular finalization
    	is that the collector makes sure the object
    	was collected - and can't be resurrected.
    
    	* gc-internal.h: Export entrypoints for the
    	new API.

diff --git a/mono/metadata/gc-internal.h b/mono/metadata/gc-internal.h
index 16d31f0..fb2af22 100644
--- a/mono/metadata/gc-internal.h
+++ b/mono/metadata/gc-internal.h
@@ -335,5 +335,28 @@ gboolean mono_gc_precise_stack_mark_enabled (void) MONO_INTERNAL;
 
 FILE *mono_gc_get_logfile (void) MONO_INTERNAL;
 
+typedef void (*mono_reference_queue_callback) (void *user_data);
+
+typedef struct _MonoReferenceQueue MonoReferenceQueue;
+typedef struct _RefQueueEntry RefQueueEntry;
+
+struct _RefQueueEntry {
+	void *dis_link;
+	void *user_data;
+	RefQueueEntry *next;
+};
+
+struct _MonoReferenceQueue {
+	RefQueueEntry *queue;
+	mono_reference_queue_callback callback;
+	MonoReferenceQueue *next;
+	gboolean should_be_deleted;
+};
+
+MonoReferenceQueue* mono_gc_reference_queue_new (mono_reference_queue_callback callback) MONO_INTERNAL;
+void mono_gc_reference_queue_free (MonoReferenceQueue *queue) MONO_INTERNAL;
+gboolean mono_gc_reference_queue_add (MonoReferenceQueue *queue, MonoObject *obj, void *user_data) MONO_INTERNAL;
+
+
 #endif /* __MONO_METADATA_GC_INTERNAL_H__ */
 
diff --git a/mono/metadata/gc.c b/mono/metadata/gc.c
index fd29cd9..2208a7a 100644
--- a/mono/metadata/gc.c
+++ b/mono/metadata/gc.c
@@ -54,6 +54,7 @@ static gboolean finalizing_root_domain = FALSE;
 #define mono_finalizer_lock() EnterCriticalSection (&finalizer_mutex)
 #define mono_finalizer_unlock() LeaveCriticalSection (&finalizer_mutex)
 static CRITICAL_SECTION finalizer_mutex;
+static CRITICAL_SECTION reference_queue_mutex;
 
 static GSList *domains_to_finalize= NULL;
 static MonoMList *threads_to_finalize = NULL;
@@ -64,6 +65,7 @@ static void object_register_finalizer (MonoObject *obj, void (*callback)(void *,
 
 static void mono_gchandle_set_target (guint32 gchandle, MonoObject *obj);
 
+static void reference_queue_proccess_all (void);
 #ifndef HAVE_NULL_GC
 static HANDLE pending_done_event;
 static HANDLE shutdown_event;
@@ -1046,47 +1048,50 @@ static guint32
 finalizer_thread (gpointer unused)
 {
 	while (!finished) {
 		/* Wait to be notified that there's at least one
 		 * finaliser to run
 		 */
 
 		g_assert (mono_domain_get () == mono_get_root_domain ());
 
 #ifdef MONO_HAS_SEMAPHORES
 		MONO_SEM_WAIT (&finalizer_sem);
 #else
 		/* Use alertable=FALSE since we will be asked to exit using the event too */
 		WaitForSingleObjectEx (finalizer_event, INFINITE, FALSE);
 #endif
 
 		mono_console_handle_async_ops ();
 
 #ifndef DISABLE_ATTACH
 		mono_attach_maybe_start ();
 #endif
 
+		reference_queue_proccess_all ();
+
 		if (domains_to_finalize) {
 			mono_finalizer_lock ();
 			if (domains_to_finalize) {
 				DomainFinalizationReq *req = domains_to_finalize->data;
 				domains_to_finalize = g_slist_remove (domains_to_finalize, req);
 				mono_finalizer_unlock ();
 
 				finalize_domain_objects (req);
 			} else {
 				mono_finalizer_unlock ();
 			}
 		}				
 
 		/* If finished == TRUE, mono_gc_cleanup has been called (from mono_runtime_cleanup),
 		 * before the domain is unloaded.
 		 */
 		mono_gc_invoke_finalizers ();
 
+
 		SetEvent (pending_done_event);
 	}
 
 	SetEvent (shutdown_event);
 	return 0;
 }
 
@@ -1094,31 +1099,32 @@ void
 mono_gc_init (void)
 {
 	InitializeCriticalSection (&handle_section);
 	InitializeCriticalSection (&allocator_section);
 
 	InitializeCriticalSection (&finalizer_mutex);
+	InitializeCriticalSection (&reference_queue_mutex);
 
 	MONO_GC_REGISTER_ROOT_FIXED (gc_handles [HANDLE_NORMAL].entries);
 	MONO_GC_REGISTER_ROOT_FIXED (gc_handles [HANDLE_PINNED].entries);
 
 	mono_gc_base_init ();
 
 	if (mono_gc_is_disabled ()) {
 		gc_disabled = TRUE;
 		return;
 	}
 	
 	finalizer_event = CreateEvent (NULL, FALSE, FALSE, NULL);
 	pending_done_event = CreateEvent (NULL, TRUE, FALSE, NULL);
 	shutdown_event = CreateEvent (NULL, TRUE, FALSE, NULL);
 	if (finalizer_event == NULL || pending_done_event == NULL || shutdown_event == NULL) {
 		g_assert_not_reached ();
 	}
 #ifdef MONO_HAS_SEMAPHORES
 	MONO_SEM_INIT (&finalizer_sem, 0);
 #endif
 
 	gc_thread = mono_thread_create_internal (mono_domain_get (), finalizer_thread, NULL, FALSE);
 	ves_icall_System_Threading_Thread_SetName_internal (gc_thread, mono_string_new (mono_domain_get (), "Finalizer"));
 }
 
@@ -1126,169 +1132,304 @@ void
 mono_gc_cleanup (void)
 {
 #ifdef DEBUG
 	g_message ("%s: cleaning up finalizer", __func__);
 #endif
 
 	if (!gc_disabled) {
 		ResetEvent (shutdown_event);
 		finished = TRUE;
 		if (mono_thread_internal_current () != gc_thread) {
 			mono_gc_finalize_notify ();
 			/* Finishing the finalizer thread, so wait a little bit... */
 			/* MS seems to wait for about 2 seconds */
 			if (WaitForSingleObjectEx (shutdown_event, 2000, FALSE) == WAIT_TIMEOUT) {
 				int ret;
 
 				/* Set a flag which the finalizer thread can check */
 				suspend_finalizers = TRUE;
 
 				/* Try to abort the thread, in the hope that it is running managed code */
 				mono_thread_internal_stop (gc_thread);
 
 				/* Wait for it to stop */
 				ret = WaitForSingleObjectEx (gc_thread->handle, 100, TRUE);
 
 				if (ret == WAIT_TIMEOUT) {
 					/* 
 					 * The finalizer thread refused to die. There is not much we 
 					 * can do here, since the runtime is shutting down so the 
 					 * state the finalizer thread depends on will vanish.
 					 */
 					g_warning ("Shutting down finalizer thread timed out.");
 				} else {
 					/*
 					 * FIXME: On unix, when the above wait returns, the thread 
 					 * might still be running io-layer code, or pthreads code.
 					 */
 					Sleep (100);
 				}
 
 			}
 		}
 		gc_thread = NULL;
 #ifdef HAVE_BOEHM_GC
 		GC_finalizer_notifier = NULL;
 #endif
 	}
 
 	DeleteCriticalSection (&handle_section);
 	DeleteCriticalSection (&allocator_section);
 	DeleteCriticalSection (&finalizer_mutex);
+	DeleteCriticalSection (&reference_queue_mutex);
 }
 
 #else
 
 /* Null GC dummy functions */
 void
 mono_gc_finalize_notify (void)
 {
 }
 
 void mono_gc_init (void)
 {
 	InitializeCriticalSection (&handle_section);
 }
 
 void mono_gc_cleanup (void)
 {
 }
 
 #endif
 
 gboolean
 mono_gc_is_finalizer_internal_thread (MonoInternalThread *thread)
 {
 	return thread == gc_thread;
 }
 
 /**
  * mono_gc_is_finalizer_thread:
  * @thread: the thread to test.
  *
  * In Mono objects are finalized asynchronously on a separate thread.
  * This routine tests whether the @thread argument represents the
  * finalization thread.
  * 
  * Returns true if @thread is the finalization thread.
  */
 gboolean
 mono_gc_is_finalizer_thread (MonoThread *thread)
 {
 	return mono_gc_is_finalizer_internal_thread (thread->internal_thread);
 }
 
 #if defined(__MACH__)
 static pthread_t mach_exception_thread;
 
 void
 mono_gc_register_mach_exception_thread (pthread_t thread)
 {
 	mach_exception_thread = thread;
 }
 
 pthread_t
 mono_gc_get_mach_exception_thread (void)
 {
 	return mach_exception_thread;
 }
 #endif
 
 /**
  * mono_gc_parse_environment_string_extract_number:
  *
  * @str: points to the first digit of the number
  * @out: pointer to the variable that will receive the value
  *
  * Tries to extract a number from the passed string, taking in to account m, k
  * and g suffixes
  *
  * Returns true if passing was successful
  */
 gboolean
 mono_gc_parse_environment_string_extract_number (const char *str, glong *out)
 {
 	char *endptr;
 	int len = strlen (str), shift = 0;
 	glong val;
 	gboolean is_suffix = FALSE;
 	char suffix;
 
 	switch (str [len - 1]) {
 		case 'g':
 		case 'G':
 			shift += 10;
 		case 'm':
 		case 'M':
 			shift += 10;
 		case 'k':
 		case 'K':
 			shift += 10;
 			is_suffix = TRUE;
 			suffix = str [len - 1];
 			break;
 	}
 
 	errno = 0;
 	val = strtol (str, &endptr, 10);
 
 	if ((errno == ERANGE && (val == LONG_MAX || val == LONG_MIN))
 			|| (errno != 0 && val == 0) || (endptr == str))
 		return FALSE;
 
 	if (is_suffix) {
 		if (*(endptr + 1)) /* Invalid string. */
 			return FALSE;
 		val <<= shift;
 	}
 
 	*out = val;
 	return TRUE;
 }
 
 #ifndef HAVE_SGEN_GC
 void*
 mono_gc_alloc_mature (MonoVTable *vtable)
 {
 	return mono_object_new_specific (vtable);
 }
 #endif
+
+
+static MonoReferenceQueue *ref_queues;
+
+static void
+ref_list_remove_element (RefQueueEntry **prev, RefQueueEntry *element)
+{
+	do {
+		/* Guard if head is changed concurrently. */
+		while (*prev != element)
+			prev = &(*prev)->next;
+	} while (prev && InterlockedCompareExchangePointer ((void*)prev, element->next, element) != element);
+}
+
+static void
+ref_list_push (RefQueueEntry **head, RefQueueEntry *value)
+{
+	RefQueueEntry *current;
+	do {
+		current = *head;
+		value->next = current;
+	} while (InterlockedCompareExchangePointer ((void*)head, value, current) != current);
+}
+
+static void
+reference_queue_proccess (MonoReferenceQueue *queue)
+{
+	RefQueueEntry **iter = &queue->queue;
+	RefQueueEntry *entry;
+	while ((entry = *iter)) {
+		if (queue->should_be_deleted || !mono_gc_weak_link_get (&entry->dis_link)) {
+			ref_list_remove_element (iter, entry);
+			mono_gc_weak_link_remove (&entry->dis_link);
+			queue->callback (entry->user_data);
+			g_free (entry);
+		} else {
+			iter = &entry->next;
+		}
+	}
+}
+
+static void
+reference_queue_proccess_all (void)
+{
+	MonoReferenceQueue **iter;
+	MonoReferenceQueue *queue = ref_queues;
+	for (; queue; queue = queue->next)
+		reference_queue_proccess (queue);
+
+restart:
+	EnterCriticalSection (&reference_queue_mutex);
+	for (iter = &ref_queues; *iter;) {
+		queue = *iter;
+		if (!queue->should_be_deleted) {
+			iter = &queue->next;
+			continue;
+		}
+		if (queue->queue) {
+			LeaveCriticalSection (&reference_queue_mutex);
+			reference_queue_proccess (queue);
+			goto restart;
+		}
+		*iter = queue->next;
+		g_free (queue);
+	}
+	LeaveCriticalSection (&reference_queue_mutex);
+}
+
+/**
+ * mono_gc_reference_queue_new:
+ * @callback callback used when processing dead entries.
+ *
+ * Create a new reference queue used to process collected objects.
+ * A reference queue let you queue the pair (managed object, user data).
+ * Once the managed object is collected @callback will be called
+ * in the finalizer thread with 'user data' as argument.
+ *
+ * The callback is called without any locks held.
+ */
+MonoReferenceQueue*
+mono_gc_reference_queue_new (mono_reference_queue_callback callback)
+{
+	MonoReferenceQueue *res = g_new0 (MonoReferenceQueue, 1);
+	res->callback = callback;
+
+	EnterCriticalSection (&reference_queue_mutex);
+	res->next = ref_queues;
+	ref_queues = res;
+	LeaveCriticalSection (&reference_queue_mutex);
+
+	return res;
+}
+
+/**
+ * mono_gc_reference_queue_add:
+ * @queue the queue to add the reference to.
+ * @obj the object to be watched for collection
+ * @user_data parameter to be passed to the queue callback
+ *
+ * Queue an object to be watched for collection.
+ *
+ * @returns false if the queue is scheduled to be freed.
+ */
+gboolean
+mono_gc_reference_queue_add (MonoReferenceQueue *queue, MonoObject *obj, void *user_data)
+{
+	RefQueueEntry *head;
+	RefQueueEntry *entry;
+	if (queue->should_be_deleted)
+		return FALSE;
+
+	entry = g_new0 (RefQueueEntry, 1);
+	entry->user_data = user_data;
+	mono_gc_weak_link_add (&entry->dis_link, obj, TRUE);
+	ref_list_push (&queue->queue, entry);
+	return TRUE;
+}
+
+/**
+ * mono_gc_reference_queue_free:
+ * @queue the queue that should be deleted.
+ *
+ * This operation signals that @queue should be deleted. This operation is deferred
+ * as it happens on the finalizer thread.
+ *
+ * After this call, no further objects can be queued. It's the responsibility of the
+ * caller to make sure that no further attempt to access queue will be made.
+ */
+void
+mono_gc_reference_queue_free (MonoReferenceQueue *queue)
+{
+	queue->should_be_deleted = TRUE;
+}
+
