   Implement a reference queue API.
   
   	* gc.c: A reference queue allows one to queue
   	callbcks for when objects are collected.
   	It allows for safe cleanup of objects that can
   	only be done when it is effectively collected.
   	The major difference with regular finalization
   	is that the collector makes sure the object
   	was collected - and can't be resurrected.
   
   	* gc-internal.h: Export entrypoints for the
   	new API.

FILE *mono_gc_get_logfile (void) MONO_INTERNAL;

#endif /* __MONO_METADATA_GC_INTERNAL_H__ */

#define mono_finalizer_lock() EnterCriticalSection (&finalizer_mutex)
#define mono_finalizer_unlock() LeaveCriticalSection (&finalizer_mutex)
static CRITICAL_SECTION finalizer_mutex;

static GSList *domains_to_finalize= NULL;
static MonoMList *threads_to_finalize = NULL;

static void mono_gchandle_set_target (guint32 gchandle, MonoObject *obj);

#ifndef HAVE_NULL_GC
static HANDLE pending_done_event;
static HANDLE shutdown_event;
		mono_attach_maybe_start ();
#endif

		if (domains_to_finalize) {
			mono_finalizer_lock ();
			if (domains_to_finalize) {
		 */
		mono_gc_invoke_finalizers ();

		SetEvent (pending_done_event);
	}

	InitializeCriticalSection (&allocator_section);

	InitializeCriticalSection (&finalizer_mutex);

	MONO_GC_REGISTER_ROOT_FIXED (gc_handles [HANDLE_NORMAL].entries);
	MONO_GC_REGISTER_ROOT_FIXED (gc_handles [HANDLE_PINNED].entries);
	DeleteCriticalSection (&handle_section);
	DeleteCriticalSection (&allocator_section);
	DeleteCriticalSection (&finalizer_mutex);
}

#else
	return mono_object_new_specific (vtable);
}
#endif
