commit 6b4dbcd86a9d464057fcc7abe4d0574093071fcc
Author: Michael Buesch <mb@bu3sch.de>
Date:   Mon Jul 20 22:58:44 2009 +0000

    parisc: isa-eeprom - Fix loff_t usage
    
    loff_t is a signed type. If userspace passes a negative ppos, the "count"
    range check is weakened. "count"s bigger than HPEE_MAX_LENGTH will pass the check.
    Also, if ppos is negative, the readb(eisa_eeprom_addr + *ppos) will poke in random
    memory.
    
    Signed-off-by: Michael Buesch <mb@bu3sch.de>
    Cc: stable@kernel.org
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/eisa_eeprom.c b/drivers/parisc/eisa_eeprom.c
index 685d94e..8c0b26e9 100644
--- a/drivers/parisc/eisa_eeprom.c
+++ b/drivers/parisc/eisa_eeprom.c
@@ -51,27 +51,27 @@ static loff_t eisa_eeprom_llseek(struct file *file, loff_t offset, int origin )
 static ssize_t eisa_eeprom_read(struct file * file,
 			      char __user *buf, size_t count, loff_t *ppos )
 {
 	unsigned char *tmp;
 	ssize_t ret;
 	int i;
 	
-	if (*ppos >= HPEE_MAX_LENGTH)
+	if (*ppos < 0 || *ppos >= HPEE_MAX_LENGTH)
 		return 0;
 	
 	count = *ppos + count < HPEE_MAX_LENGTH ? count : HPEE_MAX_LENGTH - *ppos;
 	tmp = kmalloc(count, GFP_KERNEL);
 	if (tmp) {
 		for (i = 0; i < count; i++)
 			tmp[i] = readb(eisa_eeprom_addr+(*ppos)++);
 
 		if (copy_to_user (buf, tmp, count))
 			ret = -EFAULT;
 		else
 			ret = count;
 		kfree (tmp);
 	} else
 		ret = -ENOMEM;
 	
 	return ret;
 }
 
