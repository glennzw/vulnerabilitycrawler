commit fdac1e0697356ac212259f2147aa60c72e334861
Author: Dan Rosenberg <drosenberg@vsecurity.com>
Date:   Wed Dec 22 13:58:27 2010 +0000

    irda: prevent integer underflow in IRLMP_ENUMDEVICES
    
    If the user-provided len is less than the expected offset, the
    IRLMP_ENUMDEVICES getsockopt will do a copy_to_user() with a very large
    size value.  While this isn't be a security issue on x86 because it will
    get caught by the access_ok() check, it may leak large amounts of kernel
    heap on other architectures.  In any event, this patch fixes it.
    
    Signed-off-by: Dan Rosenberg <drosenberg@vsecurity.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/irda/af_irda.c b/net/irda/af_irda.c
index 7f097989..5007541 100644
--- a/net/irda/af_irda.c
+++ b/net/irda/af_irda.c
@@ -2253,64 +2253,68 @@ static int irda_extract_ias_value(struct irda_ias_set *ias_opt,
 static int irda_getsockopt(struct socket *sock, int level, int optname,
 			   char __user *optval, int __user *optlen)
 {
 	struct sock *sk = sock->sk;
 	struct irda_sock *self = irda_sk(sk);
 	struct irda_device_list list;
 	struct irda_device_info *discoveries;
 	struct irda_ias_set *	ias_opt;	/* IAS get/query params */
 	struct ias_object *	ias_obj;	/* Object in IAS */
 	struct ias_attrib *	ias_attr;	/* Attribute in IAS object */
 	int daddr = DEV_ADDR_ANY;	/* Dest address for IAS queries */
 	int val = 0;
 	int len = 0;
 	int err = 0;
 	int offset, total;
 
 	IRDA_DEBUG(2, "%s(%p)\n", __func__, self);
 
 	if (level != SOL_IRLMP)
 		return -ENOPROTOOPT;
 
 	if (get_user(len, optlen))
 		return -EFAULT;
 
 	if(len < 0)
 		return -EINVAL;
 
 	lock_sock(sk);
 
 	switch (optname) {
 	case IRLMP_ENUMDEVICES:
+
+		/* Offset to first device entry */
+		offset = sizeof(struct irda_device_list) -
+			sizeof(struct irda_device_info);
+
+		if (len < offset) {
+			err = -EINVAL;
+			goto out;
+		}
+
 		/* Ask lmp for the current discovery log */
 		discoveries = irlmp_get_discoveries(&list.len, self->mask.word,
 						    self->nslots);
 		/* Check if the we got some results */
 		if (discoveries == NULL) {
 			err = -EAGAIN;
 			goto out;		/* Didn't find any devices */
 		}
 
 		/* Write total list length back to client */
-		if (copy_to_user(optval, &list,
-				 sizeof(struct irda_device_list) -
-				 sizeof(struct irda_device_info)))
+		if (copy_to_user(optval, &list, offset))
 			err = -EFAULT;
 
-		/* Offset to first device entry */
-		offset = sizeof(struct irda_device_list) -
-			sizeof(struct irda_device_info);
-
 		/* Copy the list itself - watch for overflow */
 		if (list.len > 2048) {
 			err = -EINVAL;
 			goto bed;
 		}
 		total = offset + (list.len * sizeof(struct irda_device_info));
 		if (total > len)
 			total = len;
 		if (copy_to_user(optval+offset, discoveries, total - offset))
 			err = -EFAULT;
 
 		/* Write total number of bytes used back to client */
 		if (put_user(total, optlen))
 			err = -EFAULT;
