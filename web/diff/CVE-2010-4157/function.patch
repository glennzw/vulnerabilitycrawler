commit f63ae56e4e97fb12053590e41a4fa59e7daa74a4
Author: Dan Carpenter <error27@gmail.com>
Date:   Fri Oct 8 09:03:07 2010 +0200

    [SCSI] gdth: integer overflow in ioctl
    
    gdth_ioctl_alloc() takes the size variable as an int.
    copy_from_user() takes the size variable as an unsigned long.
    gen.data_len and gen.sense_len are unsigned longs.
    On x86_64 longs are 64 bit and ints are 32 bit.
    
    We could pass in a very large number and the allocation would truncate
    the size to 32 bits and allocate a small buffer.  Then when we do the
    copy_from_user(), it would result in a memory corruption.
    
    CC: stable@kernel.org
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/gdth.c b/drivers/scsi/gdth.c
index 5a3f931..8411018 100644
--- a/drivers/scsi/gdth.c
+++ b/drivers/scsi/gdth.c
@@ -4167,117 +4167,125 @@ static int ioc_resetdrv(void __user *arg, char *cmnd)
 static int ioc_general(void __user *arg, char *cmnd)
 {
     gdth_ioctl_general gen;
     char *buf = NULL;
     u64 paddr; 
     gdth_ha_str *ha;
     int rval;
 
     if (copy_from_user(&gen, arg, sizeof(gdth_ioctl_general)))
         return -EFAULT;
     ha = gdth_find_ha(gen.ionode);
     if (!ha)
         return -EFAULT;
+
+    if (gen.data_len > INT_MAX)
+        return -EINVAL;
+    if (gen.sense_len > INT_MAX)
+        return -EINVAL;
+    if (gen.data_len + gen.sense_len > INT_MAX)
+        return -EINVAL;
+
     if (gen.data_len + gen.sense_len != 0) {
         if (!(buf = gdth_ioctl_alloc(ha, gen.data_len + gen.sense_len,
                                      FALSE, &paddr)))
             return -EFAULT;
         if (copy_from_user(buf, arg + sizeof(gdth_ioctl_general),  
                            gen.data_len + gen.sense_len)) {
             gdth_ioctl_free(ha, gen.data_len+gen.sense_len, buf, paddr);
             return -EFAULT;
         }
 
         if (gen.command.OpCode == GDT_IOCTL) {
             gen.command.u.ioctl.p_param = paddr;
         } else if (gen.command.Service == CACHESERVICE) {
             if (ha->cache_feat & GDT_64BIT) {
                 /* copy elements from 32-bit IOCTL structure */
                 gen.command.u.cache64.BlockCnt = gen.command.u.cache.BlockCnt;
                 gen.command.u.cache64.BlockNo = gen.command.u.cache.BlockNo;
                 gen.command.u.cache64.DeviceNo = gen.command.u.cache.DeviceNo;
                 /* addresses */
                 if (ha->cache_feat & SCATTER_GATHER) {
                     gen.command.u.cache64.DestAddr = (u64)-1;
                     gen.command.u.cache64.sg_canz = 1;
                     gen.command.u.cache64.sg_lst[0].sg_ptr = paddr;
                     gen.command.u.cache64.sg_lst[0].sg_len = gen.data_len;
                     gen.command.u.cache64.sg_lst[1].sg_len = 0;
                 } else {
                     gen.command.u.cache64.DestAddr = paddr;
                     gen.command.u.cache64.sg_canz = 0;
                 }
             } else {
                 if (ha->cache_feat & SCATTER_GATHER) {
                     gen.command.u.cache.DestAddr = 0xffffffff;
                     gen.command.u.cache.sg_canz = 1;
                     gen.command.u.cache.sg_lst[0].sg_ptr = (u32)paddr;
                     gen.command.u.cache.sg_lst[0].sg_len = gen.data_len;
                     gen.command.u.cache.sg_lst[1].sg_len = 0;
                 } else {
                     gen.command.u.cache.DestAddr = paddr;
                     gen.command.u.cache.sg_canz = 0;
                 }
             }
         } else if (gen.command.Service == SCSIRAWSERVICE) {
             if (ha->raw_feat & GDT_64BIT) {
                 /* copy elements from 32-bit IOCTL structure */
                 char cmd[16];
                 gen.command.u.raw64.sense_len = gen.command.u.raw.sense_len;
                 gen.command.u.raw64.bus = gen.command.u.raw.bus;
                 gen.command.u.raw64.lun = gen.command.u.raw.lun;
                 gen.command.u.raw64.target = gen.command.u.raw.target;
                 memcpy(cmd, gen.command.u.raw.cmd, 16);
                 memcpy(gen.command.u.raw64.cmd, cmd, 16);
                 gen.command.u.raw64.clen = gen.command.u.raw.clen;
                 gen.command.u.raw64.sdlen = gen.command.u.raw.sdlen;
                 gen.command.u.raw64.direction = gen.command.u.raw.direction;
                 /* addresses */
                 if (ha->raw_feat & SCATTER_GATHER) {
                     gen.command.u.raw64.sdata = (u64)-1;
                     gen.command.u.raw64.sg_ranz = 1;
                     gen.command.u.raw64.sg_lst[0].sg_ptr = paddr;
                     gen.command.u.raw64.sg_lst[0].sg_len = gen.data_len;
                     gen.command.u.raw64.sg_lst[1].sg_len = 0;
                 } else {
                     gen.command.u.raw64.sdata = paddr;
                     gen.command.u.raw64.sg_ranz = 0;
                 }
                 gen.command.u.raw64.sense_data = paddr + gen.data_len;
             } else {
                 if (ha->raw_feat & SCATTER_GATHER) {
                     gen.command.u.raw.sdata = 0xffffffff;
                     gen.command.u.raw.sg_ranz = 1;
                     gen.command.u.raw.sg_lst[0].sg_ptr = (u32)paddr;
                     gen.command.u.raw.sg_lst[0].sg_len = gen.data_len;
                     gen.command.u.raw.sg_lst[1].sg_len = 0;
                 } else {
                     gen.command.u.raw.sdata = paddr;
                     gen.command.u.raw.sg_ranz = 0;
                 }
                 gen.command.u.raw.sense_data = (u32)paddr + gen.data_len;
             }
         } else {
             gdth_ioctl_free(ha, gen.data_len+gen.sense_len, buf, paddr);
             return -EFAULT;
         }
     }
 
     rval = __gdth_execute(ha->sdev, &gen.command, cmnd, gen.timeout, &gen.info);
     if (rval < 0)
         return rval;
     gen.status = rval;
 
     if (copy_to_user(arg + sizeof(gdth_ioctl_general), buf, 
                      gen.data_len + gen.sense_len)) {
         gdth_ioctl_free(ha, gen.data_len+gen.sense_len, buf, paddr);
         return -EFAULT; 
     } 
     if (copy_to_user(arg, &gen, 
         sizeof(gdth_ioctl_general) - sizeof(gdth_cmd_str))) {
         gdth_ioctl_free(ha, gen.data_len+gen.sense_len, buf, paddr);
         return -EFAULT;
     }
     gdth_ioctl_free(ha, gen.data_len+gen.sense_len, buf, paddr);
     return 0;
 }
  
