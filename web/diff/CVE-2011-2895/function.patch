commit d11ee5886e9d9ec610051a206b135a4cdc1e09a0
Author: Thomas Hoger <thoger@redhat.com>
Date:   Mon Aug 8 18:03:09 2011 +0200

    LZW decompress: fix for CVE-2011-2895
    
    Specially crafted LZW stream can crash an application using libXfont
    that is used to open untrusted font files.  With X server, this may
    allow privilege escalation when exploited
    
    Reviewed-by: Matthieu Herrb <matthieu.herrb@laas.fr>
    Signed-off-by: Matthieu Herrb <matthieu.herrb@laas.fr>
    Signed-off-by: Alan Coopersmith <alan.coopersmith@oracle.com>

diff --git a/src/fontfile/decompress.c b/src/fontfile/decompress.c
index b1fc37b..c8171dd 100644
--- a/src/fontfile/decompress.c
+++ b/src/fontfile/decompress.c
@@ -210,93 +210,95 @@ static int
 BufCompressedFill (BufFilePtr f)
 {
     CompressedFile  *file;
     register char_type *stackp, *de_stack;
     register char_type finchar;
     register code_int code, oldcode, incode;
     BufChar	    *buf, *bufend;
 
     file = (CompressedFile *) f->private;
 
     buf = f->buffer;
     bufend = buf + BUFFILESIZE;
     stackp = file->stackp;
     de_stack = file->de_stack;
     finchar = file->finchar;
     oldcode = file->oldcode;
     while (buf < bufend) {
 	while (stackp > de_stack && buf < bufend)
 	    *buf++ = *--stackp;
 
 	if (buf == bufend)
 	    break;
 
 	if (oldcode == -1)
 	    break;
 
 	code = getcode (file);
 	if (code == -1)
 	    break;
     
     	if ( (code == CLEAR) && file->block_compress ) {
 	    for ( code = 255; code >= 0; code-- )
 	    	file->tab_prefix[code] = 0;
 	    file->clear_flg = 1;
 	    file->free_ent = FIRST - 1;
 	    if ( (code = getcode (file)) == -1 )	/* O, untimely death! */
 	    	break;
     	}
     	incode = code;
     	/*
      	 * Special case for KwKwK string.
      	 */
     	if ( code >= file->free_ent ) {
 	    *stackp++ = finchar;
 	    code = oldcode;
     	}
     
     	/*
      	 * Generate output characters in reverse order
      	 */
     	while ( code >= 256 )
     	{
+	    if (stackp - de_stack >= STACK_SIZE - 1)
+		return BUFFILEEOF;
 	    *stackp++ = file->tab_suffix[code];
 	    code = file->tab_prefix[code];
     	}
 	finchar = file->tab_suffix[code];
 	*stackp++ = finchar;
     
     	/*
      	 * Generate the new entry.
      	 */
     	if ( (code=file->free_ent) < file->maxmaxcode ) {
 	    file->tab_prefix[code] = (unsigned short)oldcode;
 	    file->tab_suffix[code] = finchar;
 	    file->free_ent = code+1;
     	} 
 	/*
 	 * Remember previous code.
 	 */
 	oldcode = incode;
     }
     file->oldcode = oldcode;
     file->stackp = stackp;
     file->finchar = finchar;
     if (buf == f->buffer) {
 	f->left = 0;
 	return BUFFILEEOF;
     }
     f->bufp = f->buffer + 1;
     f->left = (buf - f->buffer) - 1;
     return f->buffer[0];
 }
 
 /*****************************************************************
  * TAG( getcode )
  *
  * Read one code from the standard input.  If BUFFILEEOF, return -1.
  * Inputs:
  * 	stdin
  * Outputs:
  * 	code or -1 is returned.
  */
 
