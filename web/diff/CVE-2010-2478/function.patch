commit db048b69037e7fa6a7d9e95a1271a50dc08ae233
Author: Ben Hutchings <bhutchings@solarflare.com>
Date:   Mon Jun 28 08:44:07 2010 +0000

    ethtool: Fix potential kernel buffer overflow in ETHTOOL_GRXCLSRLALL
    
    On a 32-bit machine, info.rule_cnt >= 0x40000000 leads to integer
    overflow and the buffer may be smaller than needed.  Since
    ETHTOOL_GRXCLSRLALL is unprivileged, this can presumably be used for at
    least denial of service.
    
    Signed-off-by: Ben Hutchings <bhutchings@solarflare.com>
    Cc: stable@kernel.org
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/core/ethtool.c b/net/core/ethtool.c
index a0f4964..a3a7e9a 100644
--- a/net/core/ethtool.c
+++ b/net/core/ethtool.c
@@ -334,39 +334,40 @@ static noinline_for_stack int ethtool_set_rxnfc(struct net_device *dev,
 static noinline_for_stack int ethtool_get_rxnfc(struct net_device *dev,
 						void __user *useraddr)
 {
 	struct ethtool_rxnfc info;
 	const struct ethtool_ops *ops = dev->ethtool_ops;
 	int ret;
 	void *rule_buf = NULL;
 
 	if (!ops->get_rxnfc)
 		return -EOPNOTSUPP;
 
 	if (copy_from_user(&info, useraddr, sizeof(info)))
 		return -EFAULT;
 
 	if (info.cmd == ETHTOOL_GRXCLSRLALL) {
 		if (info.rule_cnt > 0) {
-			rule_buf = kmalloc(info.rule_cnt * sizeof(u32),
-					   GFP_USER);
+			if (info.rule_cnt <= KMALLOC_MAX_SIZE / sizeof(u32))
+				rule_buf = kmalloc(info.rule_cnt * sizeof(u32),
+						   GFP_USER);
 			if (!rule_buf)
 				return -ENOMEM;
 		}
 	}
 
 	ret = ops->get_rxnfc(dev, &info, rule_buf);
 	if (ret < 0)
 		goto err_out;
 
 	ret = -EFAULT;
 	if (copy_to_user(useraddr, &info, sizeof(info)))
 		goto err_out;
 
 	if (rule_buf) {
 		useraddr += offsetof(struct ethtool_rxnfc, rule_locs);
 		if (copy_to_user(useraddr, rule_buf,
 				 info.rule_cnt * sizeof(u32)))
 			goto err_out;
 	}
 	ret = 0;
 
