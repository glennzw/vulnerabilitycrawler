commit dcca89b7ab6e1220815af38da246434b2e13fd9f
Author: Ray Strode <rstrode@redhat.com>
Date:   Mon Feb 8 10:25:10 2010 -0500

    Ensure keyboard grab and unlock dialog exist after monitor removal
    
    gnome-screensaver currently doesn't deal with monitors getting
    removed properly.  If the unlock dialog is on the removed monitor
    then the unlock dialog and its associated keyboard grab are not
    moved to an existing monitor when the monitor removal is processed.
    
    This means that users can gain access to the locked system by placing
    the mouse pointer on an external monitor and then disconnect the
    external monitor.
    
    CVE-2010-0414
    https://bugzilla.gnome.org/show_bug.cgi?id=609337

diff --git a/src/gs-manager.c b/src/gs-manager.c
index bb0ddf6..6581031 100644
--- a/src/gs-manager.c
+++ b/src/gs-manager.c
@@ -1460,41 +1460,54 @@ static void
 on_screen_monitors_changed (GdkScreen *screen,
                             GSManager *manager)
 {
         GSList *l;
         int     n_monitors;
         int     n_windows;
         int     i;
 
         n_monitors = gdk_screen_get_n_monitors (screen);
         n_windows = g_slist_length (manager->priv->windows);
 
         gs_debug ("Monitors changed for screen %d: num=%d",
                   gdk_screen_get_number (screen),
                   n_monitors);
 
         if (n_monitors > n_windows) {
                 /* add more windows */
                 for (i = n_windows; i < n_monitors; i++) {
                         gs_manager_create_window_for_monitor (manager, screen, i);
                 }
         } else {
+
+                gdk_x11_grab_server ();
+
                 /* remove the extra windows */
                 l = manager->priv->windows;
                 while (l != NULL) {
                         GdkScreen *this_screen;
                         int        this_monitor;
                         GSList    *next = l->next;
 
                         this_screen = gs_window_get_screen (GS_WINDOW (l->data));
                         this_monitor = gs_window_get_monitor (GS_WINDOW (l->data));
                         if (this_screen == screen && this_monitor >= n_monitors) {
                                 manager_maybe_stop_job_for_window (manager, GS_WINDOW (l->data));
                                 g_hash_table_remove (manager->priv->jobs, l->data);
                                 gs_window_destroy (GS_WINDOW (l->data));
                                 manager->priv->windows = g_slist_delete_link (manager->priv->windows, l);
                         }
                         l = next;
                 }
+
+                /* make sure there is a lock dialog on a connected monitor,
+                 * and that the keyboard is still properly grabbed after all
+                 * the windows above got destroyed*/
+                if (n_windows > n_monitors) {
+                        gs_manager_request_unlock (manager);
+                }
+
+                gdk_flush ();
+                gdk_x11_ungrab_server ();
         }
 }
 
diff --git a/src/gs-window-x11.c b/src/gs-window-x11.c
index ea6c1cd..4bdbf58 100644
--- a/src/gs-window-x11.c
+++ b/src/gs-window-x11.c
@@ -45,6 +45,8 @@ static void gs_window_init       (GSWindow      *window);
 static void gs_window_finalize   (GObject       *object);
 
 static gboolean popup_dialog_idle (GSWindow *window);
+static void gs_window_dialog_finish (GSWindow *window);
+static void remove_command_watches (GSWindow *window);
 
 enum {
         DIALOG_RESPONSE_CANCEL,
@@ -926,7 +928,22 @@ void
 gs_window_destroy (GSWindow *window)
 {
         g_return_if_fail (GS_IS_WINDOW (window));
 
+        if (window->priv->lock_pid > 0) {
+                gs_window_dialog_finish (window);
+        }
+
+        remove_popup_dialog_idle (window);
+        remove_command_watches (window);
+        remove_watchdog_timer (window);
+
+        if (window->priv->lock_box != NULL) {
+                gtk_container_remove (GTK_CONTAINER (window->priv->vbox), GTK_WIDGET (window->priv->lock_box));
+                window->priv->lock_box = NULL;
+
+                g_signal_emit (window, signals [DIALOG_DOWN], 0);
+        }
+
         gtk_widget_destroy (GTK_WIDGET (window));
 }
 
