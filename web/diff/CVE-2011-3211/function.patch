commit f4a35efec1b6a1e54d61cf1b8bfc83dd1d89eef7
Author: Chris St. Pierre <chris.a.st.pierre@gmail.com>
Date:   Fri Aug 5 08:24:22 2011 -0400

    fixed security bugs with unescaped input to the shell

diff --git a/src/lib/Server/Admin/Viz.py b/src/lib/Server/Admin/Viz.py
index 3ab54e5..9b1e788 100644
--- a/src/lib/Server/Admin/Viz.py
+++ b/src/lib/Server/Admin/Viz.py
@@ -8,107 +8,106 @@ import Bcfg2.Server.Admin
 class Viz(Bcfg2.Server.Admin.MetadataCore):
     __shorthelp__ = "Produce graphviz diagrams of metadata structures"
     __longhelp__ = (__shorthelp__ + "\n\nbcfg2-admin viz [--includehosts] "
                                     "[--includebundles] [--includekey] "
                                     "[--only-client clientname] "
                                     "[-o output.<ext>]\n")
     __usage__ = ("bcfg2-admin viz [options]\n\n"
                  "     %-32s%s\n"
                  "     %-32s%s\n"
                  "     %-32s%s\n"
                  "     %-32s%s\n"
                  "     %-32s%s\n" %
                 ("-H, --includehosts",
                  "include hosts in the viz output",
                  "-b, --includebundles",
                  "include bundles in the viz output",
                  "-k, --includekey",
                  "show a key for different digraph shapes",
                  "-c, --only-client <clientname>",
                  "show only the groups, bundles for the named client",
                  "-o, --outfile <file>",
                  "write viz output to an output file"))
 
     colors = ['steelblue1', 'chartreuse', 'gold', 'magenta',
               'indianred1', 'limegreen', 'orange1', 'lightblue2',
               'green1', 'blue1', 'yellow1', 'darkturquoise', 'gray66']
 
     plugin_blacklist = ['DBStats', 'Snapshots', 'Cfg', 'Pkgmgr', 'Packages',
                         'Rules', 'Account', 'Decisions', 'Deps', 'Git', 'Svn',
                         'Fossil', 'Bzr', 'Bundler', 'TGenshi', 'SGenshi',
                         'Base']
 
     def __init__(self, cfile):
 
         Bcfg2.Server.Admin.MetadataCore.__init__(self, cfile,
                                                  self.__usage__,
                                                  pblacklist=self.plugin_blacklist)
 
     def __call__(self, args):
         Bcfg2.Server.Admin.MetadataCore.__call__(self, args)
         # First get options to the 'viz' subcommand
         try:
             opts, args = getopt.getopt(args, 'Hbkc:o:',
                                        ['includehosts', 'includebundles',
                                         'includekey', 'only-client=', 'outfile='])
         except getopt.GetoptError:
             msg = sys.exc_info()[1]
             print(msg)
             print(self.__longhelp__)
             raise SystemExit(1)
 
         hset = False
         bset = False
         kset = False
         only_client = None
         outputfile = False
         for opt, arg in opts:
             if opt in ("-H", "--includehosts"):
                 hset = True
             elif opt in ("-b", "--includebundles"):
                 bset = True
             elif opt in ("-k", "--includekey"):
                 kset = True
             elif opt in ("-c", "--only-client"):
                 only_client = arg
             elif opt in ("-o", "--outfile"):
                 outputfile = arg
 
         data = self.Visualize(self.get_repo_path(), hset, bset,
                               kset, only_client, outputfile)
         print(data)
         raise SystemExit(0)
 
     def Visualize(self, repopath, hosts=False,
                   bundles=False, key=False, only_client=None, output=False):
         """Build visualization of groups file."""
         if output:
             format = output.split('.')[-1]
         else:
             format = 'png'
 
-        cmd = "dot -T%s" % (format)
+        cmd = ["dot", "-T", format]
         if output:
-            cmd += " -o %s" % output
-        dotpipe = Popen(cmd, shell=True, stdin=PIPE,
-                        stdout=PIPE, close_fds=True)
+            cmd.extend(["-o", output])
+        dotpipe = Popen(cmd, stdin=PIPE, stdout=PIPE, close_fds=True)
         try:
             dotpipe.stdin.write("digraph groups {\n")
         except:
             print("write to dot process failed. Is graphviz installed?")
             raise SystemExit(1)
         dotpipe.stdin.write('\trankdir="LR";\n')
         dotpipe.stdin.write(self.metadata.viz(hosts, bundles,
                                               key, only_client, self.colors))
         if key:
             dotpipe.stdin.write("\tsubgraph cluster_key {\n")
             dotpipe.stdin.write('''\tstyle="filled";\n''')
             dotpipe.stdin.write('''\tcolor="lightblue";\n''')
             dotpipe.stdin.write('''\tBundle [ shape="septagon" ];\n''')
             dotpipe.stdin.write('''\tGroup [shape="ellipse"];\n''')
             dotpipe.stdin.write('''\tProfile [style="bold", shape="ellipse"];\n''')
             dotpipe.stdin.write('''\tHblock [label="Host1|Host2|Host3", shape="record"];\n''')
             dotpipe.stdin.write('''\tlabel="Key";\n''')
             dotpipe.stdin.write("\t}\n")
         dotpipe.stdin.write("}\n")
         dotpipe.stdin.close()
         return dotpipe.stdout.read()
diff --git a/src/lib/Server/Plugins/Hg.py b/src/lib/Server/Plugins/Hg.py
index 3f2864a..70e33ef 100644
--- a/src/lib/Server/Plugins/Hg.py
+++ b/src/lib/Server/Plugins/Hg.py
@@ -1,6 +1,5 @@
 import os
 from mercurial import ui, hg
-from subprocess import Popen, PIPE
 import Bcfg2.Server.Plugin
 
 # for debugging output only
diff --git a/src/lib/Server/Plugins/SSHbase.py b/src/lib/Server/Plugins/SSHbase.py
index b152758..8cc4ef6 100644
--- a/src/lib/Server/Plugins/SSHbase.py
+++ b/src/lib/Server/Plugins/SSHbase.py
@@ -14,279 +14,278 @@ import Bcfg2.Server.Plugin
 class SSHbase(Bcfg2.Server.Plugin.Plugin,
               Bcfg2.Server.Plugin.Generator,
               Bcfg2.Server.Plugin.DirectoryBacked,
               Bcfg2.Server.Plugin.PullTarget):
     """
        The sshbase generator manages ssh host keys (both v1 and v2)
        for hosts.  It also manages the ssh_known_hosts file. It can
        integrate host keys from other management domains and similarly
        export its keys. The repository contains files in the following
        formats:
 
        ssh_host_key.H_(hostname) -> the v1 host private key for
          (hostname)
        ssh_host_key.pub.H_(hostname) -> the v1 host public key
          for (hostname)
        ssh_host_(dr)sa_key.H_(hostname) -> the v2 ssh host
          private key for (hostname)
        ssh_host_(dr)sa_key.pub.H_(hostname) -> the v2 ssh host
          public key for (hostname)
        ssh_known_hosts -> the current known hosts file. this
          is regenerated each time a new key is generated.
 
     """
     name = 'SSHbase'
     __version__ = '$Id$'
     __author__ = 'bcfg-dev@mcs.anl.gov'
 
     pubkeys = ["ssh_host_dsa_key.pub.H_%s",
                "ssh_host_rsa_key.pub.H_%s",
                "ssh_host_key.pub.H_%s"]
     hostkeys = ["ssh_host_dsa_key.H_%s",
                 "ssh_host_rsa_key.H_%s",
                 "ssh_host_key.H_%s"]
     keypatterns = ["ssh_host_dsa_key",
                    "ssh_host_rsa_key",
                    "ssh_host_key",
                    "ssh_host_dsa_key.pub",
                    "ssh_host_rsa_key.pub",
                    "ssh_host_key.pub"]
 
     def __init__(self, core, datastore):
         Bcfg2.Server.Plugin.Plugin.__init__(self, core, datastore)
         Bcfg2.Server.Plugin.Generator.__init__(self)
         Bcfg2.Server.Plugin.PullTarget.__init__(self)
         try:
             Bcfg2.Server.Plugin.DirectoryBacked.__init__(self, self.data,
                                                          self.core.fam)
         except OSError:
             ioerr = sys.exc_info()[1]
             self.logger.error("Failed to load SSHbase repository from %s" \
                               % (self.data))
             self.logger.error(ioerr)
             raise Bcfg2.Server.Plugin.PluginInitError
         self.Entries = {'Path':
                         {'/etc/ssh/ssh_known_hosts': self.build_skn,
                          '/etc/ssh/ssh_host_dsa_key': self.build_hk,
                          '/etc/ssh/ssh_host_rsa_key': self.build_hk,
                          '/etc/ssh/ssh_host_dsa_key.pub': self.build_hk,
                          '/etc/ssh/ssh_host_rsa_key.pub': self.build_hk,
                          '/etc/ssh/ssh_host_key': self.build_hk,
                          '/etc/ssh/ssh_host_key.pub': self.build_hk}}
         self.ipcache = {}
         self.namecache = {}
         self.__skn = False
 
     def get_skn(self):
         """Build memory cache of the ssh known hosts file."""
         if not self.__skn:
             self.__skn = "\n".join([value.data.decode() for key, value in \
                                     list(self.entries.items()) if \
                                     key.endswith('.static')])
             names = dict()
             # if no metadata is registered yet, defer
             if len(self.core.metadata.query.all()) == 0:
                 self.__skn = False
                 return self.__skn
             for cmeta in self.core.metadata.query.all():
                 names[cmeta.hostname] = set([cmeta.hostname])
                 names[cmeta.hostname].update(cmeta.aliases)
                 newnames = set()
                 newips = set()
                 for name in names[cmeta.hostname]:
                     newnames.add(name.split('.')[0])
                     try:
                         newips.add(self.get_ipcache_entry(name)[0])
                     except:
                         continue
                 names[cmeta.hostname].update(newnames)
                 names[cmeta.hostname].update(cmeta.addresses)
                 names[cmeta.hostname].update(newips)
                 # TODO: Only perform reverse lookups on IPs if an option is set.
                 if True:
                     for ip in newips:
                         try:
                             names[cmeta.hostname].update(self.get_namecache_entry(ip))
                         except:
                             continue
                 names[cmeta.hostname] = sorted(names[cmeta.hostname])
             # now we have our name cache
             pubkeys = [pubk for pubk in list(self.entries.keys()) \
                        if pubk.find('.pub.H_') != -1]
             pubkeys.sort()
             badnames = set()
             for pubkey in pubkeys:
                 hostname = pubkey.split('H_')[1]
                 if hostname not in names:
                     if hostname not in badnames:
                         badnames.add(hostname)
                         self.logger.error("SSHbase: Unknown host %s; ignoring public keys" % hostname)
                     continue
                 self.__skn += "%s %s" % (','.join(names[hostname]),
                                          self.entries[pubkey].data.decode())
         return self.__skn
 
     def set_skn(self, value):
         """Set backing data for skn."""
         self.__skn = value
     skn = property(get_skn, set_skn)
 
     def HandleEvent(self, event=None):
         """Local event handler that does skn regen on pubkey change."""
         Bcfg2.Server.Plugin.DirectoryBacked.HandleEvent(self, event)
         if event and '_key.pub.H_' in event.filename:
             self.skn = False
         if event and event.filename.endswith('.static'):
             self.skn = False
         if not self.__skn:
             if (len(list(self.entries.keys()))) >= (len(os.listdir(self.data)) - 1):
                 _ = self.skn
 
     def HandlesEntry(self, entry, _):
         """Handle key entries dynamically."""
         return entry.tag == 'Path' and \
                ([fpat for fpat in self.keypatterns
                  if entry.get('name').endswith(fpat)]
                 or entry.get('name').endswith('ssh_known_hosts'))
 
     def HandleEntry(self, entry, metadata):
         """Bind data."""
         if entry.get('name').endswith('ssh_known_hosts'):
             return self.build_skn(entry, metadata)
         else:
             return self.build_hk(entry, metadata)
 
     def get_ipcache_entry(self, client):
         """Build a cache of dns results."""
         if client in self.ipcache:
             if self.ipcache[client]:
                 return self.ipcache[client]
             else:
                 raise socket.gaierror
         else:
             # need to add entry
             try:
                 ipaddr = socket.gethostbyname(client)
                 self.ipcache[client] = (ipaddr, client)
                 return (ipaddr, client)
             except socket.gaierror:
-                cmd = "getent hosts %s" % client
-                ipaddr = Popen(cmd, shell=True, \
+                ipaddr = Popen(["getent", "hosts", client],
                                stdout=PIPE).stdout.read().strip().split()
                 if ipaddr:
                     self.ipcache[client] = (ipaddr, client)
                     return (ipaddr, client)
                 self.ipcache[client] = False
                 self.logger.error("Failed to find IP address for %s" % client)
                 raise socket.gaierror
 
     def get_namecache_entry(self, cip):
         """Build a cache of name lookups from client IP addresses."""
         if cip in self.namecache:
             # lookup cached name from IP
             if self.namecache[cip]:
                 return self.namecache[cip]
             else:
                 raise socket.gaierror
         else:
             # add an entry that has not been cached
             try:
                 rvlookup = socket.gethostbyaddr(cip)
                 if rvlookup[0]:
                     self.namecache[cip] = [rvlookup[0]]
                 else:
                     self.namecache[cip] = []
                 self.namecache[cip].extend(rvlookup[1])
                 return self.namecache[cip]
             except socket.gaierror:
                 self.namecache[cip] = False
                 self.logger.error("Failed to find any names associated with IP address %s" % cip)
                 raise
 
     def build_skn(self, entry, metadata):
         """This function builds builds a host specific known_hosts file."""
         client = metadata.hostname
         entry.text = self.skn
         hostkeys = [keytmpl % client for keytmpl in self.pubkeys \
                         if (keytmpl % client) in self.entries]
         hostkeys.sort()
         for hostkey in hostkeys:
             entry.text += "localhost,localhost.localdomain,127.0.0.1 %s" % (
                 self.entries[hostkey].data.decode())
         permdata = {'owner': 'root',
                     'group': 'root',
                     'type': 'file',
                     'perms': '0644'}
         [entry.attrib.__setitem__(key, permdata[key]) for key in permdata]
 
     def build_hk(self, entry, metadata):
         """This binds host key data into entries."""
         client = metadata.hostname
         filename = "%s.H_%s" % (entry.get('name').split('/')[-1], client)
         if filename not in list(self.entries.keys()):
             self.GenerateHostKeys(client)
         if not filename in self.entries:
             self.logger.error("%s still not registered" % filename)
             raise Bcfg2.Server.Plugin.PluginExecutionError
         keydata = self.entries[filename].data
         permdata = {'owner': 'root',
                     'group': 'root',
                     'type': 'file'}
         if entry.get('name')[-4:] == '.pub':
             permdata['perms'] = '0644'
         else:
             permdata['perms'] = '0600'
             permdata['sensitive'] = 'true'
         [entry.attrib.__setitem__(key, permdata[key]) for key in permdata]
         if "ssh_host_key.H_" == filename[:15]:
             entry.attrib['encoding'] = 'base64'
             entry.text = binascii.b2a_base64(keydata)
         else:
             entry.text = keydata
 
     def GenerateHostKeys(self, client):
         """Generate new host keys for client."""
         keylist = [keytmpl % client for keytmpl in self.hostkeys]
         for hostkey in keylist:
             if 'ssh_host_rsa_key.H_' == hostkey[:19]:
                 keytype = 'rsa'
             elif 'ssh_host_dsa_key.H_' == hostkey[:19]:
                 keytype = 'dsa'
             else:
                 keytype = 'rsa1'
 
             if hostkey not in list(self.entries.keys()):
                 fileloc = "%s/%s" % (self.data, hostkey)
                 publoc = self.data + '/' + ".".join([hostkey.split('.')[0],
                                                      'pub',
                                                      "H_%s" % client])
                 tempdir = tempfile.mkdtemp()
                 temploc = "%s/%s" % (tempdir, hostkey)
                 cmd = 'ssh-keygen -q -f %s -N "" -t %s -C root@%s < /dev/null'
                 os.system(cmd % (temploc, keytype, client))
                 shutil.copy(temploc, fileloc)
                 shutil.copy("%s.pub" % temploc, publoc)
                 self.AddEntry(hostkey)
                 self.AddEntry(".".join([hostkey.split('.')[0]] + ['pub', "H_%s" \
                                                                   % client]))
                 try:
                     os.unlink(temploc)
                     os.unlink("%s.pub" % temploc)
                     os.rmdir(tempdir)
                 except OSError:
                     self.logger.error("Failed to unlink temporary ssh keys")
 
     def AcceptChoices(self, _, metadata):
         return [Bcfg2.Server.Plugin.Specificity(hostname=metadata.hostname)]
 
     def AcceptPullData(self, specific, entry, log):
         """Per-plugin bcfg2-admin pull support."""
         # specific will always be host specific
         filename = "%s/%s.H_%s" % (self.data, entry['name'].split('/')[-1],
                                    specific.hostname)
         try:
             open(filename, 'w').write(entry['text'])
             if log:
                 print("Wrote file %s" % filename)
         except KeyError:
             self.logger.error("Failed to pull %s. This file does not currently "
                               "exist on the client" % entry.get('name'))
diff --git a/src/lib/Server/Plugins/SSLCA.py b/src/lib/Server/Plugins/SSLCA.py
index baaa14b..a2ab3bf 100644
--- a/src/lib/Server/Plugins/SSLCA.py
+++ b/src/lib/Server/Plugins/SSLCA.py
@@ -3,6 +3,7 @@ import Bcfg2.Options
 import lxml.etree
 import posixpath
 import tempfile
+import pipes
 import os
 from subprocess import Popen, PIPE, STDOUT
 # Compatibility import
@@ -12,268 +13,263 @@ from Bcfg2.Bcfg2Py3k import ConfigParser
 class SSLCA(Bcfg2.Server.Plugin.GroupSpool):
     """
     The SSLCA generator handles the creation and
     management of ssl certificates and their keys.
     """
     name = 'SSLCA'
     __version__ = '$Id:$'
     __author__ = 'g.hagger@gmail.com'
     __child__ = Bcfg2.Server.Plugin.FileBacked
     key_specs = {}
     cert_specs = {}
     CAs = {}
 
     def HandleEvent(self, event=None):
         """
         Updates which files this plugin handles based upon filesystem events.
         Allows configuration items to be added/removed without server restarts.
         """
         action = event.code2str()
         if event.filename[0] == '/':
             return
         epath = "".join([self.data, self.handles[event.requestID],
                          event.filename])
         if posixpath.isdir(epath):
             ident = self.handles[event.requestID] + event.filename
         else:
             ident = self.handles[event.requestID][:-1]
 
         fname = "".join([ident, '/', event.filename])
 
         if event.filename.endswith('.xml'):
             if action in ['exists', 'created', 'changed']:
                 if event.filename.endswith('key.xml'):
                     key_spec = dict(list(lxml.etree.parse(epath).find('Key').items()))
                     self.key_specs[ident] = {
                         'bits': key_spec.get('bits', 2048),
                         'type': key_spec.get('type', 'rsa')
                     }
                     self.Entries['Path'][ident] = self.get_key
                 elif event.filename.endswith('cert.xml'):
                     cert_spec = dict(list(lxml.etree.parse(epath).find('Cert').items()))
                     ca = cert_spec.get('ca', 'default')
                     self.cert_specs[ident] = {
                         'ca': ca,
                         'format': cert_spec.get('format', 'pem'),
                         'key': cert_spec.get('key'),
                         'days': cert_spec.get('days', 365),
                         'C': cert_spec.get('c'),
                         'L': cert_spec.get('l'),
                         'ST': cert_spec.get('st'),
                         'OU': cert_spec.get('ou'),
                         'O': cert_spec.get('o'),
                         'emailAddress': cert_spec.get('emailaddress')
                     }
                     cp = ConfigParser()
                     cp.read(self.core.cfile)
                     self.CAs[ca] = dict(cp.items('sslca_' + ca))
                     self.Entries['Path'][ident] = self.get_cert
             if action == 'deleted':
                 if ident in self.Entries['Path']:
                     del self.Entries['Path'][ident]
         else:
             if action in ['exists', 'created']:
                 if posixpath.isdir(epath):
                     self.AddDirectoryMonitor(epath[len(self.data):])
                 if ident not in self.entries and posixpath.isfile(epath):
                     self.entries[fname] = self.__child__(epath)
                     self.entries[fname].HandleEvent(event)
             if action == 'changed':
                 self.entries[fname].HandleEvent(event)
             elif action == 'deleted':
                 if fname in self.entries:
                     del self.entries[fname]
                 else:
                     self.entries[fname].HandleEvent(event)
 
     def get_key(self, entry, metadata):
         """
         either grabs a prexisting key hostfile, or triggers the generation
         of a new key if one doesn't exist.
         """
         # set path type and permissions, otherwise bcfg2 won't bind the file
         permdata = {'owner': 'root',
                     'group': 'root',
                     'type': 'file',
                     'perms': '644'}
         [entry.attrib.__setitem__(key, permdata[key]) for key in permdata]
 
         # check if we already have a hostfile, or need to generate a new key
         # TODO: verify key fits the specs
         path = entry.get('name')
         filename = "".join([path, '/', path.rsplit('/', 1)[1],
                             '.H_', metadata.hostname])
         if filename not in list(self.entries.keys()):
             key = self.build_key(filename, entry, metadata)
             open(self.data + filename, 'w').write(key)
             entry.text = key
             self.entries[filename] = self.__child__("%s%s" % (self.data,
                                                               filename))
             self.entries[filename].HandleEvent()
         else:
             entry.text = self.entries[filename].data
 
     def build_key(self, filename, entry, metadata):
         """
         generates a new key according the the specification
         """
         type = self.key_specs[entry.get('name')]['type']
         bits = self.key_specs[entry.get('name')]['bits']
         if type == 'rsa':
-            cmd = "openssl genrsa %s " % bits
+            cmd = ["openssl", "genrsa", bits]
         elif type == 'dsa':
-            cmd = "openssl dsaparam -noout -genkey %s" % bits
-        key = Popen(cmd, shell=True, stdout=PIPE).stdout.read()
+            cmd = ["openssl", "dsaparam", "-noout", "-genkey", bits]
+        key = Popen(cmd, stdout=PIPE).stdout.read()
         return key
 
     def get_cert(self, entry, metadata):
         """
         either grabs a prexisting cert hostfile, or triggers the generation
         of a new cert if one doesn't exist.
         """
         # set path type and permissions, otherwise bcfg2 won't bind the file
         permdata = {'owner': 'root',
                     'group': 'root',
                     'type': 'file',
                     'perms': '644'}
         [entry.attrib.__setitem__(key, permdata[key]) for key in permdata]
 
         path = entry.get('name')
         filename = "".join([path, '/', path.rsplit('/', 1)[1],
                             '.H_', metadata.hostname])
 
         # first - ensure we have a key to work with
         key = self.cert_specs[entry.get('name')].get('key')
         key_filename = "".join([key, '/', key.rsplit('/', 1)[1],
                                 '.H_', metadata.hostname])
         if key_filename not in self.entries:
             e = lxml.etree.Element('Path')
             e.attrib['name'] = key
             self.core.Bind(e, metadata)
 
         # check if we have a valid hostfile
         if filename in list(self.entries.keys()) and self.verify_cert(filename,
                                                                       key_filename,
                                                                       entry):
             entry.text = self.entries[filename].data
         else:
             cert = self.build_cert(key_filename, entry, metadata)
             open(self.data + filename, 'w').write(cert)
             self.entries[filename] = self.__child__("%s%s" % (self.data,
                                                               filename))
             self.entries[filename].HandleEvent()
             entry.text = cert
 
     def verify_cert(self, filename, key_filename, entry):
         if self.verify_cert_against_ca(filename, entry):
             if self.verify_cert_against_key(filename, key_filename):
                 return True
         return False
 
     def verify_cert_against_ca(self, filename, entry):
         """
         check that a certificate validates against the ca cert,
         and that it has not expired.
         """
         chaincert = self.CAs[self.cert_specs[entry.get('name')]['ca']].get('chaincert')
         cert = self.data + filename
-        cmd = "openssl verify -CAfile %s %s" % (chaincert, cert)
-        res = Popen(cmd, shell=True, stdout=PIPE, stderr=STDOUT).stdout.read()
+        res = Popen(["openssl", "verify", "-CAfile", chaincert, cert],
+                    stdout=PIPE, stderr=STDOUT).stdout.read()
         if res == cert + ": OK\n":
             return True
         return False
 
     def verify_cert_against_key(self, filename, key_filename):
         """
         check that a certificate validates against its private key.
         """
         cert = self.data + filename
         key = self.data + key_filename
-        cmd = "openssl x509 -noout -modulus -in %s | openssl md5" % cert
+        cmd = ("openssl x509 -noout -modulus -in %s | openssl md5" %
+               pipes.quote(cert))
         cert_md5 = Popen(cmd, shell=True, stdout=PIPE, stderr=STDOUT).stdout.read()
-        cmd = "openssl rsa -noout -modulus -in %s | openssl md5" % key
+        cmd = ("openssl rsa -noout -modulus -in %s | openssl md5" %
+               pipes.quote(key))
         key_md5 = Popen(cmd, shell=True, stdout=PIPE, stderr=STDOUT).stdout.read()
         if cert_md5 == key_md5:
             return True
         return False
 
     def build_cert(self, key_filename, entry, metadata):
         """
         creates a new certificate according to the specification
         """
         req_config = self.build_req_config(entry, metadata)
         req = self.build_request(key_filename, req_config, entry)
         ca = self.cert_specs[entry.get('name')]['ca']
         ca_config = self.CAs[ca]['config']
         days = self.cert_specs[entry.get('name')]['days']
         passphrase = self.CAs[ca].get('passphrase')
+        cmd = ["openssl", "ca", "-config", ca_config, "-in", req,
+               "-days", days, "-batch"]
         if passphrase:
-            cmd = "openssl ca -config %s -in %s -days %s -batch -passin pass:%s" % (ca_config,
-                                                                                    req,
-                                                                                    days,
-                                                                                    passphrase)
-        else:
-            cmd = "openssl ca -config %s -in %s -days %s -batch" % (ca_config,
-                                                                    req,
-                                                                    days)
-        cert = Popen(cmd, shell=True, stdout=PIPE).stdout.read()
+            cmd.extend(["-passin", "pass:%s" % passphrase])
+        cert = Popen(cmd, stdout=PIPE).stdout.read()
         try:
             os.unlink(req_config)
             os.unlink(req)
         except OSError:
             self.logger.error("Failed to unlink temporary files")
         return cert
 
     def build_req_config(self, entry, metadata):
         """
         generates a temporary openssl configuration file that is
         used to generate the required certificate request
         """
         # create temp request config file
         conffile = open(tempfile.mkstemp()[1], 'w')
         cp = ConfigParser({})
         cp.optionxform = str
         defaults = {
             'req': {
                 'default_md': 'sha1',
                 'distinguished_name': 'req_distinguished_name',
                 'req_extensions': 'v3_req',
                 'x509_extensions': 'v3_req',
                 'prompt': 'no'
             },
             'req_distinguished_name': {},
             'v3_req': {
                 'subjectAltName': '@alt_names'
             },
             'alt_names': {}
         }
         for section in list(defaults.keys()):
             cp.add_section(section)
             for key in defaults[section]:
                 cp.set(section, key, defaults[section][key])
         x = 1
         altnames = list(metadata.aliases)
         altnames.append(metadata.hostname)
         for altname in altnames:
             cp.set('alt_names', 'DNS.' + str(x), altname)
             x += 1
         for item in ['C', 'L', 'ST', 'O', 'OU', 'emailAddress']:
             if self.cert_specs[entry.get('name')][item]:
                 cp.set('req_distinguished_name', item, self.cert_specs[entry.get('name')][item])
         cp.set('req_distinguished_name', 'CN', metadata.hostname)
         cp.write(conffile)
         conffile.close()
         return conffile.name
 
     def build_request(self, key_filename, req_config, entry):
         """
         creates the certificate request
         """
         req = tempfile.mkstemp()[1]
         days = self.cert_specs[entry.get('name')]['days']
         key = self.data + key_filename
-        cmd = "openssl req -new -config %s -days %s -key %s -text -out %s" % (req_config,
-                                                                              days,
-                                                                              key,
-                                                                              req)
+        cmd = ["openssl", "req", "-new", "-config", req_config,
+               "-days", days, "-key", key, "-text", "-out", req]
         res = Popen(cmd, shell=True, stdout=PIPE).stdout.read()
         return req
diff --git a/src/lib/Server/Plugins/Svn.py b/src/lib/Server/Plugins/Svn.py
index cb4ab64..a127d02 100644
--- a/src/lib/Server/Plugins/Svn.py
+++ b/src/lib/Server/Plugins/Svn.py
@@ -10,37 +10,37 @@ logger = logging.getLogger('Bcfg2.Plugins.Svn')
 class Svn(Bcfg2.Server.Plugin.Plugin,
           Bcfg2.Server.Plugin.Version):
     """Svn is a version plugin for dealing with Bcfg2 repos."""
     name = 'Svn'
     __version__ = '$Id$'
     __author__ = 'bcfg-dev@mcs.anl.gov'
 
     def __init__(self, core, datastore):
         Bcfg2.Server.Plugin.Plugin.__init__(self, core, datastore)
         self.core = core
         self.datastore = datastore
 
         # path to svn directory for bcfg2 repo
         svn_dir = "%s/.svn" % datastore
 
         # Read revision from bcfg2 repo
         if os.path.isdir(svn_dir):
             self.get_revision()
         else:
             logger.error("%s is not a directory" % svn_dir)
             raise Bcfg2.Server.Plugin.PluginInitError
 
         logger.debug("Initialized svn plugin with svn directory = %s" % svn_dir)
 
     def get_revision(self):
         """Read svn revision information for the Bcfg2 repository."""
         try:
             data = Popen(("env LC_ALL=C svn info %s" %
-                         (self.datastore)), shell=True,
+                         pipes.quote(self.datastore)), shell=True,
                          stdout=PIPE).communicate()[0].split('\n')
             return [line.split(': ')[1] for line in data \
                     if line[:9] == 'Revision:'][-1]
         except IndexError:
             logger.error("Failed to read svn info; disabling svn support")
             logger.error('''Ran command "svn info %s"''' % (self.datastore))
             logger.error("Got output: %s" % data)
             raise Bcfg2.Server.Plugin.PluginInitError
