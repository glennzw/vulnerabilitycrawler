   agp: fix OOM and buffer overflow
   
   page_count is copied from userspace.  agp_allocate_memory() tries to
   check whether this number is too big, but doesn't take into account the
   wrap case.  Also agp_create_user_memory() doesn't check whether
   alloc_size is calculated from num_agp_pages variable without overflow.
   This may lead to allocation of too small buffer with following buffer
   overflow.
   
   Another problem in agp code is not addressed in the patch - kernel memory
   exhaustion (AGPIOC_RESERVE and AGPIOC_ALLOCATE ioctls).  It is not checked
   whether requested pid is a pid of the caller (no check in agpioc_reserve_wrap()).
   Each allocation is limited to 16KB, though, there is no per-process limit.
   This might lead to OOM situation, which is not even solved in case of the
   caller death by OOM killer - the memory is allocated for another (faked) process.
   
   Signed-off-by: Vasiliy Kulikov <segoon@openwall.com>
   Signed-off-by: Dave Airlie <airlied@redhat.com>
	struct agp_memory *new;
	unsigned long alloc_size = num_agp_pages*sizeof(struct page *);

	new = kzalloc(sizeof(struct agp_memory), GFP_KERNEL);
	if (new == NULL)
		return NULL;
	int scratch_pages;
	struct agp_memory *new;
	size_t i;

	if (!bridge)
		return NULL;

	if ((atomic_read(&bridge->current_memory_agp) + page_count) > bridge->max_memory_agp)
		return NULL;

	if (type >= AGP_USER_TYPES) {
