commit 1027d5df07398c1507fb1fe3a9981aa6b4bc3a56
Author: Matthias Hopf <mhopf@suse.de>
Date:   Tue Mar 1 19:37:34 2011 +0100

    Create shell-escape-safe cpp options in the non-pathetic-cpp case.
    
    Fixes CVE-2011-0465.
    
    Signed-off-by: Matthias Hopf <mhopf@suse.de>
    Reviewed-by: Adam Jackson <ajax@redhat.com>

diff --git a/xrdb.c b/xrdb.c
index c3ef0fd..ea698b9 100644
--- a/xrdb.c
+++ b/xrdb.c
@@ -142,6 +142,8 @@ static Entries newDB;
 
 static void fatal(char *, ...);
 static void addstring ( String *arg, const char *s );
+static void addescapedstring ( String *arg, const char *s );
+static void addtokstring ( String *arg, const char *s );
 static void FormatEntries ( Buffer *buffer, Entries *entries );
 static void StoreProperty ( Display *dpy, Window root, Atom res_prop );
 static void Process ( int scrno, Bool doScreen, Bool execute );
@@ -416,43 +418,50 @@ static void
 AddDef(String *buff, char *title, char *value)
 {
 #ifdef PATHETICCPP
     if (need_real_defines) {
 	addstring(buff, "\n#define ");
 	addstring(buff, title);
 	if (value && (value[0] != '\0')) {
 	    addstring(buff, " ");
 	    addstring(buff, value);
 	}
 	return;
     }
 #endif
     if (buff->used) {
 	if (oper == OPSYMBOLS)
 	    addstring(buff, "\n-D");
 	else
 	    addstring(buff, " -D");
     } else
 	addstring(buff, "-D");
-    addstring(buff, title);
+    addtokstring(buff, title);
     if (value && (value[0] != '\0')) {
 	addstring(buff, "=");
-	addstring(buff, value);
+	addescapedstring(buff, value);
     }
 }
 
 static void
+AddSimpleDef(String *buff, char *title)
+{
+    AddDef(buff, title, (char *)NULL);
+}
+
+static void
 AddDefQ(String *buff, char *title, char *value)
 {
 #ifdef PATHETICCPP
     if (need_real_defines)
 	AddDef(buff, title, value);
     else
 #endif
     if (value && (value[0] != '\0')) {
-	AddDef(buff, title, "\"");
-	addstring(buff, value);
+	AddSimpleDef(buff, title);
+	addstring(buff, "=\"");
+	addescapedstring(buff, value);
 	addstring(buff, "\"");
     } else
 	AddDef(buff, title, NULL);
 }
 
@@ -465,44 +474,48 @@ AddNum(String *buff, char *title, int value)
 }
 
 static void
-AddSimpleDef(String *buff, char *title)
+AddDefTok(String *buff, char *prefix, char *title)
 {
-    AddDef(buff, title, (char *)NULL);
+    char name[512];
+
+    snprintf(name, sizeof(name), "%s%s", prefix, title);
+    AddSimpleDef(buff, name);
 }
 
 static void
-AddDefTok(String *buff, char *prefix, char *title)
+AddDefHostname(String *buff, char *title, char *value)
 {
     char *s;
     char name[512];
     char c;
 
-    snprintf(name, sizeof(name), "%s%s", prefix, title);
+    strncpy (name, value, sizeof(name)-1);
+    name[sizeof(name)-1] = '\0';
     for (s = name; (c = *s); s++) {
-	if (!isalpha(c) && !isdigit(c) && c != '_')
+	if (!isalpha(c) && !isdigit(c) && c != '_' && c != '.' && c != ':' && c != '-')
 	    *s = '_';
     }
-    AddSimpleDef(buff, name);
+    AddDef(buff, title, name);
 }
 
 static void
 AddUndef(String *buff, char *title)
 {
 #ifdef PATHETICCPP
     if (need_real_defines) {
 	addstring(buff, "\n#undef ");
 	addstring(buff, title);
 	return;
     }
 #endif
     if (buff->used) {
 	if (oper == OPSYMBOLS)
 	    addstring(buff, "\n-U");
 	else
 	    addstring(buff, " -U");
     } else
 	addstring(buff, "-U");
-    addstring(buff, title);
+    addtokstring(buff, title);
 }
 
 static void 
@@ -540,46 +553,46 @@ static void
 DoDisplayDefines(Display *display, String *defs, char *host)
 {
 #ifndef MAXHOSTNAMELEN
 #define MAXHOSTNAMELEN 255
 #endif
     char client[MAXHOSTNAMELEN], server[MAXHOSTNAMELEN], *colon;
     char **extnames;
     int n;
     
     XmuGetHostname(client, MAXHOSTNAMELEN);
     strncpy(server, XDisplayName(host), sizeof(server));
     server[sizeof(server) - 1] = '\0';
     /* search for final colon to skip over any embedded colons in IPv6
        numeric address forms */
     colon = strrchr(server, ':');
     n = 0;
     if (colon) {
 	/* remove extra colon if there are exactly two, since it indicates 
 	   DECnet.  Three colons is an IPv6 address ending in :: though. */
 	if ((colon > server) && (*(colon-1) == ':') &&
 	  ( ((colon - 1) == server) || (*(colon-2) != ':') ) ) {
 	    *(colon-1) = ':';
 	}
 	*colon++ = '\0';
 	sscanf(colon, "%d", &n);
     }
     if (!*server || !strcmp(server, "unix") || !strcmp(server, "localhost"))
 	strcpy(server, client);
-    AddDef(defs, "HOST", server); /* R3 compatibility */
-    AddDef(defs, "SERVERHOST", server);
+    AddDefHostname(defs, "HOST", server); /* R3 compatibility */
+    AddDefHostname(defs, "SERVERHOST", server);
     AddDefTok(defs, "SRVR_", server);
     AddNum(defs, "DISPLAY_NUM", n);
-    AddDef(defs, "CLIENTHOST", client);
+    AddDefHostname(defs, "CLIENTHOST", client);
     AddDefTok(defs, "CLNT_", client);
     AddNum(defs, "VERSION", ProtocolVersion(display));
     AddNum(defs, "REVISION", ProtocolRevision(display));
     AddDefQ(defs, "VENDOR", ServerVendor(display));
     AddDefTok(defs, "VNDR_", ServerVendor(display));
     AddNum(defs, "RELEASE", VendorRelease(display));
     AddNum(defs, "NUM_SCREENS", ScreenCount(display));
     extnames = XListExtensions(display, &n);
     while (--n >= 0)
 	AddDefTok(defs, "EXT_", extnames[n]);
     XFreeExtensionList(extnames);
 }
 
@@ -596,45 +609,45 @@ static void
 DoScreenDefines(Display *display, int scrno, String *defs)
 {
     Screen *screen;
     Visual *visual;
     XVisualInfo vinfo, *vinfos;
     int nv, i, j;
     char name[50];
     
     screen = ScreenOfDisplay(display, scrno);
     visual = DefaultVisualOfScreen(screen);
     vinfo.screen = scrno;
     vinfos = XGetVisualInfo(display, VisualScreenMask, &vinfo, &nv);
     AddNum(defs, "SCREEN_NUM", scrno);
     AddNum(defs, "WIDTH", screen->width);
     AddNum(defs, "HEIGHT", screen->height);
     AddNum(defs, "X_RESOLUTION", Resolution(screen->width,screen->mwidth));
     AddNum(defs, "Y_RESOLUTION", Resolution(screen->height,screen->mheight));
     AddNum(defs, "PLANES", DisplayPlanes(display, scrno));
     AddNum(defs, "BITS_PER_RGB", visual->bits_per_rgb);
-    AddDef(defs, "CLASS", ClassNames[visual->class]);
+    AddDefQ(defs, "CLASS", ClassNames[visual->class]);
     snprintf(name, sizeof(name), "CLASS_%s", ClassNames[visual->class]);
     AddNum(defs, name, (int)visual->visualid);
     switch(visual->class) {
 	case StaticColor:
 	case PseudoColor:
 	case TrueColor:
 	case DirectColor:
 	    AddSimpleDef(defs, "COLOR");
 	    break;
     }
     for (i = 0; i < nv; i++) {
 	for (j = i; --j >= 0; ) {
 	    if (vinfos[j].class == vinfos[i].class &&
 		vinfos[j].depth == vinfos[i].depth)
 		break;
 	}
 	if (j < 0) {
 	    snprintf(name, sizeof(name), "CLASS_%s_%d",
 		    ClassNames[vinfos[i].class], vinfos[i].depth);
 	    AddNum(defs, name, (int)vinfos[i].visualid);
 	}
     }
     XFree((char *)vinfos);
 }
 
@@ -765,298 +778,332 @@ static void
 addstring(String *arg, const char *s)
 {
     if(arg->used + strlen(s) + 1 >= arg->room) {
 	if(arg->val)
 	    arg->val = (char *)realloc(arg->val, arg->room + CHUNK_SIZE);
 	else
 	    arg->val = (char *)malloc(arg->room + CHUNK_SIZE);	    
 	if(arg->val == NULL)
 	    fatal("%s: Not enough memory\n", ProgramName);
 	arg->room += CHUNK_SIZE;
     }
     if(arg->used)
 	strcat(arg->val, s);
     else
 	strcpy(arg->val, s);
     arg->used += strlen(s);
 }   
 
+static void
+addescapedstring(String *arg, const char *s)
+{
+    char copy[512], *c;
+
+    for (c = copy; *s && c < &copy[sizeof(copy)-1]; s++) {
+	switch (*s) {
+	case '"':       case '\'':      case '`':
+	case '$':       case '\\':
+	    *c++ = '_';
+	    break;
+	default:
+	    *c++ = *s;
+	}
+    }
+    *c = 0;
+    addstring (arg, copy);
+}
+
+static void
+addtokstring(String *arg, const char *s)
+{
+    char copy[512], *c;
+
+    for (c = copy; *s && c < &copy[sizeof(copy)-1]; s++) {
+	if (!isalpha(*s) && !isdigit(*s) && *s != '_')
+	    *c++ = '_';
+	else
+	    *c++ = *s;
+    }
+    *c = 0;
+    addstring (arg, copy);
+}
+
 
 int
 main(int argc, char *argv[])
 {
     int i;
     char *displayname = NULL;
     int whichResources = RALL;
     int retainProp = 0;
     FILE *fp = NULL;
     Bool need_newline;
 
     ProgramName = argv[0];
 
     defines.room = defines.used = includes.room = includes.used = 0;
 
     /* initialize the includes String struct */
     addstring(&includes, "");
 
     /* Pick the default cpp to use.  This needs to be done before
      * we parse the command line in order to honor -nocpp which sets
      * it back to NULL.
      */
     if (cpp_program == NULL) {
 	int number_of_elements
 	    = (sizeof cpp_locations) / (sizeof cpp_locations[0]);
 	int j;
 
 	for (j = 0; j < number_of_elements; j++) {
 	    if (access(cpp_locations[j], X_OK) == 0) {
 		cpp_program = cpp_locations[j];
 		break;
 	    }
 	} 
     }
 
     /* needs to be replaced with XrmParseCommand */
 
     for (i = 1; i < argc; i++) {
 	char *arg = argv[i];
 
 	if (arg[0] == '-') {
 	    if (arg[1] == '\0') {
 		filename = NULL;
 		continue;
 	    } else if (isabbreviation ("-help", arg, 2)) {
 		Syntax ();
 		/* doesn't return */
 	    } else if (isabbreviation ("-display", arg, 2)) {
 		if (++i >= argc) Syntax ();
 		displayname = argv[i];
 		continue;
 	    } else if (isabbreviation ("-geometry", arg, 3)) {
 		if (++i >= argc) Syntax ();
 		/* ignore geometry */
 		continue;
 	    } else if (isabbreviation ("-cpp", arg, 2)) {
 		if (++i >= argc) Syntax ();
 		cpp_program = argv[i];
 		continue;
 	    } else if (!strcmp ("-n", arg)) {
 		dont_execute = True;
 		continue;
 	    } else if (isabbreviation ("-nocpp", arg, 3)) {
 		cpp_program = NULL;
 		continue;
 	    } else if (isabbreviation ("-query", arg, 2)) {
 		oper = OPQUERY;
 		continue;
 	    } else if (isabbreviation ("-load", arg, 2)) {
 		oper = OPLOAD;
 		continue;
 	    } else if (isabbreviation ("-merge", arg, 2)) {
 		oper = OPMERGE;
 		continue;
 	    } else if (isabbreviation ("-override", arg, 2)) {
 		oper = OPOVERRIDE;
 		continue;
 	    } else if (isabbreviation ("-symbols", arg, 3)) {
 		oper = OPSYMBOLS;
 		continue;
 	    } else if (isabbreviation ("-remove", arg, 4)) {
 		oper = OPREMOVE;
 		continue;
 	    } else if (isabbreviation ("-edit", arg, 2)) {
 		if (++i >= argc) Syntax ();
 		oper = OPEDIT;
 		editFile = argv[i];
 		continue;
 	    } else if (isabbreviation ("-backup", arg, 2)) {
 		if (++i >= argc) Syntax ();
 		backup_suffix = argv[i];
 		continue;
 	    } else if (isabbreviation ("-all", arg, 2)) {
 		whichResources = RALL;
 		continue;
 	    } else if (isabbreviation ("-global", arg, 3)) {
 		whichResources = RGLOBAL;
 		continue;
 	    } else if (isabbreviation ("-screen", arg, 3)) {
 		whichResources = RSCREEN;
 		continue;
 	    } else if (!strcmp ("-screens", arg)) {
 		whichResources = RSCREENS;
 		continue;
 	    } else if (isabbreviation ("-retain", arg, 4)) {
 		retainProp = 1;
 		continue;
 	    } else if (isabbreviation ("-quiet", arg, 2)) {
 		quiet = True;
 		continue;
 	    } else if (arg[1] == 'I') {
 		addstring(&includes, " ");
-		addstring(&includes, arg);
+		addescapedstring(&includes, arg);
 		continue;
 	    } else if (arg[1] == 'U' || arg[1] == 'D') {
 		if (num_cmd_defines < MAX_CMD_DEFINES) {
 		    cmd_defines[num_cmd_defines++] = arg;
 		} else {
 		    fatal("%s: Too many -U/-D arguments\n", ProgramName);
 		}
 		continue;
 	    }
 	    Syntax ();
 	} else if (arg[0] == '=') 
 	    continue;
 	else
 	    filename = arg;
     }							/* end for */
 
 #ifndef WIN32
     while ((i = open("/dev/null", O_RDONLY)) < 3)
 	; /* make sure later freopen won't clobber things */
     (void) close(i);
 #endif
     /* Open display  */
     if (!(dpy = XOpenDisplay (displayname)))
 	fatal("%s: Can't open display '%s'\n", ProgramName,
 		 XDisplayName (displayname));
 
     if (whichResources == RALL && ScreenCount(dpy) == 1)
 	whichResources = RGLOBAL;
 
 #ifdef PATHETICCPP
     if (cpp_program &&
 	(oper == OPLOAD || oper == OPMERGE || oper == OPOVERRIDE)) {
 	need_real_defines = True;
 #ifdef WIN32
 	strcpy(tmpname2, "xrdbD_XXXXXX");
 	strcpy(tmpname3, "\\temp\\xrdbD_XXXXXX");
 #else
 #ifdef __UNIXOS2__
 	{ char *tmpdir=getenv("TMP");
 	  if (!tmpdir) tmpdir="/";
 	  sprintf(tmpname2, "%s/xrdbD_XXXXXX",tmpdir);
 	}
 #else
 	strcpy(tmpname2, "/tmp/xrdbD_XXXXXX");
 #endif
 #endif
 	(void) mktemp(tmpname2);
     }
 #endif
 
     if (!filename &&
 #ifdef PATHETICCPP
 	need_real_defines
 #else
 	(oper == OPLOAD || oper == OPMERGE || oper == OPOVERRIDE) &&
 	(whichResources == RALL || whichResources == RSCREENS)
 #endif
 	) {
 	char inputbuf[1024];
 #ifdef WIN32
 	strcpy(tmpname, "\\temp\\xrdb_XXXXXX");
 #else
 #ifdef __UNIXOS2__
 	{ char *tmpdir=getenv("TMP");
 	  if (!tmpdir) tmpdir="/";
 	  sprintf(tmpname, "%s/xrdb_XXXXXX",tmpdir);
 	}
 #else
 	strcpy(tmpname, "/tmp/xrdb_XXXXXX");
 #endif
 #endif
 #ifndef HAVE_MKSTEMP
 	(void) mktemp(tmpname);
 	filename = tmpname;
 	fp = fopen(filename, "w");
 #else
 	{
 	int fd = mkstemp(tmpname);
 	filename = tmpname;
 	fp = fdopen(fd, "w");
 	}
 #endif /* MKSTEMP */
 	if (!fp)
 	    fatal("%s: Failed to open temp file: %s\n", ProgramName,
 		  filename);
 	while (fgets(inputbuf, sizeof(inputbuf), stdin) != NULL) 
 	    fputs(inputbuf, fp);
 	fclose(fp);
     }
 	
     DoDisplayDefines(dpy, &defines, displayname);
     defines_base = defines.used;
     need_newline = (oper == OPQUERY || oper == OPSYMBOLS ||
 		    (dont_execute && oper != OPREMOVE));
     InitBuffer(&buffer);
     if (whichResources == RGLOBAL)
 	Process(DefaultScreen(dpy), False, True);
     else if (whichResources == RSCREEN)
 	Process(DefaultScreen(dpy), True, True);
     else if (whichResources == RSCREENS ||
 	     (oper != OPLOAD && oper != OPMERGE && oper != OPOVERRIDE)) {
 	if (whichResources == RALL && oper != OPSYMBOLS) {
 	    if (need_newline)
 		printf("! screen-independent resources\n");
 	    Process(0, False, True);
 	    if (need_newline)
 		printf("\n");
 	}
 	for (i = 0; i < ScreenCount(dpy); i++) {
 	    if (need_newline) {
 		if (oper == OPSYMBOLS)
 		    printf("# screen %d symbols\n", i);
 		else {
 		    printf("! screen %d resources\n", i);
 		    printf("#if SCREEN_NUM == %d\n", i);
 		}
 	    }
 	    Process(i, True, True);
 	    if (need_newline) {
 		if (oper != OPSYMBOLS)
 		    printf("#endif\n");
 		if (i+1 != ScreenCount(dpy))
 		    printf("\n");
 	    }
 	}
     }
     else {
 	Entries *dbs;
 
 	dbs = (Entries *)malloc(ScreenCount(dpy) * sizeof(Entries));
 	for (i = 0; i < ScreenCount(dpy); i++) {
 	    Process(i, True, False);
 	    dbs[i] = newDB;
 	}
 	InitEntries(&newDB);
 	if (oper == OPMERGE || oper == OPOVERRIDE)
 	    GetEntriesString(&newDB, XResourceManagerString(dpy));
 	ShuffleEntries(&newDB, dbs, ScreenCount(dpy));
 	if (need_newline)
 	    printf("! screen-independent resources\n");
 	ReProcess(0, False);
 	if (need_newline)
 	    printf("\n");
 	for (i = 0; i < ScreenCount(dpy); i++) {
 	    newDB = dbs[i];
 	    if (need_newline) {
 		printf("! screen %d resources\n", i);
 		printf("#if SCREEN_NUM == %d\n", i);
 	    }
 	    ReProcess(i, True);
 	    if (need_newline) {
 		printf("#endif\n");
 		if (i+1 != ScreenCount(dpy))
 		    printf("\n");
 	    }
 	}
     }
 
     if (fp)
 	unlink(filename);
     if (retainProp)
 	XSetCloseDownMode(dpy, RetainPermanent);
     XCloseDisplay(dpy);
     exit (0);
 }
 
 
