commit 8a39f411dc3c806422785b1f4d5c7c9d58e4bf85
Author: Aaron Patterson <aaron.patterson@gmail.com>
Date:   Tue Aug 16 15:17:17 2011 -0700

    prevent sql injection attacks by escaping quotes in column names

diff --git a/activerecord/lib/active_record/connection_adapters/mysql2_adapter.rb b/activerecord/lib/active_record/connection_adapters/mysql2_adapter.rb
index ae5ae16..ef51f5e 100644
--- a/activerecord/lib/active_record/connection_adapters/mysql2_adapter.rb
+++ b/activerecord/lib/active_record/connection_adapters/mysql2_adapter.rb
@@ -6,688 +6,688 @@ require 'mysql2'
 module ActiveRecord
   class Base
     # Establishes a connection to the database that's used by all Active Record objects.
     def self.mysql2_connection(config)
       config[:username] = 'root' if config[:username].nil?
 
       if Mysql2::Client.const_defined? :FOUND_ROWS
         config[:flags] = Mysql2::Client::FOUND_ROWS
       end
 
       client = Mysql2::Client.new(config.symbolize_keys)
       options = [config[:host], config[:username], config[:password], config[:database], config[:port], config[:socket], 0]
       ConnectionAdapters::Mysql2Adapter.new(client, logger, options, config)
     end
   end
 
   module ConnectionAdapters
     class Mysql2IndexDefinition < Struct.new(:table, :name, :unique, :columns, :lengths) #:nodoc:
     end
 
     class Mysql2Column < Column
       BOOL = "tinyint(1)"
       def extract_default(default)
         if sql_type =~ /blob/i || type == :text
           if default.blank?
             return null ? nil : ''
           else
             raise ArgumentError, "#{type} columns cannot have a default value: #{default.inspect}"
           end
         elsif missing_default_forged_as_empty_string?(default)
           nil
         else
           super
         end
       end
 
       def has_default?
         return false if sql_type =~ /blob/i || type == :text #mysql forbids defaults on blob and text columns
         super
       end
 
       private
         def simplified_type(field_type)
           return :boolean if Mysql2Adapter.emulate_booleans && field_type.downcase.index(BOOL)
 
           case field_type
           when /enum/i, /set/i then :string
           when /year/i         then :integer
           when /bit/i          then :binary
           else
             super
           end
         end
 
         def extract_limit(sql_type)
           case sql_type
           when /blob|text/i
             case sql_type
             when /tiny/i
               255
             when /medium/i
               16777215
             when /long/i
               2147483647 # mysql only allows 2^31-1, not 2^32-1, somewhat inconsistently with the tiny/medium/normal cases
             else
               super # we could return 65535 here, but we leave it undecorated by default
             end
           when /^bigint/i;    8
           when /^int/i;       4
           when /^mediumint/i; 3
           when /^smallint/i;  2
           when /^tinyint/i;   1
           else
             super
           end
         end
 
         # MySQL misreports NOT NULL column default when none is given.
         # We can't detect this for columns which may have a legitimate ''
         # default (string) but we can for others (integer, datetime, boolean,
         # and the rest).
         #
         # Test whether the column has default '', is not null, and is not
         # a type allowing default ''.
         def missing_default_forged_as_empty_string?(default)
           type != :string && !null && default == ''
         end
     end
 
     class Mysql2Adapter < AbstractAdapter
       cattr_accessor :emulate_booleans
       self.emulate_booleans = true
 
       ADAPTER_NAME = 'Mysql2'
       PRIMARY = "PRIMARY"
 
       LOST_CONNECTION_ERROR_MESSAGES = [
         "Server shutdown in progress",
         "Broken pipe",
         "Lost connection to MySQL server during query",
         "MySQL server has gone away" ]
 
       QUOTED_TRUE, QUOTED_FALSE = '1', '0'
 
       NATIVE_DATABASE_TYPES = {
         :primary_key => "int(11) DEFAULT NULL auto_increment PRIMARY KEY",
         :string      => { :name => "varchar", :limit => 255 },
         :text        => { :name => "text" },
         :integer     => { :name => "int", :limit => 4 },
         :float       => { :name => "float" },
         :decimal     => { :name => "decimal" },
         :datetime    => { :name => "datetime" },
         :timestamp   => { :name => "datetime" },
         :time        => { :name => "time" },
         :date        => { :name => "date" },
         :binary      => { :name => "blob" },
         :boolean     => { :name => "tinyint", :limit => 1 }
       }
 
       def initialize(connection, logger, connection_options, config)
         super(connection, logger)
         @connection_options, @config = connection_options, config
         @quoted_column_names, @quoted_table_names = {}, {}
         configure_connection
       end
 
       def self.visitor_for(pool) # :nodoc:
         Arel::Visitors::MySQL.new(pool)
       end
 
       def adapter_name
         ADAPTER_NAME
       end
 
       # Returns true, since this connection adapter supports migrations.
       def supports_migrations?
         true
       end
 
       def supports_primary_key?
         true
       end
 
       # Returns true, since this connection adapter supports savepoints.
       def supports_savepoints?
         true
       end
 
       def native_database_types
         NATIVE_DATABASE_TYPES
       end
 
       # QUOTING ==================================================
 
       def quote(value, column = nil)
         if value.kind_of?(String) && column && column.type == :binary && column.class.respond_to?(:string_to_binary)
           s = column.class.string_to_binary(value).unpack("H*")[0]
           "x'#{s}'"
         elsif value.kind_of?(BigDecimal)
           value.to_s("F")
         else
           super
         end
       end
 
       def quote_column_name(name) #:nodoc:
-        @quoted_column_names[name] ||= "`#{name}`"
+        @quoted_column_names[name] ||= "`#{name.to_s.gsub('`', '``')}`"
       end
 
       def quote_table_name(name) #:nodoc:
         @quoted_table_names[name] ||= quote_column_name(name).gsub('.', '`.`')
       end
 
       def quote_string(string)
         @connection.escape(string)
       end
 
       def quoted_true
         QUOTED_TRUE
       end
 
       def quoted_false
         QUOTED_FALSE
       end
 
       def substitute_at(column, index)
         Arel.sql "\0"
       end
 
       # REFERENTIAL INTEGRITY ====================================
 
       def disable_referential_integrity(&block) #:nodoc:
         old = select_value("SELECT @@FOREIGN_KEY_CHECKS")
 
         begin
           update("SET FOREIGN_KEY_CHECKS = 0")
           yield
         ensure
           update("SET FOREIGN_KEY_CHECKS = #{old}")
         end
       end
 
       # CONNECTION MANAGEMENT ====================================
 
       def active?
         return false unless @connection
         @connection.ping
       end
 
       def reconnect!
         disconnect!
         connect
       end
 
       # this is set to true in 2.3, but we don't want it to be
       def requires_reloading?
         false
       end
 
       # Disconnects from the database if already connected.
       # Otherwise, this method does nothing.
       def disconnect!
         unless @connection.nil?
           @connection.close
           @connection = nil
         end
       end
 
       def reset!
         disconnect!
         connect
       end
 
       # DATABASE STATEMENTS ======================================
 
       # FIXME: re-enable the following once a "better" query_cache solution is in core
       #
       # The overrides below perform much better than the originals in AbstractAdapter
       # because we're able to take advantage of mysql2's lazy-loading capabilities
       #
       # # Returns a record hash with the column names as keys and column values
       # # as values.
       # def select_one(sql, name = nil)
       #   result = execute(sql, name)
       #   result.each(:as => :hash) do |r|
       #     return r
       #   end
       # end
       #
       # # Returns a single value from a record
       # def select_value(sql, name = nil)
       #   result = execute(sql, name)
       #   if first = result.first
       #     first.first
       #   end
       # end
       #
       # # Returns an array of the values of the first column in a select:
       # #   select_values("SELECT id FROM companies LIMIT 3") => [1,2,3]
       # def select_values(sql, name = nil)
       #   execute(sql, name).map { |row| row.first }
       # end
 
       # Returns an array of arrays containing the field values.
       # Order is the same as that returned by +columns+.
       def select_rows(sql, name = nil)
         execute(sql, name).to_a
       end
 
       # Executes the SQL statement in the context of this connection.
       def execute(sql, name = nil)
         # make sure we carry over any changes to ActiveRecord::Base.default_timezone that have been
         # made since we established the connection
         @connection.query_options[:database_timezone] = ActiveRecord::Base.default_timezone
         if name == :skip_logging
           @connection.query(sql)
         else
           log(sql, name) { @connection.query(sql) }
         end
       rescue ActiveRecord::StatementInvalid => exception
         if exception.message.split(":").first =~ /Packets out of order/
           raise ActiveRecord::StatementInvalid, "'Packets out of order' error was received from the database. Please update your mysql bindings (gem install mysql) and read http://dev.mysql.com/doc/mysql/en/password-hashing.html for more information. If you're on Windows, use the Instant Rails installer to get the updated mysql bindings."
         else
           raise
         end
       end
 
       def insert_sql(sql, name = nil, pk = nil, id_value = nil, sequence_name = nil)
         super
         id_value || @connection.last_id
       end
       alias :create :insert_sql
 
       def exec_insert(sql, name, binds)
         binds = binds.dup
 
         # Pretend to support bind parameters
         execute sql.gsub("\0") { quote(*binds.shift.reverse) }, name
       end
 
       def exec_delete(sql, name, binds)
         binds = binds.dup
 
         # Pretend to support bind parameters
         execute sql.gsub("\0") { quote(*binds.shift.reverse) }, name
         @connection.affected_rows
       end
       alias :exec_update :exec_delete
 
       def last_inserted_id(result)
         @connection.last_id
       end
 
       def update_sql(sql, name = nil)
         super
         @connection.affected_rows
       end
 
       def begin_db_transaction
         execute "BEGIN"
       rescue Exception
         # Transactions aren't supported
       end
 
       def commit_db_transaction
         execute "COMMIT"
       rescue Exception
         # Transactions aren't supported
       end
 
       def rollback_db_transaction
         execute "ROLLBACK"
       rescue Exception
         # Transactions aren't supported
       end
 
       def create_savepoint
         execute("SAVEPOINT #{current_savepoint_name}")
       end
 
       def rollback_to_savepoint
         execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
       end
 
       def release_savepoint
         execute("RELEASE SAVEPOINT #{current_savepoint_name}")
       end
 
       # SCHEMA STATEMENTS ========================================
 
       def structure_dump
         if supports_views?
           sql = "SHOW FULL TABLES WHERE Table_type = 'BASE TABLE'"
         else
           sql = "SHOW TABLES"
         end
 
         select_all(sql).inject("") do |structure, table|
           table.delete('Table_type')
           structure += select_one("SHOW CREATE TABLE #{quote_table_name(table.to_a.first.last)}")["Create Table"] + ";\n\n"
         end
       end
 
       # Drops the database specified on the +name+ attribute
       # and creates it again using the provided +options+.
       def recreate_database(name, options = {})
         drop_database(name)
         create_database(name, options)
       end
 
       # Create a new MySQL database with optional <tt>:charset</tt> and <tt>:collation</tt>.
       # Charset defaults to utf8.
       #
       # Example:
       #   create_database 'charset_test', :charset => 'latin1', :collation => 'latin1_bin'
       #   create_database 'matt_development'
       #   create_database 'matt_development', :charset => :big5
       def create_database(name, options = {})
         if options[:collation]
           execute "CREATE DATABASE `#{name}` DEFAULT CHARACTER SET `#{options[:charset] || 'utf8'}` COLLATE `#{options[:collation]}`"
         else
           execute "CREATE DATABASE `#{name}` DEFAULT CHARACTER SET `#{options[:charset] || 'utf8'}`"
         end
       end
 
       # Drops a MySQL database.
       #
       # Example:
       #   drop_database('sebastian_development')
       def drop_database(name) #:nodoc:
         execute "DROP DATABASE IF EXISTS `#{name}`"
       end
 
       def current_database
         select_value 'SELECT DATABASE() as db'
       end
 
       # Returns the database character set.
       def charset
         show_variable 'character_set_database'
       end
 
       # Returns the database collation strategy.
       def collation
         show_variable 'collation_database'
       end
 
       def tables(name = nil, database = nil) #:nodoc:
         sql = ["SHOW TABLES", database].compact.join(' IN ')
         execute(sql, 'SCHEMA').collect do |field|
           field.first
         end
       end
 
       def table_exists?(name)
         return true if super
 
         name          = name.to_s
         schema, table = name.split('.', 2)
 
         unless table # A table was provided without a schema
           table  = schema
           schema = nil
         end
 
         tables(nil, schema).include? table
       end
 
       # Returns an array of indexes for the given table.
       def indexes(table_name, name = nil)
         indexes = []
         current_index = nil
         result = execute("SHOW KEYS FROM #{quote_table_name(table_name)}", 'SCHEMA')
         result.each(:symbolize_keys => true, :as => :hash) do |row|
           if current_index != row[:Key_name]
             next if row[:Key_name] == PRIMARY # skip the primary key
             current_index = row[:Key_name]
             indexes << Mysql2IndexDefinition.new(row[:Table], row[:Key_name], row[:Non_unique] == 0, [], [])
           end
 
           indexes.last.columns << row[:Column_name]
           indexes.last.lengths << row[:Sub_part]
         end
         indexes
       end
 
       # Returns an array of +Mysql2Column+ objects for the table specified by +table_name+.
       def columns(table_name, name = nil)
         sql = "SHOW FIELDS FROM #{quote_table_name(table_name)}"
         columns = []
         result = execute(sql, 'SCHEMA')
         result.each(:symbolize_keys => true, :as => :hash) { |field|
           columns << Mysql2Column.new(field[:Field], field[:Default], field[:Type], field[:Null] == "YES")
         }
         columns
       end
 
       def create_table(table_name, options = {})
         super(table_name, options.reverse_merge(:options => "ENGINE=InnoDB"))
       end
 
       # Renames a table.
       #
       # Example:
       #   rename_table('octopuses', 'octopi')
       def rename_table(table_name, new_name)
         execute "RENAME TABLE #{quote_table_name(table_name)} TO #{quote_table_name(new_name)}"
       end
 
       def add_column(table_name, column_name, type, options = {})
         add_column_sql = "ALTER TABLE #{quote_table_name(table_name)} ADD #{quote_column_name(column_name)} #{type_to_sql(type, options[:limit], options[:precision], options[:scale])}"
         add_column_options!(add_column_sql, options)
         add_column_position!(add_column_sql, options)
         execute(add_column_sql)
       end
 
       def change_column_default(table_name, column_name, default)
         column = column_for(table_name, column_name)
         change_column table_name, column_name, column.sql_type, :default => default
       end
 
       def change_column_null(table_name, column_name, null, default = nil)
         column = column_for(table_name, column_name)
 
         unless null || default.nil?
           execute("UPDATE #{quote_table_name(table_name)} SET #{quote_column_name(column_name)}=#{quote(default)} WHERE #{quote_column_name(column_name)} IS NULL")
         end
 
         change_column table_name, column_name, column.sql_type, :null => null
       end
 
       def change_column(table_name, column_name, type, options = {})
         column = column_for(table_name, column_name)
 
         unless options_include_default?(options)
           options[:default] = column.default
         end
 
         unless options.has_key?(:null)
           options[:null] = column.null
         end
 
         change_column_sql = "ALTER TABLE #{quote_table_name(table_name)} CHANGE #{quote_column_name(column_name)} #{quote_column_name(column_name)} #{type_to_sql(type, options[:limit], options[:precision], options[:scale])}"
         add_column_options!(change_column_sql, options)
         add_column_position!(change_column_sql, options)
         execute(change_column_sql)
       end
 
       def rename_column(table_name, column_name, new_column_name)
         options = {}
         if column = columns(table_name).find { |c| c.name == column_name.to_s }
           options[:default] = column.default
           options[:null] = column.null
         else
           raise ActiveRecordError, "No such column: #{table_name}.#{column_name}"
         end
         current_type = select_one("SHOW COLUMNS FROM #{quote_table_name(table_name)} LIKE '#{column_name}'")["Type"]
         rename_column_sql = "ALTER TABLE #{quote_table_name(table_name)} CHANGE #{quote_column_name(column_name)} #{quote_column_name(new_column_name)} #{current_type}"
         add_column_options!(rename_column_sql, options)
         execute(rename_column_sql)
       end
 
       # Maps logical Rails types to MySQL-specific data types.
       def type_to_sql(type, limit = nil, precision = nil, scale = nil)
         return super unless type.to_s == 'integer'
 
         case limit
         when 1; 'tinyint'
         when 2; 'smallint'
         when 3; 'mediumint'
         when nil, 4, 11; 'int(11)'  # compatibility with MySQL default
         when 5..8; 'bigint'
         else raise(ActiveRecordError, "No integer type has byte size #{limit}")
         end
       end
 
       def add_column_position!(sql, options)
         if options[:first]
           sql << " FIRST"
         elsif options[:after]
           sql << " AFTER #{quote_column_name(options[:after])}"
         end
       end
 
       # SHOW VARIABLES LIKE 'name'.
       def show_variable(name)
         variables = select_all("SHOW VARIABLES LIKE '#{name}'")
         variables.first['Value'] unless variables.empty?
       end
 
       # Returns a table's primary key and belonging sequence.
       def pk_and_sequence_for(table)
         keys = []
         result = execute("DESCRIBE #{quote_table_name(table)}", 'SCHEMA')
         result.each(:symbolize_keys => true, :as => :hash) do |row|
           keys << row[:Field] if row[:Key] == "PRI"
         end
         keys.length == 1 ? [keys.first, nil] : nil
       end
 
       # Returns just a table's primary key
       def primary_key(table)
         pk_and_sequence = pk_and_sequence_for(table)
         pk_and_sequence && pk_and_sequence.first
       end
 
       def case_sensitive_modifier(node)
         Arel::Nodes::Bin.new(node)
       end
 
       def limited_update_conditions(where_sql, quoted_table_name, quoted_primary_key)
         where_sql
       end
 
       # In the simple case, MySQL allows us to place JOINs directly into the UPDATE
       # query. However, this does not allow for LIMIT, OFFSET and ORDER. To support
       # these, we must use a subquery. However, MySQL is too stupid to create a
       # temporary table for this automatically, so we have to give it some prompting
       # in the form of a subsubquery. Ugh!
       def join_to_update(update, select) #:nodoc:
         if select.limit || select.offset || select.orders.any?
           subsubselect = select.clone
           subsubselect.projections = [update.key]
 
           subselect = Arel::SelectManager.new(select.engine)
           subselect.project Arel.sql(update.key.name)
           subselect.from subsubselect.as('__active_record_temp')
 
           update.where update.key.in(subselect)
         else
           update.table select.source
           update.wheres = select.constraints
         end
       end
 
       protected
         def quoted_columns_for_index(column_names, options = {})
           length = options[:length] if options.is_a?(Hash)
 
           case length
           when Hash
             column_names.map {|name| length[name] ? "#{quote_column_name(name)}(#{length[name]})" : quote_column_name(name) }
           when Fixnum
             column_names.map {|name| "#{quote_column_name(name)}(#{length})"}
           else
             column_names.map {|name| quote_column_name(name) }
           end
         end
 
         def translate_exception(exception, message)
           return super unless exception.respond_to?(:error_number)
 
           case exception.error_number
           when 1062
             RecordNotUnique.new(message, exception)
           when 1452
             InvalidForeignKey.new(message, exception)
           else
             super
           end
         end
 
       private
         def connect
           @connection = Mysql2::Client.new(@config)
           configure_connection
         end
 
         def configure_connection
           @connection.query_options.merge!(:as => :array)
 
           # By default, MySQL 'where id is null' selects the last inserted id.
           # Turn this off. http://dev.rubyonrails.org/ticket/6778
           variable_assignments = ['SQL_AUTO_IS_NULL=0']
           encoding = @config[:encoding]
 
           # make sure we set the encoding
           variable_assignments << "NAMES '#{encoding}'" if encoding
 
           # increase timeout so mysql server doesn't disconnect us
           wait_timeout = @config[:wait_timeout]
           wait_timeout = 2592000 unless wait_timeout.is_a?(Fixnum)
           variable_assignments << "@@wait_timeout = #{wait_timeout}"
 
           execute("SET #{variable_assignments.join(', ')}", :skip_logging)
         end
 
         # Returns an array of record hashes with the column names as keys and
         # column values as values.
         def select(sql, name = nil, binds = [])
           binds = binds.dup
           exec_query(sql.gsub("\0") { quote(*binds.shift.reverse) }, name).to_a
         end
 
         def exec_query(sql, name = 'SQL', binds = [])
           @connection.query_options[:database_timezone] = ActiveRecord::Base.default_timezone
 
           log(sql, name, binds) do
             begin
               result = @connection.query(sql)
             rescue ActiveRecord::StatementInvalid => exception
               if exception.message.split(":").first =~ /Packets out of order/
                 raise ActiveRecord::StatementInvalid, "'Packets out of order' error was received from the database. Please update your mysql bindings (gem install mysql) and read http://dev.mysql.com/doc/mysql/en/password-hashing.html for more information. If you're on Windows, use the Instant Rails installer to get the updated mysql bindings."
               else
                 raise
               end
             end
 
             ActiveRecord::Result.new(result.fields, result.to_a)
           end
         end
 
         def supports_views?
           version[0] >= 5
         end
 
         def version
           @version ||= @connection.info[:version].scan(/^(\d+)\.(\d+)\.(\d+)/).flatten.map { |v| v.to_i }
         end
 
         def column_for(table_name, column_name)
           unless column = columns(table_name).find { |c| c.name == column_name.to_s }
             raise "No such column: #{table_name}.#{column_name}"
           end
           column
         end
     end
   end
diff --git a/activerecord/lib/active_record/connection_adapters/mysql_adapter.rb b/activerecord/lib/active_record/connection_adapters/mysql_adapter.rb
index a44ac08..b844e5a 100644
--- a/activerecord/lib/active_record/connection_adapters/mysql_adapter.rb
+++ b/activerecord/lib/active_record/connection_adapters/mysql_adapter.rb
@@ -20,897 +20,897 @@ end
 module ActiveRecord
   class Base
     # Establishes a connection to the database that's used by all Active Record objects.
     def self.mysql_connection(config) # :nodoc:
       config = config.symbolize_keys
       host     = config[:host]
       port     = config[:port]
       socket   = config[:socket]
       username = config[:username] ? config[:username].to_s : 'root'
       password = config[:password].to_s
       database = config[:database]
 
       mysql = Mysql.init
       mysql.ssl_set(config[:sslkey], config[:sslcert], config[:sslca], config[:sslcapath], config[:sslcipher]) if config[:sslca] || config[:sslkey]
 
       default_flags = Mysql.const_defined?(:CLIENT_MULTI_RESULTS) ? Mysql::CLIENT_MULTI_RESULTS : 0
       default_flags |= Mysql::CLIENT_FOUND_ROWS if Mysql.const_defined?(:CLIENT_FOUND_ROWS)
       options = [host, username, password, database, port, socket, default_flags]
       ConnectionAdapters::MysqlAdapter.new(mysql, logger, options, config)
     end
   end
 
   module ConnectionAdapters
     class MysqlColumn < Column #:nodoc:
       class << self
         def string_to_time(value)
           return super unless Mysql::Time === value
           new_time(
             value.year,
             value.month,
             value.day,
             value.hour,
             value.minute,
             value.second,
             value.second_part)
         end
 
         def string_to_dummy_time(v)
           return super unless Mysql::Time === v
           new_time(2000, 01, 01, v.hour, v.minute, v.second, v.second_part)
         end
 
         def string_to_date(v)
           return super unless Mysql::Time === v
           new_date(v.year, v.month, v.day)
         end
       end
 
       def extract_default(default)
         if sql_type =~ /blob/i || type == :text
           if default.blank?
             return null ? nil : ''
           else
             raise ArgumentError, "#{type} columns cannot have a default value: #{default.inspect}"
           end
         elsif missing_default_forged_as_empty_string?(default)
           nil
         else
           super
         end
       end
 
       def has_default?
         return false if sql_type =~ /blob/i || type == :text #mysql forbids defaults on blob and text columns
         super
       end
 
       private
         def simplified_type(field_type)
           return :boolean if MysqlAdapter.emulate_booleans && field_type.downcase.index("tinyint(1)")
           return :string  if field_type =~ /enum/i
           super
         end
 
         def extract_limit(sql_type)
           case sql_type
           when /blob|text/i
             case sql_type
             when /tiny/i
               255
             when /medium/i
               16777215
             when /long/i
               2147483647 # mysql only allows 2^31-1, not 2^32-1, somewhat inconsistently with the tiny/medium/normal cases
             else
               super # we could return 65535 here, but we leave it undecorated by default
             end
           when /^bigint/i;    8
           when /^int/i;       4
           when /^mediumint/i; 3
           when /^smallint/i;  2
           when /^tinyint/i;   1
           else
             super
           end
         end
 
         # MySQL misreports NOT NULL column default when none is given.
         # We can't detect this for columns which may have a legitimate ''
         # default (string) but we can for others (integer, datetime, boolean,
         # and the rest).
         #
         # Test whether the column has default '', is not null, and is not
         # a type allowing default ''.
         def missing_default_forged_as_empty_string?(default)
           type != :string && !null && default == ''
         end
     end
 
     # The MySQL adapter will work with both Ruby/MySQL, which is a Ruby-based MySQL adapter that comes bundled with Active Record, and with
     # the faster C-based MySQL/Ruby adapter (available both as a gem and from http://www.tmtm.org/en/mysql/ruby/).
     #
     # Options:
     #
     # * <tt>:host</tt> - Defaults to "localhost".
     # * <tt>:port</tt> - Defaults to 3306.
     # * <tt>:socket</tt> - Defaults to "/tmp/mysql.sock".
     # * <tt>:username</tt> - Defaults to "root"
     # * <tt>:password</tt> - Defaults to nothing.
     # * <tt>:database</tt> - The name of the database. No default, must be provided.
     # * <tt>:encoding</tt> - (Optional) Sets the client encoding by executing "SET NAMES <encoding>" after connection.
     # * <tt>:reconnect</tt> - Defaults to false (See MySQL documentation: http://dev.mysql.com/doc/refman/5.0/en/auto-reconnect.html).
     # * <tt>:sslca</tt> - Necessary to use MySQL with an SSL connection.
     # * <tt>:sslkey</tt> - Necessary to use MySQL with an SSL connection.
     # * <tt>:sslcert</tt> - Necessary to use MySQL with an SSL connection.
     # * <tt>:sslcapath</tt> - Necessary to use MySQL with an SSL connection.
     # * <tt>:sslcipher</tt> - Necessary to use MySQL with an SSL connection.
     #
     class MysqlAdapter < AbstractAdapter
 
       ##
       # :singleton-method:
       # By default, the MysqlAdapter will consider all columns of type <tt>tinyint(1)</tt>
       # as boolean. If you wish to disable this emulation (which was the default
       # behavior in versions 0.13.1 and earlier) you can add the following line
       # to your application.rb file:
       #
       #   ActiveRecord::ConnectionAdapters::MysqlAdapter.emulate_booleans = false
       cattr_accessor :emulate_booleans
       self.emulate_booleans = true
 
       ADAPTER_NAME = 'MySQL'
 
       LOST_CONNECTION_ERROR_MESSAGES = [
         "Server shutdown in progress",
         "Broken pipe",
         "Lost connection to MySQL server during query",
         "MySQL server has gone away" ]
 
       QUOTED_TRUE, QUOTED_FALSE = '1', '0'
 
       NATIVE_DATABASE_TYPES = {
         :primary_key => "int(11) DEFAULT NULL auto_increment PRIMARY KEY",
         :string      => { :name => "varchar", :limit => 255 },
         :text        => { :name => "text" },
         :integer     => { :name => "int", :limit => 4 },
         :float       => { :name => "float" },
         :decimal     => { :name => "decimal" },
         :datetime    => { :name => "datetime" },
         :timestamp   => { :name => "datetime" },
         :time        => { :name => "time" },
         :date        => { :name => "date" },
         :binary      => { :name => "blob" },
         :boolean     => { :name => "tinyint", :limit => 1 }
       }
 
       def initialize(connection, logger, connection_options, config)
         super(connection, logger)
         @connection_options, @config = connection_options, config
         @quoted_column_names, @quoted_table_names = {}, {}
         @statements = {}
         @client_encoding = nil
         connect
       end
 
       def self.visitor_for(pool) # :nodoc:
         Arel::Visitors::MySQL.new(pool)
       end
 
       def adapter_name #:nodoc:
         ADAPTER_NAME
       end
 
       def supports_bulk_alter? #:nodoc:
         true
       end
 
       # Returns true, since this connection adapter supports prepared statement
       # caching.
       def supports_statement_cache?
         true
       end
 
       # Returns true, since this connection adapter supports migrations.
       def supports_migrations? #:nodoc:
         true
       end
 
       # Returns true.
       def supports_primary_key? #:nodoc:
         true
       end
 
       # Returns true, since this connection adapter supports savepoints.
       def supports_savepoints? #:nodoc:
         true
       end
 
       def native_database_types #:nodoc:
         NATIVE_DATABASE_TYPES
       end
 
 
       # QUOTING ==================================================
 
       def quote(value, column = nil)
         if value.kind_of?(String) && column && column.type == :binary && column.class.respond_to?(:string_to_binary)
           s = column.class.string_to_binary(value).unpack("H*")[0]
           "x'#{s}'"
         elsif value.kind_of?(BigDecimal)
           value.to_s("F")
         else
           super
         end
       end
 
       def type_cast(value, column)
         return super unless value == true || value == false
 
         value ? 1 : 0
       end
 
       def quote_column_name(name) #:nodoc:
-        @quoted_column_names[name] ||= "`#{name}`"
+        @quoted_column_names[name] ||= "`#{name.to_s.gsub('`', '``')}`"
       end
 
       def quote_table_name(name) #:nodoc:
         @quoted_table_names[name] ||= quote_column_name(name).gsub('.', '`.`')
       end
 
       def quote_string(string) #:nodoc:
         @connection.quote(string)
       end
 
       def quoted_true
         QUOTED_TRUE
       end
 
       def quoted_false
         QUOTED_FALSE
       end
 
       # REFERENTIAL INTEGRITY ====================================
 
       def disable_referential_integrity #:nodoc:
         old = select_value("SELECT @@FOREIGN_KEY_CHECKS")
 
         begin
           update("SET FOREIGN_KEY_CHECKS = 0")
           yield
         ensure
           update("SET FOREIGN_KEY_CHECKS = #{old}")
         end
       end
 
       # CONNECTION MANAGEMENT ====================================
 
       def active?
         if @connection.respond_to?(:stat)
           @connection.stat
         else
           @connection.query 'select 1'
         end
 
         # mysql-ruby doesn't raise an exception when stat fails.
         if @connection.respond_to?(:errno)
           @connection.errno.zero?
         else
           true
         end
       rescue Mysql::Error
         false
       end
 
       def reconnect!
         disconnect!
         clear_cache!
         connect
       end
 
       # Disconnects from the database if already connected. Otherwise, this
       # method does nothing.
       def disconnect!
         @connection.close rescue nil
       end
 
       def reset!
         if @connection.respond_to?(:change_user)
           # See http://bugs.mysql.com/bug.php?id=33540 -- the workaround way to
           # reset the connection is to change the user to the same user.
           @connection.change_user(@config[:username], @config[:password], @config[:database])
           configure_connection
         end
       end
 
       # DATABASE STATEMENTS ======================================
 
       def select_rows(sql, name = nil)
         @connection.query_with_result = true
         rows = exec_without_stmt(sql, name).rows
         @connection.more_results && @connection.next_result    # invoking stored procedures with CLIENT_MULTI_RESULTS requires this to tidy up else connection will be dropped
         rows
       end
 
       # Clears the prepared statements cache.
       def clear_cache!
         @statements.values.each do |cache|
           cache[:stmt].close
         end
         @statements.clear
       end
 
       if "<3".respond_to?(:encode)
         # Taken from here:
         #   https://github.com/tmtm/ruby-mysql/blob/master/lib/mysql/charset.rb
         # Author: TOMITA Masahiro <tommy@tmtm.org>
         ENCODINGS = {
           "armscii8" => nil,
           "ascii"    => Encoding::US_ASCII,
           "big5"     => Encoding::Big5,
           "binary"   => Encoding::ASCII_8BIT,
           "cp1250"   => Encoding::Windows_1250,
           "cp1251"   => Encoding::Windows_1251,
           "cp1256"   => Encoding::Windows_1256,
           "cp1257"   => Encoding::Windows_1257,
           "cp850"    => Encoding::CP850,
           "cp852"    => Encoding::CP852,
           "cp866"    => Encoding::IBM866,
           "cp932"    => Encoding::Windows_31J,
           "dec8"     => nil,
           "eucjpms"  => Encoding::EucJP_ms,
           "euckr"    => Encoding::EUC_KR,
           "gb2312"   => Encoding::EUC_CN,
           "gbk"      => Encoding::GBK,
           "geostd8"  => nil,
           "greek"    => Encoding::ISO_8859_7,
           "hebrew"   => Encoding::ISO_8859_8,
           "hp8"      => nil,
           "keybcs2"  => nil,
           "koi8r"    => Encoding::KOI8_R,
           "koi8u"    => Encoding::KOI8_U,
           "latin1"   => Encoding::ISO_8859_1,
           "latin2"   => Encoding::ISO_8859_2,
           "latin5"   => Encoding::ISO_8859_9,
           "latin7"   => Encoding::ISO_8859_13,
           "macce"    => Encoding::MacCentEuro,
           "macroman" => Encoding::MacRoman,
           "sjis"     => Encoding::SHIFT_JIS,
           "swe7"     => nil,
           "tis620"   => Encoding::TIS_620,
           "ucs2"     => Encoding::UTF_16BE,
           "ujis"     => Encoding::EucJP_ms,
           "utf8"     => Encoding::UTF_8,
           "utf8mb4"  => Encoding::UTF_8,
         }
       else
         ENCODINGS = Hash.new { |h,k| h[k] = k }
       end
 
       # Get the client encoding for this database
       def client_encoding
         return @client_encoding if @client_encoding
 
         result = exec_query(
           "SHOW VARIABLES WHERE Variable_name = 'character_set_client'",
           'SCHEMA')
         @client_encoding = ENCODINGS[result.rows.last.last]
       end
 
       def exec_query(sql, name = 'SQL', binds = [])
         log(sql, name, binds) do
           exec_stmt(sql, name, binds) do |cols, stmt|
             ActiveRecord::Result.new(cols, stmt.to_a) if cols
           end
         end
       end
 
       def last_inserted_id(result)
         @connection.insert_id
       end
 
       def exec_without_stmt(sql, name = 'SQL') # :nodoc:
         # Some queries, like SHOW CREATE TABLE don't work through the prepared
         # statement API. For those queries, we need to use this method. :'(
         log(sql, name) do
           result = @connection.query(sql)
           cols = []
           rows = []
 
           if result
             cols = result.fetch_fields.map { |field| field.name }
             rows = result.to_a
             result.free
           end
           ActiveRecord::Result.new(cols, rows)
         end
       end
 
       # Executes an SQL query and returns a MySQL::Result object. Note that you have to free
       # the Result object after you're done using it.
       def execute(sql, name = nil) #:nodoc:
         if name == :skip_logging
           @connection.query(sql)
         else
           log(sql, name) { @connection.query(sql) }
         end
       rescue ActiveRecord::StatementInvalid => exception
         if exception.message.split(":").first =~ /Packets out of order/
           raise ActiveRecord::StatementInvalid, "'Packets out of order' error was received from the database. Please update your mysql bindings (gem install mysql) and read http://dev.mysql.com/doc/mysql/en/password-hashing.html for more information. If you're on Windows, use the Instant Rails installer to get the updated mysql bindings."
         else
           raise
         end
       end
 
       def insert_sql(sql, name = nil, pk = nil, id_value = nil, sequence_name = nil) #:nodoc:
         super sql, name
         id_value || @connection.insert_id
       end
       alias :create :insert_sql
 
       def update_sql(sql, name = nil) #:nodoc:
         super
         @connection.affected_rows
       end
 
       def exec_delete(sql, name, binds)
         log(sql, name, binds) do
           exec_stmt(sql, name, binds) do |cols, stmt|
             stmt.affected_rows
           end
         end
       end
       alias :exec_update :exec_delete
 
       def begin_db_transaction #:nodoc:
         exec_without_stmt "BEGIN"
       rescue Mysql::Error
         # Transactions aren't supported
       end
 
       def commit_db_transaction #:nodoc:
         execute "COMMIT"
       rescue Exception
         # Transactions aren't supported
       end
 
       def rollback_db_transaction #:nodoc:
         execute "ROLLBACK"
       rescue Exception
         # Transactions aren't supported
       end
 
       def create_savepoint
         execute("SAVEPOINT #{current_savepoint_name}")
       end
 
       def rollback_to_savepoint
         execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
       end
 
       def release_savepoint
         execute("RELEASE SAVEPOINT #{current_savepoint_name}")
       end
 
       # In the simple case, MySQL allows us to place JOINs directly into the UPDATE
       # query. However, this does not allow for LIMIT, OFFSET and ORDER. To support
       # these, we must use a subquery. However, MySQL is too stupid to create a
       # temporary table for this automatically, so we have to give it some prompting
       # in the form of a subsubquery. Ugh!
       def join_to_update(update, select) #:nodoc:
         if select.limit || select.offset || select.orders.any?
           subsubselect = select.clone
           subsubselect.projections = [update.key]
 
           subselect = Arel::SelectManager.new(select.engine)
           subselect.project Arel.sql(update.key.name)
           subselect.from subsubselect.as('__active_record_temp')
 
           update.where update.key.in(subselect)
         else
           update.table select.source
           update.wheres = select.constraints
         end
       end
 
       # SCHEMA STATEMENTS ========================================
 
       def structure_dump #:nodoc:
         if supports_views?
           sql = "SHOW FULL TABLES WHERE Table_type = 'BASE TABLE'"
         else
           sql = "SHOW TABLES"
         end
 
         select_all(sql).map do |table|
           table.delete('Table_type')
           sql = "SHOW CREATE TABLE #{quote_table_name(table.to_a.first.last)}"
           exec_without_stmt(sql).first['Create Table'] + ";\n\n"
         end.join("")
       end
 
       # Drops the database specified on the +name+ attribute
       # and creates it again using the provided +options+.
       def recreate_database(name, options = {}) #:nodoc:
         drop_database(name)
         create_database(name, options)
       end
 
       # Create a new MySQL database with optional <tt>:charset</tt> and <tt>:collation</tt>.
       # Charset defaults to utf8.
       #
       # Example:
       #   create_database 'charset_test', :charset => 'latin1', :collation => 'latin1_bin'
       #   create_database 'matt_development'
       #   create_database 'matt_development', :charset => :big5
       def create_database(name, options = {})
         if options[:collation]
           execute "CREATE DATABASE `#{name}` DEFAULT CHARACTER SET `#{options[:charset] || 'utf8'}` COLLATE `#{options[:collation]}`"
         else
           execute "CREATE DATABASE `#{name}` DEFAULT CHARACTER SET `#{options[:charset] || 'utf8'}`"
         end
       end
 
       # Drops a MySQL database.
       #
       # Example:
       #   drop_database 'sebastian_development'
       def drop_database(name) #:nodoc:
         execute "DROP DATABASE IF EXISTS `#{name}`"
       end
 
       def current_database
         select_value 'SELECT DATABASE() as db'
       end
 
       # Returns the database character set.
       def charset
         show_variable 'character_set_database'
       end
 
       # Returns the database collation strategy.
       def collation
         show_variable 'collation_database'
       end
 
       def tables(name = nil, database = nil) #:nodoc:
         result = execute(["SHOW TABLES", database].compact.join(' IN '), 'SCHEMA')
         tables = result.collect { |field| field[0] }
         result.free
         tables
       end
 
       def table_exists?(name)
         return true if super
 
         name          = name.to_s
         schema, table = name.split('.', 2)
 
         unless table # A table was provided without a schema
           table  = schema
           schema = nil
         end
 
         tables(nil, schema).include? table
       end
 
       # Returns an array of indexes for the given table.
       def indexes(table_name, name = nil)#:nodoc:
         indexes = []
         current_index = nil
         result = execute("SHOW KEYS FROM #{quote_table_name(table_name)}", name)
         result.each do |row|
           if current_index != row[2]
             next if row[2] == "PRIMARY" # skip the primary key
             current_index = row[2]
             indexes << IndexDefinition.new(row[0], row[2], row[1] == "0", [], [])
           end
 
           indexes.last.columns << row[4]
           indexes.last.lengths << row[7]
         end
         result.free
         indexes
       end
 
       # Returns an array of +MysqlColumn+ objects for the table specified by +table_name+.
       def columns(table_name, name = nil)#:nodoc:
         sql = "SHOW FIELDS FROM #{quote_table_name(table_name)}"
         result = execute(sql, 'SCHEMA')
         columns = result.collect { |field| MysqlColumn.new(field[0], field[4], field[1], field[2] == "YES") }
         result.free
         columns
       end
 
       def create_table(table_name, options = {}) #:nodoc:
         super(table_name, options.reverse_merge(:options => "ENGINE=InnoDB"))
       end
 
       # Renames a table.
       #
       # Example:
       #   rename_table('octopuses', 'octopi')
       def rename_table(table_name, new_name)
         execute "RENAME TABLE #{quote_table_name(table_name)} TO #{quote_table_name(new_name)}"
       end
 
       def bulk_change_table(table_name, operations) #:nodoc:
         sqls = operations.map do |command, args|
           table, arguments = args.shift, args
           method = :"#{command}_sql"
 
           if respond_to?(method)
             send(method, table, *arguments)
           else
             raise "Unknown method called : #{method}(#{arguments.inspect})"
           end
         end.flatten.join(", ")
 
         execute("ALTER TABLE #{quote_table_name(table_name)} #{sqls}")
       end
 
       def add_column(table_name, column_name, type, options = {})
         execute("ALTER TABLE #{quote_table_name(table_name)} #{add_column_sql(table_name, column_name, type, options)}")
       end
 
       def change_column_default(table_name, column_name, default) #:nodoc:
         column = column_for(table_name, column_name)
         change_column table_name, column_name, column.sql_type, :default => default
       end
 
       def change_column_null(table_name, column_name, null, default = nil)
         column = column_for(table_name, column_name)
 
         unless null || default.nil?
           execute("UPDATE #{quote_table_name(table_name)} SET #{quote_column_name(column_name)}=#{quote(default)} WHERE #{quote_column_name(column_name)} IS NULL")
         end
 
         change_column table_name, column_name, column.sql_type, :null => null
       end
 
       def change_column(table_name, column_name, type, options = {}) #:nodoc:
         execute("ALTER TABLE #{quote_table_name(table_name)} #{change_column_sql(table_name, column_name, type, options)}")
       end
 
       def rename_column(table_name, column_name, new_column_name) #:nodoc:
         execute("ALTER TABLE #{quote_table_name(table_name)} #{rename_column_sql(table_name, column_name, new_column_name)}")
       end
 
       # Maps logical Rails types to MySQL-specific data types.
       def type_to_sql(type, limit = nil, precision = nil, scale = nil)
         return super unless type.to_s == 'integer'
 
         case limit
         when 1; 'tinyint'
         when 2; 'smallint'
         when 3; 'mediumint'
         when nil, 4, 11; 'int(11)'  # compatibility with MySQL default
         when 5..8; 'bigint'
         else raise(ActiveRecordError, "No integer type has byte size #{limit}")
         end
       end
 
       def add_column_position!(sql, options)
         if options[:first]
           sql << " FIRST"
         elsif options[:after]
           sql << " AFTER #{quote_column_name(options[:after])}"
         end
       end
 
       # SHOW VARIABLES LIKE 'name'
       def show_variable(name)
         variables = select_all("SHOW VARIABLES LIKE '#{name}'")
         variables.first['Value'] unless variables.empty?
       end
 
       # Returns a table's primary key and belonging sequence.
       def pk_and_sequence_for(table) #:nodoc:
         keys = []
         result = execute("describe #{quote_table_name(table)}", 'SCHEMA')
         result.each_hash do |h|
           keys << h["Field"]if h["Key"] == "PRI"
         end
         result.free
         keys.length == 1 ? [keys.first, nil] : nil
       end
 
       # Returns just a table's primary key
       def primary_key(table)
         pk_and_sequence = pk_and_sequence_for(table)
         pk_and_sequence && pk_and_sequence.first
       end
 
       def case_sensitive_modifier(node)
         Arel::Nodes::Bin.new(node)
       end
 
       def limited_update_conditions(where_sql, quoted_table_name, quoted_primary_key)
         where_sql
       end
 
       protected
         def quoted_columns_for_index(column_names, options = {})
           length = options[:length] if options.is_a?(Hash)
 
           case length
           when Hash
             column_names.map {|name| length[name] ? "#{quote_column_name(name)}(#{length[name]})" : quote_column_name(name) }
           when Fixnum
             column_names.map {|name| "#{quote_column_name(name)}(#{length})"}
           else
             column_names.map {|name| quote_column_name(name) }
           end
         end
 
         def translate_exception(exception, message)
           return super unless exception.respond_to?(:errno)
 
           case exception.errno
           when 1062
             RecordNotUnique.new(message, exception)
           when 1452
             InvalidForeignKey.new(message, exception)
           else
             super
           end
         end
 
         def add_column_sql(table_name, column_name, type, options = {})
           add_column_sql = "ADD #{quote_column_name(column_name)} #{type_to_sql(type, options[:limit], options[:precision], options[:scale])}"
           add_column_options!(add_column_sql, options)
           add_column_position!(add_column_sql, options)
           add_column_sql
         end
 
         def remove_column_sql(table_name, *column_names)
           columns_for_remove(table_name, *column_names).map {|column_name| "DROP #{column_name}" }
         end
         alias :remove_columns_sql :remove_column
 
         def change_column_sql(table_name, column_name, type, options = {})
           column = column_for(table_name, column_name)
 
           unless options_include_default?(options)
             options[:default] = column.default
           end
 
           unless options.has_key?(:null)
             options[:null] = column.null
           end
 
           change_column_sql = "CHANGE #{quote_column_name(column_name)} #{quote_column_name(column_name)} #{type_to_sql(type, options[:limit], options[:precision], options[:scale])}"
           add_column_options!(change_column_sql, options)
           add_column_position!(change_column_sql, options)
           change_column_sql
         end
 
         def rename_column_sql(table_name, column_name, new_column_name)
           options = {}
 
           if column = columns(table_name).find { |c| c.name == column_name.to_s }
             options[:default] = column.default
             options[:null] = column.null
           else
             raise ActiveRecordError, "No such column: #{table_name}.#{column_name}"
           end
 
           current_type = select_one("SHOW COLUMNS FROM #{quote_table_name(table_name)} LIKE '#{column_name}'")["Type"]
           rename_column_sql = "CHANGE #{quote_column_name(column_name)} #{quote_column_name(new_column_name)} #{current_type}"
           add_column_options!(rename_column_sql, options)
           rename_column_sql
         end
 
         def add_index_sql(table_name, column_name, options = {})
           index_name, index_type, index_columns = add_index_options(table_name, column_name, options)
           "ADD #{index_type} INDEX #{index_name} (#{index_columns})"
         end
 
         def remove_index_sql(table_name, options = {})
           index_name = index_name_for_remove(table_name, options)
           "DROP INDEX #{index_name}"
         end
 
         def add_timestamps_sql(table_name)
           [add_column_sql(table_name, :created_at, :datetime), add_column_sql(table_name, :updated_at, :datetime)]
         end
 
         def remove_timestamps_sql(table_name)
           [remove_column_sql(table_name, :updated_at), remove_column_sql(table_name, :created_at)]
         end
 
       private
       def exec_stmt(sql, name, binds)
         cache = {}
         if binds.empty?
           stmt = @connection.prepare(sql)
         else
           cache = @statements[sql] ||= {
             :stmt => @connection.prepare(sql)
           }
           stmt = cache[:stmt]
         end
 
 
         begin
           stmt.execute(*binds.map { |col, val| type_cast(val, col) })
         rescue Mysql::Error => e
           # Older versions of MySQL leave the prepared statement in a bad
           # place when an error occurs. To support older mysql versions, we
           # need to close the statement and delete the statement from the
           # cache.
           stmt.close
           @statements.delete sql
           raise e
         end
 
         cols = nil
         if metadata = stmt.result_metadata
           cols = cache[:cols] ||= metadata.fetch_fields.map { |field|
             field.name
           }
         end
 
         result = yield [cols, stmt]
 
         stmt.result_metadata.free if cols
         stmt.free_result
         stmt.close if binds.empty?
 
         result
       end
 
         def connect
           encoding = @config[:encoding]
           if encoding
             @connection.options(Mysql::SET_CHARSET_NAME, encoding) rescue nil
           end
 
           if @config[:sslca] || @config[:sslkey]
             @connection.ssl_set(@config[:sslkey], @config[:sslcert], @config[:sslca], @config[:sslcapath], @config[:sslcipher])
           end
 
           @connection.options(Mysql::OPT_CONNECT_TIMEOUT, @config[:connect_timeout]) if @config[:connect_timeout]
           @connection.options(Mysql::OPT_READ_TIMEOUT, @config[:read_timeout]) if @config[:read_timeout]
           @connection.options(Mysql::OPT_WRITE_TIMEOUT, @config[:write_timeout]) if @config[:write_timeout]
 
           @connection.real_connect(*@connection_options)
 
           # reconnect must be set after real_connect is called, because real_connect sets it to false internally
           @connection.reconnect = !!@config[:reconnect] if @connection.respond_to?(:reconnect=)
 
           configure_connection
         end
 
         def configure_connection
           encoding = @config[:encoding]
           execute("SET NAMES '#{encoding}'", :skip_logging) if encoding
 
           # By default, MySQL 'where id is null' selects the last inserted id.
           # Turn this off. http://dev.rubyonrails.org/ticket/6778
           execute("SET SQL_AUTO_IS_NULL=0", :skip_logging)
         end
 
         def select(sql, name = nil, binds = [])
           @connection.query_with_result = true
           rows = exec_query(sql, name, binds).to_a
           @connection.more_results && @connection.next_result    # invoking stored procedures with CLIENT_MULTI_RESULTS requires this to tidy up else connection will be dropped
           rows
         end
 
         def supports_views?
           version[0] >= 5
         end
 
         # Returns the version of the connected MySQL server.
         def version
           @version ||= @connection.server_info.scan(/^(\d+)\.(\d+)\.(\d+)/).flatten.map { |v| v.to_i }
         end
 
         def column_for(table_name, column_name)
           unless column = columns(table_name).find { |c| c.name == column_name.to_s }
             raise "No such column: #{table_name}.#{column_name}"
           end
           column
         end
     end
   end
diff --git a/activerecord/lib/active_record/connection_adapters/sqlite_adapter.rb b/activerecord/lib/active_record/connection_adapters/sqlite_adapter.rb
index 486efc5..da86957 100644
--- a/activerecord/lib/active_record/connection_adapters/sqlite_adapter.rb
+++ b/activerecord/lib/active_record/connection_adapters/sqlite_adapter.rb
@@ -3,492 +3,492 @@ require 'active_record/connection_adapters/abstract_adapter'
 module ActiveRecord
   module ConnectionAdapters #:nodoc:
     class SQLiteColumn < Column #:nodoc:
       class <<  self
         def string_to_binary(value)
           value.gsub(/\0|\%/n) do |b|
             case b
               when "\0" then "%00"
               when "%"  then "%25"
             end
           end
         end
 
         def binary_to_string(value)
           if value.respond_to?(:force_encoding) && value.encoding != Encoding::ASCII_8BIT
             value = value.force_encoding(Encoding::ASCII_8BIT)
           end
 
           value.gsub(/%00|%25/n) do |b|
             case b
               when "%00" then "\0"
               when "%25" then "%"
             end
           end
         end
       end
     end
 
     # The SQLite adapter works with both the 2.x and 3.x series of SQLite with the sqlite-ruby
     # drivers (available both as gems and from http://rubyforge.org/projects/sqlite-ruby/).
     #
     # Options:
     #
     # * <tt>:database</tt> - Path to the database file.
     class SQLiteAdapter < AbstractAdapter
       class Version
         include Comparable
 
         def initialize(version_string)
           @version = version_string.split('.').map { |v| v.to_i }
         end
 
         def <=>(version_string)
           @version <=> version_string.split('.').map { |v| v.to_i }
         end
       end
 
       def initialize(connection, logger, config)
         super(connection, logger)
         @statements = {}
         @config = config
       end
 
       def self.visitor_for(pool) # :nodoc:
         Arel::Visitors::SQLite.new(pool)
       end
 
       def adapter_name #:nodoc:
         'SQLite'
       end
 
       # Returns true if SQLite version is '2.0.0' or greater, false otherwise.
       def supports_ddl_transactions?
         sqlite_version >= '2.0.0'
       end
 
       # Returns true if SQLite version is '3.6.8' or greater, false otherwise.
       def supports_savepoints?
         sqlite_version >= '3.6.8'
       end
 
       # Returns true, since this connection adapter supports prepared statement
       # caching.
       def supports_statement_cache?
         true
       end
 
       # Returns true, since this connection adapter supports migrations.
       def supports_migrations? #:nodoc:
         true
       end
 
       # Returns true.
       def supports_primary_key? #:nodoc:
         true
       end
 
       def requires_reloading?
         true
       end
 
       # Returns true if SQLite version is '3.1.6' or greater, false otherwise.
       def supports_add_column?
         sqlite_version >= '3.1.6'
       end
 
       # Disconnects from the database if already connected. Otherwise, this
       # method does nothing.
       def disconnect!
         super
         clear_cache!
         @connection.close rescue nil
       end
 
       # Clears the prepared statements cache.
       def clear_cache!
         @statements.values.map { |hash| hash[:stmt] }.each { |stmt|
           stmt.close unless stmt.closed?
         }
 
         @statements.clear
       end
 
       # Returns true if SQLite version is '3.2.6' or greater, false otherwise.
       def supports_count_distinct? #:nodoc:
         sqlite_version >= '3.2.6'
       end
 
       # Returns true if SQLite version is '3.1.0' or greater, false otherwise.
       def supports_autoincrement? #:nodoc:
         sqlite_version >= '3.1.0'
       end
 
       def native_database_types #:nodoc:
         {
           :primary_key => default_primary_key_type,
           :string      => { :name => "varchar", :limit => 255 },
           :text        => { :name => "text" },
           :integer     => { :name => "integer" },
           :float       => { :name => "float" },
           :decimal     => { :name => "decimal" },
           :datetime    => { :name => "datetime" },
           :timestamp   => { :name => "datetime" },
           :time        => { :name => "time" },
           :date        => { :name => "date" },
           :binary      => { :name => "blob" },
           :boolean     => { :name => "boolean" }
         }
       end
 
 
       # QUOTING ==================================================
 
       def quote_string(s) #:nodoc:
         @connection.class.quote(s)
       end
 
       def quote_column_name(name) #:nodoc:
-        %Q("#{name}")
+        %Q("#{name.to_s.gsub('"', '""')}")
       end
 
       # Quote date/time values for use in SQL input. Includes microseconds
       # if the value is a Time responding to usec.
       def quoted_date(value) #:nodoc:
         if value.respond_to?(:usec)
           "#{super}.#{sprintf("%06d", value.usec)}"
         else
           super
         end
       end
 
       def type_cast(value, column) # :nodoc:
         return super unless BigDecimal === value
 
         value.to_f
       end
 
       # DATABASE STATEMENTS ======================================
 
       def exec_query(sql, name = nil, binds = [])
         log(sql, name, binds) do
 
           # Don't cache statements without bind values
           if binds.empty?
             stmt    = @connection.prepare(sql)
             cols    = stmt.columns
             records = stmt.to_a
             stmt.close
             stmt = records
           else
             cache = @statements[sql] ||= {
               :stmt => @connection.prepare(sql)
             }
             stmt = cache[:stmt]
             cols = cache[:cols] ||= stmt.columns
             stmt.reset!
             stmt.bind_params binds.map { |col, val|
               type_cast(val, col)
             }
           end
 
           ActiveRecord::Result.new(cols, stmt.to_a)
         end
       end
 
       def exec_delete(sql, name = 'SQL', binds = [])
         exec_query(sql, name, binds)
         @connection.changes
       end
       alias :exec_update :exec_delete
 
       def last_inserted_id(result)
         @connection.last_insert_row_id
       end
 
       def execute(sql, name = nil) #:nodoc:
         log(sql, name) { @connection.execute(sql) }
       end
 
       def update_sql(sql, name = nil) #:nodoc:
         super
         @connection.changes
       end
 
       def delete_sql(sql, name = nil) #:nodoc:
         sql += " WHERE 1=1" unless sql =~ /WHERE/i
         super sql, name
       end
 
       def insert_sql(sql, name = nil, pk = nil, id_value = nil, sequence_name = nil) #:nodoc:
         super
         id_value || @connection.last_insert_row_id
       end
       alias :create :insert_sql
 
       def select_rows(sql, name = nil)
         exec_query(sql, name).rows
       end
 
       def create_savepoint
         execute("SAVEPOINT #{current_savepoint_name}")
       end
 
       def rollback_to_savepoint
         execute("ROLLBACK TO SAVEPOINT #{current_savepoint_name}")
       end
 
       def release_savepoint
         execute("RELEASE SAVEPOINT #{current_savepoint_name}")
       end
 
       def begin_db_transaction #:nodoc:
         log('begin transaction',nil) { @connection.transaction }
       end
 
       def commit_db_transaction #:nodoc:
         log('commit transaction',nil) { @connection.commit }
       end
 
       def rollback_db_transaction #:nodoc:
         log('rollback transaction',nil) { @connection.rollback }
       end
 
       # SCHEMA STATEMENTS ========================================
 
       def tables(name = 'SCHEMA') #:nodoc:
         sql = <<-SQL
           SELECT name
           FROM sqlite_master
           WHERE type = 'table' AND NOT name = 'sqlite_sequence'
         SQL
 
         exec_query(sql, name).map do |row|
           row['name']
         end
       end
 
       # Returns an array of +SQLiteColumn+ objects for the table specified by +table_name+.
       def columns(table_name, name = nil) #:nodoc:
         table_structure(table_name).map do |field|
           case field["dflt_value"]
           when /^null$/i
             field["dflt_value"] = nil
           when /^'(.*)'$/
             field["dflt_value"] = $1.gsub(/''/, "'")
           when /^"(.*)"$/
             field["dflt_value"] = $1.gsub(/""/, '"')
           end
 
           SQLiteColumn.new(field['name'], field['dflt_value'], field['type'], field['notnull'].to_i == 0)
         end
       end
 
       # Returns an array of indexes for the given table.
       def indexes(table_name, name = nil) #:nodoc:
         exec_query("PRAGMA index_list(#{quote_table_name(table_name)})", name).map do |row|
           IndexDefinition.new(
             table_name,
             row['name'],
             row['unique'] != 0,
             exec_query("PRAGMA index_info('#{row['name']}')").map { |col|
               col['name']
             })
         end
       end
 
       def primary_key(table_name) #:nodoc:
         column = table_structure(table_name).find { |field|
           field['pk'] == 1
         }
         column && column['name']
       end
 
       def remove_index!(table_name, index_name) #:nodoc:
         exec_query "DROP INDEX #{quote_column_name(index_name)}"
       end
 
       # Renames a table.
       #
       # Example:
       #   rename_table('octopuses', 'octopi')
       def rename_table(name, new_name)
         exec_query "ALTER TABLE #{quote_table_name(name)} RENAME TO #{quote_table_name(new_name)}"
       end
 
       # See: http://www.sqlite.org/lang_altertable.html
       # SQLite has an additional restriction on the ALTER TABLE statement
       def valid_alter_table_options( type, options)
         type.to_sym != :primary_key
       end
 
       def add_column(table_name, column_name, type, options = {}) #:nodoc:
         if supports_add_column? && valid_alter_table_options( type, options )
           super(table_name, column_name, type, options)
         else
           alter_table(table_name) do |definition|
             definition.column(column_name, type, options)
           end
         end
       end
 
       def remove_column(table_name, *column_names) #:nodoc:
         raise ArgumentError.new("You must specify at least one column name. Example: remove_column(:people, :first_name)") if column_names.empty?
         column_names.flatten.each do |column_name|
           alter_table(table_name) do |definition|
             definition.columns.delete(definition[column_name])
           end
         end
       end
       alias :remove_columns :remove_column
 
       def change_column_default(table_name, column_name, default) #:nodoc:
         alter_table(table_name) do |definition|
           definition[column_name].default = default
         end
       end
 
       def change_column_null(table_name, column_name, null, default = nil)
         unless null || default.nil?
           exec_query("UPDATE #{quote_table_name(table_name)} SET #{quote_column_name(column_name)}=#{quote(default)} WHERE #{quote_column_name(column_name)} IS NULL")
         end
         alter_table(table_name) do |definition|
           definition[column_name].null = null
         end
       end
 
       def change_column(table_name, column_name, type, options = {}) #:nodoc:
         alter_table(table_name) do |definition|
           include_default = options_include_default?(options)
           definition[column_name].instance_eval do
             self.type    = type
             self.limit   = options[:limit] if options.include?(:limit)
             self.default = options[:default] if include_default
             self.null    = options[:null] if options.include?(:null)
           end
         end
       end
 
       def rename_column(table_name, column_name, new_column_name) #:nodoc:
         unless columns(table_name).detect{|c| c.name == column_name.to_s }
           raise ActiveRecord::ActiveRecordError, "Missing column #{table_name}.#{column_name}"
         end
         alter_table(table_name, :rename => {column_name.to_s => new_column_name.to_s})
       end
 
       def empty_insert_statement_value
         "VALUES(NULL)"
       end
 
       protected
         def select(sql, name = nil, binds = []) #:nodoc:
           exec_query(sql, name, binds).to_a
         end
 
         def table_structure(table_name)
           structure = exec_query("PRAGMA table_info(#{quote_table_name(table_name)})", 'SCHEMA').to_hash
           raise(ActiveRecord::StatementInvalid, "Could not find table '#{table_name}'") if structure.empty?
           structure
         end
 
         def alter_table(table_name, options = {}) #:nodoc:
           altered_table_name = "altered_#{table_name}"
           caller = lambda {|definition| yield definition if block_given?}
 
           transaction do
             move_table(table_name, altered_table_name,
               options.merge(:temporary => true))
             move_table(altered_table_name, table_name, &caller)
           end
         end
 
         def move_table(from, to, options = {}, &block) #:nodoc:
           copy_table(from, to, options, &block)
           drop_table(from)
         end
 
         def copy_table(from, to, options = {}) #:nodoc:
           options = options.merge(:id => (!columns(from).detect{|c| c.name == 'id'}.nil? && 'id' == primary_key(from).to_s))
           create_table(to, options) do |definition|
             @definition = definition
             columns(from).each do |column|
               column_name = options[:rename] ?
                 (options[:rename][column.name] ||
                  options[:rename][column.name.to_sym] ||
                  column.name) : column.name
 
               @definition.column(column_name, column.type,
                 :limit => column.limit, :default => column.default,
                 :null => column.null)
             end
             @definition.primary_key(primary_key(from)) if primary_key(from)
             yield @definition if block_given?
           end
 
           copy_table_indexes(from, to, options[:rename] || {})
           copy_table_contents(from, to,
             @definition.columns.map {|column| column.name},
             options[:rename] || {})
         end
 
         def copy_table_indexes(from, to, rename = {}) #:nodoc:
           indexes(from).each do |index|
             name = index.name
             if to == "altered_#{from}"
               name = "temp_#{name}"
             elsif from == "altered_#{to}"
               name = name[5..-1]
             end
 
             to_column_names = columns(to).map { |c| c.name }
             columns = index.columns.map {|c| rename[c] || c }.select do |column|
               to_column_names.include?(column)
             end
 
             unless columns.empty?
               # index name can't be the same
               opts = { :name => name.gsub(/_(#{from})_/, "_#{to}_") }
               opts[:unique] = true if index.unique
               add_index(to, columns, opts)
             end
           end
         end
 
         def copy_table_contents(from, to, columns, rename = {}) #:nodoc:
           column_mappings = Hash[columns.map {|name| [name, name]}]
           rename.each { |a| column_mappings[a.last] = a.first }
           from_columns = columns(from).collect {|col| col.name}
           columns = columns.find_all{|col| from_columns.include?(column_mappings[col])}
           quoted_columns = columns.map { |col| quote_column_name(col) } * ','
 
           quoted_to = quote_table_name(to)
           exec_query("SELECT * FROM #{quote_table_name(from)}").each do |row|
             sql = "INSERT INTO #{quoted_to} (#{quoted_columns}) VALUES ("
             sql << columns.map {|col| quote row[column_mappings[col]]} * ', '
             sql << ')'
             exec_query sql
           end
         end
 
         def sqlite_version
           @sqlite_version ||= SQLiteAdapter::Version.new(select_value('select sqlite_version(*)'))
         end
 
         def default_primary_key_type
           if supports_autoincrement?
             'INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL'
           else
             'INTEGER PRIMARY KEY NOT NULL'
           end
         end
 
         def translate_exception(exception, message)
           case exception.message
           when /column(s)? .* (is|are) not unique/
             RecordNotUnique.new(message, exception)
           else
             super
           end
         end
 
     end
   end
diff --git a/activerecord/test/cases/base_test.rb b/activerecord/test/cases/base_test.rb
index b8ebabf..fe46c00 100644
--- a/activerecord/test/cases/base_test.rb
+++ b/activerecord/test/cases/base_test.rb
@@ -67,1804 +67,1821 @@ end
 class BasicsTest < ActiveRecord::TestCase
   fixtures :topics, :companies, :developers, :projects, :computers, :accounts, :minimalistics, 'warehouse-things', :authors, :categorizations, :categories, :posts
 
+  def test_column_names_are_escaped
+    conn      = ActiveRecord::Base.connection
+    classname = conn.class.name[/[^:]*$/]
+    badchar   = {
+      'SQLite3Adapter'    => '"',
+      'MysqlAdapter'      => '`',
+      'Mysql2Adapter'     => '`',
+      'PostgreSQLAdapter' => '"',
+      'OracleAdapter'     => '"',
+    }.fetch(classname) {
+      raise "need a bad char for #{classname}"
+    }
+
+    quoted = conn.quote_column_name "foo#{badchar}bar"
+    assert_equal("#{badchar}foo#{badchar * 2}bar#{badchar}", quoted)
+  end
+
   def test_columns_should_obey_set_primary_key
     pk = Subscriber.columns.find { |x| x.name == 'nick' }
     assert pk.primary, 'nick should be primary key'
   end
 
   def test_primary_key_with_no_id
     assert_nil Edge.primary_key
   end
 
   unless current_adapter?(:PostgreSQLAdapter,:OracleAdapter,:SQLServerAdapter)
     def test_limit_with_comma
       assert_nothing_raised do
         Topic.limit("1,2").all
       end
     end
   end
 
   def test_limit_without_comma
     assert_nothing_raised do
       assert_equal 1, Topic.limit("1").all.length
     end
 
     assert_nothing_raised do
       assert_equal 1, Topic.limit(1).all.length
     end
   end
 
   def test_invalid_limit
     assert_raises(ArgumentError) do
       Topic.limit("asdfadf").all
     end
   end
 
   def test_limit_should_sanitize_sql_injection_for_limit_without_comas
     assert_raises(ArgumentError) do
       Topic.limit("1 select * from schema").all
     end
   end
 
   def test_limit_should_sanitize_sql_injection_for_limit_with_comas
     assert_raises(ArgumentError) do
       Topic.limit("1, 7 procedure help()").all
     end
   end
 
   unless current_adapter?(:MysqlAdapter) || current_adapter?(:Mysql2Adapter)
     def test_limit_should_allow_sql_literal
       assert_equal 1, Topic.limit(Arel.sql('2-1')).all.length
     end
   end
 
   def test_select_symbol
     topic_ids = Topic.select(:id).map(&:id).sort
     assert_equal Topic.all.map(&:id).sort, topic_ids
   end
 
   def test_table_exists
     assert !NonExistentTable.table_exists?
     assert Topic.table_exists?
   end
 
   def test_preserving_date_objects
     if current_adapter?(:SybaseAdapter)
       # Sybase ctlib does not (yet?) support the date type; use datetime instead.
       assert_kind_of(
         Time, Topic.find(1).last_read,
         "The last_read attribute should be of the Time class"
       )
     else
       # Oracle enhanced adapter allows to define Date attributes in model class (see topic.rb)
       assert_kind_of(
         Date, Topic.find(1).last_read,
         "The last_read attribute should be of the Date class"
       )
     end
   end
 
   def test_preserving_time_objects
     assert_kind_of(
       Time, Topic.find(1).bonus_time,
       "The bonus_time attribute should be of the Time class"
     )
 
     assert_kind_of(
       Time, Topic.find(1).written_on,
       "The written_on attribute should be of the Time class"
     )
 
     # For adapters which support microsecond resolution.
     if current_adapter?(:PostgreSQLAdapter) || current_adapter?(:SQLiteAdapter)
       assert_equal 11, Topic.find(1).written_on.sec
       assert_equal 223300, Topic.find(1).written_on.usec
       assert_equal 9900, Topic.find(2).written_on.usec
     end
   end
 
   def test_preserving_time_objects_with_local_time_conversion_to_default_timezone_utc
     with_env_tz 'America/New_York' do
       with_active_record_default_timezone :utc do
         time = Time.local(2000)
         topic = Topic.create('written_on' => time)
         saved_time = Topic.find(topic.id).reload.written_on
         assert_equal time, saved_time
         assert_equal [0, 0, 0, 1, 1, 2000, 6, 1, false, "EST"], time.to_a
         assert_equal [0, 0, 5, 1, 1, 2000, 6, 1, false, "UTC"], saved_time.to_a
       end
     end
   end
 
   def test_preserving_time_objects_with_time_with_zone_conversion_to_default_timezone_utc
     with_env_tz 'America/New_York' do
       with_active_record_default_timezone :utc do
         Time.use_zone 'Central Time (US & Canada)' do
           time = Time.zone.local(2000)
           topic = Topic.create('written_on' => time)
           saved_time = Topic.find(topic.id).reload.written_on
           assert_equal time, saved_time
           assert_equal [0, 0, 0, 1, 1, 2000, 6, 1, false, "CST"], time.to_a
           assert_equal [0, 0, 6, 1, 1, 2000, 6, 1, false, "UTC"], saved_time.to_a
         end
       end
     end
   end
 
   def test_preserving_time_objects_with_utc_time_conversion_to_default_timezone_local
     with_env_tz 'America/New_York' do
       time = Time.utc(2000)
       topic = Topic.create('written_on' => time)
       saved_time = Topic.find(topic.id).reload.written_on
       assert_equal time, saved_time
       assert_equal [0, 0, 0, 1, 1, 2000, 6, 1, false, "UTC"], time.to_a
       assert_equal [0, 0, 19, 31, 12, 1999, 5, 365, false, "EST"], saved_time.to_a
     end
   end
 
   def test_preserving_time_objects_with_time_with_zone_conversion_to_default_timezone_local
     with_env_tz 'America/New_York' do
       with_active_record_default_timezone :local do
         Time.use_zone 'Central Time (US & Canada)' do
           time = Time.zone.local(2000)
           topic = Topic.create('written_on' => time)
           saved_time = Topic.find(topic.id).reload.written_on
           assert_equal time, saved_time
           assert_equal [0, 0, 0, 1, 1, 2000, 6, 1, false, "CST"], time.to_a
           assert_equal [0, 0, 1, 1, 1, 2000, 6, 1, false, "EST"], saved_time.to_a
         end
       end
     end
   end
 
   def test_custom_mutator
     topic = Topic.find(1)
     # This mutator is protected in the class definition
     topic.send(:approved=, true)
     assert topic.instance_variable_get("@custom_approved")
   end
 
   def test_initialize_with_attributes
     topic = Topic.new({
       "title" => "initialized from attributes", "written_on" => "2003-12-12 23:23"
     })
 
     assert_equal("initialized from attributes", topic.title)
   end
 
   def test_initialize_with_invalid_attribute
     begin
       Topic.new({ "title" => "test",
         "last_read(1i)" => "2005", "last_read(2i)" => "2", "last_read(3i)" => "31"})
     rescue ActiveRecord::MultiparameterAssignmentErrors => ex
       assert_equal(1, ex.errors.size)
       assert_equal("last_read", ex.errors[0].attribute)
     end
   end
 
   def test_create_after_initialize_without_block
     cb = CustomBulb.create(:name => 'Dude')
     assert_equal('Dude', cb.name)
     assert_equal(true, cb.frickinawesome)
   end
 
   def test_create_after_initialize_with_block
     cb = CustomBulb.create {|c| c.name = 'Dude' }
     assert_equal('Dude', cb.name)
     assert_equal(true, cb.frickinawesome)
   end
 
   def test_load
     topics = Topic.find(:all, :order => 'id')
     assert_equal(4, topics.size)
     assert_equal(topics(:first).title, topics.first.title)
   end
 
   def test_load_with_condition
     topics = Topic.find(:all, :conditions => "author_name = 'Mary'")
 
     assert_equal(1, topics.size)
     assert_equal(topics(:second).title, topics.first.title)
   end
 
   GUESSED_CLASSES = [Category, Smarts, CreditCard, CreditCard::PinNumber, CreditCard::PinNumber::CvvCode, CreditCard::SubPinNumber, CreditCard::Brand, MasterCreditCard]
 
   def test_table_name_guesses
     assert_equal "topics", Topic.table_name
 
     assert_equal "categories", Category.table_name
     assert_equal "smarts", Smarts.table_name
     assert_equal "credit_cards", CreditCard.table_name
     assert_equal "credit_card_pin_numbers", CreditCard::PinNumber.table_name
     assert_equal "credit_card_pin_number_cvv_codes", CreditCard::PinNumber::CvvCode.table_name
     assert_equal "credit_card_pin_numbers", CreditCard::SubPinNumber.table_name
     assert_equal "categories", CreditCard::Brand.table_name
     assert_equal "master_credit_cards", MasterCreditCard.table_name
   ensure
     GUESSED_CLASSES.each(&:reset_table_name)
   end
 
   def test_singular_table_name_guesses
     ActiveRecord::Base.pluralize_table_names = false
     GUESSED_CLASSES.each(&:reset_table_name)
 
     assert_equal "category", Category.table_name
     assert_equal "smarts", Smarts.table_name
     assert_equal "credit_card", CreditCard.table_name
     assert_equal "credit_card_pin_number", CreditCard::PinNumber.table_name
     assert_equal "credit_card_pin_number_cvv_code", CreditCard::PinNumber::CvvCode.table_name
     assert_equal "credit_card_pin_number", CreditCard::SubPinNumber.table_name
     assert_equal "category", CreditCard::Brand.table_name
     assert_equal "master_credit_card", MasterCreditCard.table_name
   ensure
     ActiveRecord::Base.pluralize_table_names = true
     GUESSED_CLASSES.each(&:reset_table_name)
   end
 
   def test_table_name_guesses_with_prefixes_and_suffixes
     ActiveRecord::Base.table_name_prefix = "test_"
     Category.reset_table_name
     assert_equal "test_categories", Category.table_name
     ActiveRecord::Base.table_name_suffix = "_test"
     Category.reset_table_name
     assert_equal "test_categories_test", Category.table_name
     ActiveRecord::Base.table_name_prefix = ""
     Category.reset_table_name
     assert_equal "categories_test", Category.table_name
     ActiveRecord::Base.table_name_suffix = ""
     Category.reset_table_name
     assert_equal "categories", Category.table_name
   ensure
     ActiveRecord::Base.table_name_prefix = ""
     ActiveRecord::Base.table_name_suffix = ""
     GUESSED_CLASSES.each(&:reset_table_name)
   end
 
   def test_singular_table_name_guesses_with_prefixes_and_suffixes
     ActiveRecord::Base.pluralize_table_names = false
 
     ActiveRecord::Base.table_name_prefix = "test_"
     Category.reset_table_name
     assert_equal "test_category", Category.table_name
     ActiveRecord::Base.table_name_suffix = "_test"
     Category.reset_table_name
     assert_equal "test_category_test", Category.table_name
     ActiveRecord::Base.table_name_prefix = ""
     Category.reset_table_name
     assert_equal "category_test", Category.table_name
     ActiveRecord::Base.table_name_suffix = ""
     Category.reset_table_name
     assert_equal "category", Category.table_name
   ensure
     ActiveRecord::Base.pluralize_table_names = true
     ActiveRecord::Base.table_name_prefix = ""
     ActiveRecord::Base.table_name_suffix = ""
     GUESSED_CLASSES.each(&:reset_table_name)
   end
 
   def test_table_name_guesses_with_inherited_prefixes_and_suffixes
     GUESSED_CLASSES.each(&:reset_table_name)
 
     CreditCard.table_name_prefix = "test_"
     CreditCard.reset_table_name
     Category.reset_table_name
     assert_equal "test_credit_cards", CreditCard.table_name
     assert_equal "categories", Category.table_name
     CreditCard.table_name_suffix = "_test"
     CreditCard.reset_table_name
     Category.reset_table_name
     assert_equal "test_credit_cards_test", CreditCard.table_name
     assert_equal "categories", Category.table_name
     CreditCard.table_name_prefix = ""
     CreditCard.reset_table_name
     Category.reset_table_name
     assert_equal "credit_cards_test", CreditCard.table_name
     assert_equal "categories", Category.table_name
     CreditCard.table_name_suffix = ""
     CreditCard.reset_table_name
     Category.reset_table_name
     assert_equal "credit_cards", CreditCard.table_name
     assert_equal "categories", Category.table_name
   ensure
     CreditCard.table_name_prefix = ""
     CreditCard.table_name_suffix = ""
     GUESSED_CLASSES.each(&:reset_table_name)
   end
 
   def test_singular_table_name_guesses_for_individual_table
     CreditCard.pluralize_table_names = false
     CreditCard.reset_table_name
     assert_equal "credit_card", CreditCard.table_name
     assert_equal "categories", Category.table_name
   ensure
     CreditCard.pluralize_table_names = true
     CreditCard.reset_table_name
   end
 
   if current_adapter?(:MysqlAdapter) or current_adapter?(:Mysql2Adapter)
     def test_update_all_with_order_and_limit
       assert_equal 1, Topic.update_all("content = 'bulk updated!'", nil, :limit => 1, :order => 'id DESC')
     end
   end
 
   def test_null_fields
     assert_nil Topic.find(1).parent_id
     assert_nil Topic.create("title" => "Hey you").parent_id
   end
 
   def test_default_values
     topic = Topic.new
     assert topic.approved?
     assert_nil topic.written_on
     assert_nil topic.bonus_time
     assert_nil topic.last_read
 
     topic.save
 
     topic = Topic.find(topic.id)
     assert topic.approved?
     assert_nil topic.last_read
 
     # Oracle has some funky default handling, so it requires a bit of
     # extra testing. See ticket #2788.
     if current_adapter?(:OracleAdapter)
       test = TestOracleDefault.new
       assert_equal "X", test.test_char
       assert_equal "hello", test.test_string
       assert_equal 3, test.test_int
     end
   end
 
   # Oracle, and Sybase do not have a TIME datatype.
   unless current_adapter?(:OracleAdapter, :SybaseAdapter)
     def test_utc_as_time_zone
       Topic.default_timezone = :utc
       attributes = { "bonus_time" => "5:42:00AM" }
       topic = Topic.find(1)
       topic.attributes = attributes
       assert_equal Time.utc(2000, 1, 1, 5, 42, 0), topic.bonus_time
       Topic.default_timezone = :local
     end
 
     def test_utc_as_time_zone_and_new
       Topic.default_timezone = :utc
       attributes = { "bonus_time(1i)"=>"2000",
                      "bonus_time(2i)"=>"1",
                      "bonus_time(3i)"=>"1",
                      "bonus_time(4i)"=>"10",
                      "bonus_time(5i)"=>"35",
                      "bonus_time(6i)"=>"50" }
       topic = Topic.new(attributes)
       assert_equal Time.utc(2000, 1, 1, 10, 35, 50), topic.bonus_time
       Topic.default_timezone = :local
     end
   end
 
   def test_default_values_on_empty_strings
     topic = Topic.new
     topic.approved  = nil
     topic.last_read = nil
 
     topic.save
 
     topic = Topic.find(topic.id)
     assert_nil topic.last_read
 
     # Sybase adapter does not allow nulls in boolean columns
     if current_adapter?(:SybaseAdapter)
       assert topic.approved == false
     else
       assert_nil topic.approved
     end
   end
 
   def test_equality
     assert_equal Topic.find(1), Topic.find(2).topic
   end
 
   def test_find_by_slug
     assert_equal Topic.find('1-meowmeow'), Topic.find(1)
   end
 
   def test_equality_of_new_records
     assert_not_equal Topic.new, Topic.new
   end
 
   def test_equality_of_destroyed_records
     topic_1 = Topic.new(:title => 'test_1')
     topic_1.save
     topic_2 = Topic.find(topic_1.id)
     topic_1.destroy
     assert_equal topic_1, topic_2
     assert_equal topic_2, topic_1
   end
 
   def test_hashing
     assert_equal [ Topic.find(1) ], [ Topic.find(2).topic ] & [ Topic.find(1) ]
   end
 
   def test_comparison
     topic_1 = Topic.create!
     topic_2 = Topic.create!
 
     assert_equal [topic_2, topic_1].sort, [topic_1, topic_2]
   end
 
   def test_comparison_with_different_objects
     topic = Topic.create
     category = Category.create(:name => "comparison")
     assert_nil topic <=> category
   end
 
   def test_readonly_attributes
     assert_equal Set.new([ 'title' , 'comments_count' ]), ReadonlyTitlePost.readonly_attributes
 
     post = ReadonlyTitlePost.create(:title => "cannot change this", :body => "changeable")
     post.reload
     assert_equal "cannot change this", post.title
 
     post.update_attributes(:title => "try to change", :body => "changed")
     post.reload
     assert_equal "cannot change this", post.title
     assert_equal "changed", post.body
   end
 
   def test_non_valid_identifier_column_name
     weird = Weird.create('a$b' => 'value')
     weird.reload
     assert_equal 'value', weird.send('a$b')
 
     weird.update_column('a$b', 'value2')
     weird.reload
     assert_equal 'value2', weird.send('a$b')
   end
 
   def test_multiparameter_attributes_on_date
     attributes = { "last_read(1i)" => "2004", "last_read(2i)" => "6", "last_read(3i)" => "24" }
     topic = Topic.find(1)
     topic.attributes = attributes
     # note that extra #to_date call allows test to pass for Oracle, which
     # treats dates/times the same
     assert_date_from_db Date.new(2004, 6, 24), topic.last_read.to_date
   end
 
   def test_multiparameter_attributes_on_date_with_empty_year
     attributes = { "last_read(1i)" => "", "last_read(2i)" => "6", "last_read(3i)" => "24" }
     topic = Topic.find(1)
     topic.attributes = attributes
     # note that extra #to_date call allows test to pass for Oracle, which
     # treats dates/times the same
     assert_nil topic.last_read
   end
 
   def test_multiparameter_attributes_on_date_with_empty_month
     attributes = { "last_read(1i)" => "2004", "last_read(2i)" => "", "last_read(3i)" => "24" }
     topic = Topic.find(1)
     topic.attributes = attributes
     # note that extra #to_date call allows test to pass for Oracle, which
     # treats dates/times the same
     assert_nil topic.last_read
   end
 
   def test_multiparameter_attributes_on_date_with_empty_day
     attributes = { "last_read(1i)" => "2004", "last_read(2i)" => "6", "last_read(3i)" => "" }
     topic = Topic.find(1)
     topic.attributes = attributes
     # note that extra #to_date call allows test to pass for Oracle, which
     # treats dates/times the same
     assert_nil topic.last_read
   end
 
   def test_multiparameter_attributes_on_date_with_empty_day_and_year
     attributes = { "last_read(1i)" => "", "last_read(2i)" => "6", "last_read(3i)" => "" }
     topic = Topic.find(1)
     topic.attributes = attributes
     # note that extra #to_date call allows test to pass for Oracle, which
     # treats dates/times the same
     assert_nil topic.last_read
   end
 
   def test_multiparameter_attributes_on_date_with_empty_day_and_month
     attributes = { "last_read(1i)" => "2004", "last_read(2i)" => "", "last_read(3i)" => "" }
     topic = Topic.find(1)
     topic.attributes = attributes
     # note that extra #to_date call allows test to pass for Oracle, which
     # treats dates/times the same
     assert_nil topic.last_read
   end
 
   def test_multiparameter_attributes_on_date_with_empty_year_and_month
     attributes = { "last_read(1i)" => "", "last_read(2i)" => "", "last_read(3i)" => "24" }
     topic = Topic.find(1)
     topic.attributes = attributes
     # note that extra #to_date call allows test to pass for Oracle, which
     # treats dates/times the same
     assert_nil topic.last_read
   end
 
   def test_multiparameter_attributes_on_date_with_all_empty
     attributes = { "last_read(1i)" => "", "last_read(2i)" => "", "last_read(3i)" => "" }
     topic = Topic.find(1)
     topic.attributes = attributes
     assert_nil topic.last_read
   end
 
   def test_multiparameter_attributes_on_time
     attributes = {
       "written_on(1i)" => "2004", "written_on(2i)" => "6", "written_on(3i)" => "24",
       "written_on(4i)" => "16", "written_on(5i)" => "24", "written_on(6i)" => "00"
     }
     topic = Topic.find(1)
     topic.attributes = attributes
     assert_equal Time.local(2004, 6, 24, 16, 24, 0), topic.written_on
   end
 
   def test_multiparameter_attributes_on_time_with_no_date
     ex = assert_raise(ActiveRecord::MultiparameterAssignmentErrors) do
       attributes = {
         "written_on(4i)" => "16", "written_on(5i)" => "24", "written_on(6i)" => "00"
       }
       topic = Topic.find(1)
       topic.attributes = attributes
     end
     assert_equal("written_on", ex.errors[0].attribute)
   end
 
   def test_multiparameter_attributes_on_time_with_invalid_time_params
     ex = assert_raise(ActiveRecord::MultiparameterAssignmentErrors) do
       attributes = {
         "written_on(1i)" => "2004", "written_on(2i)" => "6", "written_on(3i)" => "24",
         "written_on(4i)" => "2004", "written_on(5i)" => "36", "written_on(6i)" => "64",
       }
       topic = Topic.find(1)
       topic.attributes = attributes
     end
     assert_equal("written_on", ex.errors[0].attribute)
   end
 
   def test_multiparameter_attributes_on_time_with_old_date
     attributes = {
       "written_on(1i)" => "1850", "written_on(2i)" => "6", "written_on(3i)" => "24",
       "written_on(4i)" => "16", "written_on(5i)" => "24", "written_on(6i)" => "00"
     }
     topic = Topic.find(1)
     topic.attributes = attributes
     # testing against to_s(:db) representation because either a Time or a DateTime might be returned, depending on platform
     assert_equal "1850-06-24 16:24:00", topic.written_on.to_s(:db)
   end
 
   def test_multiparameter_attributes_on_time_will_raise_on_big_time_if_missing_date_parts
     ex = assert_raise(ActiveRecord::MultiparameterAssignmentErrors) do
       attributes = {
         "written_on(4i)" => "16", "written_on(5i)" => "24"
       }
       topic = Topic.find(1)
       topic.attributes = attributes
     end
     assert_equal("written_on", ex.errors[0].attribute)
   end
 
   def test_multiparameter_attributes_on_time_with_raise_on_small_time_if_missing_date_parts
     ex = assert_raise(ActiveRecord::MultiparameterAssignmentErrors) do
       attributes = {
         "written_on(4i)" => "16", "written_on(5i)" => "12", "written_on(6i)" => "02"
       }
       topic = Topic.find(1)
       topic.attributes = attributes
     end
     assert_equal("written_on", ex.errors[0].attribute)
   end
 
   def test_multiparameter_attributes_on_time_will_ignore_hour_if_missing
     attributes = {
       "written_on(1i)" => "2004", "written_on(2i)" => "12", "written_on(3i)" => "12",
       "written_on(5i)" => "12", "written_on(6i)" => "02"
     }
     topic = Topic.find(1)
     topic.attributes = attributes
     assert_equal Time.local(2004, 12, 12, 0, 12, 2), topic.written_on
   end
 
   def test_multiparameter_attributes_on_time_will_ignore_hour_if_blank
     attributes = {
       "written_on(1i)" => "", "written_on(2i)" => "", "written_on(3i)" => "",
       "written_on(4i)" => "", "written_on(5i)" => "12", "written_on(6i)" => "02"
     }
     topic = Topic.find(1)
     topic.attributes = attributes
     assert_nil topic.written_on
   end
 
   def test_multiparameter_attributes_on_time_will_ignore_date_if_empty
     attributes = {
       "written_on(1i)" => "", "written_on(2i)" => "", "written_on(3i)" => "",
       "written_on(4i)" => "16", "written_on(5i)" => "24"
     }
     topic = Topic.find(1)
     topic.attributes = attributes
     assert_nil topic.written_on
   end
   def test_multiparameter_attributes_on_time_with_seconds_will_ignore_date_if_empty
     attributes = {
       "written_on(1i)" => "", "written_on(2i)" => "", "written_on(3i)" => "",
       "written_on(4i)" => "16", "written_on(5i)" => "12", "written_on(6i)" => "02"
     }
     topic = Topic.find(1)
     topic.attributes = attributes
     assert_nil topic.written_on
   end
 
   def test_multiparameter_attributes_on_time_with_utc
     ActiveRecord::Base.default_timezone = :utc
     attributes = {
       "written_on(1i)" => "2004", "written_on(2i)" => "6", "written_on(3i)" => "24",
       "written_on(4i)" => "16", "written_on(5i)" => "24", "written_on(6i)" => "00"
     }
     topic = Topic.find(1)
     topic.attributes = attributes
     assert_equal Time.utc(2004, 6, 24, 16, 24, 0), topic.written_on
   ensure
     ActiveRecord::Base.default_timezone = :local
   end
 
   def test_multiparameter_attributes_on_time_with_time_zone_aware_attributes
     ActiveRecord::Base.time_zone_aware_attributes = true
     ActiveRecord::Base.default_timezone = :utc
     Time.zone = ActiveSupport::TimeZone[-28800]
     attributes = {
       "written_on(1i)" => "2004", "written_on(2i)" => "6", "written_on(3i)" => "24",
       "written_on(4i)" => "16", "written_on(5i)" => "24", "written_on(6i)" => "00"
     }
     topic = Topic.find(1)
     topic.attributes = attributes
     assert_equal Time.utc(2004, 6, 24, 23, 24, 0), topic.written_on
     assert_equal Time.utc(2004, 6, 24, 16, 24, 0), topic.written_on.time
     assert_equal Time.zone, topic.written_on.time_zone
   ensure
     ActiveRecord::Base.time_zone_aware_attributes = false
     ActiveRecord::Base.default_timezone = :local
     Time.zone = nil
   end
 
   def test_multiparameter_attributes_on_time_with_time_zone_aware_attributes_false
     ActiveRecord::Base.time_zone_aware_attributes = false
     Time.zone = ActiveSupport::TimeZone[-28800]
     attributes = {
       "written_on(1i)" => "2004", "written_on(2i)" => "6", "written_on(3i)" => "24",
       "written_on(4i)" => "16", "written_on(5i)" => "24", "written_on(6i)" => "00"
     }
     topic = Topic.find(1)
     topic.attributes = attributes
     assert_equal Time.local(2004, 6, 24, 16, 24, 0), topic.written_on
     assert_equal false, topic.written_on.respond_to?(:time_zone)
   ensure
     Time.zone = nil
   end
 
   def test_multiparameter_attributes_on_time_with_skip_time_zone_conversion_for_attributes
     ActiveRecord::Base.time_zone_aware_attributes = true
     ActiveRecord::Base.default_timezone = :utc
     Time.zone = ActiveSupport::TimeZone[-28800]
     Topic.skip_time_zone_conversion_for_attributes = [:written_on]
     attributes = {
       "written_on(1i)" => "2004", "written_on(2i)" => "6", "written_on(3i)" => "24",
       "written_on(4i)" => "16", "written_on(5i)" => "24", "written_on(6i)" => "00"
     }
     topic = Topic.find(1)
     topic.attributes = attributes
     assert_equal Time.utc(2004, 6, 24, 16, 24, 0), topic.written_on
     assert_equal false, topic.written_on.respond_to?(:time_zone)
   ensure
     ActiveRecord::Base.time_zone_aware_attributes = false
     ActiveRecord::Base.default_timezone = :local
     Time.zone = nil
     Topic.skip_time_zone_conversion_for_attributes = []
   end
 
   # Oracle, and Sybase do not have a TIME datatype.
   unless current_adapter?(:OracleAdapter, :SybaseAdapter)
     def test_multiparameter_attributes_on_time_only_column_with_time_zone_aware_attributes_does_not_do_time_zone_conversion
       ActiveRecord::Base.time_zone_aware_attributes = true
       ActiveRecord::Base.default_timezone = :utc
       Time.zone = ActiveSupport::TimeZone[-28800]
       attributes = {
         "bonus_time(1i)" => "2000", "bonus_time(2i)" => "1", "bonus_time(3i)" => "1",
         "bonus_time(4i)" => "16", "bonus_time(5i)" => "24"
       }
       topic = Topic.find(1)
       topic.attributes = attributes
       assert_equal Time.utc(2000, 1, 1, 16, 24, 0), topic.bonus_time
       assert topic.bonus_time.utc?
     ensure
       ActiveRecord::Base.time_zone_aware_attributes = false
       ActiveRecord::Base.default_timezone = :local
       Time.zone = nil
     end
   end
 
   def test_multiparameter_attributes_on_time_with_empty_seconds
     attributes = {
       "written_on(1i)" => "2004", "written_on(2i)" => "6", "written_on(3i)" => "24",
       "written_on(4i)" => "16", "written_on(5i)" => "24", "written_on(6i)" => ""
     }
     topic = Topic.find(1)
     topic.attributes = attributes
     assert_equal Time.local(2004, 6, 24, 16, 24, 0), topic.written_on
   end
 
   def test_multiparameter_assignment_of_aggregation
     customer = Customer.new
     address = Address.new("The Street", "The City", "The Country")
     attributes = { "address(1)" => address.street, "address(2)" => address.city, "address(3)" => address.country }
     customer.attributes = attributes
     assert_equal address, customer.address
   end
 
   def test_multiparameter_assignment_of_aggregation_out_of_order
     customer = Customer.new
     address = Address.new("The Street", "The City", "The Country")
     attributes = { "address(3)" => address.country, "address(2)" => address.city, "address(1)" => address.street }
     customer.attributes = attributes
     assert_equal address, customer.address
   end
 
   def test_multiparameter_assignment_of_aggregation_with_missing_values
     ex = assert_raise(ActiveRecord::MultiparameterAssignmentErrors) do
       customer = Customer.new
       address = Address.new("The Street", "The City", "The Country")
       attributes = { "address(2)" => address.city, "address(3)" => address.country }
       customer.attributes = attributes
     end
     assert_equal("address", ex.errors[0].attribute)
   end
 
   def test_multiparameter_assignment_of_aggregation_with_blank_values
     customer = Customer.new
     address = Address.new("The Street", "The City", "The Country")
     attributes = { "address(1)" => "", "address(2)" => address.city, "address(3)" => address.country }
     customer.attributes = attributes
     assert_equal Address.new(nil, "The City", "The Country"), customer.address
   end
 
   def test_multiparameter_assignment_of_aggregation_with_large_index
     ex = assert_raise(ActiveRecord::MultiparameterAssignmentErrors) do
       customer = Customer.new
       address = Address.new("The Street", "The City", "The Country")
       attributes = { "address(1)" => "The Street", "address(2)" => address.city, "address(3000)" => address.country }
       customer.attributes = attributes
     end
     assert_equal("address", ex.errors[0].attribute)
   end
 
   def test_attributes_on_dummy_time
     # Oracle, and Sybase do not have a TIME datatype.
     return true if current_adapter?(:OracleAdapter, :SybaseAdapter)
 
     attributes = {
       "bonus_time" => "5:42:00AM"
     }
     topic = Topic.find(1)
     topic.attributes = attributes
     assert_equal Time.local(2000, 1, 1, 5, 42, 0), topic.bonus_time
   end
 
   def test_boolean
     b_nil = Boolean.create({ "value" => nil })
     nil_id = b_nil.id
     b_false = Boolean.create({ "value" => false })
     false_id = b_false.id
     b_true = Boolean.create({ "value" => true })
     true_id = b_true.id
 
     b_nil = Boolean.find(nil_id)
     assert_nil b_nil.value
     b_false = Boolean.find(false_id)
     assert !b_false.value?
     b_true = Boolean.find(true_id)
     assert b_true.value?
   end
 
   def test_boolean_cast_from_string
     b_blank = Boolean.create({ "value" => "" })
     blank_id = b_blank.id
     b_false = Boolean.create({ "value" => "0" })
     false_id = b_false.id
     b_true = Boolean.create({ "value" => "1" })
     true_id = b_true.id
 
     b_blank = Boolean.find(blank_id)
     assert_nil b_blank.value
     b_false = Boolean.find(false_id)
     assert !b_false.value?
     b_true = Boolean.find(true_id)
     assert b_true.value?
   end
 
   def test_new_record_returns_boolean
     assert_equal false, Topic.new.persisted?
     assert_equal true, Topic.find(1).persisted?
   end
 
   def test_dup
     topic = Topic.find(1)
     duped_topic = nil
     assert_nothing_raised { duped_topic = topic.dup }
     assert_equal topic.title, duped_topic.title
     assert !duped_topic.persisted?
 
     # test if the attributes have been duped
     topic.title = "a"
     duped_topic.title = "b"
     assert_equal "a", topic.title
     assert_equal "b", duped_topic.title
 
     # test if the attribute values have been duped
     topic.title = {"a" => "b"}
     duped_topic = topic.dup
     duped_topic.title["a"] = "c"
     assert_equal "b", topic.title["a"]
 
     # test if attributes set as part of after_initialize are duped correctly
     assert_equal topic.author_email_address, duped_topic.author_email_address
 
     # test if saved clone object differs from original
     duped_topic.save
     assert duped_topic.persisted?
     assert_not_equal duped_topic.id, topic.id
 
     duped_topic.reload
     # FIXME: I think this is poor behavior, and will fix it with #5686
     assert_equal({'a' => 'c'}.to_yaml, duped_topic.title)
   end
 
   def test_dup_with_aggregate_of_same_name_as_attribute
     dev = DeveloperWithAggregate.find(1)
     assert_kind_of DeveloperSalary, dev.salary
 
     dup = nil
     assert_nothing_raised { dup = dev.dup }
     assert_kind_of DeveloperSalary, dup.salary
     assert_equal dev.salary.amount, dup.salary.amount
     assert !dup.persisted?
 
     # test if the attributes have been dupd
     original_amount = dup.salary.amount
     dev.salary.amount = 1
     assert_equal original_amount, dup.salary.amount
 
     assert dup.save
     assert dup.persisted?
     assert_not_equal dup.id, dev.id
   end
 
   def test_dup_does_not_copy_associations
     author = authors(:david)
     assert_not_equal [], author.posts
     author.send(:clear_association_cache)
 
     author_dup = author.dup
     assert_equal [], author_dup.posts
   end
 
   def test_clone_preserves_subtype
     clone = nil
     assert_nothing_raised { clone = Company.find(3).clone }
     assert_kind_of Client, clone
   end
 
   def test_clone_of_new_object_with_defaults
     developer = Developer.new
     assert !developer.name_changed?
     assert !developer.salary_changed?
 
     cloned_developer = developer.clone
     assert !cloned_developer.name_changed?
     assert !cloned_developer.salary_changed?
   end
 
   def test_clone_of_new_object_marks_attributes_as_dirty
     developer = Developer.new :name => 'Bjorn', :salary => 100000
     assert developer.name_changed?
     assert developer.salary_changed?
 
     cloned_developer = developer.clone
     assert cloned_developer.name_changed?
     assert cloned_developer.salary_changed?
   end
 
   def test_clone_of_new_object_marks_as_dirty_only_changed_attributes
     developer = Developer.new :name => 'Bjorn'
     assert developer.name_changed?            # obviously
     assert !developer.salary_changed?         # attribute has non-nil default value, so treated as not changed
 
     cloned_developer = developer.clone
     assert cloned_developer.name_changed?
     assert !cloned_developer.salary_changed?  # ... and cloned instance should behave same
   end
 
   def test_dup_of_saved_object_marks_attributes_as_dirty
     developer = Developer.create! :name => 'Bjorn', :salary => 100000
     assert !developer.name_changed?
     assert !developer.salary_changed?
 
     cloned_developer = developer.dup
     assert cloned_developer.name_changed?     # both attributes differ from defaults
     assert cloned_developer.salary_changed?
   end
 
   def test_dup_of_saved_object_marks_as_dirty_only_changed_attributes
     developer = Developer.create! :name => 'Bjorn'
     assert !developer.name_changed?           # both attributes of saved object should be treated as not changed
     assert !developer.salary_changed?
 
     cloned_developer = developer.dup
     assert cloned_developer.name_changed?     # ... but on cloned object should be
     assert !cloned_developer.salary_changed?  # ... BUT salary has non-nil default which should be treated as not changed on cloned instance
   end
 
   def test_bignum
     company = Company.find(1)
     company.rating = 2147483647
     company.save
     company = Company.find(1)
     assert_equal 2147483647, company.rating
   end
 
   # TODO: extend defaults tests to other databases!
   if current_adapter?(:PostgreSQLAdapter)
     def test_default
       default = Default.new
 
       # fixed dates / times
       assert_equal Date.new(2004, 1, 1), default.fixed_date
       assert_equal Time.local(2004, 1,1,0,0,0,0), default.fixed_time
 
       # char types
       assert_equal 'Y', default.char1
       assert_equal 'a varchar field', default.char2
       assert_equal 'a text field', default.char3
     end
 
     class Geometric < ActiveRecord::Base; end
     def test_geometric_content
 
       # accepted format notes:
       # ()'s aren't required
       # values can be a mix of float or integer
 
       g = Geometric.new(
         :a_point        => '(5.0, 6.1)',
         #:a_line         => '((2.0, 3), (5.5, 7.0))' # line type is currently unsupported in postgresql
         :a_line_segment => '(2.0, 3), (5.5, 7.0)',
         :a_box          => '2.0, 3, 5.5, 7.0',
         :a_path         => '[(2.0, 3), (5.5, 7.0), (8.5, 11.0)]',  # [ ] is an open path
         :a_polygon      => '((2.0, 3), (5.5, 7.0), (8.5, 11.0))',
         :a_circle       => '<(5.3, 10.4), 2>'
       )
 
       assert g.save
 
       # Reload and check that we have all the geometric attributes.
       h = ActiveRecord::IdentityMap.without { Geometric.find(g.id) }
 
       assert_equal '(5,6.1)', h.a_point
       assert_equal '[(2,3),(5.5,7)]', h.a_line_segment
       assert_equal '(5.5,7),(2,3)', h.a_box   # reordered to store upper right corner then bottom left corner
       assert_equal '[(2,3),(5.5,7),(8.5,11)]', h.a_path
       assert_equal '((2,3),(5.5,7),(8.5,11))', h.a_polygon
       assert_equal '<(5.3,10.4),2>', h.a_circle
 
       # use a geometric function to test for an open path
       objs = Geometric.find_by_sql ["select isopen(a_path) from geometrics where id = ?", g.id]
       assert_equal objs[0].isopen, 't'
 
       # test alternate formats when defining the geometric types
 
       g = Geometric.new(
         :a_point        => '5.0, 6.1',
         #:a_line         => '((2.0, 3), (5.5, 7.0))' # line type is currently unsupported in postgresql
         :a_line_segment => '((2.0, 3), (5.5, 7.0))',
         :a_box          => '(2.0, 3), (5.5, 7.0)',
         :a_path         => '((2.0, 3), (5.5, 7.0), (8.5, 11.0))',  # ( ) is a closed path
         :a_polygon      => '2.0, 3, 5.5, 7.0, 8.5, 11.0',
         :a_circle       => '((5.3, 10.4), 2)'
       )
 
       assert g.save
 
       # Reload and check that we have all the geometric attributes.
       h = ActiveRecord::IdentityMap.without { Geometric.find(g.id) }
 
       assert_equal '(5,6.1)', h.a_point
       assert_equal '[(2,3),(5.5,7)]', h.a_line_segment
       assert_equal '(5.5,7),(2,3)', h.a_box   # reordered to store upper right corner then bottom left corner
       assert_equal '((2,3),(5.5,7),(8.5,11))', h.a_path
       assert_equal '((2,3),(5.5,7),(8.5,11))', h.a_polygon
       assert_equal '<(5.3,10.4),2>', h.a_circle
 
       # use a geometric function to test for an closed path
       objs = Geometric.find_by_sql ["select isclosed(a_path) from geometrics where id = ?", g.id]
       assert_equal objs[0].isclosed, 't'
     end
   end
 
   class NumericData < ActiveRecord::Base
     self.table_name = 'numeric_data'
   end
 
   def test_big_decimal_conditions
     m = NumericData.new(
       :bank_balance => 1586.43,
       :big_bank_balance => BigDecimal("1000234000567.95"),
       :world_population => 6000000000,
       :my_house_population => 3
     )
     assert m.save
     assert_equal 0, NumericData.where("bank_balance > ?", 2000.0).count
   end
 
   def test_numeric_fields
     m = NumericData.new(
       :bank_balance => 1586.43,
       :big_bank_balance => BigDecimal("1000234000567.95"),
       :world_population => 6000000000,
       :my_house_population => 3
     )
     assert m.save
 
     m1 = NumericData.find(m.id)
     assert_not_nil m1
 
     # As with migration_test.rb, we should make world_population >= 2**62
     # to cover 64-bit platforms and test it is a Bignum, but the main thing
     # is that it's an Integer.
     assert_kind_of Integer, m1.world_population
     assert_equal 6000000000, m1.world_population
 
     assert_kind_of Fixnum, m1.my_house_population
     assert_equal 3, m1.my_house_population
 
     assert_kind_of BigDecimal, m1.bank_balance
     assert_equal BigDecimal("1586.43"), m1.bank_balance
 
     assert_kind_of BigDecimal, m1.big_bank_balance
     assert_equal BigDecimal("1000234000567.95"), m1.big_bank_balance
   end
 
   def test_auto_id
     auto = AutoId.new
     auto.save
     assert(auto.id > 0)
   end
 
   def quote_column_name(name)
     "<#{name}>"
   end
 
   def test_quote_keys
     ar = AutoId.new
     source = {"foo" => "bar", "baz" => "quux"}
     actual = ar.send(:quote_columns, self, source)
     inverted = actual.invert
     assert_equal("<foo>", inverted["bar"])
     assert_equal("<baz>", inverted["quux"])
   end
 
   def test_sql_injection_via_find
     assert_raise(ActiveRecord::RecordNotFound, ActiveRecord::StatementInvalid) do
       Topic.find("123456 OR id > 0")
     end
   end
 
   def test_column_name_properly_quoted
     col_record = ColumnName.new
     col_record.references = 40
     assert col_record.save
     col_record.references = 41
     assert col_record.save
     assert_not_nil c2 = ColumnName.find(col_record.id)
     assert_equal(41, c2.references)
   end
 
   def test_quoting_arrays
     replies = Reply.find(:all, :conditions => [ "id IN (?)", topics(:first).replies.collect(&:id) ])
     assert_equal topics(:first).replies.size, replies.size
 
     replies = Reply.find(:all, :conditions => [ "id IN (?)", [] ])
     assert_equal 0, replies.size
   end
 
   MyObject = Struct.new :attribute1, :attribute2
 
   def test_serialized_attribute
     Topic.serialize("content", MyObject)
 
     myobj = MyObject.new('value1', 'value2')
     topic = Topic.create("content" => myobj)
     assert_equal(myobj, topic.content)
 
     topic.reload
     assert_equal(myobj, topic.content)
   end
 
   def test_serialized_time_attribute
     myobj = Time.local(2008,1,1,1,0)
     topic = Topic.create("content" => myobj).reload
     assert_equal(myobj, topic.content)
   end
 
   def test_serialized_string_attribute
     myobj = "Yes"
     topic = Topic.create("content" => myobj).reload
     assert_equal(myobj, topic.content)
   end
 
   def test_nil_serialized_attribute_with_class_constraint
     topic = Topic.new
     assert_nil topic.content
   end
 
   def test_should_raise_exception_on_serialized_attribute_with_type_mismatch
     myobj = MyObject.new('value1', 'value2')
     topic = Topic.new(:content => myobj)
     assert topic.save
     Topic.serialize(:content, Hash)
     assert_raise(ActiveRecord::SerializationTypeMismatch) { Topic.find(topic.id).reload.content }
   ensure
     Topic.serialize(:content)
   end
 
   def test_serialized_attribute_with_class_constraint
     settings = { "color" => "blue" }
     Topic.serialize(:content, Hash)
     topic = Topic.new(:content => settings)
     assert topic.save
     assert_equal(settings, Topic.find(topic.id).content)
   ensure
     Topic.serialize(:content)
   end
 
   def test_serialized_default_class
     Topic.serialize(:content, Hash)
     topic = Topic.new
     assert_equal Hash, topic.content.class
     assert_equal Hash, topic.read_attribute(:content).class
     topic.content["beer"] = "MadridRb"
     assert topic.save
     topic.reload
     assert_equal Hash, topic.content.class
     assert_equal "MadridRb", topic.content["beer"]
   ensure
     Topic.serialize(:content)
   end
 
   def test_serialized_no_default_class_for_object
     topic = Topic.new
     assert_nil topic.content
   end
 
   def test_serialized_boolean_value_true
     Topic.serialize(:content)
     topic = Topic.new(:content => true)
     assert topic.save
     topic = topic.reload
     assert_equal topic.content, true
   end
 
   def test_serialized_boolean_value_false
     Topic.serialize(:content)
     topic = Topic.new(:content => false)
     assert topic.save
     topic = topic.reload
     assert_equal topic.content, false
   end
 
   def test_serialize_with_coder
     coder = Class.new {
       # Identity
       def load(thing)
         thing
       end
 
       # base 64
       def dump(thing)
         [thing].pack('m')
       end
     }.new
 
     Topic.serialize(:content, coder)
     s = 'hello world'
     topic = Topic.new(:content => s)
     assert topic.save
     topic = topic.reload
     assert_equal [s].pack('m'), topic.content
   ensure
     Topic.serialize(:content)
   end
 
   def test_serialize_with_bcrypt_coder
     crypt_coder = Class.new {
       def load(thing)
         return unless thing
         BCrypt::Password.new thing
       end
 
       def dump(thing)
         BCrypt::Password.create(thing).to_s
       end
     }.new
 
     Topic.serialize(:content, crypt_coder)
     password = 'password'
     topic = Topic.new(:content => password)
     assert topic.save
     topic = topic.reload
     assert_kind_of BCrypt::Password, topic.content
     assert_equal(true, topic.content == password, 'password should equal')
   ensure
     Topic.serialize(:content)
   end
 
   def test_quote
     author_name = "\\ \001 ' \n \\n \""
     topic = Topic.create('author_name' => author_name)
     assert_equal author_name, Topic.find(topic.id).author_name
   end
 
   if RUBY_VERSION < '1.9'
     def test_quote_chars
       with_kcode('UTF8') do
         str = 'The Narrator'
         topic = Topic.create(:author_name => str)
         assert_equal str, topic.author_name
 
         assert_kind_of ActiveSupport::Multibyte.proxy_class, str.mb_chars
         topic = Topic.find_by_author_name(str.mb_chars)
 
         assert_kind_of Topic, topic
         assert_equal str, topic.author_name, "The right topic should have been found by name even with name passed as Chars"
       end
     end
   end
 
   def test_toggle_attribute
     assert !topics(:first).approved?
     topics(:first).toggle!(:approved)
     assert topics(:first).approved?
     topic = topics(:first)
     topic.toggle(:approved)
     assert !topic.approved?
     topic.reload
     assert topic.approved?
   end
 
   def test_reload
     t1 = Topic.find(1)
     t2 = Topic.find(1)
     t1.title = "something else"
     t1.save
     t2.reload
     assert_equal t1.title, t2.title
   end
 
   def test_reload_with_exclusive_scope
     dev = DeveloperCalledDavid.first
     dev.update_attributes!( :name => "NotDavid" )
     assert_equal dev, dev.reload
   end
 
   def test_define_attr_method_with_value
     k = Class.new( ActiveRecord::Base )
     k.send(:define_attr_method, :table_name, "foo")
     assert_equal "foo", k.table_name
   end
 
   def test_define_attr_method_with_block
     k = Class.new( ActiveRecord::Base ) do
       class << self
         attr_accessor :foo_key
       end
     end
     k.foo_key = "id"
     k.send(:define_attr_method, :foo_key) { "sys_" + original_foo_key }
     assert_equal "sys_id", k.foo_key
   end
 
   def test_set_table_name_with_value
     k = Class.new( ActiveRecord::Base )
     k.table_name = "foo"
     assert_equal "foo", k.table_name
     k.set_table_name "bar"
     assert_equal "bar", k.table_name
   end
 
   def test_switching_between_table_name
     assert_difference("GoodJoke.count") do
       Joke.set_table_name "cold_jokes"
       Joke.create
 
       Joke.set_table_name "funny_jokes"
       Joke.create
     end
   end
 
   def test_quoted_table_name_after_set_table_name
     klass = Class.new(ActiveRecord::Base)
 
     klass.set_table_name "foo"
     assert_equal "foo", klass.table_name
     assert_equal klass.connection.quote_table_name("foo"), klass.quoted_table_name
 
     klass.set_table_name "bar"
     assert_equal "bar", klass.table_name
     assert_equal klass.connection.quote_table_name("bar"), klass.quoted_table_name
   end
 
   def test_set_table_name_with_block
     k = Class.new( ActiveRecord::Base )
     k.set_table_name { "ks" }
     assert_equal "ks", k.table_name
   end
 
   def test_set_primary_key_with_value
     k = Class.new( ActiveRecord::Base )
     k.primary_key = "foo"
     assert_equal "foo", k.primary_key
     k.set_primary_key "bar"
     assert_equal "bar", k.primary_key
   end
 
   def test_set_primary_key_with_block
     k = Class.new( ActiveRecord::Base )
     k.primary_key = 'id'
     k.set_primary_key { "sys_" + original_primary_key }
     assert_equal "sys_id", k.primary_key
   end
 
   def test_set_inheritance_column_with_value
     k = Class.new( ActiveRecord::Base )
     k.inheritance_column = "foo"
     assert_equal "foo", k.inheritance_column
     k.set_inheritance_column "bar"
     assert_equal "bar", k.inheritance_column
   end
 
   def test_set_inheritance_column_with_block
     k = Class.new( ActiveRecord::Base )
     k.set_inheritance_column { original_inheritance_column + "_id" }
     assert_equal "type_id", k.inheritance_column
   end
 
   def test_count_with_join
     res = Post.count_by_sql "SELECT COUNT(*) FROM posts LEFT JOIN comments ON posts.id=comments.post_id WHERE posts.#{QUOTED_TYPE} = 'Post'"
 
     res2 = Post.count(:conditions => "posts.#{QUOTED_TYPE} = 'Post'", :joins => "LEFT JOIN comments ON posts.id=comments.post_id")
     assert_equal res, res2
 
     res3 = nil
     assert_nothing_raised do
       res3 = Post.count(:conditions => "posts.#{QUOTED_TYPE} = 'Post'",
                         :joins => "LEFT JOIN comments ON posts.id=comments.post_id")
     end
     assert_equal res, res3
 
     res4 = Post.count_by_sql "SELECT COUNT(p.id) FROM posts p, comments co WHERE p.#{QUOTED_TYPE} = 'Post' AND p.id=co.post_id"
     res5 = nil
     assert_nothing_raised do
       res5 = Post.count(:conditions => "p.#{QUOTED_TYPE} = 'Post' AND p.id=co.post_id",
                         :joins => "p, comments co",
                         :select => "p.id")
     end
 
     assert_equal res4, res5
 
     res6 = Post.count_by_sql "SELECT COUNT(DISTINCT p.id) FROM posts p, comments co WHERE p.#{QUOTED_TYPE} = 'Post' AND p.id=co.post_id"
     res7 = nil
     assert_nothing_raised do
       res7 = Post.count(:conditions => "p.#{QUOTED_TYPE} = 'Post' AND p.id=co.post_id",
                         :joins => "p, comments co",
                         :select => "p.id",
                         :distinct => true)
     end
     assert_equal res6, res7
   end
 
   def test_scoped_find_conditions
     scoped_developers = Developer.send(:with_scope, :find => { :conditions => 'salary > 90000' }) do
       Developer.find(:all, :conditions => 'id < 5')
     end
     assert !scoped_developers.include?(developers(:david)) # David's salary is less than 90,000
     assert_equal 3, scoped_developers.size
   end
 
   def test_no_limit_offset
     assert_nothing_raised do
       Developer.find(:all, :offset => 2)
     end
   end
 
   def test_scoped_find_limit_offset
     scoped_developers = Developer.send(:with_scope, :find => { :limit => 3, :offset => 2 }) do
       Developer.find(:all, :order => 'id')
     end
     assert !scoped_developers.include?(developers(:david))
     assert !scoped_developers.include?(developers(:jamis))
     assert_equal 3, scoped_developers.size
 
     # Test without scoped find conditions to ensure we get the whole thing
     developers = Developer.find(:all, :order => 'id')
     assert_equal Developer.count, developers.size
   end
 
   def test_scoped_find_order
     # Test order in scope
     scoped_developers = Developer.send(:with_scope, :find => { :limit => 1, :order => 'salary DESC' }) do
       Developer.find(:all)
     end
     assert_equal 'Jamis', scoped_developers.first.name
     assert scoped_developers.include?(developers(:jamis))
     # Test scope without order and order in find
     scoped_developers = Developer.send(:with_scope, :find => { :limit => 1 }) do
       Developer.find(:all, :order => 'salary DESC')
     end
     # Test scope order + find order, order has priority
     scoped_developers = Developer.send(:with_scope, :find => { :limit => 3, :order => 'id DESC' }) do
       Developer.find(:all, :order => 'salary ASC')
     end
     assert scoped_developers.include?(developers(:poor_jamis))
     assert ! scoped_developers.include?(developers(:david))
     assert ! scoped_developers.include?(developers(:jamis))
     assert_equal 3, scoped_developers.size
 
     # Test without scoped find conditions to ensure we get the right thing
     assert ! scoped_developers.include?(Developer.find(1))
     assert scoped_developers.include?(Developer.find(11))
   end
 
   def test_scoped_find_limit_offset_including_has_many_association
     topics = Topic.send(:with_scope, :find => {:limit => 1, :offset => 1, :include => :replies}) do
       Topic.find(:all, :order => "topics.id")
     end
     assert_equal 1, topics.size
     assert_equal 2, topics.first.id
   end
 
   def test_scoped_find_order_including_has_many_association
     developers = Developer.send(:with_scope, :find => { :order => 'developers.salary DESC', :include => :projects }) do
       Developer.find(:all)
     end
     assert developers.size >= 2
     for i in 1...developers.size
       assert developers[i-1].salary >= developers[i].salary
     end
   end
 
   def test_scoped_find_with_group_and_having
     developers = Developer.send(:with_scope, :find => { :group => 'developers.salary', :having => "SUM(salary) > 10000", :select => "SUM(salary) as salary" }) do
       Developer.find(:all)
     end
     assert_equal 3, developers.size
   end
 
   def test_find_last
     last  = Developer.find :last
     assert_equal last, Developer.find(:first, :order => 'id desc')
   end
 
   def test_last
     assert_equal Developer.find(:first, :order => 'id desc'), Developer.last
   end
 
   def test_all
     developers = Developer.all
     assert_kind_of Array, developers
     assert_equal Developer.find(:all), developers
   end
 
   def test_all_with_conditions
     assert_equal Developer.find(:all, :order => 'id desc'), Developer.order('id desc').all
   end
 
   def test_find_ordered_last
     last  = Developer.find :last, :order => 'developers.salary ASC'
     assert_equal last, Developer.find(:all, :order => 'developers.salary ASC').last
   end
 
   def test_find_reverse_ordered_last
     last  = Developer.find :last, :order => 'developers.salary DESC'
     assert_equal last, Developer.find(:all, :order => 'developers.salary DESC').last
   end
 
   def test_find_multiple_ordered_last
     last  = Developer.find :last, :order => 'developers.name, developers.salary DESC'
     assert_equal last, Developer.find(:all, :order => 'developers.name, developers.salary DESC').last
   end
 
   def test_find_keeps_multiple_order_values
     combined = Developer.find(:all, :order => 'developers.name, developers.salary')
     assert_equal combined, Developer.find(:all, :order => ['developers.name', 'developers.salary'])
   end
 
   def test_find_keeps_multiple_group_values
     combined = Developer.find(:all, :group => 'developers.name, developers.salary, developers.id, developers.created_at, developers.updated_at')
     assert_equal combined, Developer.find(:all, :group => ['developers.name', 'developers.salary', 'developers.id', 'developers.created_at', 'developers.updated_at'])
   end
 
   def test_find_symbol_ordered_last
     last  = Developer.find :last, :order => :salary
     assert_equal last, Developer.find(:all, :order => :salary).last
   end
 
   def test_find_scoped_ordered_last
     last_developer = Developer.send(:with_scope, :find => { :order => 'developers.salary ASC' }) do
       Developer.find(:last)
     end
     assert_equal last_developer, Developer.find(:all, :order => 'developers.salary ASC').last
   end
 
   def test_abstract_class
     assert !ActiveRecord::Base.abstract_class?
     assert LoosePerson.abstract_class?
     assert !LooseDescendant.abstract_class?
   end
 
   def test_base_class
     assert_equal LoosePerson,     LoosePerson.base_class
     assert_equal LooseDescendant, LooseDescendant.base_class
     assert_equal TightPerson,     TightPerson.base_class
     assert_equal TightPerson,     TightDescendant.base_class
 
     assert_equal Post, Post.base_class
     assert_equal Post, SpecialPost.base_class
     assert_equal Post, StiPost.base_class
     assert_equal SubStiPost, SubStiPost.base_class
   end
 
   def test_descends_from_active_record
     # Tries to call Object.abstract_class?
     assert_raise(NoMethodError) do
       ActiveRecord::Base.descends_from_active_record?
     end
 
     # Abstract subclass of AR::Base.
     assert LoosePerson.descends_from_active_record?
 
     # Concrete subclass of an abstract class.
     assert LooseDescendant.descends_from_active_record?
 
     # Concrete subclass of AR::Base.
     assert TightPerson.descends_from_active_record?
 
     # Concrete subclass of a concrete class but has no type column.
     assert TightDescendant.descends_from_active_record?
 
     # Concrete subclass of AR::Base.
     assert Post.descends_from_active_record?
 
     # Abstract subclass of a concrete class which has a type column.
     # This is pathological, as you'll never have Sub < Abstract < Concrete.
     assert !StiPost.descends_from_active_record?
 
     # Concrete subclasses an abstract class which has a type column.
     assert !SubStiPost.descends_from_active_record?
   end
 
   def test_find_on_abstract_base_class_doesnt_use_type_condition
     old_class = LooseDescendant
     Object.send :remove_const, :LooseDescendant
 
     descendant = old_class.create! :first_name => 'bob'
     assert_not_nil LoosePerson.find(descendant.id), "Should have found instance of LooseDescendant when finding abstract LoosePerson: #{descendant.inspect}"
   ensure
     unless Object.const_defined?(:LooseDescendant)
       Object.const_set :LooseDescendant, old_class
     end
   end
 
   def test_assert_queries
     query = lambda { ActiveRecord::Base.connection.execute 'select count(*) from developers' }
     assert_queries(2) { 2.times { query.call } }
     assert_queries 1, &query
     assert_no_queries { assert true }
   end
 
   def test_to_param_should_return_string
     assert_kind_of String, Client.find(:first).to_param
   end
 
   def test_inspect_class
     assert_equal 'ActiveRecord::Base', ActiveRecord::Base.inspect
     assert_equal 'LoosePerson(abstract)', LoosePerson.inspect
     assert_match(/^Topic\(id: integer, title: string/, Topic.inspect)
   end
 
   def test_inspect_instance
     topic = topics(:first)
     assert_equal %(#<Topic id: 1, title: "The First Topic", author_name: "David", author_email_address: "david@loudthinking.com", written_on: "#{topic.written_on.to_s(:db)}", bonus_time: "#{topic.bonus_time.to_s(:db)}", last_read: "#{topic.last_read.to_s(:db)}", content: "Have a nice day", approved: false, replies_count: 1, parent_id: nil, parent_title: nil, type: nil, group: nil, created_at: "#{topic.created_at.to_s(:db)}", updated_at: "#{topic.updated_at.to_s(:db)}">), topic.inspect
   end
 
   def test_inspect_new_instance
     assert_match(/Topic id: nil/, Topic.new.inspect)
   end
 
   def test_inspect_limited_select_instance
     assert_equal %(#<Topic id: 1>), Topic.find(:first, :select => 'id', :conditions => 'id = 1').inspect
     assert_equal %(#<Topic id: 1, title: "The First Topic">), Topic.find(:first, :select => 'id, title', :conditions => 'id = 1').inspect
   end
 
   def test_inspect_class_without_table
     assert_equal "NonExistentTable(Table doesn't exist)", NonExistentTable.inspect
   end
 
   def test_attribute_for_inspect
     t = topics(:first)
     t.title = "The First Topic Now Has A Title With\nNewlines And More Than 50 Characters"
 
     assert_equal %("#{t.written_on.to_s(:db)}"), t.attribute_for_inspect(:written_on)
     assert_equal '"The First Topic Now Has A Title With\nNewlines And M..."', t.attribute_for_inspect(:title)
   end
 
   def test_becomes
     assert_kind_of Reply, topics(:first).becomes(Reply)
     assert_equal "The First Topic", topics(:first).becomes(Reply).title
   end
 
   def test_silence_sets_log_level_to_error_in_block
     original_logger = ActiveRecord::Base.logger
     log = StringIO.new
     ActiveRecord::Base.logger = Logger.new(log)
     ActiveRecord::Base.logger.level = Logger::DEBUG
     ActiveRecord::Base.silence do
       ActiveRecord::Base.logger.warn "warn"
       ActiveRecord::Base.logger.error "error"
     end
     assert_equal "error\n", log.string
   ensure
     ActiveRecord::Base.logger = original_logger
   end
 
   def test_silence_sets_log_level_back_to_level_before_yield
     original_logger = ActiveRecord::Base.logger
     log = StringIO.new
     ActiveRecord::Base.logger = Logger.new(log)
     ActiveRecord::Base.logger.level = Logger::WARN
     ActiveRecord::Base.silence do
     end
     assert_equal Logger::WARN, ActiveRecord::Base.logger.level
   ensure
     ActiveRecord::Base.logger = original_logger
   end
 
   def test_benchmark_with_log_level
     original_logger = ActiveRecord::Base.logger
     log = StringIO.new
     ActiveRecord::Base.logger = Logger.new(log)
     ActiveRecord::Base.logger.level = Logger::WARN
     ActiveRecord::Base.benchmark("Debug Topic Count", :level => :debug) { Topic.count }
     ActiveRecord::Base.benchmark("Warn Topic Count",  :level => :warn)  { Topic.count }
     ActiveRecord::Base.benchmark("Error Topic Count", :level => :error) { Topic.count }
     assert_no_match(/Debug Topic Count/, log.string)
     assert_match(/Warn Topic Count/, log.string)
     assert_match(/Error Topic Count/, log.string)
   ensure
     ActiveRecord::Base.logger = original_logger
   end
 
   def test_benchmark_with_use_silence
     original_logger = ActiveRecord::Base.logger
     log = StringIO.new
     ActiveRecord::Base.logger = Logger.new(log)
     ActiveRecord::Base.benchmark("Logging", :level => :debug, :silence => true) { ActiveRecord::Base.logger.debug "Loud" }
     ActiveRecord::Base.benchmark("Logging", :level => :debug, :silence => false)  { ActiveRecord::Base.logger.debug "Quiet" }
     assert_no_match(/Loud/, log.string)
     assert_match(/Quiet/, log.string)
   ensure
     ActiveRecord::Base.logger = original_logger
   end
 
   def test_compute_type_success
     assert_equal Author, ActiveRecord::Base.send(:compute_type, 'Author')
   end
 
   def test_compute_type_nonexistent_constant
     assert_raises NameError do
       ActiveRecord::Base.send :compute_type, 'NonexistentModel'
     end
   end
 
   def test_compute_type_no_method_error
     ActiveSupport::Dependencies.stubs(:constantize).raises(NoMethodError)
     assert_raises NoMethodError do
       ActiveRecord::Base.send :compute_type, 'InvalidModel'
     end
   end
 
   def test_compute_type_argument_error
     ActiveSupport::Dependencies.stubs(:constantize).raises(ArgumentError)
     assert_raises ArgumentError do
       ActiveRecord::Base.send :compute_type, 'InvalidModel'
     end
   end
 
   def test_clear_cache!
     # preheat cache
     c1 = Post.columns
     ActiveRecord::Base.clear_cache!
     c2 = Post.columns
     assert_not_equal c1, c2
   end
 
   def test_current_scope_is_reset
     Object.const_set :UnloadablePost, Class.new(ActiveRecord::Base)
     UnloadablePost.send(:current_scope=, UnloadablePost.scoped)
 
     UnloadablePost.unloadable
     assert_not_nil Thread.current[:UnloadablePost_current_scope]
     ActiveSupport::Dependencies.remove_unloadable_constants!
     assert_nil Thread.current[:UnloadablePost_current_scope]
   ensure
     Object.class_eval{ remove_const :UnloadablePost } if defined?(UnloadablePost)
   end
 
   def test_marshal_round_trip
     expected = posts(:welcome)
     marshalled = Marshal.dump(expected)
     actual   = Marshal.load(marshalled)
 
     assert_equal expected.attributes, actual.attributes
   end
 
   def test_marshal_new_record_round_trip
     marshalled = Marshal.dump(Post.new)
     post       = Marshal.load(marshalled)
 
     assert post.new_record?, "should be a new record"
   end
 
   def test_marshalling_with_associations
     post = Post.new
     post.comments.build
 
     marshalled = Marshal.dump(post)
     post       = Marshal.load(marshalled)
 
     assert_equal 1, post.comments.length
   end
 
   def test_attribute_names
     assert_equal ["id", "type", "ruby_type", "firm_id", "firm_name", "name", "client_of", "rating", "account_id"],
                  Company.attribute_names
   end
 
   def test_attribute_names_on_table_not_exists
     assert_equal [], NonExistentTable.attribute_names
   end
 
   def test_attribtue_names_on_abstract_class
     assert_equal [], AbstractCompany.attribute_names
   end
 
   def test_cache_key_for_existing_record_is_not_timezone_dependent
     ActiveRecord::Base.time_zone_aware_attributes = true
 
     Time.zone = "UTC"
     utc_key = Developer.first.cache_key
 
     Time.zone = "EST"
     est_key = Developer.first.cache_key
 
     assert_equal utc_key, est_key
   ensure
     ActiveRecord::Base.time_zone_aware_attributes = false
   end
 
   def test_cache_key_format_for_existing_record_with_updated_at
     dev = Developer.first
     assert_equal "developers/#{dev.id}-#{dev.updated_at.utc.to_s(:number)}", dev.cache_key
   end
 
   def test_cache_key_format_for_existing_record_with_nil_updated_at
     dev = Developer.first
     dev.update_attribute(:updated_at, nil)
     assert_match(/\/#{dev.id}$/, dev.cache_key)
   end
