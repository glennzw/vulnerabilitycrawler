   [SCTP]: Prevent possible infinite recursion with multiple bundled DATA.
   
   There is a rare situation that causes lksctp to go into infinite recursion
   and crash the system.  The trigger is a packet that contains at least the
   first two DATA fragments of a message bundled together. The recursion is
   triggered when the user data buffer is smaller that the full data message.
   The problem is that we clone the skb for every fragment in the message.
   When reassembling the full message, we try to link skbs from the "first
   fragment" clone using the frag_list. However, since the frag_list is shared
   between two clones in this rare situation, we end up setting the frag_list
   pointer of the second fragment to point to itself.  This causes
   sctp_skb_pull() to potentially recurse indefinitely.
   
   Proposed solution is to make a copy of the skb when attempting to link
   things using frag_list.
   
   Signed-off-by: Vladislav Yasevich <vladsilav.yasevich@hp.com>
   Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>
   Signed-off-by: David S. Miller <davem@davemloft.net>
static struct sctp_ulpevent *sctp_make_reassembled_event(struct sk_buff_head *queue, struct sk_buff *f_frag, struct sk_buff *l_frag)
{
	struct sk_buff *pos;
	struct sctp_ulpevent *event;
	struct sk_buff *pnext, *last;
	struct sk_buff *list = skb_shinfo(f_frag)->frag_list;
	 */
	if (last)
		last->next = pos;
	else
		skb_shinfo(f_frag)->frag_list = pos;

	/* Remove the first fragment from the reassembly queue.  */
	__skb_unlink(f_frag, queue);
	while (pos) {

		pnext = pos->next;
