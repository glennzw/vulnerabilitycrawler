commit 539689e74a3bcb04d29e4cd9396de91a81045b99
Author: Father Chrysostomos <sprout@cpan.org>
Date:   Thu Mar 31 06:28:49 2011 -0700

    [perl #87336] lc/uc(first) fail to taint the returned string
    
    This bug was caused by change 28011 (ec9af7d), which stopped pp_lc
    from using sv_setsv_flags, thereby bypassing these two lines at the
    end of that function:
        if (SvTAINTED(sstr))
    	SvTAINT(dstr);
    
    Change 28012 (6730619) did exactly the same thing to pp_uc.
    
    28013 (d54190f) broke ucfirst and lcfirst.
    
    This commit simply puts that taint logic at the end of the pp_*
    functions.

diff --git a/pp.c b/pp.c
index 751a0bf..8b15b6e 100644
--- a/pp.c
+++ b/pp.c
@@ -3906,802 +3906,808 @@ STMT_START {								    \
 PP(pp_ucfirst)
 {
     /* Actually is both lcfirst() and ucfirst().  Only the first character
      * changes.  This means that possibly we can change in-place, ie., just
      * take the source and change that one character and store it back, but not
      * if read-only etc, or if the length changes */
 
     dVAR;
     dSP;
     SV *source = TOPs;
     STRLEN slen; /* slen is the byte length of the whole SV. */
     STRLEN need;
     SV *dest;
     bool inplace;   /* ? Convert first char only, in-place */
     bool doing_utf8 = FALSE;		   /* ? using utf8 */
     bool convert_source_to_utf8 = FALSE;   /* ? need to convert */
     const int op_type = PL_op->op_type;
     const U8 *s;
     U8 *d;
     U8 tmpbuf[UTF8_MAXBYTES_CASE+1];
     STRLEN ulen;    /* ulen is the byte length of the original Unicode character
 		     * stored as UTF-8 at s. */
     STRLEN tculen;  /* tculen is the byte length of the freshly titlecased (or
 		     * lowercased) character stored in tmpbuf.  May be either
 		     * UTF-8 or not, but in either case is the number of bytes */
 
     SvGETMAGIC(source);
     if (SvOK(source)) {
 	s = (const U8*)SvPV_nomg_const(source, slen);
     } else {
 	if (ckWARN(WARN_UNINITIALIZED))
 	    report_uninit(source);
 	s = (const U8*)"";
 	slen = 0;
     }
 
     /* We may be able to get away with changing only the first character, in
      * place, but not if read-only, etc.  Later we may discover more reasons to
      * not convert in-place. */
     inplace = SvPADTMP(source) && !SvREADONLY(source) && SvTEMP(source);
 
     /* First calculate what the changed first character should be.  This affects
      * whether we can just swap it out, leaving the rest of the string unchanged,
      * or even if have to convert the dest to UTF-8 when the source isn't */
 
     if (! slen) {   /* If empty */
 	need = 1; /* still need a trailing NUL */
     }
     else if (DO_UTF8(source)) {	/* Is the source utf8? */
 	doing_utf8 = TRUE;
 
 /* TODO: This is #ifdefd out because it has hard-coded the standard mappings,
  * and doesn't allow for the user to specify their own.  When code is added to
  * detect if there is a user-defined mapping in force here, and if so to use
  * that, then the code below can be compiled.  The detection would be a good
  * thing anyway, as currently the user-defined mappings only work on utf8
  * strings, and thus depend on the chosen internal storage method, which is a
  * bad thing */
 #ifdef GO_AHEAD_AND_BREAK_USER_DEFINED_CASE_MAPPINGS
 	if (UTF8_IS_INVARIANT(*s)) {
 
 	    /* An invariant source character is either ASCII or, in EBCDIC, an
 	     * ASCII equivalent or a caseless C1 control.  In both these cases,
 	     * the lower and upper cases of any character are also invariants
 	     * (and title case is the same as upper case).  So it is safe to
 	     * use the simple case change macros which avoid the overhead of
 	     * the general functions.  Note that if perl were to be extended to
 	     * do locale handling in UTF-8 strings, this wouldn't be true in,
 	     * for example, Lithuanian or Turkic.  */
 	    *tmpbuf = (op_type == OP_LCFIRST) ? toLOWER(*s) : toUPPER(*s);
 	    tculen = ulen = 1;
 	    need = slen + 1;
 	}
 	else if (UTF8_IS_DOWNGRADEABLE_START(*s)) {
 	    U8 chr;
 
 	    /* Similarly, if the source character isn't invariant but is in the
 	     * latin1 range (or EBCDIC equivalent thereof), we have the case
 	     * changes compiled into perl, and can avoid the overhead of the
 	     * general functions.  In this range, the characters are stored as
 	     * two UTF-8 bytes, and it so happens that any changed-case version
 	     * is also two bytes (in both ASCIIish and EBCDIC machines). */
 	    tculen = ulen = 2;
 	    need = slen + 1;
 
 	    /* Convert the two source bytes to a single Unicode code point
 	     * value, change case and save for below */
 	    chr = TWO_BYTE_UTF8_TO_UNI(*s, *(s+1));
 	    if (op_type == OP_LCFIRST) {    /* lower casing is easy */
 		U8 lower = toLOWER_LATIN1(chr);
 		STORE_UNI_TO_UTF8_TWO_BYTE(tmpbuf, lower);
 	    }
 	    else {	/* ucfirst */
 		U8 upper = toUPPER_LATIN1_MOD(chr);
 
 		/* Most of the latin1 range characters are well-behaved.  Their
 		 * title and upper cases are the same, and are also in the
 		 * latin1 range.  The macro above returns their upper (hence
 		 * title) case, and all that need be done is to save the result
 		 * for below.  However, several characters are problematic, and
 		 * have to be handled specially.  The MOD in the macro name
 		 * above means that these tricky characters all get mapped to
 		 * the single character LATIN_SMALL_LETTER_Y_WITH_DIAERESIS.
 		 * This mapping saves some tests for the majority of the
 		 * characters */
 
 		if (upper != LATIN_SMALL_LETTER_Y_WITH_DIAERESIS) {
 
 		    /* Not tricky.  Just save it. */
 		    STORE_UNI_TO_UTF8_TWO_BYTE(tmpbuf, upper);
 		}
 		else if (chr == LATIN_SMALL_LETTER_SHARP_S) {
 
 		    /* This one is tricky because it is two characters long,
 		     * though the UTF-8 is still two bytes, so the stored
 		     * length doesn't change */
 		    *tmpbuf = 'S';  /* The UTF-8 is 'Ss' */
 		    *(tmpbuf + 1) = 's';
 		}
 		else {
 
 		    /* The other two have their title and upper cases the same,
 		     * but are tricky because the changed-case characters
 		     * aren't in the latin1 range.  They, however, do fit into
 		     * two UTF-8 bytes */
 		    STORE_NON_LATIN1_UC(tmpbuf, chr);    
 		}
 	    }
 	}
 	else {
 #endif	/* end of dont want to break user-defined casing */
 
 	    /* Here, can't short-cut the general case */
 
 	    utf8_to_uvchr(s, &ulen);
 	    if (op_type == OP_UCFIRST) toTITLE_utf8(s, tmpbuf, &tculen);
 	    else toLOWER_utf8(s, tmpbuf, &tculen);
 
 	    /* we can't do in-place if the length changes.  */
 	    if (ulen != tculen) inplace = FALSE;
 	    need = slen + 1 - ulen + tculen;
 #ifdef GO_AHEAD_AND_BREAK_USER_DEFINED_CASE_MAPPINGS
 	}
 #endif
     }
     else { /* Non-zero length, non-UTF-8,  Need to consider locale and if
 	    * latin1 is treated as caseless.  Note that a locale takes
 	    * precedence */ 
 	tculen = 1;	/* Most characters will require one byte, but this will
 			 * need to be overridden for the tricky ones */
 	need = slen + 1;
 
 	if (op_type == OP_LCFIRST) {
 
 	    /* lower case the first letter: no trickiness for any character */
 	    *tmpbuf = (IN_LOCALE_RUNTIME) ? toLOWER_LC(*s) :
 			((IN_UNI_8_BIT) ? toLOWER_LATIN1(*s) : toLOWER(*s));
 	}
 	/* is ucfirst() */
 	else if (IN_LOCALE_RUNTIME) {
 	    *tmpbuf = toUPPER_LC(*s);	/* This would be a bug if any locales
 					 * have upper and title case different
 					 */
 	}
 	else if (! IN_UNI_8_BIT) {
 	    *tmpbuf = toUPPER(*s);	/* Returns caseless for non-ascii, or
 					 * on EBCDIC machines whatever the
 					 * native function does */
 	}
 	else { /* is ucfirst non-UTF-8, not in locale, and cased latin1 */
 	    *tmpbuf = toUPPER_LATIN1_MOD(*s);
 
 	    /* tmpbuf now has the correct title case for all latin1 characters
 	     * except for the several ones that have tricky handling.  All
 	     * of these are mapped by the MOD to the letter below. */
 	    if (*tmpbuf == LATIN_SMALL_LETTER_Y_WITH_DIAERESIS) {
 
 		/* The length is going to change, with all three of these, so
 		 * can't replace just the first character */
 		inplace = FALSE;
 
 		/* We use the original to distinguish between these tricky
 		 * cases */
 		if (*s == LATIN_SMALL_LETTER_SHARP_S) {
 		    /* Two character title case 'Ss', but can remain non-UTF-8 */
 		    need = slen + 2;
 		    *tmpbuf = 'S';
 		    *(tmpbuf + 1) = 's';   /* Assert: length(tmpbuf) >= 2 */
 		    tculen = 2;
 		}
 		else {
 
 		    /* The other two tricky ones have their title case outside
 		     * latin1.  It is the same as their upper case. */
 		    doing_utf8 = TRUE;
 		    STORE_NON_LATIN1_UC(tmpbuf, *s);
 
 		    /* The UTF-8 and UTF-EBCDIC lengths of both these characters
 		     * and their upper cases is 2. */
 		    tculen = ulen = 2;
 
 		    /* The entire result will have to be in UTF-8.  Assume worst
 		     * case sizing in conversion. (all latin1 characters occupy
 		     * at most two bytes in utf8) */
 		    convert_source_to_utf8 = TRUE;
 		    need = slen * 2 + 1;
 		}
 	    } /* End of is one of the three special chars */
 	} /* End of use Unicode (Latin1) semantics */
     } /* End of changing the case of the first character */
 
     /* Here, have the first character's changed case stored in tmpbuf.  Ready to
      * generate the result */
     if (inplace) {
 
 	/* We can convert in place.  This means we change just the first
 	 * character without disturbing the rest; no need to grow */
 	dest = source;
 	s = d = (U8*)SvPV_force_nomg(source, slen);
     } else {
 	dTARGET;
 
 	dest = TARG;
 
 	/* Here, we can't convert in place; we earlier calculated how much
 	 * space we will need, so grow to accommodate that */
 	SvUPGRADE(dest, SVt_PV);
 	d = (U8*)SvGROW(dest, need);
 	(void)SvPOK_only(dest);
 
 	SETs(dest);
     }
 
     if (doing_utf8) {
 	if (! inplace) {
 	    if (! convert_source_to_utf8) {
 
 		/* Here  both source and dest are in UTF-8, but have to create
 		 * the entire output.  We initialize the result to be the
 		 * title/lower cased first character, and then append the rest
 		 * of the string. */
 		sv_setpvn(dest, (char*)tmpbuf, tculen);
 		if (slen > ulen) {
 		    sv_catpvn(dest, (char*)(s + ulen), slen - ulen);
 		}
 	    }
 	    else {
 		const U8 *const send = s + slen;
 
 		/* Here the dest needs to be in UTF-8, but the source isn't,
 		 * except we earlier UTF-8'd the first character of the source
 		 * into tmpbuf.  First put that into dest, and then append the
 		 * rest of the source, converting it to UTF-8 as we go. */
 
 		/* Assert tculen is 2 here because the only two characters that
 		 * get to this part of the code have 2-byte UTF-8 equivalents */
 		*d++ = *tmpbuf;
 		*d++ = *(tmpbuf + 1);
 		s++;	/* We have just processed the 1st char */
 
 		for (; s < send; s++) {
 		    d = uvchr_to_utf8(d, *s);
 		}
 		*d = '\0';
 		SvCUR_set(dest, d - (U8*)SvPVX_const(dest));
 	    }
 	    SvUTF8_on(dest);
 	}
 	else {   /* in-place UTF-8.  Just overwrite the first character */
 	    Copy(tmpbuf, d, tculen, U8);
 	    SvCUR_set(dest, need - 1);
 	}
     }
     else {  /* Neither source nor dest are in or need to be UTF-8 */
 	if (slen) {
 	    if (IN_LOCALE_RUNTIME) {
 		TAINT;
 		SvTAINTED_on(dest);
 	    }
 	    if (inplace) {  /* in-place, only need to change the 1st char */
 		*d = *tmpbuf;
 	    }
 	    else {	/* Not in-place */
 
 		/* Copy the case-changed character(s) from tmpbuf */
 		Copy(tmpbuf, d, tculen, U8);
 		d += tculen - 1; /* Code below expects d to point to final
 				  * character stored */
 	    }
 	}
 	else {	/* empty source */
 	    /* See bug #39028: Don't taint if empty  */
 	    *d = *s;
 	}
 
 	/* In a "use bytes" we don't treat the source as UTF-8, but, still want
 	 * the destination to retain that flag */
 	if (SvUTF8(source))
 	    SvUTF8_on(dest);
 
 	if (!inplace) {	/* Finish the rest of the string, unchanged */
 	    /* This will copy the trailing NUL  */
 	    Copy(s + 1, d + 1, slen, U8);
 	    SvCUR_set(dest, need - 1);
 	}
     }
+    if (dest != source && SvTAINTED(source))
+	SvTAINT(dest);
     SvSETMAGIC(dest);
     RETURN;
 }
 
 /* There's so much setup/teardown code common between uc and lc, I wonder if
    it would be worth merging the two, and just having a switch outside each
    of the three tight loops.  There is less and less commonality though */
 PP(pp_uc)
 {
     dVAR;
     dSP;
     SV *source = TOPs;
     STRLEN len;
     STRLEN min;
     SV *dest;
     const U8 *s;
     U8 *d;
 
     SvGETMAGIC(source);
 
     if (SvPADTMP(source) && !SvREADONLY(source) && !SvAMAGIC(source)
 	&& SvTEMP(source) && !DO_UTF8(source)
 	&& (IN_LOCALE_RUNTIME || ! IN_UNI_8_BIT)) {
 
 	/* We can convert in place.  The reason we can't if in UNI_8_BIT is to
 	 * make the loop tight, so we overwrite the source with the dest before
 	 * looking at it, and we need to look at the original source
 	 * afterwards.  There would also need to be code added to handle
 	 * switching to not in-place in midstream if we run into characters
 	 * that change the length.
 	 */
 	dest = source;
 	s = d = (U8*)SvPV_force_nomg(source, len);
 	min = len + 1;
     } else {
 	dTARGET;
 
 	dest = TARG;
 
 	/* The old implementation would copy source into TARG at this point.
 	   This had the side effect that if source was undef, TARG was now
 	   an undefined SV with PADTMP set, and they don't warn inside
 	   sv_2pv_flags(). However, we're now getting the PV direct from
 	   source, which doesn't have PADTMP set, so it would warn. Hence the
 	   little games.  */
 
 	if (SvOK(source)) {
 	    s = (const U8*)SvPV_nomg_const(source, len);
 	} else {
 	    if (ckWARN(WARN_UNINITIALIZED))
 		report_uninit(source);
 	    s = (const U8*)"";
 	    len = 0;
 	}
 	min = len + 1;
 
 	SvUPGRADE(dest, SVt_PV);
 	d = (U8*)SvGROW(dest, min);
 	(void)SvPOK_only(dest);
 
 	SETs(dest);
     }
 
     /* Overloaded values may have toggled the UTF-8 flag on source, so we need
        to check DO_UTF8 again here.  */
 
     if (DO_UTF8(source)) {
 	const U8 *const send = s + len;
 	U8 tmpbuf[UTF8_MAXBYTES+1];
 
 	/* All occurrences of these are to be moved to follow any other marks.
 	 * This is context-dependent.  We may not be passed enough context to
 	 * move the iota subscript beyond all of them, but we do the best we can
 	 * with what we're given.  The result is always better than if we
 	 * hadn't done this.  And, the problem would only arise if we are
 	 * passed a character without all its combining marks, which would be
 	 * the caller's mistake.  The information this is based on comes from a
 	 * comment in Unicode SpecialCasing.txt, (and the Standard's text
 	 * itself) and so can't be checked properly to see if it ever gets
 	 * revised.  But the likelihood of it changing is remote */
 	bool in_iota_subscript = FALSE;
 
 	while (s < send) {
 	    if (in_iota_subscript && ! is_utf8_mark(s)) {
 		/* A non-mark.  Time to output the iota subscript */
 #define GREEK_CAPITAL_LETTER_IOTA 0x0399
 #define COMBINING_GREEK_YPOGEGRAMMENI 0x0345
 
 		CAT_UNI_TO_UTF8_TWO_BYTE(d, GREEK_CAPITAL_LETTER_IOTA);
 		in_iota_subscript = FALSE;
 	    }
 
 
 /* See comments at the first instance in this file of this ifdef */
 #ifdef GO_AHEAD_AND_BREAK_USER_DEFINED_CASE_MAPPINGS
 
 	    /* If the UTF-8 character is invariant, then it is in the range
 	     * known by the standard macro; result is only one byte long */
 	    if (UTF8_IS_INVARIANT(*s)) {
 		*d++ = toUPPER(*s);
 		s++;
 	    }
 	    else if (UTF8_IS_DOWNGRADEABLE_START(*s)) {
 
 		/* Likewise, if it fits in a byte, its case change is in our
 		 * table */
 		U8 orig = TWO_BYTE_UTF8_TO_UNI(*s, *s++);
 		U8 upper = toUPPER_LATIN1_MOD(orig);
 		CAT_TWO_BYTE_UNI_UPPER_MOD(d, orig, upper);
 		s++;
 	    }
 	    else {
 #else
 	    {
 #endif
 
 		/* Otherwise, need the general UTF-8 case.  Get the changed
 		 * case value and copy it to the output buffer */
 
 		const STRLEN u = UTF8SKIP(s);
 		STRLEN ulen;
 
 		const UV uv = toUPPER_utf8(s, tmpbuf, &ulen);
 		if (uv == GREEK_CAPITAL_LETTER_IOTA
 		    && utf8_to_uvchr(s, 0) == COMBINING_GREEK_YPOGEGRAMMENI)
 		{
 		    in_iota_subscript = TRUE;
 		}
 		else {
 		    if (ulen > u && (SvLEN(dest) < (min += ulen - u))) {
 			/* If the eventually required minimum size outgrows
 			 * the available space, we need to grow. */
 			const UV o = d - (U8*)SvPVX_const(dest);
 
 			/* If someone uppercases one million U+03B0s we
 			 * SvGROW() one million times.  Or we could try
 			 * guessing how much to allocate without allocating too
 			 * much.  Such is life.  See corresponding comment in
 			 * lc code for another option */
 			SvGROW(dest, min);
 			d = (U8*)SvPVX(dest) + o;
 		    }
 		    Copy(tmpbuf, d, ulen, U8);
 		    d += ulen;
 		}
 		s += u;
 	    }
 	}
 	if (in_iota_subscript) {
 	    CAT_UNI_TO_UTF8_TWO_BYTE(d, GREEK_CAPITAL_LETTER_IOTA);
 	}
 	SvUTF8_on(dest);
 	*d = '\0';
 	SvCUR_set(dest, d - (U8*)SvPVX_const(dest));
     }
     else {	/* Not UTF-8 */
 	if (len) {
 	    const U8 *const send = s + len;
 
 	    /* Use locale casing if in locale; regular style if not treating
 	     * latin1 as having case; otherwise the latin1 casing.  Do the
 	     * whole thing in a tight loop, for speed, */
 	    if (IN_LOCALE_RUNTIME) {
 		TAINT;
 		SvTAINTED_on(dest);
 		for (; s < send; d++, s++)
 		    *d = toUPPER_LC(*s);
 	    }
 	    else if (! IN_UNI_8_BIT) {
 		for (; s < send; d++, s++) {
 		    *d = toUPPER(*s);
 		}
 	    }
 	    else {
 		for (; s < send; d++, s++) {
 		    *d = toUPPER_LATIN1_MOD(*s);
 		    if (*d != LATIN_SMALL_LETTER_Y_WITH_DIAERESIS) continue;
 
 		    /* The mainstream case is the tight loop above.  To avoid
 		     * extra tests in that, all three characters that require
 		     * special handling are mapped by the MOD to the one tested
 		     * just above.  
 		     * Use the source to distinguish between the three cases */
 
 		    if (*s == LATIN_SMALL_LETTER_SHARP_S) {
 
 			/* uc() of this requires 2 characters, but they are
 			 * ASCII.  If not enough room, grow the string */
 			if (SvLEN(dest) < ++min) {	
 			    const UV o = d - (U8*)SvPVX_const(dest);
 			    SvGROW(dest, min);
 			    d = (U8*)SvPVX(dest) + o;
 			}
 			*d++ = 'S'; *d = 'S'; /* upper case is 'SS' */
 			continue;   /* Back to the tight loop; still in ASCII */
 		    }
 
 		    /* The other two special handling characters have their
 		     * upper cases outside the latin1 range, hence need to be
 		     * in UTF-8, so the whole result needs to be in UTF-8.  So,
 		     * here we are somewhere in the middle of processing a
 		     * non-UTF-8 string, and realize that we will have to convert
 		     * the whole thing to UTF-8.  What to do?  There are
 		     * several possibilities.  The simplest to code is to
 		     * convert what we have so far, set a flag, and continue on
 		     * in the loop.  The flag would be tested each time through
 		     * the loop, and if set, the next character would be
 		     * converted to UTF-8 and stored.  But, I (khw) didn't want
 		     * to slow down the mainstream case at all for this fairly
 		     * rare case, so I didn't want to add a test that didn't
 		     * absolutely have to be there in the loop, besides the
 		     * possibility that it would get too complicated for
 		     * optimizers to deal with.  Another possibility is to just
 		     * give up, convert the source to UTF-8, and restart the
 		     * function that way.  Another possibility is to convert
 		     * both what has already been processed and what is yet to
 		     * come separately to UTF-8, then jump into the loop that
 		     * handles UTF-8.  But the most efficient time-wise of the
 		     * ones I could think of is what follows, and turned out to
 		     * not require much extra code.  */
 
 		    /* Convert what we have so far into UTF-8, telling the
 		     * function that we know it should be converted, and to
 		     * allow extra space for what we haven't processed yet.
 		     * Assume the worst case space requirements for converting
 		     * what we haven't processed so far: that it will require
 		     * two bytes for each remaining source character, plus the
 		     * NUL at the end.  This may cause the string pointer to
 		     * move, so re-find it. */
 
 		    len = d - (U8*)SvPVX_const(dest);
 		    SvCUR_set(dest, len);
 		    len = sv_utf8_upgrade_flags_grow(dest,
 						SV_GMAGIC|SV_FORCE_UTF8_UPGRADE,
 						(send -s) * 2 + 1);
 		    d = (U8*)SvPVX(dest) + len;
 
 		    /* And append the current character's upper case in UTF-8 */
 		    CAT_NON_LATIN1_UC(d, *s);
 
 		    /* Now process the remainder of the source, converting to
 		     * upper and UTF-8.  If a resulting byte is invariant in
 		     * UTF-8, output it as-is, otherwise convert to UTF-8 and
 		     * append it to the output. */
 
 		    s++;
 		    for (; s < send; s++) {
 			U8 upper = toUPPER_LATIN1_MOD(*s);
 			if UTF8_IS_INVARIANT(upper) {
 			    *d++ = upper;
 			}
 			else {
 			    CAT_TWO_BYTE_UNI_UPPER_MOD(d, *s, upper);
 			}
 		    }
 
 		    /* Here have processed the whole source; no need to continue
 		     * with the outer loop.  Each character has been converted
 		     * to upper case and converted to UTF-8 */
 
 		    break;
 		} /* End of processing all latin1-style chars */
 	    } /* End of processing all chars */
 	} /* End of source is not empty */
 
 	if (source != dest) {
 	    *d = '\0';  /* Here d points to 1 after last char, add NUL */
 	    SvCUR_set(dest, d - (U8*)SvPVX_const(dest));
 	}
     } /* End of isn't utf8 */
+    if (dest != source && SvTAINTED(source))
+	SvTAINT(dest);
     SvSETMAGIC(dest);
     RETURN;
 }
 
 PP(pp_lc)
 {
     dVAR;
     dSP;
     SV *source = TOPs;
     STRLEN len;
     STRLEN min;
     SV *dest;
     const U8 *s;
     U8 *d;
 
     SvGETMAGIC(source);
 
     if (SvPADTMP(source) && !SvREADONLY(source) && !SvAMAGIC(source)
 	&& SvTEMP(source) && !DO_UTF8(source)) {
 
 	/* We can convert in place, as lowercasing anything in the latin1 range
 	 * (or else DO_UTF8 would have been on) doesn't lengthen it */
 	dest = source;
 	s = d = (U8*)SvPV_force_nomg(source, len);
 	min = len + 1;
     } else {
 	dTARGET;
 
 	dest = TARG;
 
 	/* The old implementation would copy source into TARG at this point.
 	   This had the side effect that if source was undef, TARG was now
 	   an undefined SV with PADTMP set, and they don't warn inside
 	   sv_2pv_flags(). However, we're now getting the PV direct from
 	   source, which doesn't have PADTMP set, so it would warn. Hence the
 	   little games.  */
 
 	if (SvOK(source)) {
 	    s = (const U8*)SvPV_nomg_const(source, len);
 	} else {
 	    if (ckWARN(WARN_UNINITIALIZED))
 		report_uninit(source);
 	    s = (const U8*)"";
 	    len = 0;
 	}
 	min = len + 1;
 
 	SvUPGRADE(dest, SVt_PV);
 	d = (U8*)SvGROW(dest, min);
 	(void)SvPOK_only(dest);
 
 	SETs(dest);
     }
 
     /* Overloaded values may have toggled the UTF-8 flag on source, so we need
        to check DO_UTF8 again here.  */
 
     if (DO_UTF8(source)) {
 	const U8 *const send = s + len;
 	U8 tmpbuf[UTF8_MAXBYTES_CASE+1];
 
 	while (s < send) {
 /* See comments at the first instance in this file of this ifdef */
 #ifdef GO_AHEAD_AND_BREAK_USER_DEFINED_CASE_MAPPINGS
 	    if (UTF8_IS_INVARIANT(*s)) {
 
 		/* Invariant characters use the standard mappings compiled in.
 		 */
 		*d++ = toLOWER(*s);
 		s++;
 	    }
 	    else if (UTF8_IS_DOWNGRADEABLE_START(*s)) {
 
 		/* As do the ones in the Latin1 range */
 		U8 lower = toLOWER_LATIN1(TWO_BYTE_UTF8_TO_UNI(*s, *s++));
 		CAT_UNI_TO_UTF8_TWO_BYTE(d, lower);
 		s++;
 	    }
 	    else {
 #endif
 		/* Here, is utf8 not in Latin-1 range, have to go out and get
 		 * the mappings from the tables. */
 
 		const STRLEN u = UTF8SKIP(s);
 		STRLEN ulen;
 
 #ifndef CONTEXT_DEPENDENT_CASING
 		toLOWER_utf8(s, tmpbuf, &ulen);
 #else
 /* This is ifdefd out because it needs more work and thought.  It isn't clear
  * that we should do it.
  * A minor objection is that this is based on a hard-coded rule from the
  *  Unicode standard, and may change, but this is not very likely at all.
  *  mktables should check and warn if it does.
  * More importantly, if the sigma occurs at the end of the string, we don't
  * have enough context to know whether it is part of a larger string or going
  * to be or not.  It may be that we are passed a subset of the context, via
  * a \U...\E, for example, and we could conceivably know the larger context if
  * code were changed to pass that in.  But, if the string passed in is an
  * intermediate result, and the user concatenates two strings together
  * after we have made a final sigma, that would be wrong.  If the final sigma
  * occurs in the middle of the string we are working on, then we know that it
  * should be a final sigma, but otherwise we can't be sure. */
 
 		const UV uv = toLOWER_utf8(s, tmpbuf, &ulen);
 
 		/* If the lower case is a small sigma, it may be that we need
 		 * to change it to a final sigma.  This happens at the end of 
 		 * a word that contains more than just this character, and only
 		 * when we started with a capital sigma. */
 		if (uv == UNICODE_GREEK_SMALL_LETTER_SIGMA &&
 		    s > send - len &&	/* Makes sure not the first letter */
 		    utf8_to_uvchr(s, 0) == UNICODE_GREEK_CAPITAL_LETTER_SIGMA
 		) {
 
 		    /* We use the algorithm in:
 		     * http://www.unicode.org/versions/Unicode5.0.0/ch03.pdf (C
 		     * is a CAPITAL SIGMA): If C is preceded by a sequence
 		     * consisting of a cased letter and a case-ignorable
 		     * sequence, and C is not followed by a sequence consisting
 		     * of a case ignorable sequence and then a cased letter,
 		     * then when lowercasing C, C becomes a final sigma */
 
 		    /* To determine if this is the end of a word, need to peek
 		     * ahead.  Look at the next character */
 		    const U8 *peek = s + u;
 
 		    /* Skip any case ignorable characters */
 		    while (peek < send && is_utf8_case_ignorable(peek)) {
 			peek += UTF8SKIP(peek);
 		    }
 
 		    /* If we reached the end of the string without finding any
 		     * non-case ignorable characters, or if the next such one
 		     * is not-cased, then we have met the conditions for it
 		     * being a final sigma with regards to peek ahead, and so
 		     * must do peek behind for the remaining conditions. (We
 		     * know there is stuff behind to look at since we tested
 		     * above that this isn't the first letter) */
 		    if (peek >= send || ! is_utf8_cased(peek)) {
 			peek = utf8_hop(s, -1);
 
 			/* Here are at the beginning of the first character
 			 * before the original upper case sigma.  Keep backing
 			 * up, skipping any case ignorable characters */
 			while (is_utf8_case_ignorable(peek)) {
 			    peek = utf8_hop(peek, -1);
 			}
 
 			/* Here peek points to the first byte of the closest
 			 * non-case-ignorable character before the capital
 			 * sigma.  If it is cased, then by the Unicode
 			 * algorithm, we should use a small final sigma instead
 			 * of what we have */
 			if (is_utf8_cased(peek)) {
 			    STORE_UNI_TO_UTF8_TWO_BYTE(tmpbuf,
 					UNICODE_GREEK_SMALL_LETTER_FINAL_SIGMA);
 			}
 		    }
 		}
 		else {	/* Not a context sensitive mapping */
 #endif	/* End of commented out context sensitive */
 		    if (ulen > u && (SvLEN(dest) < (min += ulen - u))) {
 
 			/* If the eventually required minimum size outgrows
 			 * the available space, we need to grow. */
 			const UV o = d - (U8*)SvPVX_const(dest);
 
 			/* If someone lowercases one million U+0130s we
 			 * SvGROW() one million times.  Or we could try
 			 * guessing how much to allocate without allocating too
 			 * much.  Such is life.  Another option would be to
 			 * grow an extra byte or two more each time we need to
 			 * grow, which would cut down the million to 500K, with
 			 * little waste */
 			SvGROW(dest, min);
 			d = (U8*)SvPVX(dest) + o;
 		    }
 #ifdef CONTEXT_DEPENDENT_CASING
 		}
 #endif
 		/* Copy the newly lowercased letter to the output buffer we're
 		 * building */
 		Copy(tmpbuf, d, ulen, U8);
 		d += ulen;
 		s += u;
 #ifdef GO_AHEAD_AND_BREAK_USER_DEFINED_CASE_MAPPINGS
 	    }
 #endif
 	}   /* End of looping through the source string */
 	SvUTF8_on(dest);
 	*d = '\0';
 	SvCUR_set(dest, d - (U8*)SvPVX_const(dest));
     } else {	/* Not utf8 */
 	if (len) {
 	    const U8 *const send = s + len;
 
 	    /* Use locale casing if in locale; regular style if not treating
 	     * latin1 as having case; otherwise the latin1 casing.  Do the
 	     * whole thing in a tight loop, for speed, */
 	    if (IN_LOCALE_RUNTIME) {
 		TAINT;
 		SvTAINTED_on(dest);
 		for (; s < send; d++, s++)
 		    *d = toLOWER_LC(*s);
 	    }
 	    else if (! IN_UNI_8_BIT) {
 		for (; s < send; d++, s++) {
 		    *d = toLOWER(*s);
 		}
 	    }
 	    else {
 		for (; s < send; d++, s++) {
 		    *d = toLOWER_LATIN1(*s);
 		}
 	    }
 	}
 	if (source != dest) {
 	    *d = '\0';
 	    SvCUR_set(dest, d - (U8*)SvPVX_const(dest));
 	}
     }
+    if (dest != source && SvTAINTED(source))
+	SvTAINT(dest);
     SvSETMAGIC(dest);
     RETURN;
 }
 
diff --git a/t/op/taint.t b/t/op/taint.t
index c695570..9df6fee 100644
--- a/t/op/taint.t
+++ b/t/op/taint.t
@@ -17,7 +17,7 @@ BEGIN {
 use strict;
 use Config;
 
-plan tests => 770;
+plan tests => 774;
 
 $| = 1;
 
@@ -2039,98 +2039,111 @@ foreach my $ord (78, 163, 256) {
 end
     "formline survives a tainted dynamic picture");
 }
 
 {
     isnt_tainted($^A, "format accumulator not tainted yet");
     formline('@ | @*', 'hallo' . $TAINT, 'welt');
     is_tainted($^A, "tainted formline argument makes a tainted accumulator");
     $^A = "";
     isnt_tainted($^A, "accumulator can be explicitly untainted");
     formline('@' .('<'*5) . ' | @*', 'hallo', 'welt');
     isnt_tainted($^A, "accumulator still untainted");
     $^A = "" . $TAINT;
     is_tainted($^A, "accumulator can be explicitly tainted");
     formline('@' .('<'*5) . ' | @*', 'hallo', 'welt');
     is_tainted($^A, "accumulator still tainted");
     $^A = "";
     isnt_tainted($^A, "accumulator untainted again");
     formline('@' .('<'*5) . ' | @*', 'hallo', 'welt');
     isnt_tainted($^A, "accumulator still untainted");
     formline('@' .('<'*(5+$TAINT0)) . ' | @*', 'hallo', 'welt');
     TODO: {
         local $::TODO = "get magic handled too late?";
         is_tainted($^A, "the accumulator should be tainted already");
     }
     is_tainted($^A, "tainted formline picture makes a tainted accumulator");
 }
 
 {   # Bug #80610
     "Constant(1)" =~ / ^ ([a-z_]\w*) (?: [(] (.*) [)] )? $ /xi;
     my $a = $1;
     my $b = $2;
     isnt_tainted($a, "regex optimization of single char /[]/i doesn't taint");
     isnt_tainted($b, "regex optimization of single char /[]/i doesn't taint");
 }
 
 {
     # RT 81230: tainted value during FETCH created extra ref to tied obj
 
     package P81230;
     use warnings;
 
     my %h;
 
     sub TIEHASH {
 	my $x = $^X; # tainted
 	bless  \$x;
     }
     sub FETCH { my $x = $_[0]; $$x . "" }
 
     tie %h, 'P81230';
 
     my $w = "";
     local $SIG{__WARN__} = sub { $w .= "@_" };
 
     untie %h if $h{"k"};
 
     ::is($w, "", "RT 81230");
 }
 
 {
     # Compiling a subroutine inside a tainted expression does not make the
     # constant folded values tainted.
     my $x = sub { "x" . "y" };
     my $y = $ENV{PATH} . $x->(); # Compile $x inside a tainted expression
     my $z = $x->();
     isnt_tainted($z, "Constants folded value not tainted");
 }
 
 {
     # now that regexes are first class SVs, make sure that they themselves
     # as well as references to them are tainted
 
     my $rr = qr/(.)$TAINT/;
     my $r = $$rr; # bare REGEX
     my $s ="abc";
     ok($s =~ s/$r/x/, "match bare regex");
     is_tainted($s, "match bare regex taint");
     is($s, 'xbc', "match bare regex taint value");
 }
 
 {
     # [perl #82616] security Issues with user-defined \p{} properties
     # A using a tainted user-defined property should croak
 
     sub IsA { sprintf "%02x", ord("A") }
 
     my $prop = "IsA";
     ok("A" =~ /\p{$prop}/, "user-defined property: non-tainted case");
     $prop = "IsA$TAINT";
     eval { "A" =~ /\p{$prop}/};
     like($@, qr/Insecure user-defined property \\p{main::IsA}/,
 	    "user-defined property: tainted case");
 }
 
+{
+    # [perl #87336] lc/uc(first) failing to taint the returned string
+    my $source = "foo$TAINT";
+    my $dest = lc $source;
+    is_tainted $dest, "lc(tainted) taints its return value";
+    $dest = lcfirst $source;
+    is_tainted $dest, "lcfirst(tainted) taints its return value";
+    $dest = uc $source;
+    is_tainted $dest, "uc(tainted) taints its return value";
+    $dest = ucfirst $source;
+    is_tainted $dest, "ucfirst(tainted) taints its return value";
+}
+
 # This may bomb out with the alarm signal so keep it last
 SKIP: {
     skip "No alarm()"  unless $Config{d_alarm};
