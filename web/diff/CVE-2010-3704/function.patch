commit 39d140bfc0b8239bdd96d6a55842034ae5c05473
Author: Albert Astals Cid <aacid@kde.org>
Date:   Tue Sep 21 18:54:31 2010 +0100

    Fix crash in broken pdf (code < 0)
    
    Found thanks to PDF provided by Joel Voss of Leviathan Security Group

diff --git a/fofi/FoFiType1.cc b/fofi/FoFiType1.cc
index 25bdc0e..3fe7f4f 100644
--- a/fofi/FoFiType1.cc
+++ b/fofi/FoFiType1.cc
@@ -1,41 +1,42 @@
 //========================================================================
 //
 // FoFiType1.cc
 //
 // Copyright 1999-2003 Glyph & Cog, LLC
 //
 //========================================================================
 
 //========================================================================
 //
 // Modified under the Poppler project - http://poppler.freedesktop.org
 //
 // All changes made under the Poppler project to this file are licensed
 // under GPL version 2 or later
 //
-// Copyright (C) 2005, 2008 Albert Astals Cid <aacid@kde.org>
+// Copyright (C) 2005, 2008, 2010 Albert Astals Cid <aacid@kde.org>
 // Copyright (C) 2005 Kristian HÃ¸gsberg <krh@redhat.com>
 // Copyright (C) 2010 Jakub Wilk <ubanus@users.sf.net>
 //
 // To see a description of the changes please see the Changelog file that
 // came with your tarball or type make ChangeLog if you are building from git
 //
 //========================================================================
 
 #include <config.h>
 
 #ifdef USE_GCC_PRAGMAS
 #pragma implementation
 #endif
 
 #include <stdlib.h>
 #include <string.h>
 #include "goo/gmem.h"
+#include "goo/GooLikely.h"
 #include "FoFiEncodings.h"
 #include "FoFiType1.h"
 #include "poppler/Error.h"
 
 //------------------------------------------------------------------------
 // FoFiType1
 //------------------------------------------------------------------------
 
@@ -191,99 +192,99 @@ char *FoFiType1::getNextLine(char *line) {
 void FoFiType1::parse() {
   char *line, *line1, *p, *p2;
   char buf[256];
   char c;
   int n, code, i, j;
   char *tokptr;
 
   for (i = 1, line = (char *)file;
        i <= 100 && line && (!name || !encoding);
        ++i) {
 
     // get font name
     if (!name && !strncmp(line, "/FontName", 9)) {
       strncpy(buf, line, 255);
       buf[255] = '\0';
       if ((p = strchr(buf+9, '/')) &&
 	  (p = strtok_r(p+1, " \t\n\r", &tokptr))) {
 	name = copyString(p);
       }
       line = getNextLine(line);
 
     // get encoding
     } else if (!encoding &&
 	       !strncmp(line, "/Encoding StandardEncoding def", 30)) {
       encoding = fofiType1StandardEncoding;
     } else if (!encoding &&
 	       !strncmp(line, "/Encoding 256 array", 19)) {
       encoding = (char **)gmallocn(256, sizeof(char *));
       for (j = 0; j < 256; ++j) {
 	encoding[j] = NULL;
       }
       for (j = 0, line = getNextLine(line);
 	   j < 300 && line && (line1 = getNextLine(line));
 	   ++j, line = line1) {
 	if ((n = line1 - line) > 255) {
 	  error(-1, "FoFiType1::parse a line has more than 255 characters, we don't support this");
 	  n = 255;
 	}
 	strncpy(buf, line, n);
 	buf[n] = '\0';
 	for (p = buf; *p == ' ' || *p == '\t'; ++p) ;
 	if (!strncmp(p, "dup", 3)) {
 	  for (p += 3; *p == ' ' || *p == '\t'; ++p) ;
 	  for (p2 = p; *p2 >= '0' && *p2 <= '9'; ++p2) ;
 	  if (*p2) {
 	    c = *p2; // store it so we can recover it after atoi
 	    *p2 = '\0'; // terminate p so atoi works
 	    code = atoi(p);
 	    *p2 = c;
 	    if (code == 8 && *p2 == '#') {
 	      code = 0;
 	      for (++p2; *p2 >= '0' && *p2 <= '7'; ++p2) {
 		code = code * 8 + (*p2 - '0');
 	      }
 	    }
-	    if (code < 256) {
+	    if (likely(code < 256 && code >= 0)) {
 	      for (p = p2; *p == ' ' || *p == '\t'; ++p) ;
 	      if (*p == '/') {
 		++p;
 		for (p2 = p; *p2 && *p2 != ' ' && *p2 != '\t'; ++p2) ;
 		c = *p2; // store it so we can recover it after copyString
 		*p2 = '\0'; // terminate p so copyString works
 		encoding[code] = copyString(p);
 		*p2 = c;
 		p = p2;
 		for (; *p == ' ' || *p == '\t'; ++p); // eat spaces between string and put
 		if (!strncmp(p, "put", 3)) {
 		  // eat put and spaces and newlines after put
 		  for (p += 3; *p == ' ' || *p == '\t' || *p == '\n' || *p == '\r'; ++p);
 		  if (*p)
 		  {
 		    // there is still something after the definition
 		    // there might be another definition in this line
 		    // so move line1 to the end of our parsing
 		    // so we start in the potential next definition in the next loop
 		    line1 = &line[p - buf];
 		  }
 		} else {
 		  error(-1, "FoFiType1::parse no put after dup");
 		}
 	      }
 	    }
 	  }
 	} else {
 	  if (strtok_r(buf, " \t", &tokptr) &&
 	      (p = strtok_r(NULL, " \t\n\r", &tokptr)) && !strcmp(p, "def")) {
 	    break;
 	  }
 	}
       }
       //~ check for getinterval/putinterval junk
 
     } else {
       line = getNextLine(line);
     }
   }
 
   parsed = gTrue;
 }
