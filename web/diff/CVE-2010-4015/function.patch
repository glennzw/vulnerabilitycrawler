commit 7ccb6dc2d3e266a551827bb99179708580f72431
Author: Tom Lane <tgl@sss.pgh.pa.us>
Date:   Thu Jan 27 17:41:41 2011 -0500

    Prevent buffer overrun while parsing an integer in a "query_int" value.
    
    contrib/intarray's gettoken() uses a fixed-size buffer to collect an
    integer's digits, and did not guard against overrunning the buffer.
    This is at least a backend crash risk, and in principle might allow
    arbitrary code execution.  The code didn't check for overflow of the
    integer value either, which while not presenting a crash risk was still
    bad.
    
    Thanks to Apple Inc's security team for reporting this issue and supplying
    the fix.
    
    Security: CVE-2010-4015

diff --git a/contrib/intarray/_int_bool.c b/contrib/intarray/_int_bool.c
index 3492100..072e8cc 100644
--- a/contrib/intarray/_int_bool.c
+++ b/contrib/intarray/_int_bool.c
@@ -56,83 +56,89 @@ typedef struct
 static int4
 gettoken(WORKSTATE *state, int4 *val)
 {
-	char		nnn[16],
-			   *curnnn;
+	char		nnn[16];
+	int			innn;
 
 	*val = 0;					/* default result */
 
-	curnnn = nnn;
+	innn = 0;
 	while (1)
 	{
+		if (innn >= sizeof(nnn))
+			return ERR;			/* buffer overrun => syntax error */
 		switch (state->state)
 		{
 			case WAITOPERAND:
-				curnnn = nnn;
+				innn = 0;
 				if ((*(state->buf) >= '0' && *(state->buf) <= '9') ||
 					*(state->buf) == '-')
 				{
 					state->state = WAITENDOPERAND;
-					*curnnn = *(state->buf);
-					curnnn++;
+					nnn[innn++] = *(state->buf);
 				}
 				else if (*(state->buf) == '!')
 				{
 					(state->buf)++;
 					*val = (int4) '!';
 					return OPR;
 				}
 				else if (*(state->buf) == '(')
 				{
 					state->count++;
 					(state->buf)++;
 					return OPEN;
 				}
 				else if (*(state->buf) != ' ')
 					return ERR;
 				break;
 			case WAITENDOPERAND:
 				if (*(state->buf) >= '0' && *(state->buf) <= '9')
 				{
-					*curnnn = *(state->buf);
-					curnnn++;
+					nnn[innn++] = *(state->buf);
 				}
 				else
 				{
-					*curnnn = '\0';
-					*val = (int4) atoi(nnn);
+					long	lval;
+
+					nnn[innn] = '\0';
+					errno = 0;
+					lval = strtol(nnn, NULL, 0);
+					*val = (int4) lval;
+					if (errno != 0 || (long) *val != lval)
+						return ERR;
 					state->state = WAITOPERATOR;
 					return (state->count && *(state->buf) == '\0')
 						? ERR : VAL;
 				}
 				break;
 			case WAITOPERATOR:
 				if (*(state->buf) == '&' || *(state->buf) == '|')
 				{
 					state->state = WAITOPERAND;
 					*val = (int4) *(state->buf);
 					(state->buf)++;
 					return OPR;
 				}
 				else if (*(state->buf) == ')')
 				{
 					(state->buf)++;
 					state->count--;
 					return (state->count < 0) ? ERR : CLOSE;
 				}
 				else if (*(state->buf) == '\0')
 					return (state->count) ? ERR : END;
 				else if (*(state->buf) != ' ')
 					return ERR;
 				break;
 			default:
 				return ERR;
 				break;
 		}
 		(state->buf)++;
 	}
 	return END;
 }
 
 /*
  * push new one in polish notation reverse view
  */
