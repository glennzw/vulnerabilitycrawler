   Prevent buffer overrun while parsing an integer in a "query_int" value.
   
   contrib/intarray's gettoken() uses a fixed-size buffer to collect an
   integer's digits, and did not guard against overrunning the buffer.
   This is at least a backend crash risk, and in principle might allow
   arbitrary code execution.  The code didn't check for overflow of the
   integer value either, which while not presenting a crash risk was still
   bad.
   
   Thanks to Apple Inc's security team for reporting this issue and supplying
   the fix.
   
   Security: CVE-2010-4015
static int4
gettoken(WORKSTATE *state, int4 *val)
{
	char		nnn[16],
			   *curnnn;

	*val = 0;					/* default result */

	curnnn = nnn;
	while (1)
	{
		switch (state->state)
		{
			case WAITOPERAND:
				curnnn = nnn;
				if ((*(state->buf) >= '0' && *(state->buf) <= '9') ||
					*(state->buf) == '-')
				{
					state->state = WAITENDOPERAND;
					*curnnn = *(state->buf);
					curnnn++;
				}
				else if (*(state->buf) == '!')
				{
			case WAITENDOPERAND:
				if (*(state->buf) >= '0' && *(state->buf) <= '9')
				{
					*curnnn = *(state->buf);
					curnnn++;
				}
				else
				{
					*curnnn = '\0';
					*val = (int4) atoi(nnn);
					state->state = WAITOPERATOR;
					return (state->count && *(state->buf) == '\0')
						? ERR : VAL;
