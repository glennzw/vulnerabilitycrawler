   Update CGI.pm to CPAN version 3.50
   
     [DELTA]
   
     Version 3.50
   
     [SECURITY]
     1. The MIME boundary in multipart_init is now random.
        Thanks to Byron Jones, Masahiro Yamada, Reed Loden, and  Mark Stosberg
     2. Further improvements to handling of newlines embedded in header values.
        An exception is thrown if header values contain invalid newlines.
        Thanks to Michal Zalewski, Max Kanat-Alexander, Yanick Champoux,
        Lincoln Stein, Fr�d�ric Buclin and Mark Stosberg
   
     [DOCUMENTATION]
     1. Correcting/clarifying documentation for param_fetch(). Thanks to
           Ren�e B�cker. (RT#59132)
   
     [INTERNALS]
     1. Fixing https test in http.t. (RT#54768)
     2. Tests were added for multipart_init(). Thanks to Mark Stosberg and CGI::Simple.
    'CGI' =>
	{
	'MAINTAINER'	=> 'lstein',
	'DISTRIBUTION'	=> 'LDS/CGI.pm-3.49.tar.gz',
	'FILES'		=> q[cpan/CGI],
	'EXCLUDED'	=> [ qr{^t/lib/Test},
				qw( cgi-lib_porting.html
Version 3.49

  [BUG FIXES]
# The most recent version and complete docs are available at:
#   http://stein.cshl.org/WWW/software/CGI/

$CGI::revision = '$Id: CGI.pm,v 1.266 2009/07/30 16:32:34 lstein Exp $';
$CGI::VERSION='3.49';

# HARD-CODED LOCATION FOR FILE UPLOAD TEMPORARY FILES.
# UNCOMMENT THIS ONLY IF YOU KNOW WHAT YOU'RE DOING.
sub multipart_init {
    my($self,@p) = self_or_default(@_);
    my($boundary,@other) = rearrange_header([BOUNDARY],@p);
    $boundary = $boundary || '------- =_aaaaaaaaaa0';
    $self->{'separator'} = "$CRLF--$boundary$CRLF";
    $self->{'final_separator'} = "$CRLF--$boundary--$CRLF";
    $type = SERVER_PUSH($boundary);
    # CR escaping for values, per RFC 822
    for my $header ($type,$status,$cookie,$target,$expires,$nph,$charset,$attachment,$p3p,@other) {
        if (defined $header) {
            $header =~ s/
                (?<=\n)    # For any character proceeded by a newline
                (?=\S)     # ... that is not whitespace
            / /xg;         # ... inject a leading space in the new line
        }
    }

    $nph     ||= $NPH;

}
END_OF_FUNC


#### Method: cache
# Control whether header() will produce the no-cache
# Pragma directive.
   unshift @{$q->param_fetch(-name=>'address')},'George Munster';

If you need access to the parameter list in a way that isn't covered
by the methods above, you can obtain a direct reference to it by
calling the B<param_fetch()> method with the name of the .  This
will return an array reference to the named parameters, which you then
can manipulate in any way you like.

You can also use a named argument style using the B<-name> argument.

For full information on cookies see 

	http://www.ics.uci.edu/pub/ietf/http/rfc2109.txt

=head1 USING CGI::Cookie

If the "secure" attribute is set, the cookie will only be sent to your
script if the CGI request is occurring on a secure channel, such as SSL.

=item B<4. httponly flag>

If the "httponly" attribute is set, the cookie will only be accessible
through HTTP Requests. This cookie will be inaccessible via JavaScript
(to prevent XSS attacks).

But, currently this feature only used and recognised by 
MS Internet Explorer 6 Service Pack 1 and later.

See this URL for more information:

L<http://msdn.microsoft.com/en-us/library/ms533046%28VS.85%29.aspx>

=back

    # https()
    # The same as http(), but operates on the HTTPS environment variables present when the SSL protocol is in
    # effect.  Can be used to determine whether SSL is turned on.
    my @expect = grep /^HTTPS/, keys %ENV;
    push @expect, 'HTTPS'         if not exists $ENV{HTTPS};
    push @expect, 'HTTPS_KEYSIZE' if not exists $ENV{HTTPS_KEYSIZE};
    local $ENV{'HTTPS'} = 'ON';
    local $ENV{'HTTPS_KEYSIZE'} = 512;
    is $cgi->https(), 'ON', 'scalar context to check SSL is on';
    ok eq_set( [$cgi->https()], \@expect), 'list context returns https keys';
}

=item *

C<CPAN> has been upgraded from 1.94_61 to 1.94_62

=item *
