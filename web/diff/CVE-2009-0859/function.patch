commit a68e61e8ff2d46327a37b69056998b47745db6fa
Author: Tony Battersby <tonyb@cybernetics.com>
Date:   Wed Feb 4 15:12:04 2009 -0800

    shm: fix shmctl(SHM_INFO) lockup with !CONFIG_SHMEM
    
    shm_get_stat() assumes that the inode is a "struct shmem_inode_info",
    which is incorrect for !CONFIG_SHMEM (see fs/ramfs/inode.c:
    ramfs_get_inode() vs.  mm/shmem.c: shmem_get_inode()).
    
    This bad assumption can cause shmctl(SHM_INFO) to lockup when
    shm_get_stat() tries to spin_lock(&info->lock).  Users of !CONFIG_SHMEM
    may encounter this lockup simply by invoking the 'ipcs' command.
    
    Reported by Jiri Olsa back in February 2008:
    http://lkml.org/lkml/2008/2/29/74
    
    Signed-off-by: Tony Battersby <tonyb@cybernetics.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Reported-by: Jiri Olsa <olsajiri@gmail.com>
    Cc: Hugh Dickins <hugh@veritas.com>
    Cc: <stable@kernel.org>		[2.6.everything]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/ipc/shm.c b/ipc/shm.c
index c0a021f..f8f69fa 100644
--- a/ipc/shm.c
+++ b/ipc/shm.c
@@ -542,42 +542,46 @@ static inline unsigned long copy_shminfo_to_user(void __user *buf, struct shminf
 static void shm_get_stat(struct ipc_namespace *ns, unsigned long *rss,
 		unsigned long *swp)
 {
 	int next_id;
 	int total, in_use;
 
 	*rss = 0;
 	*swp = 0;
 
 	in_use = shm_ids(ns).in_use;
 
 	for (total = 0, next_id = 0; total < in_use; next_id++) {
 		struct shmid_kernel *shp;
 		struct inode *inode;
 
 		shp = idr_find(&shm_ids(ns).ipcs_idr, next_id);
 		if (shp == NULL)
 			continue;
 
 		inode = shp->shm_file->f_path.dentry->d_inode;
 
 		if (is_file_hugepages(shp->shm_file)) {
 			struct address_space *mapping = inode->i_mapping;
 			struct hstate *h = hstate_file(shp->shm_file);
 			*rss += pages_per_huge_page(h) * mapping->nrpages;
 		} else {
+#ifdef CONFIG_SHMEM
 			struct shmem_inode_info *info = SHMEM_I(inode);
 			spin_lock(&info->lock);
 			*rss += inode->i_mapping->nrpages;
 			*swp += info->swapped;
 			spin_unlock(&info->lock);
+#else
+			*rss += inode->i_mapping->nrpages;
+#endif
 		}
 
 		total++;
 	}
 }
 
 /*
  * This function handles some shmctl commands which require the rw_mutex
  * to be held in write mode.
  * NOTE: no locks must be held, the rw_mutex is taken inside this function.
  */
