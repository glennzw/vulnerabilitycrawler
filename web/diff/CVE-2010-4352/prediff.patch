   CVE 2010-4352: Reject deeply nested variants
   
   Add DBUS_INVALID_NESTED_TOO_DEEPLY validity problem and a test that
   should generate it.
   
   Previously, we rejected deep nesting in the signature, but
   variants allow dynamic message nesting, conditional only
   on the depth of the message body.
   
   The nesting limit is 64, which was also the limit in static
   signatures.  Empirically, dynamic nesting depth observed on my
   Fedora 14 system doesn't exceed 2; 64 is really a huge limit.
   
   https://bugs.freedesktop.org/show_bug.cgi?id=32321
   
   Signed-Off-By: Colin Walters <walters@verbum.org>
   Signed-off-by: Will Thompson <will.thompson@collabora.co.uk>
  return result;
}

static DBusValidity
validate_body_helper (DBusTypeReader       *reader,
                      int                   byte_order,
                      dbus_bool_t           walk_reader_to_end,
                      const unsigned char  *p,
                      const unsigned char  *end,
                      const unsigned char **new_p)
{
  int current_type;

  while ((current_type = _dbus_type_reader_get_current_type (reader)) != DBUS_TYPE_INVALID)
    {
      const unsigned char *a;
                  {
                    while (p < array_end)
                      {
                        validity = validate_body_helper (&sub, byte_order, FALSE, p, end, &p);
                        if (validity != DBUS_VALID)
                          return validity;
                      }

            _dbus_assert (_dbus_type_reader_get_current_type (&sub) != DBUS_TYPE_INVALID);

            validity = validate_body_helper (&sub, byte_order, FALSE, p, end, &p);
            if (validity != DBUS_VALID)
              return validity;


            _dbus_type_reader_recurse (reader, &sub);

            validity = validate_body_helper (&sub, byte_order, TRUE, p, end, &p);
            if (validity != DBUS_VALID)
              return validity;
          }
  p = _dbus_string_get_const_data_len (value_str, value_pos, len);
  end = p + len;

  validity = validate_body_helper (&reader, byte_order, TRUE, p, end, &p);
  if (validity != DBUS_VALID)
    return validity;
  
    case DBUS_INVALID_DICT_ENTRY_HAS_TOO_MANY_FIELDS:              return "Dict entry has too many fields";
    case DBUS_INVALID_DICT_ENTRY_NOT_INSIDE_ARRAY:                 return "Dict entry not inside array";
    case DBUS_INVALID_DICT_KEY_MUST_BE_BASIC_TYPE:                 return "Dict key must be basic type";

    default:
      return "Invalid";
    }
  DBUS_INVALID_DICT_ENTRY_NOT_INSIDE_ARRAY = 54,
  DBUS_INVALID_DICT_KEY_MUST_BE_BASIC_TYPE = 55,
  DBUS_INVALID_MISSING_UNIX_FDS = 56,
  DBUS_VALIDITY_LAST
} DBusValidity;

  return message;
}

static dbus_bool_t
generate_special (DBusMessageDataIter   *iter,
                  DBusString            *data,
      
      *expected_validity = DBUS_INVALID_DICT_ENTRY_HAS_NO_FIELDS;
    }
  else
    {
      return FALSE;
	      </row><row>
                <entry><literal>VARIANT</literal></entry>
                <entry>
                  A variant type has a marshaled <literal>SIGNATURE</literal>
                  followed by a marshaled value with the type
                  given in the signature.
                  Unlike a message signature, the variant signature 
                  can contain only a single complete type.
                  So "i", "ai" or "(ii)" is OK, but "ii" is not.
                </entry>
                <entry>
                  1 (alignment of the signature)
