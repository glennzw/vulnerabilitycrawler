commit 59de2bebabc5027f93df999d59cc65df591c3e6e
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Mon Apr 20 10:08:35 2009 +1000

    agp: zero pages before sending to userspace
    
    AGP pages might be mapped into userspace finally, so the pages should be
    set to zero before userspace can use it. Otherwise there is potential
    information leakage.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/char/agp/generic.c b/drivers/char/agp/generic.c
index 10d6cbd..2224b76 100644
--- a/drivers/char/agp/generic.c
+++ b/drivers/char/agp/generic.c
@@ -1223,26 +1223,26 @@ EXPORT_SYMBOL(agp_generic_alloc_user);
 int agp_generic_alloc_pages(struct agp_bridge_data *bridge, struct agp_memory *mem, size_t num_pages)
 {
 	struct page * page;
 	int i, ret = -ENOMEM;
 
 	for (i = 0; i < num_pages; i++) {
-		page = alloc_page(GFP_KERNEL | GFP_DMA32);
+		page = alloc_page(GFP_KERNEL | GFP_DMA32 | __GFP_ZERO);
 		/* agp_free_memory() needs gart address */
 		if (page == NULL)
 			goto out;
 
 #ifndef CONFIG_X86
 		map_page_into_agp(page);
 #endif
 		get_page(page);
 		atomic_inc(&agp_bridge->current_memory_agp);
 
 		/* set_memory_array_uc() needs virtual address */
 		mem->memory[i] = (unsigned long)page_address(page);
 		mem->page_count++;
 	}
 
 #ifdef CONFIG_X86
 	set_memory_array_uc(mem->memory, num_pages);
 #endif
 	ret = 0;
@@ -1256,14 +1256,14 @@ EXPORT_SYMBOL(agp_generic_alloc_pages);
 void *agp_generic_alloc_page(struct agp_bridge_data *bridge)
 {
 	struct page * page;
 
-	page = alloc_page(GFP_KERNEL | GFP_DMA32);
+	page = alloc_page(GFP_KERNEL | GFP_DMA32 | __GFP_ZERO);
 	if (page == NULL)
 		return NULL;
 
 	map_page_into_agp(page);
 
 	get_page(page);
 	atomic_inc(&agp_bridge->current_memory_agp);
 	return page_address(page);
 }
