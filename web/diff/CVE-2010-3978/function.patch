commit d881b2bb610ea33e2364ff16feb8e702dfeda135
Author: Sean Schofield <sean@railsdog.com>
Date:   Mon Oct 25 21:19:56 2010 -0400

    SECURITY FIX: Do not allow GET access to JSON views without including CSRF token.
    
    See http://haacked.com/archive/2009/06/25/json-hijacking.aspx

diff --git a/app/controllers/admin/overview_controller.rb b/app/controllers/admin/overview_controller.rb
index 84efb2c..18536bd 100644
--- a/app/controllers/admin/overview_controller.rb
+++ b/app/controllers/admin/overview_controller.rb
@@ -3,12 +3,12 @@
 class Admin::OverviewController < Admin::BaseController
   #todo, add rss feed of information that is happening
 
   def index
     @users = User.find(:all)
     #@users = User.find_with_deleted(:all, :order => 'updated_at desc')
 #  going to list today's orders, yesterday's orders, older orders
 # have a filter / search at the top
-    # @orders, @ 
+    # @orders, @
   end
 
 end
diff --git a/app/controllers/admin/products_controller.rb b/app/controllers/admin/products_controller.rb
index 1c004e9..8cfe52c 100644
--- a/app/controllers/admin/products_controller.rb
+++ b/app/controllers/admin/products_controller.rb
@@ -1,102 +1,103 @@
 class Admin::ProductsController < Admin::BaseController
   resource_controller
+  before_filter :check_json_authenticity, :only => :index
   before_filter :load_data, :except => :index
 
   index.response do |wants|
     wants.html { render :action => :index }
     wants.json { render :json => @collection.to_json(:include => {:variants => {:include => {:option_values => {:include => :option_type}, :images => {}}}, :images => {}, :master => {}})  }
   end
 
   new_action.response do |wants|
     wants.html {render :action => :new, :layout => false}
   end
 
   update.before :update_before
 
   create.response do |wants|
     # go to edit form after creating as new product
     wants.html {redirect_to edit_admin_product_url(Product.find(@product.id)) }
   end
 
   update.response do |wants|
     # override the default redirect behavior of r_c
     # need to reload Product in case name / permalink has changed
     wants.html {redirect_to edit_admin_product_url(Product.find(@product.id)) }
   end
 
   # override the destory method to set deleted_at value
   # instead of actually deleting the product.
   def destroy
     @product = Product.find_by_permalink(params[:id])
     @product.deleted_at = Time.now()
 
     @product.variants.each do |v|
       v.deleted_at = Time.now()
       v.save
     end
 
     if @product.save
       self.notice = I18n.t("notice_messages.product_deleted")
     else
       self.notice = I18n.t("notice_messages.product_not_deleted")
     end
 
     respond_to do |format|
       format.html { redirect_to collection_url }
       format.js  { render_js_for_destroy }
     end
   end
 
   def clone
     load_object
     @new = @product.duplicate
 
     if @new.save
       self.notice = I18n.t("notice_messages.product_cloned")
     else
       self.notice = I18n.t("notice_messages.product_not_cloned")
     end
 
     redirect_to edit_admin_product_url(@new)
   end
 
   private
     def load_data
       @tax_categories = TaxCategory.find(:all, :order=>"name")
       @shipping_categories = ShippingCategory.find(:all, :order=>"name")
     end
 
     def collection
       base_scope = end_of_association_chain
 
       unless request.xhr?
         # Note: the SL scopes are on/off switches, so we need to select "not_deleted" explicitly if the switch is off
         # QUERY - better as named scope or as SL scope?
         if params[:search].nil? || params[:search][:deleted_at_not_null].blank?
           base_scope = base_scope.not_deleted
         end
 
         @search = base_scope.group_by_products_id.searchlogic(params[:search])
         @search.order ||= "ascend_by_name"
 
         @collection = @search.paginate(:include   => {:variants => [:images, :option_values]},
                                        :per_page  => Spree::Config[:admin_products_per_page],
                                        :page      => params[:page])
       else
         includes = [{:variants => [:images,  {:option_values => :option_type}]}, :master, :images]
 
         @collection = base_scope.name_contains(params[:q]).all(:include => includes, :limit => 10)
         @collection.concat base_scope.group_by_products_id.variants_including_master_sku_contains(params[:q]).all(:include => includes, :limit => 10)
 
         @collection.uniq!
       end
 
     end
 
     def update_before
       # note: we only reset the product properties if we're receiving a post from the form on that tab
       return unless params[:clear_product_properties]
       params[:product] ||= {}
       params[:product][:product_property_attributes] ||= {} if params[:product][:product_property_attributes].nil?
     end
 
diff --git a/app/controllers/admin/users_controller.rb b/app/controllers/admin/users_controller.rb
index 65ddb92..6039beb 100644
--- a/app/controllers/admin/users_controller.rb
+++ b/app/controllers/admin/users_controller.rb
@@ -1,53 +1,54 @@
 class Admin::UsersController < Admin::BaseController
   resource_controller
+  before_filter :check_json_authenticity, :only => :index
   before_filter :load_roles, :only => [:edit, :new, :update, :create]
 
   create.after :save_user_roles
   update.before :save_user_roles
 
   index.response do |wants|
     wants.html { render :action => :index }
     wants.json { render :json => @collection.to_json(:include => {:bill_address => {:include => [:state, :country]}, :ship_address => {:include => [:state, :country]}}) }
   end
-  
+
   destroy.success.wants.js { render_js_for_destroy }
 
   private
   def collection
     unless request.xhr?
       @search = User.searchlogic(params[:search])
 
       #set order by to default or form result
       @search.order ||= "ascend_by_email"
 
       @collection_count = @search.count
       @collection = @search.paginate(:per_page => Spree::Config[:admin_products_per_page],
                                      :page     => params[:page])
 
       #scope = scope.conditions "lower(email) = ?", @filter.email.downcase unless @filter.email.blank?
     else
       @collection = User.find(:all, :include => [
                                   {:bill_address => [:state, :country]},
                                   {:ship_address => [:state, :country]}],
                           :conditions => ["users.email like :search
                                             OR addresses.firstname like :search
                                             OR addresses.lastname like :search
                                             OR ship_addresses_users.firstname like :search
                                             OR ship_addresses_users.lastname like :search", {:search => "#{params[:q].strip}%"}], :limit => 20)
     end
   end
 
   def load_roles
     @roles = Role.all
   end
 
   def save_user_roles
     return unless params[:user]
     @user.roles.delete_all
     params[:user][:role] ||= {}
     params[:user][:role][:user] = 1     # all new accounts have user role
     Role.all.each { |role|
       @user.roles << role unless params[:user][:role][role.name].blank?
     }
     params[:user].delete(:role)
   end
diff --git a/app/controllers/spree/base_controller.rb b/app/controllers/spree/base_controller.rb
index 192c521..939da5d 100644
--- a/app/controllers/spree/base_controller.rb
+++ b/app/controllers/spree/base_controller.rb
@@ -1,192 +1,198 @@
 class Spree::BaseController < ActionController::Base
   layout 'spree_application'
   helper :application, :hook
   before_filter :instantiate_controller_and_action_names
   before_filter :touch_sti_subclasses
   before_filter :set_user_language
   filter_parameter_logging :password, :password_confirmation, :number, :verification_value
   helper_method :current_user_session, :current_user, :title, :title=, :get_taxonomies, :current_gateway
 
   # Pick a unique cookie name to distinguish our session data from others'
   session_options['session_key'] = '_spree_session_id'
   protect_from_forgery # See ActionController::RequestForgeryProtection for details
 
   include RoleRequirementSystem
   include EasyRoleRequirementSystem
   include SslRequirement
 
   def admin_created?
     User.first(:include => :roles, :conditions => ["roles.name = 'admin'"])
   end
 
   # retrieve the order_id from the session and then load from the database (or return a new order if no
   # such id exists in the session)
   def find_order
     if !session[:order_id].blank?
       @order = Order.find_or_create_by_id(session[:order_id])
     elsif request.get?
       @order = Order.new(:user => current_user)
     else
       @order = Order.create(:user => current_user)
     end
     session[:order_id]    = @order.id
     session[:order_token] = @order.token
     @order
   end
 
   def access_forbidden
     render :text => 'Access Forbidden', :layout => true, :status => 401
   end
 
   # can be used in views as well as controllers.
   # e.g. <% title = 'This is a custom title for this view' %>
   def title=(title)
     @title = title
   end
 
   def title
     title_string = @title.blank? ? accurate_title : @title
     if title_string.blank?
       default_title
     else
       if Spree::Config[:always_put_site_name_in_title]
         [default_title, title_string].join(' - ')
       else
         title_string
       end
     end
   end
 
   protected
 
+  # Index request for JSON needs to pass a CSRF token in order to prevent JSON Hijacking
+  def check_json_authenticity
+    return unless request.format.js? or request.format.json?
+    form_authenticity_token == params[request_forgery_protection_token] || raise(ActionController::InvalidAuthenticityToken)
+  end
+
   def default_title
     Spree::Config[:site_name]
   end
-  
+
   def accurate_title
     return nil
   end
-  
+
   def reject_unknown_object
     # workaround to catch problems with loading errors for permalink ids (reconsider RC permalink hack elsewhere?)
     begin
       load_object
     rescue Exception => e
       @object = nil
     end
     the_object = instance_variable_get "@#{object_name}"
     the_object = nil if (the_object.respond_to?(:deleted?) && the_object.deleted?)
     unless params[:id].blank? || the_object
       if self.respond_to? :object_missing
         self.object_missing(params[:id])
       else
         render_404(Exception.new("missing object in #{self.class.to_s}"))
       end
     end
     true
   end
 
   def render_404(exception)
     respond_to do |type|
       type.html { render :file    => "#{Rails.root}/public/404.html", :status => "404 Not Found" }
       type.all  { render :nothing => true,                            :status => "404 Not Found" }
     end
   end
 
   private
   def current_user_session
     return @current_user_session if defined?(@current_user_session)
     @current_user_session = UserSession.find
   end
 
   def current_user
     return @current_user if defined?(@current_user)
     @current_user = current_user_session && current_user_session.user
   end
 
   def require_user
     unless current_user
       store_location
       self.notice = I18n.t("page_only_viewable_when_logged_in")
       redirect_to new_user_session_url
       return false
     end
   end
 
   def require_no_user
     if current_user
       store_location
       self.notice = I18n.t("page_only_viewable_when_logged_out")
       redirect_to root_url
       return false
     end
   end
 
   def store_location
     # disallow return to login, logout, signup pages
     disallowed_urls = [signup_url, login_url, logout_url]
     disallowed_urls.map!{|url| url[/\/\w+$/]}
     unless disallowed_urls.include?(request.request_uri)
       session[:return_to] = request.request_uri
     end
   end
 
   def redirect_back_or_default(default)
     redirect_to(session[:return_to] || default)
     session[:return_to] = nil
   end
 
   # Redirect as appropriate when an access request fails.
   #
   # The default action is to redirect to the login screen.
   #
   # Override this method in your controllers if you want to have special
   # behavior in case the user is not authorized
   # to access the requested action.  For example, a popup window might
   # simply close itself.
   def access_denied
     respond_to do |format|
       format.html do
         if current_user
           flash[:error] = t("authorization_failure")
           redirect_to '/user_sessions/authorization_failure'
           next
         else
           store_location
           redirect_to login_path
           next
         end
       end
       format.xml do
         request_http_basic_authentication 'Web Password'
       end
     end
   end
 
   def instantiate_controller_and_action_names
     @current_action = action_name
     @current_controller = controller_name
   end
 
   def get_taxonomies
     @taxonomies ||= Taxonomy.find(:all, :include => {:root => :children})
     @taxonomies.reject { |t| t.root.nil? }
   end
 
   def current_gateway
     @current_gateway ||= Gateway.current
   end
 
   # Load all models using STI to fix associations such as @order.credits giving no results and resulting in incorrect order totals
   def touch_sti_subclasses
     if RAILS_ENV == 'development'
       load(File.join(SPREE_ROOT,'config/initializers/touch.rb'))
     end
   end
 
   def set_user_language
     locale = session[:locale] || Spree::Config[:default_locale] || I18n.default_locale
     locale = AVAILABLE_LOCALES.keys.include?(locale) ? locale : I18n.default_locale
     I18n.locale = locale
   end
 
diff --git a/vendor/extensions/overview_dashboard/app/controllers/admin/overview_controller.rb b/vendor/extensions/overview_dashboard/app/controllers/admin/overview_controller.rb
index 3e548d9..26affc9 100644
--- a/vendor/extensions/overview_dashboard/app/controllers/admin/overview_controller.rb
+++ b/vendor/extensions/overview_dashboard/app/controllers/admin/overview_controller.rb
@@ -1,151 +1,153 @@
 # this clas was inspired (heavily) from the mephisto admin architecture
 
 class Admin::OverviewController < Admin::BaseController
+  before_filter :check_json_authenticity, :only => :get_report_data
+
   #todo, add rss feed of information that is happening
 
   def index
     @show_dashboard = show_dashboard
     return unless @show_dashboard
 
     p = {:from => (Time.new().to_date  - 1.week).to_s(:db), :value => "Count"}
     @orders_by_day = orders_by_day(p)
     @orders_line_total = orders_line_total(p)
     @orders_total = orders_total(p)
     @orders_adjustment_total = orders_adjustment_total(p)
     @orders_credit_total = orders_credit_total(p)
 
     @best_selling_variants = best_selling_variants
     @top_grossing_variants = top_grossing_variants
     @last_five_orders = last_five_orders
     @biggest_spenders = biggest_spenders
     @out_of_stock_products = out_of_stock_products
     @best_selling_taxons = best_selling_taxons
 
     @pie_colors = [ "#0093DA", "#FF3500", "#92DB00", "#1AB3FF", "#FFB800"]
   end
 
   def get_report_data
     opts = case params[:name]
       when "7_days" then {:from => (Time.new().to_date - 1.week).to_s(:db)}
       when "14_days" then {:from => (Time.new().to_date - 2.week).to_s(:db)}
       when "this_month" then {:from => Date.new(Time.now.year, Time.now.month, 1).to_s(:db), :to => Date.new(Time.now.year, Time.now.month, -1).to_s(:db)}
       when "last_month" then {:from => Date.new(Time.now.year, Time.now.month - 1, 1).to_s(:db), :to => Date.new(Time.now.year, Time.now.month - 1, -1).to_s(:db)}
       when "this_year" then {:from => Date.new(Time.now.year, 1, 1).to_s(:db)}
       when "last_year" then {:from => Date.new(Time.now.year - 1, 1, 1).to_s(:db), :to => Date.new(Time.now.year - 1, 12, -1).to_s(:db)}
     end
 
     case params[:report]
       when "orders_by_day"
         opts[:value] = params[:value]
 
         render :js => "[[" + orders_by_day(opts).map { |day| "['#{day[0]}',#{day[1]}]" }.join(",") + "]]"
       when "orders_totals"
         render :js => [:orders_total => orders_total(opts).to_i, :orders_line_total => orders_line_total(opts).to_i,
           :orders_adjustment_total => orders_adjustment_total(opts).to_i, :orders_credit_total => orders_credit_total(opts).to_i ].to_json
     end
   end
 
   private
   def show_dashboard
     Order.count > 50
   end
 
   def conditions(params)
       if params.key? :to
         ["completed_at >= ? AND completed_at <= ?", params[:from], params[:to]]
       else
         ["completed_at >= ?", params[:from]]
       end
   end
-  
+
   def fill_empty_entries(orders, params)
     from_date = params[:from].to_date
     to_date = (params[:to] || Time.now).to_date
     (from_date..to_date).each do |date|
       orders[date] ||= []
     end
   end
 
   def orders_by_day(params)
 
     if params[:value] == "Count"
       orders = Order.find(:all, :select => 'created_at', :conditions => conditions(params))
       orders = orders.group_by { |o| o.created_at.to_date }
       fill_empty_entries(orders, params)
       orders.keys.sort.map {|key| [key.strftime('%Y-%m-%d'), orders[key].size ]}
     else
       orders = Order.find(:all, :select => 'total, created_at', :conditions => conditions(params))
       orders = orders.group_by { |o| o.created_at.to_date }
       fill_empty_entries(orders, params)
       orders.keys.sort.map {|key| [key.strftime('%Y-%m-%d'), orders[key].inject(0){|s,o| s += o.total} ]}
     end
   end
 
   def orders_line_total(params)
     Order.sum(:item_total, :conditions => conditions(params))
   end
 
   def orders_total(params)
     Order.sum(:total, :conditions => conditions(params))
   end
 
   def orders_adjustment_total(params)
     Order.sum(:adjustment_total, :conditions => conditions(params))
   end
 
   def orders_credit_total(params)
     Order.sum(:credit_total, :conditions => conditions(params))
   end
 
   def best_selling_variants
     li = LineItem.sum(:quantity, :group => :variant_id, :limit => 5)
     variants = li.map do |v|
       variant = Variant.find(v[0])
       [variant.name, v[1] ]
     end
     variants.sort { |x,y| y[1] <=> x[1] }
   end
 
   def top_grossing_variants
     quantity = LineItem.sum(:quantity, :group => :variant_id, :limit => 5)
     prices = LineItem.sum(:price, :group => :variant_id, :limit => 5)
     variants = quantity.map do |v|
       variant = Variant.find(v[0])
       [variant.name, v[1] * prices[v[0]]]
     end
 
     variants.sort { |x,y| y[1] <=> x[1] }
   end
 
   def best_selling_taxons
     taxonomy = Taxonomy.last
     taxons =  Taxon.connection.select_rows("select t.name, count(li.quantity) from line_items li inner join variants v on
            li.variant_id = v.id inner join products p on v.product_id = p.id inner join products_taxons pt on p.id = pt.product_id
            inner join taxons t on pt.taxon_id = t.id where t.taxonomy_id = #{taxonomy.id} group by t.name order by count(li.quantity) desc limit 5;")
   end
 
   def last_five_orders
     orders = Order.find(:all, :order => "completed_at DESC", :limit => 5, :include => :line_items, :conditions => "completed_at is not null")
     orders.map do |o|
       qty = o.line_items.inject(0) {|sum,li| sum + li.quantity}
 
       [o.name, qty, o.total]
     end
   end
 
   def biggest_spenders
     spenders = Order.sum(:total, :group => :user_id, :limit => 5, :order => "sum(total) desc", :conditions => "completed_at is not null and user_id is not null")
     spenders = spenders.map do |o|
       orders = User.find(o[0]).orders
       qty = orders.size
 
       [orders.first.name, qty, o[1]]
 
     end
 
     spenders.sort { |x,y| y[2] <=> x[2] }
   end
 
   def out_of_stock_products
     Product.find(:all, :conditions => {:count_on_hand => 0}, :limit => 5)
   end
diff --git a/vendor/extensions/overview_dashboard/public/javascripts/dashboard.js b/vendor/extensions/overview_dashboard/public/javascripts/dashboard.js
index 43511e5..f0cc7ef 100644
--- a/vendor/extensions/overview_dashboard/public/javascripts/dashboard.js
+++ b/vendor/extensions/overview_dashboard/public/javascripts/dashboard.js
@@ -1,143 +1,143 @@
 jQuery(document).ready(function(){  
 	function number_with_delimiter(number, delimiter, separator) {
 	  try {
 	    var delimiter = delimiter || ",";
 	    var separator = separator || ".";
 
 	    var parts = number.toString().split('.');
 	    parts[0] = parts[0].replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1" + delimiter);
 	    formatted_number = parts.join(separator);
 	
 			if(formatted_number.length>=6 && formatted_number.length<=9){
 				var arr = formatted_number.split(",");
 				return arr[0] + " k";
 			}else if(formatted_number.length==10){
 				var arr = formatted_number.split(",");
 				return arr[0] + " m";
 			}else{
 				return formatted_number
 			}
 	  } catch(e) {
 	    return number
 	  }
 	}
 	
   function handle_orders_by_day(r){
 		var new_points = eval(r);
 
 		if(new_points[0].length>0){
 			orders_by_day_settings.axes.xaxis.min = new_points[0][0][0].replace(/-/g, "/");
 			orders_by_day_settings.axes.xaxis.max = new_points[0][new_points[0].length -1][0].replace(/-/g, "/");
 		}
 	
 		orders_by_day_settings.axes.yaxis.label = jQuery("#orders_by_day_value :selected").val();
 
 		jQuery("#order_by_day_title").text(orders + " " + jQuery("#orders_by_day_value :selected").val() + " " + by_day + " (" + jQuery("#orders_by_day_reports :selected").text() + ")");
 
 		$('#orders_by_day').empty();
 		$.jqplot('orders_by_day', new_points, orders_by_day_settings);
 
 	}
 	
 	function handle_orders_total(r){
 		var values = eval(r);
 		
 		jQuery('#orders_total').text(number_with_delimiter(values[0].orders_total));
 		jQuery('#orders_line_total').text(number_with_delimiter(values[0].orders_line_total));
 		jQuery('#orders_adjustment_total').text(number_with_delimiter(values[0].orders_adjustment_total));
 		jQuery('#orders_adjustment_total').text(number_with_delimiter(values[0].orders_adjustment_total));
 	}
 
 	var orders_by_day_settings = {
 		title: {
 			textColor: '#476D9B',
 			fontSize: '12pt',
 		}, 
 		grid: {background:'#fff', gridLineColor:'#fff',borderColor: '#476D9B'},
 	  axes:{
 			yaxis:{
 				label:'Order (Count)',
 				labelRenderer: $.jqplot.CanvasAxisLabelRenderer,						
 				autoscale:true, 
 				tickOptions:{
 					formatString:'%d',
 					fontSize: '10pt',
 					textColor: '#476D9B'
 				},
 				min: 0
 			},	
 			xaxis:{	 
 				renderer:$.jqplot.DateAxisRenderer,
 				rendererOptions:{tickRenderer:$.jqplot.CanvasAxisTickRenderer},
 				tickOptions:{
 					formatString:'%b %#d, %y',
 					angle: -30,
 					fontSize: '10pt',
 					textColor: '#476D9B'
 				},
 				min: orders_by_day_points[0][0][0].replace(/-/g, "/"), 
 				max: orders_by_day_points[0][orders_by_day_points[0].length -1][0].replace(/-/g, "/")//,
 				//tickInterval: '1 day'
 			}
 		},
 		series:[{lineWidth:3, color: '#0095DA', fillAndStroke: true, fill: true, fillColor: '#E6F7FF'}],
 		highlighter: {
 			formatString: "Date: %s <br/>Value: %s ",
 			sizeAdjust: 7.5
 		}
 	};
 
 	jQuery.jqplot('orders_by_day', orders_by_day_points, orders_by_day_settings);
 
 	jQuery("div#orders_by_day_options select").change(function(){
 		var report = jQuery("#orders_by_day_reports :selected").val();
 		var value = jQuery("#orders_by_day_value :selected").val();
 	
 		jQuery.ajax({
 	       type: 'GET',
-	       url: 'admin/overview/get_report_data',
-	       data: ({report: 'orders_by_day', name: report, value: value, authenticity_token: AUTH_TOKEN}),
+	       url: 'admin/overview/get_report_data?authenticity_token=' + AUTH_TOKEN,
+	       data: ({report: 'orders_by_day', name: report, value: value}),
 	       success: handle_orders_by_day
 		});
 		
 		jQuery.ajax({
 	       type: 'GET',
-	       url: 'admin/overview/get_report_data',
-	       data: ({report: 'orders_totals', name: report, authenticity_token: AUTH_TOKEN}),
+	       url: 'admin/overview/get_report_data?authenticity_token=' + AUTH_TOKEN,
+	       data: ({report: 'orders_totals', name: report}),
 	       success: handle_orders_total
 		});
 
 	});
 
 	best_selling_variants = $.jqplot('best_selling_products', [best_selling_variants_points], {
 		grid: {background:'#fff',borderWidth: 0, borderColor: '#fff', shadow: false},
 		seriesDefaults:{
 		  renderer:$.jqplot.PieRenderer, 
 		  rendererOptions:{padding:6,sliceMargin:0}
 		},
 		seriesColors: pie_colors
 	});
 
 
 	top_grossing_variants = $.jqplot('top_grossing_products', [top_grossing_variants_points], {
 		grid: {background:'#fff',borderWidth: 0, borderColor: '#fff', shadow: false},
 		seriesDefaults:{
 		  renderer:$.jqplot.PieRenderer, 
 		  rendererOptions:{padding:6,sliceMargin:0}
 		},
 
 		seriesColors: pie_colors
 	});
 
 	tbest_selling_taxons = $.jqplot('best_selling_taxons', [best_selling_taxons_points], {
 		grid: {background:'#fff',borderWidth: 0, borderColor: '#fff', shadow: false},
 		seriesDefaults:{
 		  renderer:$.jqplot.PieRenderer, 
 		  rendererOptions:{padding:6,sliceMargin:0}
 		},
 
 		seriesColors: pie_colors
 	});
 
 
 });
diff --git a/vendor/extensions/theme_default/app/views/shared/_admin_head.html.erb b/vendor/extensions/theme_default/app/views/shared/_admin_head.html.erb
index 2a9641e..781fe39 100644
--- a/vendor/extensions/theme_default/app/views/shared/_admin_head.html.erb
+++ b/vendor/extensions/theme_default/app/views/shared/_admin_head.html.erb
@@ -1,21 +1,21 @@
 <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
 <title><%= "Spree #{t('administration')}: " -%>
 <%= t(controller.controller_name, :default => controller.controller_name.titleize) %></title>
 
 <%= stylesheet_link_tag 'admin/admin-reset', 'admin/grids', 'admin/admin-typography', 'admin/admin-forms', 'admin/admin-tables', 'admin/admin', :cache => 'admin-all' %>
 
 <%= javascript_include_tag 'jquery', 'jquery-ui', 'jrails', 'jquery.suggest', 'jrails.autocomplete', :cache => 'jquery-admin-plugins' %>
 <%= javascript_include_tag('jquery.template') unless controller.controller_name == "overview" %>
 <%= javascript_include_tag 'spree', 'nested-attribute', 'zone', 'calculator', 'gateway' %>
 <%= javascript_tag "$ = jQuery;" %>
-<%= javascript_tag "var AUTH_TOKEN = #{form_authenticity_token.inspect};" if protect_against_forgery? %>
+<%= javascript_tag "var AUTH_TOKEN = encodeURIComponent(#{form_authenticity_token.inspect});" %>
 <%= javascript_include_tag 'jquery.alerts/jquery.alerts.js' %>
 <%= javascript_include_tag 'jquery.autocomplete.min.js' %>
 
 <%= stylesheet_link_tag '/javascripts/jquery.alerts/jquery.alerts.css' %>
 <%= stylesheet_link_tag '/javascripts/jquery.alerts/jquery.alerts.spree.css' %>
 <%= stylesheet_link_tag 'jquery.autocomplete.css' %>
 
 <%= javascript_tag "jQuery.alerts.dialogClass = 'spree';" %>
-<%= unobtrusive_datepicker_includes %>	
+<%= unobtrusive_datepicker_includes %>
 <%= yield :head %>
diff --git a/vendor/extensions/theme_default/public/javascripts/admin/checkouts/edit.js b/vendor/extensions/theme_default/public/javascripts/admin/checkouts/edit.js
index f7281aa..f4a345d 100644
--- a/vendor/extensions/theme_default/public/javascripts/admin/checkouts/edit.js
+++ b/vendor/extensions/theme_default/public/javascripts/admin/checkouts/edit.js
@@ -1,129 +1,129 @@
 jQuery(document).ready(function(){
   add_address = function(addr){
     var html = "";
     if(addr!=undefined){
       html += addr['firstname'] + " " + addr['lastname'] + ", ";
       html += addr['address1'] + ", " + addr['address2'] + ", ";
       html += addr['city'] + ", ";
 
       if(addr['state_id']!=null){
         html += addr['state']['name'] + ", ";
       }else{
         html += addr['state_name'] + ", ";
       }
 
       html += addr['country']['name'];
     }
     return html;
   }
 
   format_autocomplete = function(data){
     var html = "<h4>" + data['email'] +"</h4>";
     html += "<span><strong>Billing:</strong> ";
     html += add_address(data['bill_address']);
     html += "</span>";
 
     html += "<span><strong>Shipping:</strong> ";
     html += add_address(data['ship_address']);
     html += "</span>";
 
     return html
   }
 
   prep_autocomplete_data = function(data){
     return $.map(eval(data), function(row) {
       return {
           data: row['user'],
           value: row['user']['email'],
           result: row['user']['email']
       }
     });
   }
 
-  $("#customer_search").autocomplete("/admin/users.json", {
+  $("#customer_search").autocomplete("/admin/users.json?authenticity_token=" + AUTH_TOKEN, {
     minChars: 5,
     delay: 1500,
     parse: prep_autocomplete_data,
     formatItem: function(item) {
       return format_autocomplete(item);
     }
   }).result(function(event, data, formatted) {
     $('#user_id').val(data['id']);
     $('#guest_checkout_true').removeAttr("checked");
     $('#guest_checkout_false').attr("checked", "checked");
     $('#guest_checkout_false').removeAttr("disabled");
     $('#checkout_email').val(data['email']);
 
     var addr = data['bill_address'];
     if(addr!=undefined){
       $('#checkout_bill_address_attributes_firstname').val(addr['firstname']);
       $('#checkout_bill_address_attributes_lastname').val(addr['lastname']);
       $('#checkout_bill_address_attributes_address1').val(addr['address1']);
       $('#checkout_bill_address_attributes_address2').val(addr['address2']);
       $('#checkout_bill_address_attributes_city').val(addr['city']);
       $('#checkout_bill_address_attributes_zipcode').val(addr['zipcode']);
       $('#checkout_bill_address_attributes_state_id').val(addr['state_id']);
       $('#checkout_bill_address_attributes_country_id').val(addr['country_id']);
       $('#checkout_bill_address_attributes_phone').val(addr['phone']);
     }
 
     var addr = data['ship_address'];
     if(addr!=undefined){
       $('#checkout_ship_address_attributes_firstname').val(addr['firstname']);
       $('#checkout_ship_address_attributes_lastname').val(addr['lastname']);
       $('#checkout_ship_address_attributes_address1').val(addr['address1']);
       $('#checkout_ship_address_attributes_address2').val(addr['address2']);
       $('#checkout_ship_address_attributes_city').val(addr['city']);
       $('#checkout_ship_address_attributes_zipcode').val(addr['zipcode']);
       $('#checkout_ship_address_attributes_state_id').val(addr['state_id']);
       $('#checkout_ship_address_attributes_country_id').val(addr['country_id']);
       $('#checkout_ship_address_attributes_phone').val(addr['phone']);
     }
   });
 
 
   $('input#checkout_use_billing').click(function() {
     show_billing(!this.checked);
   });
 
   $('#guest_checkout_true').change(function() {
     $('#customer_search').val("");
     $('#user_id').val("");
     $('#checkout_email').val("");
     $('#guest_checkout_false').attr("disabled", "true");
 
     $('#checkout_bill_address_attributes_firstname').val("");
     $('#checkout_bill_address_attributes_lastname').val("");
     $('#checkout_bill_address_attributes_address1').val("");
     $('#checkout_bill_address_attributes_address2').val("");
     $('#checkout_bill_address_attributes_city').val("");
     $('#checkout_bill_address_attributes_zipcode').val("");
     $('#checkout_bill_address_attributes_state_id').val("");
     $('#checkout_bill_address_attributes_country_id').val("");
     $('#checkout_bill_address_attributes_phone').val("");
 
     $('#checkout_ship_address_attributes_firstname').val("");
     $('#checkout_ship_address_attributes_lastname').val("");
     $('#checkout_ship_address_attributes_address1').val("");
     $('#checkout_ship_address_attributes_address2').val("");
     $('#checkout_ship_address_attributes_city').val("");
     $('#checkout_ship_address_attributes_zipcode').val("");
     $('#checkout_ship_address_attributes_state_id').val("");
     $('#checkout_ship_address_attributes_country_id').val("");
     $('#checkout_ship_address_attributes_phone').val("");
   });
 
   var show_billing = function(show) {
     if(show) {
       $('#shipping').show();
       $('#shipping input').removeAttr('disabled', 'disabled');
       $('#shipping select').removeAttr('disabled', 'disabled');
     } else {
       $('#shipping').hide();
       $('#shipping input').attr('disabled', 'disabled');
       $('#shipping select').attr('disabled', 'disabled');
     }
   }
 
 });
 
diff --git a/vendor/extensions/theme_default/public/javascripts/admin/orders/edit.js b/vendor/extensions/theme_default/public/javascripts/admin/orders/edit.js
index 5b02e99..001342b 100644
--- a/vendor/extensions/theme_default/public/javascripts/admin/orders/edit.js
+++ b/vendor/extensions/theme_default/public/javascripts/admin/orders/edit.js
@@ -1,96 +1,96 @@
 jQuery(document).ready(function(){
   image_html = function(item){
     return "<img src='/assets/products/" + item['images'][0]["id"] + "/mini/" + item['images'][0]['attachment_file_name'] + "'/>";
   }
 
   format_autocomplete = function(data){
     var html = "";
 
     var product = data['product'];
 
     if(data['variant']==undefined){
       // product
 
       if(product['images'].length!=0){
         html = image_html(product);
       }
 
       html += "<div><h4>" + product['name'] + "</h4>";
       html += "<span><strong>Sku: </strong>" + product['master']['sku'] + "</span>";
       html += "<span><strong>On Hand: </strong>" + product['count_on_hand'] + "</span></div>";
     }else{
       // variant
       var variant = data['variant'];
       var name = product['name'];
 
       if(variant['images'].length!=0){
         html = image_html(variant);
       }else{
         if(product['images'].length!=0){
           html = image_html(product);
         }
       }
 
       name += " - " + $.map(variant['option_values'], function(option_value){
         return option_value["option_type"]["presentation"] + ": " + option_value['name'];
       }).join(", ")
 
       html += "<div><h4>" + name + "</h4>";
       html += "<span><strong>Sku: </strong>" + variant['sku'] + "</span>";
       html += "<span><strong>On Hand: </strong>" + variant['count_on_hand'] + "</span></div>";
     }
 
 
     return html
   }
 
 
   prep_autocomplete_data = function(data){
     return $.map(eval(data), function(row) {
 
       var product = row['product'];
 
       if(product['variants'].length>0 && expand_variants){
         //variants
         return $.map(product['variants'], function(variant){
 
           var name = product['name'];
           name += " - " + $.map(variant['option_values'], function(option_value){
             return option_value["option_type"]["presentation"] + ": " + option_value['name'];
           }).join(", ");
 
           return {
               data: {product: product, variant: variant},
               value: name,
               result: name
           }
         });
       }else{
         return {
             data: {product: product},
             value: product['name'],
             result: product['name']
         }
       }
     });
   }
 
-  $("#add_product_name").autocomplete("/admin/products.json", {
+  $("#add_product_name").autocomplete("/admin/products.json?authenticity_token=" + AUTH_TOKEN, {
       parse: prep_autocomplete_data,
       formatItem: function(item) {
         return format_autocomplete(item);
       }
     }).result(function(event, data, formatted) {
       if (data){
         if(data['variant']==undefined){
           // product
           $('#add_variant_id').val(data['product']['master']['id']);
         }else{
           // variant
           $('#add_variant_id').val(data['variant']['id']);
         }
       }
     });
 
 });
 
