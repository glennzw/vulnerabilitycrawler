   core: fix CA cert mishandling after cert file deletion (deb #560067) (rh #546793)
   
   If a connection was created with a CA certificate, but the user later
   moved or deleted that CA certificate, the applet would simply provide the
   connection to NetworkManager without any CA certificate.  This could cause
   NM to connect to the original network (or a network spoofing the original
   network) without verifying the identity of the network as the user
   expects.
   
   In the future we can/should do better here by (1) alerting the user that
   some connection is now no longer complete by flagging it in the connection
   editor or notifying the user somehow, and (2) by using a freaking' cert
   store already (not that Linux has one yet).
                 GError **error)
{
	GHashTable *secrets;

	g_return_val_if_fail (settings != NULL, FALSE);
	g_return_val_if_fail (connection != NULL, FALSE);
	g_return_val_if_fail (error != NULL, FALSE);
	g_return_val_if_fail (*error == NULL, FALSE);

	utils_fill_connection_certs (connection);
	secrets = nm_setting_to_hash (setting);
	utils_clear_filled_connection_certs (connection);

		goto done;
	}

	utils_fill_connection_certs (NM_CONNECTION (connection));
	secrets = nm_setting_to_hash (setting);
	utils_clear_filled_connection_certs (NM_CONNECTION (connection));

	NMExportedConnection *exported = NULL;
	NMConnectionScope scope;
	gboolean success = FALSE;

	scope = nm_connection_get_scope (connection);
	if (scope == NM_CONNECTION_SCOPE_SYSTEM) {
		GError *error = NULL;

		utils_fill_connection_certs (connection);
		success = nm_dbus_settings_system_add_connection (self->system_settings, connection, &error);
		utils_clear_filled_connection_certs (connection);

		if (!success) {
			gboolean pending_auth = FALSE;
		gboolean pending_auth = FALSE;
		GtkWindow *parent;

		utils_fill_connection_certs (modified);
		new_settings = nm_connection_to_hash (modified);

		/* Hack; make sure that gconf private values are copied */
		nm_gconf_copy_private_connection_values (nm_exported_connection_get_connection (original),
		                                         modified);

		success = nm_exported_connection_update (original, new_settings, &error);
		g_hash_table_destroy (new_settings);
		utils_clear_filled_connection_certs (modified);

		parent = nm_connection_editor_get_window (editor);
		if (!success) {
			if (pk_helper_is_permission_denied_error (error)) {
				GError *auth_error = NULL;

		connection = nm_connection_editor_get_connection (editor);

		utils_fill_connection_certs (connection);
		success = nm_connection_verify (connection, &edit_error);
		utils_clear_filled_connection_certs (connection);

		if (success) {
			update_connection (info->list, editor, info->original_connection,
			                   connection, connection_updated_cb, info);
		} else {
			g_warning ("%s: invalid connection after update: bug in the "
			           "'%s' / '%s' invalid: %d",
			           __func__,
			           g_type_name (nm_connection_lookup_setting_type_by_quark (edit_error->domain)),
			           edit_error->message, edit_error->code);
			g_error_free (edit_error);
			connection_updated_cb (info->list, FALSE, user_data);
		}
#include <gconf/gconf.h>
#include <gconf/gconf-client.h>
#include <glib.h>
#include <gnome-keyring.h>
#include <dbus/dbus-glib.h>
#include <nm-setting-connection.h>
	GConfClient *client;
	const char *dir;
	guint32 dir_len;
} ReadFromGConfInfo;

static void
	}
}

static void
read_one_cert (ReadFromGConfInfo *info,
               const char *setting_name,
               const char *key)
{
	char *value = NULL;

	if (!nm_gconf_get_string_helper (info->client, info->dir, key, setting_name, &value))
		return;

	g_object_set_data_full (G_OBJECT (info->connection),
	                        key, value,
	                        (GDestroyNotify) g_free);
}

static void
read_applet_private_values_from_gconf (NMSetting *setting,
                                       ReadFromGConfInfo *info)
{
	if (NM_IS_SETTING_802_1X (setting)) {
		const char *setting_name = nm_setting_get_name (setting);
		gboolean value;

		if (nm_gconf_get_bool_helper (info->client, info->dir,
		                              NMA_CA_CERT_IGNORE_TAG,
		                              setting_name, &value)) {
			g_object_set_data (G_OBJECT (info->connection),
			                   NMA_CA_CERT_IGNORE_TAG,
			                   GUINT_TO_POINTER (value));
		}

		if (nm_gconf_get_bool_helper (info->client, info->dir,
		                              NMA_PHASE2_CA_CERT_IGNORE_TAG,
		                              setting_name, &value)) {
			g_object_set_data (G_OBJECT (info->connection),
			                   NMA_PHASE2_CA_CERT_IGNORE_TAG,
			                   GUINT_TO_POINTER (value));
		}

		/* Binary certificate and key data doesn't get stored in GConf.  Instead,
		 * the path to the certificate gets stored in a special key and the
		 * certificate is read and stuffed into the setting right before
		 * the connection is sent to NM
		 */
		read_one_cert (info, setting_name, NMA_PATH_CA_CERT_TAG);
		read_one_cert (info, setting_name, NMA_PATH_CLIENT_CERT_TAG);
		read_one_cert (info, setting_name, NMA_PATH_PRIVATE_KEY_TAG);
		read_one_cert (info, setting_name, NMA_PATH_PHASE2_CA_CERT_TAG);
		read_one_cert (info, setting_name, NMA_PATH_PHASE2_CLIENT_CERT_TAG);
		read_one_cert (info, setting_name, NMA_PATH_PHASE2_PRIVATE_KEY_TAG);
	}
}

static void

NMConnection *
nm_gconf_read_connection (GConfClient *client,
                          const char *dir)
{
	ReadFromGConfInfo info;
	GSList *list;
	GError *err = NULL;

	list = gconf_client_all_dirs (client, dir, &err);
	if (err) {
		g_warning ("Error while reading connection: %s", err->message);
		g_error_free (err);
		return NULL;
	}

	if (!list) {
		g_warning ("Invalid connection (empty)");
		return NULL;
	}

	info.connection = nm_connection_new ();
	info.client = client;
	info.dir = dir;
	g_slist_foreach (list, read_one_setting, &info);
	g_slist_free (list);

	return info.connection;
}


NMConnection *
nm_gconf_read_connection (GConfClient *client,
                          const char *dir);

void
nm_gconf_write_connection (NMConnection *connection,
nma_gconf_connection_new (GConfClient *client, const char *conf_dir)
{
	NMConnection *connection;
	NMAGConfConnection *gconf_connection;

	g_return_val_if_fail (GCONF_IS_CLIENT (client), NULL);
	g_return_val_if_fail (conf_dir != NULL, NULL);

	/* retrieve GConf data */
	connection = nm_gconf_read_connection (client, conf_dir);
	if (connection) {
		gconf_connection = nma_gconf_connection_new_from_connection (client, conf_dir, connection);
		g_object_unref (connection);
	} else {
		nm_warning ("No connection read from GConf at %s.", conf_dir);
		gconf_connection = NULL;
	}
	
	return gconf_connection;
	priv = NMA_GCONF_CONNECTION_GET_PRIVATE (self);
	wrapped_connection = nm_exported_connection_get_connection (NM_EXPORTED_CONNECTION (self));

	gconf_connection = nm_gconf_read_connection (priv->client, priv->dir);
	if (!gconf_connection) {
		g_warning ("No connection read from GConf at %s.", priv->dir);
		goto invalid;
	}

	utils_fill_connection_certs (gconf_connection);
	if (!nm_connection_verify (gconf_connection, &error)) {
		utils_clear_filled_connection_certs (gconf_connection);
		g_warning ("%s: Invalid connection %s: '%s' / '%s' invalid: %d",
	/* Update private values to catch any certificate path changes */
	nm_gconf_copy_private_connection_values (wrapped_connection, gconf_connection);

	utils_fill_connection_certs (gconf_connection);
	new_settings = nm_connection_to_hash (gconf_connection);
	utils_clear_filled_connection_certs (gconf_connection);

static GHashTable *
get_settings (NMExportedConnection *exported)
{
	NMConnection *connection;
	GHashTable *settings;

	connection = nm_exported_connection_get_connection (exported);

	utils_fill_connection_certs (connection);
	settings = nm_connection_to_hash (connection);
	utils_clear_filled_connection_certs (connection);


	connection = nm_exported_connection_get_connection (NM_EXPORTED_CONNECTION (object));

	utils_fill_connection_certs (connection);
	if (!nm_connection_verify (connection, &error)) {
		utils_clear_filled_connection_certs (connection);
		g_warning ("Invalid connection: '%s' / '%s' invalid: %d",
#include <string.h>
#include <netinet/ether.h>
#include <glib.h>

#include <nm-device-ethernet.h>
#include <nm-device-wifi.h>
	return need_client_cert;
}

void
utils_fill_connection_certs (NMConnection *connection)
{
	NMSetting8021x *s_8021x;
	const char *filename;
	GError *error = NULL;
	gboolean need_client_cert = TRUE;

	g_return_if_fail (connection != NULL);

	s_8021x = NM_SETTING_802_1X (nm_connection_get_setting (connection, NM_TYPE_SETTING_802_1X));
	if (!s_8021x)
		return;

	filename = g_object_get_data (G_OBJECT (connection), NMA_PATH_CA_CERT_TAG);
	if (filename) {
		if (!nm_setting_802_1x_set_ca_cert_from_file (s_8021x, filename, NULL, &error))
			g_warning ("%s: couldn't read CA certificate: %d %s", __func__, error->code, error->message);
		g_clear_error (&error);
	}

	/* If the private key is PKCS#12, don't set the client cert */
	if (need_client_cert) {
		filename = g_object_get_data (G_OBJECT (connection), NMA_PATH_CLIENT_CERT_TAG);
		if (filename) {
			if (!nm_setting_802_1x_set_client_cert_from_file (s_8021x, filename, NULL, &error))
				g_warning ("%s: couldn't read client certificate: %d %s", __func__, error->code, error->message);
			g_clear_error (&error);
		}
	}

	filename = g_object_get_data (G_OBJECT (connection), NMA_PATH_PHASE2_CA_CERT_TAG);
	if (filename) {
		if (!nm_setting_802_1x_set_phase2_ca_cert_from_file (s_8021x, filename, NULL, &error))
			g_warning ("%s: couldn't read phase2 CA certificate: %d %s", __func__, error->code, error->message);
		g_clear_error (&error);
	}

	/* If the private key is PKCS#12, don't set the client cert */
	if (need_client_cert) {
		filename = g_object_get_data (G_OBJECT (connection), NMA_PATH_PHASE2_CLIENT_CERT_TAG);
		if (filename) {
			if (!nm_setting_802_1x_set_phase2_client_cert_from_file (s_8021x, filename, NULL, &error))
				g_warning ("%s: couldn't read phase2 client certificate: %d %s", __func__, error->code, error->message);
			g_clear_error (&error);
		}
	}
}

void

const char *utils_get_device_description (NMDevice *device);

void utils_fill_connection_certs (NMConnection *connection);

void utils_clear_filled_connection_certs (NMConnection *connection);

