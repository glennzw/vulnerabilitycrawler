   asn1: additional sanity checking during BER decoding
   
   - Don't trust a length which is greater than the working buffer.
     An invalid length could cause overflow when calculating buffer size
     for decoding oid.
   
   - An oid length of zero is invalid and allows for an off-by-one error when
     decoding oid because the first subid actually encodes first 2 subids.
   
   - A primitive encoding may not have an indefinite length.
   
   Thanks to Wei Wang from McAfee for report.
   
   Cc: Steven French <sfrench@us.ibm.com>
   Cc: stable@kernel.org
   Acked-by: Patrick McHardy <kaber@trash.net>
   Signed-off-by: Chris Wright <chrisw@sous-sol.org>
   Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
			}
		}
	}
	return 1;
}

	if (!asn1_length_decode(ctx, &def, &len))
		return 0;

	if (def)
		*eoc = ctx->pointer + len;
	else
	unsigned long *optr;

	size = eoc - ctx->pointer + 1;
	*oid = kmalloc(size * sizeof(unsigned long), GFP_ATOMIC);
	if (*oid == NULL)
		return 0;
			}
		}
	}
	return 1;
}

	if (!asn1_length_decode(ctx, &def, &len))
		return 0;

	if (def)
		*eoc = ctx->pointer + len;
	else
	unsigned long *optr;

	size = eoc - ctx->pointer + 1;
	*oid = kmalloc(size * sizeof(unsigned long), GFP_ATOMIC);
	if (*oid == NULL) {
		if (net_ratelimit())
