commit ddb2c43594f22843e9f3153da151deaba1a834c5
Author: Chris Wright <chrisw@sous-sol.org>
Date:   Wed Jun 4 09:16:33 2008 -0700

    asn1: additional sanity checking during BER decoding
    
    - Don't trust a length which is greater than the working buffer.
      An invalid length could cause overflow when calculating buffer size
      for decoding oid.
    
    - An oid length of zero is invalid and allows for an off-by-one error when
      decoding oid because the first subid actually encodes first 2 subids.
    
    - A primitive encoding may not have an indefinite length.
    
    Thanks to Wei Wang from McAfee for report.
    
    Cc: Steven French <sfrench@us.ibm.com>
    Cc: stable@kernel.org
    Acked-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/cifs/asn1.c b/fs/cifs/asn1.c
index cb52cbb..f58e41d 100644
--- a/fs/cifs/asn1.c
+++ b/fs/cifs/asn1.c
@@ -162,30 +162,35 @@ static unsigned char
 asn1_length_decode(struct asn1_ctx *ctx, unsigned int *def, unsigned int *len)
 {
 	unsigned char ch, cnt;
 
 	if (!asn1_octet_decode(ctx, &ch))
 		return 0;
 
 	if (ch == 0x80)
 		*def = 0;
 	else {
 		*def = 1;
 
 		if (ch < 0x80)
 			*len = ch;
 		else {
 			cnt = (unsigned char) (ch & 0x7F);
 			*len = 0;
 
 			while (cnt > 0) {
 				if (!asn1_octet_decode(ctx, &ch))
 					return 0;
 				*len <<= 8;
 				*len |= ch;
 				cnt--;
 			}
 		}
 	}
+
+	/* don't trust len bigger than ctx buffer */
+	if (*len > ctx->end - ctx->pointer)
+		return 0;
+
 	return 1;
 }
 
@@ -193,20 +198,24 @@ static unsigned char
 asn1_header_decode(struct asn1_ctx *ctx,
 		   unsigned char **eoc,
 		   unsigned int *cls, unsigned int *con, unsigned int *tag)
 {
 	unsigned int def = 0;
 	unsigned int len = 0;
 
 	if (!asn1_id_decode(ctx, cls, con, tag))
 		return 0;
 
 	if (!asn1_length_decode(ctx, &def, &len))
 		return 0;
 
+	/* primitive shall be definite, indefinite shall be constructed */
+	if (*con == ASN1_PRI && !def)
+		return 0;
+
 	if (def)
 		*eoc = ctx->pointer + len;
 	else
 		*eoc = NULL;
 	return 1;
 }
 
@@ -384,51 +393,56 @@ static int
 asn1_oid_decode(struct asn1_ctx *ctx,
 		unsigned char *eoc, unsigned long **oid, unsigned int *len)
 {
 	unsigned long subid;
 	unsigned int size;
 	unsigned long *optr;
 
 	size = eoc - ctx->pointer + 1;
+
+	/* first subid actually encodes first two subids */
+	if (size < 2 || size > ULONG_MAX/sizeof(unsigned long))
+		return 0;
+
 	*oid = kmalloc(size * sizeof(unsigned long), GFP_ATOMIC);
 	if (*oid == NULL)
 		return 0;
 
 	optr = *oid;
 
 	if (!asn1_subid_decode(ctx, &subid)) {
 		kfree(*oid);
 		*oid = NULL;
 		return 0;
 	}
 
 	if (subid < 40) {
 		optr[0] = 0;
 		optr[1] = subid;
 	} else if (subid < 80) {
 		optr[0] = 1;
 		optr[1] = subid - 40;
 	} else {
 		optr[0] = 2;
 		optr[1] = subid - 80;
 	}
 
 	*len = 2;
 	optr += 2;
 
 	while (ctx->pointer < eoc) {
 		if (++(*len) > size) {
 			ctx->error = ASN1_ERR_DEC_BADVALUE;
 			kfree(*oid);
 			*oid = NULL;
 			return 0;
 		}
 
 		if (!asn1_subid_decode(ctx, optr++)) {
 			kfree(*oid);
 			*oid = NULL;
 			return 0;
 		}
 	}
 	return 1;
 }
 
diff --git a/net/ipv4/netfilter/nf_nat_snmp_basic.c b/net/ipv4/netfilter/nf_nat_snmp_basic.c
index 5daefad..7750c97 100644
--- a/net/ipv4/netfilter/nf_nat_snmp_basic.c
+++ b/net/ipv4/netfilter/nf_nat_snmp_basic.c
@@ -206,54 +206,63 @@ static unsigned char asn1_id_decode(struct asn1_ctx *ctx,
 static unsigned char asn1_length_decode(struct asn1_ctx *ctx,
 					unsigned int *def,
 					unsigned int *len)
 {
 	unsigned char ch, cnt;
 
 	if (!asn1_octet_decode(ctx, &ch))
 		return 0;
 
 	if (ch == 0x80)
 		*def = 0;
 	else {
 		*def = 1;
 
 		if (ch < 0x80)
 			*len = ch;
 		else {
 			cnt = ch & 0x7F;
 			*len = 0;
 
 			while (cnt > 0) {
 				if (!asn1_octet_decode(ctx, &ch))
 					return 0;
 				*len <<= 8;
 				*len |= ch;
 				cnt--;
 			}
 		}
 	}
+
+	/* don't trust len bigger than ctx buffer */
+	if (*len > ctx->end - ctx->pointer)
+		return 0;
+
 	return 1;
 }
 
 static unsigned char asn1_header_decode(struct asn1_ctx *ctx,
 					unsigned char **eoc,
 					unsigned int *cls,
 					unsigned int *con,
 					unsigned int *tag)
 {
 	unsigned int def, len;
 
 	if (!asn1_id_decode(ctx, cls, con, tag))
 		return 0;
 
 	def = len = 0;
 	if (!asn1_length_decode(ctx, &def, &len))
 		return 0;
 
+	/* primitive shall be definite, indefinite shall be constructed */
+	if (*con == ASN1_PRI && !def)
+		return 0;
+
 	if (def)
 		*eoc = ctx->pointer + len;
 	else
 		*eoc = NULL;
 	return 1;
 }
 
@@ -427,136 +436,141 @@ static unsigned char asn1_subid_decode(struct asn1_ctx *ctx,
 static unsigned char asn1_oid_decode(struct asn1_ctx *ctx,
 				     unsigned char *eoc,
 				     unsigned long **oid,
 				     unsigned int *len)
 {
 	unsigned long subid;
 	unsigned int  size;
 	unsigned long *optr;
 
 	size = eoc - ctx->pointer + 1;
+
+	/* first subid actually encodes first two subids */
+	if (size < 2 || size > ULONG_MAX/sizeof(unsigned long))
+		return 0;
+
 	*oid = kmalloc(size * sizeof(unsigned long), GFP_ATOMIC);
 	if (*oid == NULL) {
 		if (net_ratelimit())
 			printk("OOM in bsalg (%d)\n", __LINE__);
 		return 0;
 	}
 
 	optr = *oid;
 
 	if (!asn1_subid_decode(ctx, &subid)) {
 		kfree(*oid);
 		*oid = NULL;
 		return 0;
 	}
 
 	if (subid < 40) {
 		optr [0] = 0;
 		optr [1] = subid;
 	} else if (subid < 80) {
 		optr [0] = 1;
 		optr [1] = subid - 40;
 	} else {
 		optr [0] = 2;
 		optr [1] = subid - 80;
 	}
 
 	*len = 2;
 	optr += 2;
 
 	while (ctx->pointer < eoc) {
 		if (++(*len) > size) {
 			ctx->error = ASN1_ERR_DEC_BADVALUE;
 			kfree(*oid);
 			*oid = NULL;
 			return 0;
 		}
 
 		if (!asn1_subid_decode(ctx, optr++)) {
 			kfree(*oid);
 			*oid = NULL;
 			return 0;
 		}
 	}
 	return 1;
 }
 
 /*****************************************************************************
  *
  * SNMP decoding routines (gxsnmp author Dirk Wisse)
  *
  *****************************************************************************/
 
 /* SNMP Versions */
 #define SNMP_V1				0
 #define SNMP_V2C			1
 #define SNMP_V2				2
 #define SNMP_V3				3
 
 /* Default Sizes */
 #define SNMP_SIZE_COMM			256
 #define SNMP_SIZE_OBJECTID		128
 #define SNMP_SIZE_BUFCHR		256
 #define SNMP_SIZE_BUFINT		128
 #define SNMP_SIZE_SMALLOBJECTID		16
 
 /* Requests */
 #define SNMP_PDU_GET			0
 #define SNMP_PDU_NEXT			1
 #define SNMP_PDU_RESPONSE		2
 #define SNMP_PDU_SET			3
 #define SNMP_PDU_TRAP1			4
 #define SNMP_PDU_BULK			5
 #define SNMP_PDU_INFORM			6
 #define SNMP_PDU_TRAP2			7
 
 /* Errors */
 #define SNMP_NOERROR			0
 #define SNMP_TOOBIG			1
 #define SNMP_NOSUCHNAME			2
 #define SNMP_BADVALUE			3
 #define SNMP_READONLY			4
 #define SNMP_GENERROR			5
 #define SNMP_NOACCESS			6
 #define SNMP_WRONGTYPE			7
 #define SNMP_WRONGLENGTH		8
 #define SNMP_WRONGENCODING		9
 #define SNMP_WRONGVALUE			10
 #define SNMP_NOCREATION			11
 #define SNMP_INCONSISTENTVALUE		12
 #define SNMP_RESOURCEUNAVAILABLE	13
 #define SNMP_COMMITFAILED		14
 #define SNMP_UNDOFAILED			15
 #define SNMP_AUTHORIZATIONERROR		16
 #define SNMP_NOTWRITABLE		17
 #define SNMP_INCONSISTENTNAME		18
 
 /* General SNMP V1 Traps */
 #define SNMP_TRAP_COLDSTART		0
 #define SNMP_TRAP_WARMSTART		1
 #define SNMP_TRAP_LINKDOWN		2
 #define SNMP_TRAP_LINKUP		3
 #define SNMP_TRAP_AUTFAILURE		4
 #define SNMP_TRAP_EQPNEIGHBORLOSS	5
 #define SNMP_TRAP_ENTSPECIFIC		6
 
 /* SNMPv1 Types */
 #define SNMP_NULL                0
 #define SNMP_INTEGER             1    /* l  */
 #define SNMP_OCTETSTR            2    /* c  */
 #define SNMP_DISPLAYSTR          2    /* c  */
 #define SNMP_OBJECTID            3    /* ul */
 #define SNMP_IPADDR              4    /* uc */
 #define SNMP_COUNTER             5    /* ul */
 #define SNMP_GAUGE               6    /* ul */
 #define SNMP_TIMETICKS           7    /* ul */
 #define SNMP_OPAQUE              8    /* c  */
 
 /* Additional SNMPv2 Types */
 #define SNMP_UINTEGER            5    /* ul */
 #define SNMP_BITSTR              9    /* uc */
 #define SNMP_NSAP               10    /* uc */
 #define SNMP_COUNTER64          11    /* ul */
 #define SNMP_NOSUCHOBJECT       12
 #define SNMP_NOSUCHINSTANCE     13
 #define SNMP_ENDOFMIBVIEW       14
 
