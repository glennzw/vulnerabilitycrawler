commit f9b664eac0e1a7bceed9d7b5854fd9fc351b4aab
Author: Dan Rosenberg <drosenberg@vsecurity.com>
Date:   Fri Jan 7 11:06:08 2011 -0500

    Fix heap overflows in CDG decoder
    
    This patch resolves two heap corruption vulnerabilities in the CDG
    decoder for VLC media player.  In both cases, a failure to properly
    validate indexes into statically-sized arrays on the heap could allow a
    maliciously crafted CDG video to corrupt the heap in a controlled
    manner, potentially leading to code execution.
    
    The patch is against v1.1.5 from vlc git, but this decoder hasn't been
    touched in awhile, so I'd expect it to cleanly apply to older versions.
    I've tested it and confirmed it resolves the heap corruption issues and
    does not break functionality.
    
    (...)
    
    Signed-off-by: RÃ©mi Denis-Courmont <remi@remlab.net>

diff --git a/modules/codec/cdg.c b/modules/codec/cdg.c
index 31ecd0e..fe7b62d 100644
--- a/modules/codec/cdg.c
+++ b/modules/codec/cdg.c
@@ -240,99 +240,105 @@ static int DecodeLoadColorTable( decoder_sys_t *p_cdg, const uint8_t *p_data, in
 static int DecodeTileBlock( decoder_sys_t *p_cdg, const uint8_t *p_data, int doXor )
 {
     int p_color[2];
     int sx, sy;
     int x, y;
 
     p_color[0] = p_data[0] & 0x0f;
     p_color[1] = p_data[1] & 0x0f;
 
     sy = (p_data[2] & 0x1f)*12;
     sx = (p_data[3] & 0x3f)*6;
 
     for( y = 0; y < 12; y++ )
     {
         for( x = 0; x < 6; x++ )
         {
             const int idx = ( p_data[4+y] >> (5-x) ) & 0x01;
-            uint8_t *p = &p_cdg->p_screen[(sy+y)*CDG_SCREEN_PITCH+(sx+x)];
+
+            int index = (sy+y)*CDG_SCREEN_PITCH+(sx+x);
+            if( index >= CDG_SCREEN_PITCH*CDG_SCREEN_HEIGHT )
+                return 0;
+
+            uint8_t *p = &p_cdg->p_screen[index];
+
             if( doXor )
                 *p ^= p_color[idx];
             else
                 *p = p_color[idx];
         }
     }
     return 0;
 }
 
 static int DecodeScroll( decoder_sys_t *p_cdg, const uint8_t *p_data, int b_copy )
 {
     uint8_t copy[CDG_SCREEN_PITCH*CDG_SCREEN_HEIGHT];
 
     uint8_t color = p_data[0]&0x0f;
     int i_shifth;
     int i_shiftv;
     int x, y;
 
     /* */
     p_cdg->i_offseth = p_data[1]&0x7;
     if( p_cdg->i_offseth >= CDG_SCREEN_BORDER_WIDTH )
         p_cdg->i_offseth = CDG_SCREEN_BORDER_WIDTH-1;
 
     p_cdg->i_offsetv = p_data[2]&0xf;
     if( p_cdg->i_offsetv >= CDG_SCREEN_BORDER_HEIGHT )
         p_cdg->i_offsetv = CDG_SCREEN_BORDER_HEIGHT-1;
 
     /* */
     switch( (p_data[1] >> 4)&0x3 )
     {
     case 0x01: i_shifth =  6; break;
     case 0x02: i_shifth = -6; break;
     default:
         i_shifth = 0;
         break;
     }
     switch( (p_data[2] >> 4)&0x3 )
     {
     case 0x01: i_shiftv = 12; break;
     case 0x02: i_shiftv =-12; break;
     default:
         i_shiftv = 0;
         break;
     }
 
     if( i_shifth == 0 && i_shiftv == 0 )
         return 0;
 
     /* Make a copy of the screen */
     memcpy( copy, p_cdg->screen, sizeof(p_cdg->screen) );
 
     /* Fill the uncovered part XXX way too much */
     ScreenFill( p_cdg, 0, 0, CDG_SCREEN_WIDTH, CDG_SCREEN_HEIGHT, color );
 
     /* Copy back */
     for( y = 0; y < CDG_SCREEN_HEIGHT; y++ )
     {
         int dy = i_shiftv + y;
         for( x = 0; x < CDG_SCREEN_WIDTH; x++ )
         {
             int dx = i_shifth + x;
 
             if( b_copy )
             {
-                dy = ( dy + CDG_SCREEN_HEIGHT ) % CDG_SCREEN_HEIGHT;
-                dy = ( dy + CDG_SCREEN_WIDTH  ) % CDG_SCREEN_WIDTH;
+                dy %= CDG_SCREEN_HEIGHT;
+                dx %= CDG_SCREEN_WIDTH;
             }
             else
             {
                 if( dy < 0 || dy >= CDG_SCREEN_HEIGHT ||
                     dx < 0 || dx >= CDG_SCREEN_WIDTH )
                     continue;
             }
             p_cdg->screen[dy*CDG_SCREEN_PITCH+dx] = copy[y*CDG_SCREEN_PITCH+x];
         }
     }
     /* */
     //CdgDebug( CDG_LOG_WARNING, "DecodeScroll: color=%d ch=%d oh=%d cv=%d ov=%d\n copy=%d\n", color, i_shifth, p_cdg->i_offseth, i_shiftv, p_cdg->i_offsetv, b_copy );
     return 0;
 }
 
