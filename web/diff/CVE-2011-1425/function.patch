commit 35eaacde6093d6711339754fc2146341b8b9f5fa
Author: Aleksey Sanin <aleksey@aleksey.com>
Date:   Tue Mar 29 18:04:53 2011 -0700

    disable xslt read/write by default and allow user to overwrite it

diff --git a/include/xmlsec/private/Makefile.am b/include/xmlsec/private/Makefile.am
index aab78c8..74de46a 100644
--- a/include/xmlsec/private/Makefile.am
+++ b/include/xmlsec/private/Makefile.am
@@ -3,6 +3,7 @@ NULL =
 xmlsecprivateincdir = $(includedir)/xmlsec1/xmlsec/private
 
 xmlsecprivateinc_HEADERS = \
+xslt.h \
 xkms.h \
 $(NULL)
 
diff --git a/include/xmlsec/private/xslt.h b/include/xmlsec/private/xslt.h
new file mode 100644
index 0000000..e9ba697
--- /dev/null
+++ b/include/xmlsec/private/xslt.h
@@ -0,0 +1,34 @@
+/**
+ * XML Security Library (http://www.aleksey.com/xmlsec).
+ *
+ * XSLT helper functions
+ *
+ * This is free software; see Copyright file in the source
+ * distribution for preciese wording.
+ *
+ * Copyright (C) 2002-2003 Aleksey Sanin <aleksey@aleksey.com>
+ */
+#ifndef __XMLSEC_PRIVATE_XSLT_H__
+#define __XMLSEC_PRIVATE_XSLT_H__
+
+#ifndef XMLSEC_PRIVATE
+#error "xmlsec/private/xslt.h file contains private xmlsec definitions and should not be used outside xmlsec or xmlsec-<crypto> libraries"
+#endif /* XMLSEC_PRIVATE */
+
+#ifndef XMLSEC_NO_XSLT
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+void xmlSecTransformXsltInitialize                          (void);
+void xmlSecTransformXsltShutdown                            (void);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* XMLSEC_NO_XSLT */
+
+#endif /* __XMLSEC_PRIVATE_XSLT_H__ */
+
diff --git a/include/xmlsec/transforms.h b/include/xmlsec/transforms.h
index f0d3d08..f0c70c9 100644
--- a/include/xmlsec/transforms.h
+++ b/include/xmlsec/transforms.h
@@ -948,22 +948,25 @@ XMLSEC_EXPORT xmlSecTransformId xmlSecTransformXPointerGetKlass         (void);
 XMLSEC_EXPORT int               xmlSecTransformXPointerSetExpr          (xmlSecTransformPtr transform,
                                                                          const xmlChar* expr,
                                                                          xmlSecNodeSetType nodeSetType,
                                                                          xmlNodePtr hereNode);
 #ifndef XMLSEC_NO_XSLT
+#include <libxslt/security.h>
+
 /**
  * xmlSecTransformXsltId:
  *
  * The XSLT transform klass.
  */
 #define xmlSecTransformXsltId \
         xmlSecTransformXsltGetKlass()
 XMLSEC_EXPORT xmlSecTransformId xmlSecTransformXsltGetKlass             (void);
+XMLSEC_EXPORT void              xmlSecTransformXsltSetDefaultSecurityPrefs(xsltSecurityPrefsPtr sec);
 #endif /* XMLSEC_NO_XSLT */
 
 /**
  * xmlSecTransformRemoveXmlTagsC14NId:
  *
  * The "remove all xml tags" transform klass (used before base64 transforms).
  */
 #define xmlSecTransformRemoveXmlTagsC14NId \
         xmlSecTransformRemoveXmlTagsC14NGetKlass()
diff --git a/src/transforms.c b/src/transforms.c
index 8ef38b5..8a2ded2 100644
--- a/src/transforms.c
+++ b/src/transforms.c
@@ -1,68 +1,70 @@
 /**
  * XML Security Library (http://www.aleksey.com/xmlsec).
  *
  * The Transforms Element (http://www.w3.org/TR/xmldsig-core/#sec-Transforms)
  *
  * The optional Transforms element contains an ordered list of Transform
  * elements; these describe how the signer obtained the data object that
  * was digested.
  *
  * Schema Definition:
  *
  *  <element name="Transforms" type="ds:TransformsType"/>
  *  <complexType name="TransformsType">
  *    <sequence>
  *      <element ref="ds:Transform" maxOccurs="unbounded"/>
  *    </sequence>
  *   </complexType>
  *
  *  <element name="Transform" type="ds:TransformType"/>
  *  <complexType name="TransformType" mixed="true">
  *    <choice minOccurs="0" maxOccurs="unbounded">
  *      <any namespace="##other" processContents="lax"/>
  *      <!-- (1,1) elements from (0,unbounded) namespaces -->
  *      <element name="XPath" type="string"/>
  *    </choice>
  *    <attribute name="Algorithm" type="anyURI" use="required"/>
  *  </complexType>
  *
  * DTD:
  *
  *  <!ELEMENT Transforms (Transform+)>
  *  <!ELEMENT Transform (#PCDATA|XPath %Transform.ANY;)* >
  *  <!ATTLIST Transform Algorithm    CDATA    #REQUIRED >
  *  <!ELEMENT XPath (#PCDATA) >
  *
  * This is free software; see Copyright file in the source
  * distribution for preciese wording.
  *
  * Copyright (C) 2002-2003 Aleksey Sanin <aleksey@aleksey.com>
  */
 
 #include "globals.h"
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
 
 #include <libxml/tree.h>
 #include <libxml/xpath.h>
 #include <libxml/xpointer.h>
 
 #include <xmlsec/xmlsec.h>
 #include <xmlsec/buffer.h>
 #include <xmlsec/xmltree.h>
 #include <xmlsec/keysdata.h>
 #include <xmlsec/keys.h>
 #include <xmlsec/keyinfo.h>
 #include <xmlsec/transforms.h>
 #include <xmlsec/base64.h>
 #include <xmlsec/io.h>
 #include <xmlsec/membuf.h>
 #include <xmlsec/parser.h>
 #include <xmlsec/errors.h>
 
+#include <xmlsec/private/xslt.h>
+
 /**************************************************************************
  *
  * Global xmlSecTransformIds list functions
  *
  *************************************************************************/
@@ -93,32 +95,36 @@ int
 xmlSecTransformIdsInit(void) {
     int ret;
 
     ret = xmlSecPtrListInitialize(xmlSecTransformIdsGet(), xmlSecTransformIdListId);
     if(ret < 0) {
         xmlSecError(XMLSEC_ERRORS_HERE,
                     NULL,
                     "xmlSecPtrListPtrInitialize",
                     XMLSEC_ERRORS_R_XMLSEC_FAILED,
                     "xmlSecTransformIdListId");
         return(-1);
     }
 
     ret = xmlSecTransformIdsRegisterDefault();
     if(ret < 0) {
         xmlSecError(XMLSEC_ERRORS_HERE,
                     NULL,
                     "xmlSecTransformIdsRegisterDefault",
                     XMLSEC_ERRORS_R_XMLSEC_FAILED,
                     XMLSEC_ERRORS_NO_MESSAGE);
         return(-1);
     }
 
+#ifndef XMLSEC_NO_XSLT
+    xmlSecTransformXsltInitialize();
+#endif /* XMLSEC_NO_XSLT */
+
     return(0);
 }
 
 /**
  * xmlSecTransformIdsShutdown:
  *
  * Shuts down the keys data klasses. This function is called from the
  * #xmlSecShutdown function and the application should not call it directly.
  */
@@ -124,14 +130,18 @@ xmlSecTransformIdsInit(void) {
  */
 void
 xmlSecTransformIdsShutdown(void) {
+#ifndef XMLSEC_NO_XSLT
+    xmlSecTransformXsltShutdown();
+#endif /* XMLSEC_NO_XSLT */
+
     xmlSecPtrListFinalize(xmlSecTransformIdsGet());
 }
 
 /**
  * xmlSecTransformIdsRegister:
  * @id:                 the transform klass.
  *
  * Registers @id in the global list of transform klasses.
  *
  * Returns: 0 on success or a negative value if an error occurs.
  */
diff --git a/src/xslt.c b/src/xslt.c
index 21b502d..b752c35 100644
--- a/src/xslt.c
+++ b/src/xslt.c
@@ -1,36 +1,37 @@
 /**
  * XML Security Library (http://www.aleksey.com/xmlsec).
  *
  * XSLT Transform (http://www.w3.org/TR/xmldsig-core/#sec-XSLT)
  *
  * This is free software; see Copyright file in the source
  * distribution for preciese wording.
  *
  * Copyright (C) 2002-2003 Aleksey Sanin <aleksey@aleksey.com>
  */
 #include "globals.h"
 
 #ifndef XMLSEC_NO_XSLT
 
 #include <stdlib.h>
 #include <string.h>
 
 #include <libxml/tree.h>
 #include <libxslt/xslt.h>
 #include <libxslt/xsltInternals.h>
 #include <libxslt/transform.h>
 #include <libxslt/xsltutils.h>
 
 #include <xmlsec/xmlsec.h>
 #include <xmlsec/xmltree.h>
 #include <xmlsec/keys.h>
 #include <xmlsec/transforms.h>
 #include <xmlsec/keys.h>
 #include <xmlsec/parser.h>
 #include <xmlsec/errors.h>
+#include <xmlsec/private/xslt.h>
 
 /**************************************************************************
  *
  * Internal xslt ctx
  *
  *****************************************************************************/
@@ -71,59 +72,104 @@ static int              xmlSecXslProcess                        (xmlSecBufferPtr
 static xmlSecTransformKlass xmlSecXsltKlass = {
     /* klass/object sizes */
     sizeof(xmlSecTransformKlass),               /* xmlSecSize klassSize */
     xmlSecXsltSize,                             /* xmlSecSize objSize */
 
     xmlSecNameXslt,                             /* const xmlChar* name; */
     xmlSecHrefXslt,                             /* const xmlChar* href; */
     xmlSecTransformUsageDSigTransform,          /* xmlSecAlgorithmUsage usage; */
 
     xmlSecXsltInitialize,                       /* xmlSecTransformInitializeMethod initialize; */
     xmlSecXsltFinalize,                         /* xmlSecTransformFinalizeMethod finalize; */
     xmlSecXsltReadNode,                         /* xmlSecTransformNodeReadMethod readNode; */
     NULL,                                       /* xmlSecTransformNodeWriteMethod writeNode; */
     NULL,                                       /* xmlSecTransformSetKeyReqMethod setKeyReq; */
     NULL,                                       /* xmlSecTransformSetKeyMethod setKey; */
     NULL,                                       /* xmlSecTransformValidateMethod validate; */
     xmlSecTransformDefaultGetDataType,          /* xmlSecTransformGetDataTypeMethod getDataType; */
     xmlSecXsltPushBin,                          /* xmlSecTransformPushBinMethod pushBin; */
     xmlSecTransformDefaultPopBin,               /* xmlSecTransformPopBinMethod popBin; */
     NULL,                                       /* xmlSecTransformPushXmlMethod pushXml; */
     NULL,                                       /* xmlSecTransformPopXmlMethod popXml; */
     xmlSecXsltExecute,                          /* xmlSecTransformExecuteMethod execute; */
 
     NULL,                                       /* void* reserved0; */
     NULL,                                       /* void* reserved1; */
 };
 
+
+#define XMLSEC_XSLT_COPY_SEC_PREF(src, dst, pref) \
+    xsltSetSecurityPrefs((dst), (pref),  xsltGetSecurityPrefs((src), (pref)))
+
+static xsltSecurityPrefsPtr g_xslt_default_security_prefs = NULL;
+
+void xmlSecTransformXsltInitialize(void) {
+    xmlSecAssert(g_xslt_default_security_prefs == NULL);
+
+    g_xslt_default_security_prefs = xsltNewSecurityPrefs();
+    xmlSecAssert(g_xslt_default_security_prefs != NULL);
+    xsltSetSecurityPrefs(g_xslt_default_security_prefs,  XSLT_SECPREF_READ_FILE,        xsltSecurityForbid);
+    xsltSetSecurityPrefs(g_xslt_default_security_prefs,  XSLT_SECPREF_WRITE_FILE,       xsltSecurityForbid);
+    xsltSetSecurityPrefs(g_xslt_default_security_prefs,  XSLT_SECPREF_CREATE_DIRECTORY, xsltSecurityForbid);
+    xsltSetSecurityPrefs(g_xslt_default_security_prefs,  XSLT_SECPREF_READ_NETWORK,     xsltSecurityForbid);
+    xsltSetSecurityPrefs(g_xslt_default_security_prefs,  XSLT_SECPREF_WRITE_NETWORK,    xsltSecurityForbid);
+}
+
+void xmlSecTransformXsltShutdown(void) {
+    if(g_xslt_default_security_prefs != NULL) {
+        xsltFreeSecurityPrefs(g_xslt_default_security_prefs);
+        g_xslt_default_security_prefs = NULL;
+    }
+}
+
+/**
+ * xmlSecTransformXsltSetDefaultSecurityPrefs:
+ * @sec: the new security preferences
+ *
+ * Sets the new default security preferences. The xmlsec default security policy is 
+ * to disable everything.
+ */
+XMLSEC_EXPORT void
+xmlSecTransformXsltSetDefaultSecurityPrefs(xsltSecurityPrefsPtr sec) {
+    xmlSecAssert(sec != NULL);
+    xmlSecAssert(g_xslt_default_security_prefs != NULL);
+    
+    /* copy prefs */
+    XMLSEC_XSLT_COPY_SEC_PREF(sec, g_xslt_default_security_prefs, XSLT_SECPREF_READ_FILE);
+    XMLSEC_XSLT_COPY_SEC_PREF(sec, g_xslt_default_security_prefs, XSLT_SECPREF_WRITE_FILE);
+    XMLSEC_XSLT_COPY_SEC_PREF(sec, g_xslt_default_security_prefs, XSLT_SECPREF_CREATE_DIRECTORY);
+    XMLSEC_XSLT_COPY_SEC_PREF(sec, g_xslt_default_security_prefs, XSLT_SECPREF_READ_NETWORK);
+    XMLSEC_XSLT_COPY_SEC_PREF(sec, g_xslt_default_security_prefs, XSLT_SECPREF_WRITE_NETWORK);
+}
+
 /**
  * xmlSecTransformXsltGetKlass:
  *
  * XSLT transform klass (http://www.w3.org/TR/xmldsig-core/#sec-XSLT):
  *
  * The normative specification for XSL Transformations is [XSLT].
  * Specification of a namespace-qualified stylesheet element, which MUST be
  * the sole child of the Transform element, indicates that the specified style
  * sheet should be used. Whether this instantiates in-line processing of local
  * XSLT declarations within the resource is determined by the XSLT processing
  * model; the ordered application of multiple stylesheet may require multiple
  * Transforms. No special provision is made for the identification of a remote
  * stylesheet at a given URI because it can be communicated via an  xsl:include
  * or  xsl:import within the stylesheet child of the Transform.
  *
  * This transform requires an octet stream as input. If the actual input is an
  * XPath node-set, then the signature application should attempt to convert it
  * to octets (apply Canonical XML]) as described in the Reference Processing
  * Model (section 4.3.3.2).]
  *
  * The output of this transform is an octet stream. The processing rules for
  * the XSL style sheet or transform element are stated in the XSLT specification
  * [XSLT]. We RECOMMEND that XSLT transform authors use an output method of xml
  * for XML and HTML. As XSLT implementations do not produce consistent
  * serializations of their output, we further RECOMMEND inserting a transform
  * after the XSLT transform to canonicalize the output. These steps will help
  * to ensure interoperability of the resulting signatures among applications
  * that support the XSLT transform. Note that if the output is actually HTML,
  * then the result of these steps is logically equivalent [XHTML].
  *
  * Returns: pointer to XSLT transform klass.
  */
@@ -135,15 +181,22 @@ xmlSecTransformXsltGetKlass(void) {
 static int
 xmlSecXsltInitialize(xmlSecTransformPtr transform) {
     xmlSecXsltCtxPtr ctx;
+    int ret;
 
     xmlSecAssert2(xmlSecTransformCheckId(transform, xmlSecTransformXsltId), -1);
     xmlSecAssert2(xmlSecTransformCheckSize(transform, xmlSecXsltSize), -1);
 
     ctx = xmlSecXsltGetCtx(transform);
     xmlSecAssert2(ctx != NULL, -1);
 
     /* initialize context */
     memset(ctx, 0, sizeof(xmlSecXsltCtx));
+    
+    /* set security prefs  */
+    ret = xsltSetCtxtSecurityPrefs(g_xslt_default_security_prefs, ctx);
+    xmlSecAssert2(ret == 0, -1);
+
+    /* done */
     return(0);
 }
 
