commit c25b9abbc2c2c0da88e180c3933d6e773245815a
Author: Roel Kluin <roel.kluin@gmail.com>
Date:   Thu Jan 29 17:32:20 2009 -0800

    drivers/net/skfp: if !capable(CAP_NET_ADMIN): inverted logic
    
    Fix inverted logic
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/skfp/skfddi.c b/drivers/net/skfp/skfddi.c
index 607efea..9a00e55 100644
--- a/drivers/net/skfp/skfddi.c
+++ b/drivers/net/skfp/skfddi.c
@@ -988,80 +988,80 @@ static int skfp_ctl_set_mac_address(struct net_device *dev, void *addr)
 static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	struct s_smc *smc = netdev_priv(dev);
 	skfddi_priv *lp = &smc->os;
 	struct s_skfp_ioctl ioc;
 	int status = 0;
 
 	if (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))
 		return -EFAULT;
 
 	switch (ioc.cmd) {
 	case SKFP_GET_STATS:	/* Get the driver statistics */
 		ioc.len = sizeof(lp->MacStat);
 		status = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)
 				? -EFAULT : 0;
 		break;
 	case SKFP_CLR_STATS:	/* Zero out the driver statistics */
 		if (!capable(CAP_NET_ADMIN)) {
-			memset(&lp->MacStat, 0, sizeof(lp->MacStat));
-		} else {
 			status = -EPERM;
+		} else {
+			memset(&lp->MacStat, 0, sizeof(lp->MacStat));
 		}
 		break;
 	default:
 		printk("ioctl for %s: unknow cmd: %04x\n", dev->name, ioc.cmd);
 		status = -EOPNOTSUPP;
 
 	}			// switch
 
 	return status;
 }				// skfp_ioctl
 
 
 /*
  * =====================
  * = skfp_send_pkt     =
  * =====================
  *   
  * Overview:
  *   Queues a packet for transmission and try to transmit it.
  *  
  * Returns:
  *   Condition code
  *       
  * Arguments:
  *   skb - pointer to sk_buff to queue for transmission
  *   dev - pointer to device information
  *
  * Functional Description:
  *   Here we assume that an incoming skb transmit request
  *   is contained in a single physically contiguous buffer
  *   in which the virtual address of the start of packet
  *   (skb->data) can be converted to a physical address
  *   by using pci_map_single().
  *
  *   We have an internal queue for packets we can not send 
  *   immediately. Packets in this queue can be given to the 
  *   adapter if transmit buffers are freed.
  *
  *   We can't free the skb until after it's been DMA'd
  *   out by the adapter, so we'll keep it in the driver and
  *   return it in mac_drv_tx_complete.
  *
  * Return Codes:
  *   0 - driver has queued and/or sent packet
  *       1 - caller should requeue the sk_buff for later transmission
  *
  * Assumptions:
  *   The entire packet is stored in one physically
  *   contiguous buffer which is not cached and whose
  *   32-bit physical address can be determined.
  *
  *   It's vital that this routine is NOT reentered for the
  *   same board and that the OS is not in another section of
  *   code (eg. skfp_interrupt) for the same board on a
  *   different thread.
  *
  * Side Effects:
  *   None
  */
