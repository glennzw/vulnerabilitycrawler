commit 9a6bce9b615abca6068348c1606ba8eaf13d9ae0
Author: Colin Walters <walters@verbum.org>
Date:   Mon Apr 19 16:47:11 2010 -0400

    Respect property access flags for writing, allow disabling for reads
    
    Because DBus-GLib originally was designed as a generic "object mapping"
    binding, the handler for org.freedesktop.DBus.Properties simply
    allowed access (read or write) to any GObject property that was
    exported.
    
    Later, the (compile time) introspection XML was added, and while we only
    listed "exported" properties in the dynamic introspection XML, we
    still allowed Get or Set calls to any property that was valid.
    
    With this patch, we deny writes to properties which aren't listed
    in the XML, or are listed as read-only.
    
    For backwards compatibility however, we still allow reads.  A
    service may disable this by calling
    dbus_glib_global_set_disable_legacy_property_access().

diff --git a/dbus/dbus-binding-tool-glib.c b/dbus/dbus-binding-tool-glib.c
index adede27..7e280f6 100644
--- a/dbus/dbus-binding-tool-glib.c
+++ b/dbus/dbus-binding-tool-glib.c
@@ -1,43 +1,47 @@
 /* -*- mode: C; c-file-style: "gnu" -*- */
 /* dbus-binding-tool-glib.c: Output C glue
  *
  * Copyright (C) 2003, 2004, 2005 Red Hat, Inc.
  * Copyright (C) 2005 Nokia
  *
  * Licensed under the Academic Free License version 2.1
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  */
 
 #include <config.h>
 #include "dbus/dbus-glib.h"
 #include "dbus-gidl.h"
 #include "dbus-gparser.h"
 #include "dbus-gutils.h"
 #include "dbus-gtype-specialized.h"
 #include "dbus-gsignature.h"
 #include "dbus-gvalue-utils.h"
 #include "dbus-glib-tool.h"
 #include "dbus-binding-tool-glib.h"
 #include <glib/gi18n.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
 
+/* Remember to grep for ->format_version in the code if you change this,
+ * most changes should be in dbus-gobject.c. */
+#define FORMAT_VERSION 1
+
 #define MARSHAL_PREFIX "dbus_glib_marshal_"
 
 typedef struct
@@ -461,292 +465,314 @@ static gboolean
 generate_glue (BaseInfo *base, DBusBindingToolCData *data, GError **error)
 {
   if (base_info_get_type (base) == INFO_TYPE_NODE)
     {
       GString *object_introspection_data_blob;
       GIOChannel *channel;
 
       channel = data->channel;
       
       object_introspection_data_blob = g_string_new_len ("", 0);
       
       data->blob = object_introspection_data_blob;
       data->count = 0;
 
       data->signal_blob = g_string_new_len ("", 0);
       data->property_blob = g_string_new_len ("", 0);
 
       if (!write_printf_to_iochannel ("static const DBusGMethodInfo dbus_glib_%s_methods[] = {\n", channel, error, data->prefix))
 	goto io_lose;
 
       if (!generate_glue_list (node_info_get_nodes ((NodeInfo *) base),
 			       data, error))
 	return FALSE;
       if (!generate_glue_list (node_info_get_interfaces ((NodeInfo *) base),
 			       data, error))
 	return FALSE;
 
       WRITE_OR_LOSE ("};\n\n");
 
       /* Information about the object. */
 
-      if (!write_printf_to_iochannel ("const DBusGObjectInfo dbus_glib_%s_object_info = {\n",
-				      channel, error, data->prefix))
-	goto io_lose;
-      WRITE_OR_LOSE ("  0,\n");
+      if (!write_printf_to_iochannel ("const DBusGObjectInfo dbus_glib_%s_object_info = {  %d,\n",
+                                  channel, error, data->prefix, FORMAT_VERSION))
+        goto io_lose;
       if (!write_printf_to_iochannel ("  dbus_glib_%s_methods,\n", channel, error, data->prefix))
 	goto io_lose;
       if (!write_printf_to_iochannel ("  %d,\n", channel, error, data->count))
 	goto io_lose;
 
       if (!write_quoted_string (channel, object_introspection_data_blob, error))
 	goto io_lose;
       WRITE_OR_LOSE (",\n");
       if (!write_quoted_string (channel, data->signal_blob, error))
 	goto io_lose;
       WRITE_OR_LOSE (",\n");
       if (!write_quoted_string (channel, data->property_blob, error))
 	goto io_lose;
       WRITE_OR_LOSE ("\n};\n\n");
 
       g_string_free (object_introspection_data_blob, TRUE);
       g_string_free (data->signal_blob, TRUE);
       g_string_free (data->property_blob, TRUE);
     }
   else
     {
       GIOChannel *channel;
       InterfaceInfo *interface;
       GSList *methods;
       GSList *signals;
       GSList *properties;
       GSList *tmp;
       const char *interface_c_name;
       GString *object_introspection_data_blob;
 
       channel = data->channel;
       object_introspection_data_blob = data->blob;
 
       interface = (InterfaceInfo *) base;
       interface_c_name = interface_info_get_annotation (interface, DBUS_GLIB_ANNOTATION_C_SYMBOL);
       if (interface_c_name == NULL)
         {
 	  if (data->prefix == NULL)
 	    return TRUE;
 	  interface_c_name = data->prefix;
         }
 
       methods = interface_info_get_methods (interface);
 
       /* Table of marshalled methods. */
 
       for (tmp = methods; tmp != NULL; tmp = g_slist_next (tmp))
         {
           MethodInfo *method;
           char *marshaller_name;
 	  char *method_c_name;
           gboolean async = FALSE;
 	  GSList *args;
 	  gboolean found_retval = FALSE;
 
           method = (MethodInfo *) tmp->data;
 	  method_c_name = g_strdup (method_info_get_annotation (method, DBUS_GLIB_ANNOTATION_C_SYMBOL));
           if (method_c_name == NULL)
 	    {
 	      char *method_name_uscored;
 	      method_name_uscored = _dbus_gutils_wincaps_to_uscore (method_info_get_name (method));
               method_c_name = g_strdup_printf ("%s_%s",
 					       interface_c_name,
 					       method_name_uscored);
 	      g_free (method_name_uscored);
             }
 
           if (!write_printf_to_iochannel ("  { (GCallback) %s, ", channel, error,
 					  method_c_name))
 	    goto io_lose;
 
           marshaller_name = compute_marshaller_name (method, data->prefix, error);
 	  if (!marshaller_name)
 	    goto io_lose;
 
           if (!write_printf_to_iochannel ("%s, %d },\n", channel, error,
 					  marshaller_name,
 					  object_introspection_data_blob->len))
 	    {
 	      g_free (marshaller_name);
 	      goto io_lose;
 	    }
 
           if (method_info_get_annotation (method, DBUS_GLIB_ANNOTATION_ASYNC) != NULL)
             async = TRUE;
 
 	  /* Object method data blob format:
 	   * <iface>\0<name>\0(<argname>\0<argdirection>\0<argtype>\0)*\0
 	   */
 
 	  g_string_append (object_introspection_data_blob, interface_info_get_name (interface));
 	  g_string_append_c (object_introspection_data_blob, '\0');
 
 	  g_string_append (object_introspection_data_blob, method_info_get_name (method));
 	  g_string_append_c (object_introspection_data_blob, '\0');
 
 	  g_string_append_c (object_introspection_data_blob, async ? 'A' : 'S');
 	  g_string_append_c (object_introspection_data_blob, '\0');
 
 	  for (args = method_info_get_args (method); args; args = args->next)
 	    {
 	      ArgInfo *arg;
 	      char direction;
 	      const char *returnval_annotation;
 
 	      arg = args->data;
 
 	      g_string_append (object_introspection_data_blob, arg_info_get_name (arg));
 	      g_string_append_c (object_introspection_data_blob, '\0');
 
 	      switch (arg_info_get_direction (arg))
 		{
 		case ARG_IN:
 		  direction = 'I';
 		  break;
 		case ARG_OUT:
 		  direction = 'O';
 		  break;
 		case ARG_INVALID:
                 default:
                   g_assert_not_reached ();
                   direction = 0; /* silence gcc */
 		  break;
 		}
 	      g_string_append_c (object_introspection_data_blob, direction);
 	      g_string_append_c (object_introspection_data_blob, '\0');
 
 	      if (arg_info_get_annotation (arg, DBUS_GLIB_ANNOTATION_CONST) != NULL)
 		{
 		  if (arg_info_get_direction (arg) == ARG_IN)
 		    {
 		      g_set_error (error,
 				   DBUS_BINDING_TOOL_ERROR,
 				   DBUS_BINDING_TOOL_ERROR_INVALID_ANNOTATION,
 				   "Input argument \"%s\" cannot have const annotation in method \"%s\" of interface \"%s\"\n",
 				   arg_info_get_name (arg),
 				   method_info_get_name (method),
 				   interface_info_get_name (interface));
 		      return FALSE;
 		    }
 		  g_string_append_c (object_introspection_data_blob, 'C');
 		  g_string_append_c (object_introspection_data_blob, '\0');
 		}
 	      else if (arg_info_get_direction (arg) == ARG_OUT)
 		{
 		  g_string_append_c (object_introspection_data_blob, 'F');
 		  g_string_append_c (object_introspection_data_blob, '\0');
 		}
 
 	      returnval_annotation = arg_info_get_annotation (arg, DBUS_GLIB_ANNOTATION_RETURNVAL);
 	      if (returnval_annotation != NULL)
 		{
 		  GType gtype;
 
 		  if (found_retval)
 		    {
 		      g_set_error (error,
 				   DBUS_BINDING_TOOL_ERROR,
 				   DBUS_BINDING_TOOL_ERROR_INVALID_ANNOTATION,
 				   "Multiple arguments with return value annotation in method \"%s\" of interface \"%s\"\n",
 				   method_info_get_name (method),
 				   interface_info_get_name (interface));
 		      return FALSE;
 		    }
 		  found_retval = TRUE;
 		  if (arg_info_get_direction (arg) == ARG_IN)
 		    {
 		      g_set_error (error,
 				   DBUS_BINDING_TOOL_ERROR,
 				   DBUS_BINDING_TOOL_ERROR_INVALID_ANNOTATION,
 				   "Input argument \"%s\" cannot have return value annotation in method \"%s\" of interface \"%s\"\n",
 				   arg_info_get_name (arg),
 				   method_info_get_name (method),
 				   interface_info_get_name (interface));
 		      return FALSE;
 		    }
 		  if (!strcmp ("", returnval_annotation))
 		    g_string_append_c (object_introspection_data_blob, 'R');
 		  else if (!strcmp ("error", returnval_annotation))
 		    {
 		      gtype = _dbus_gtype_from_signature (arg_info_get_type (arg), TRUE);
 		      if (!_dbus_gtype_can_signal_error (gtype))
 			{
 			  g_set_error (error,
 				       DBUS_BINDING_TOOL_ERROR,
 				       DBUS_BINDING_TOOL_ERROR_INVALID_ANNOTATION,
 				       "Output argument \"%s\" cannot signal error with type \"%s\" in method \"%s\" of interface \"%s\"\n",
 				       arg_info_get_name (arg),
 				       g_type_name (gtype),
 				       method_info_get_name (method),
 				       interface_info_get_name (interface));
 			  return FALSE;
 			}
 		      g_string_append_c (object_introspection_data_blob, 'E');
 		    }
 		  else
 		    {
 		      g_set_error (error,
 				   DBUS_BINDING_TOOL_ERROR,
 				   DBUS_BINDING_TOOL_ERROR_INVALID_ANNOTATION,
 				   "Invalid ReturnVal annotation for argument \"%s\" in method \"%s\" of interface \"%s\"\n",
 				   arg_info_get_name (arg),
 				   method_info_get_name (method),
 				   interface_info_get_name (interface));
 		      return FALSE;
 		    }
 		      
 		  g_string_append_c (object_introspection_data_blob, '\0');
 		}
 	      else if (arg_info_get_direction (arg) == ARG_OUT)
 		{
 		  g_string_append_c (object_introspection_data_blob, 'N');
 		  g_string_append_c (object_introspection_data_blob, '\0');
 		}
 
 	      g_string_append (object_introspection_data_blob, arg_info_get_type (arg));
 	      g_string_append_c (object_introspection_data_blob, '\0');
 	    }
 
 	  g_string_append_c (object_introspection_data_blob, '\0');
 
           data->count++;
         }
 
       signals = interface_info_get_signals (interface);
 
       for (tmp = signals; tmp != NULL; tmp = g_slist_next (tmp))
         {
           SignalInfo *sig;
 	  
 	  sig = tmp->data;
 
 	  g_string_append (data->signal_blob, interface_info_get_name (interface));
 	  g_string_append_c (data->signal_blob, '\0');
 	  g_string_append (data->signal_blob, signal_info_get_name (sig));
 	  g_string_append_c (data->signal_blob, '\0');
 	}
 
       properties = interface_info_get_properties (interface);
 
       for (tmp = properties; tmp != NULL; tmp = g_slist_next (tmp))
         {
           PropertyInfo *prop;
-	  
-	  prop = tmp->data;
-
-	  g_string_append (data->property_blob, interface_info_get_name (interface));
-	  g_string_append_c (data->property_blob, '\0');
-	  g_string_append (data->property_blob, property_info_get_name (prop));
-	  g_string_append_c (data->property_blob, '\0');
+          PropertyAccessFlags access_flags;
+          const char *access_string;
+          char *uscored;
+
+          prop = tmp->data;
+
+          access_flags = property_info_get_access (prop);
+          if ((access_flags & PROPERTY_READ) && (access_flags & PROPERTY_WRITE))
+            access_string = "readwrite";
+          else if (access_flags & PROPERTY_READ)
+            access_string = "read";
+          else if (access_flags & PROPERTY_WRITE)
+            access_string = "write";
+          else
+            continue;
+
+          /* We append both in the blob so we have to malloc() less when processing
+           * properties */
+          uscored = _dbus_gutils_wincaps_to_uscore (property_info_get_name (prop));
+
+          g_string_append (data->property_blob, interface_info_get_name (interface));
+          g_string_append_c (data->property_blob, '\0');
+          g_string_append (data->property_blob, property_info_get_name (prop));
+          g_string_append_c (data->property_blob, '\0');
+          g_string_append (data->property_blob, uscored);
+          g_string_append_c (data->property_blob, '\0');
+          g_string_append (data->property_blob, access_string);
+          g_string_append_c (data->property_blob, '\0');
+
+          g_free (uscored);
 	}
     }
   return TRUE;
  io_lose:
   return FALSE;
 }
 
diff --git a/dbus/dbus-glib.h b/dbus/dbus-glib.h
index 664e89f..a3a3597 100644
--- a/dbus/dbus-glib.h
+++ b/dbus/dbus-glib.h
@@ -150,6 +150,8 @@ struct _DBusGObjectInfo
   const char *exported_properties; 
 };
 
+void       dbus_glib_global_set_disable_legacy_property_access (void);
+
 void       dbus_g_object_type_install_info     (GType                 object_type,
                                                 const DBusGObjectInfo *info);
 
diff --git a/dbus/dbus-gobject.c b/dbus/dbus-gobject.c
index ec93ad4..1755f2c 100644
--- a/dbus/dbus-gobject.c
+++ b/dbus/dbus-gobject.c
@@ -42,9 +42,28 @@ typedef struct
 } DBusGErrorInfo;
 
 static GStaticRWLock globals_lock = G_STATIC_RW_LOCK_INIT;
+/* See comments in check_property_access */
+static gboolean disable_legacy_property_access = FALSE;
 static GHashTable *marshal_table = NULL;
 static GData *error_metadata = NULL;
 
+/* Ugly yes - but we have to accept strings from both formats */
+static gboolean
+compare_strings_ignoring_uscore_vs_dash (const char *a, const char *b)
+{
+  guint i;
+
+  for (i = 0; a[i] && b[i]; i++)
+    {
+      if ((a[i] == '-' && b[i] == '_')
+          || (a[i] == '_' && b[i] == '-'))
+        continue;
+      if (a[i] != b[i])
+        return FALSE;
+    }
+  return (a[i] == '\0') && (b[i] == '\0');
+}
+
 static char*
 uscore_to_wincaps (const char *uscore)
 {
@@ -270,16 +289,118 @@ method_output_signature_from_object_info (const DBusGObjectInfo *object,
 }
 
 static const char *
-propsig_iterate (const char *data, const char **iface, const char **name)
+signal_iterate (const char *data, const char **iface, const char **name)
 {
   *iface = data;
 
   data = string_table_next (data);
   *name = data;
 
   return string_table_next (data);
 }
 
+static const char *
+property_iterate (const char  *data,
+                  int          format_version,
+                  const char **iface,
+                  const char **exported_name,
+                  const char **name_uscored,
+                  const char **access_type)
+{
+  *iface = data;
+
+  data = string_table_next (data);
+  *exported_name = data;
+
+  data = string_table_next (data);
+  if (format_version == 1)
+    {
+      *name_uscored = data;
+      data = string_table_next (data);
+      *access_type = data;
+      return string_table_next (data);
+    }
+  else
+    {
+      /* This tells the caller they need to compute it */
+      *name_uscored = NULL;
+      /* We don't know here, however note that we will still check against the
+       * readable/writable flags from GObject's metadata.
+       */
+      *access_type = "readwrite";
+      return data;
+    }
+}
+
+/**
+ * property_info_from_object_info:
+ * @object: introspection data
+ * @interface_name: (allow-none): Expected interface name, or %NULL for any
+ * @property_name: Expected property name (can use "-" or "_" as separator)
+ * @access_type: (out): Can be one of "read", "write", "readwrite"
+ *
+ * Look up property introspection data for the given interface/name pair.
+ *
+ * Returns: %TRUE if property was found
+ */
+static gboolean
+property_info_from_object_info (const DBusGObjectInfo  *object,
+                                const char             *interface_name,
+                                const char             *property_name,
+                                const char            **access_type)
+{
+  const char *properties_iter;
+
+  properties_iter = object->exported_properties;
+  while (properties_iter != NULL && *properties_iter)
+    {
+      const char *cur_interface_name;
+      const char *cur_property_name;
+      const char *cur_uscore_property_name;
+      const char *cur_access_type;
+
+
+      properties_iter = property_iterate (properties_iter, object->format_version,
+                                          &cur_interface_name, &cur_property_name,
+                                          &cur_uscore_property_name, &cur_access_type);
+
+      if (interface_name && strcmp (interface_name, cur_interface_name) != 0)
+        continue;
+
+      /* This big pile of ugly is necessary to support the matrix resulting from multiplying
+       * (v0 data, v1 data) * (FooBar, foo-bar)
+       * In v1 data we have both forms of string, so we do a comparison against both without
+       * having to malloc.
+       * For v0 data, we need to reconstruct the foo-bar form.
+       *
+       * Adding to the complexity is that we *also* have to ignore the distinction between
+       * '-' and '_', because g_object_{get,set} does.
+       */
+      /* First, compare against the primary property name - no malloc required */
+      if (!compare_strings_ignoring_uscore_vs_dash (property_name, cur_property_name))
+        {
+          if (cur_uscore_property_name != NULL
+              && !compare_strings_ignoring_uscore_vs_dash (property_name, cur_uscore_property_name))
+            continue;
+          else
+            {
+              /* v0 metadata, construct uscore */
+              char *tmp_uscored;
+              gboolean matches;
+              tmp_uscored = _dbus_gutils_wincaps_to_uscore (cur_property_name);
+              matches = compare_strings_ignoring_uscore_vs_dash (property_name, tmp_uscored);
+              g_free (tmp_uscored);
+              if (!matches)
+                continue;
+            }
+        }
+
+      *access_type = cur_access_type;
+      return TRUE;
+    }
+  return FALSE;
+}
+
 static GQuark
 dbus_g_object_type_dbus_metadata_quark (void)
 {
@@ -290,39 +411,117 @@ dbus_g_object_type_dbus_metadata_quark (void)
   return quark;
 }
 
-static GList *
-lookup_object_info (GObject *object)
+/* Iterator function should return FALSE to stop iteration, TRUE to continue */
+typedef gboolean (*ForeachObjectInfoFn) (const DBusGObjectInfo *info,
+                                         GType                 gtype,
+                                         gpointer              user_data);
+
+static void
+foreach_object_info (GObject *object,
+		     ForeachObjectInfoFn callback,
+		     gpointer user_data)
 {
   GType *interfaces, *p;
-  GList *info_list = NULL;
   const DBusGObjectInfo *info;
   GType classtype;
 
   interfaces = g_type_interfaces (G_TYPE_FROM_INSTANCE (object), NULL);
 
   for (p = interfaces; *p != 0; p++)
     {
       info = g_type_get_qdata (*p, dbus_g_object_type_dbus_metadata_quark ());
       if (info != NULL && info->format_version >= 0)
-          info_list = g_list_prepend (info_list, (gpointer) info);
+        {
+	  if (!callback (info, *p, user_data))
+	    break;
+	}
     }
 
   g_free (interfaces);
 
   for (classtype = G_TYPE_FROM_INSTANCE (object); classtype != 0; classtype = g_type_parent (classtype))
     {
       info = g_type_get_qdata (classtype, dbus_g_object_type_dbus_metadata_quark ());
       if (info != NULL && info->format_version >= 0)
-          info_list = g_list_prepend (info_list, (gpointer) info);
+	{
+	  if (!callback (info, classtype, user_data))
+	    break;
+	}
     }
 
-  /* if needed only:
-  return g_list_reverse (info_list);
-  */
-  
+}
+
+static gboolean
+lookup_object_info_cb (const DBusGObjectInfo *info,
+                       GType gtype,
+		       gpointer user_data)
+{
+  GList **list = (GList **) user_data;
+
+  *list = g_list_prepend (*list, (gpointer) info);
+  return TRUE;
+}
+
+static GList *
+lookup_object_info (GObject *object)
+{
+  GList *info_list = NULL;
+
+  foreach_object_info (object, lookup_object_info_cb, &info_list);
+
   return info_list;
 }
 
+typedef struct {
+  const char *iface;
+  const DBusGObjectInfo *info;
+  gboolean fallback;
+  GType iface_type;
+} LookupObjectInfoByIfaceData;
+
+static gboolean
+lookup_object_info_by_iface_cb (const DBusGObjectInfo *info,
+				GType gtype,
+				gpointer user_data)
+{
+  LookupObjectInfoByIfaceData *lookup_data = (LookupObjectInfoByIfaceData *) user_data;
+
+  /* If interface is not specified, choose the first info */
+  if (lookup_data->fallback && (!lookup_data->iface || strlen (lookup_data->iface) == 0))
+    {
+      lookup_data->info = info;
+      lookup_data->iface_type = gtype;
+    }
+  else if (info->exported_properties && !strcmp (info->exported_properties, lookup_data->iface))
+    {
+      lookup_data->info = info;
+      lookup_data->iface_type = gtype;
+    }
+
+  return !lookup_data->info;
+}
+
+static const DBusGObjectInfo *
+lookup_object_info_by_iface (GObject     *object,
+			     const char  *iface,
+			     gboolean     fallback,
+			     GType       *out_iface_type)
+{
+  LookupObjectInfoByIfaceData data;
+
+  data.iface = iface;
+  data.info = NULL;
+  data.fallback = fallback;
+  data.iface_type = 0;
+
+  foreach_object_info (object, lookup_object_info_by_iface_cb, &data);
+
+  if (out_iface_type && data.info)
+    *out_iface_type = data.iface_type;
+
+  return data.info;
+}
+
 static void
 gobject_unregister_function (DBusConnection  *connection,
                              void            *user_data)
@@ -353,147 +552,156 @@ static void
 write_interface (gpointer key, gpointer val, gpointer user_data)
 {
   const char *name;
   GSList *methods;
   GSList *signals;
   GSList *properties;
   GString *xml;
   const DBusGObjectInfo *object_info;
   DBusGLibWriteIterfaceData *data;
   DBusGLibWriteInterfaceValues *values;
 
   name = key;
 
   values = val;
   methods = values->methods;
   signals = values->signals;
   properties = values->properties;
 
   data = user_data;
   xml = data->xml;
   object_info = data->object_info;
 
   g_string_append_printf (xml, "  <interface name=\"%s\">\n", name);
 
   /* FIXME: recurse to parent types ? */
   for (; methods; methods = methods->next)
     {
       DBusGMethodInfo *method;
       const char *args;
       method = methods->data;
 
       g_string_append_printf (xml, "    <method name=\"%s\">\n",
 			      method_name_from_object_info (object_info, method));
 
       args = method_arg_info_from_object_info (object_info, method);
 
       while (*args)
 	{
 	  const char *name;
 	  gboolean arg_in;
 	  const char *type;
 	  
 	  args = arg_iterate (args, &name, &arg_in, NULL, NULL, &type);
 
 	  /* FIXME - handle container types */
 	  g_string_append_printf (xml, "      <arg name=\"%s\" type=\"%s\" direction=\"%s\"/>\n",
 				  name, type, arg_in ? "in" : "out");
 
 	}
       g_string_append (xml, "    </method>\n");
 
     }
   g_slist_free (values->methods);
 
   for (; signals; signals = signals->next)
     {
       guint id;
       guint arg;
       const char *signame;
       GSignalQuery query;
       char *s;
 
       signame = signals->data;
 
       s = _dbus_gutils_wincaps_to_uscore (signame);
       
       id = g_signal_lookup (s, data->gtype);
       g_assert (id != 0);
 
       g_signal_query (id, &query);
       g_assert (query.return_type == G_TYPE_NONE);
 
       g_string_append_printf (xml, "    <signal name=\"%s\">\n", signame);
 
       for (arg = 0; arg < query.n_params; arg++)
 	{
 	  char *dbus_type = _dbus_gtype_to_signature (query.param_types[arg]);
 
 	  g_assert (dbus_type != NULL);
 
           g_string_append (xml, "      <arg type=\"");
           g_string_append (xml, dbus_type);
           g_string_append (xml, "\"/>\n");
 	  g_free (dbus_type);
 	}
 
       g_string_append (xml, "    </signal>\n");
       g_free (s);
     }
   g_slist_free (values->signals);
 
   for (; properties; properties = properties->next)
     {
+      const char *iface;
       const char *propname;
+      const char *propname_uscore;
+      const char *access_type;
       GParamSpec *spec;
       char *dbus_type;
       gboolean can_set;
       gboolean can_get;
       char *s;
 
-      propname = properties->data;
       spec = NULL;
 
-      s = _dbus_gutils_wincaps_to_uscore (propname);
+      property_iterate (properties->data, object_info->format_version, &iface, &propname, &propname_uscore, &access_type);
 
-      spec = g_object_class_find_property (g_type_class_peek (data->gtype), s);
+      if (!propname_uscore)
+        {
+          char *s = _dbus_gutils_wincaps_to_uscore (propname);
+          spec = g_object_class_find_property (g_type_class_peek (data->gtype), s);
+          g_free (s);
+        }
+      else
+        {
+          spec =  g_object_class_find_property (g_type_class_peek (data->gtype), propname_uscore);
+        }
       g_assert (spec != NULL);
-      g_free (s);
-      
+
       dbus_type = _dbus_gtype_to_signature (G_PARAM_SPEC_VALUE_TYPE (spec));
       g_assert (dbus_type != NULL);
-      
-      can_set = ((spec->flags & G_PARAM_WRITABLE) != 0 &&
-		 (spec->flags & G_PARAM_CONSTRUCT_ONLY) == 0);
-      
+
+      can_set = strcmp (access_type, "readwrite") == 0
+                    && ((spec->flags & G_PARAM_WRITABLE) != 0
+                    && (spec->flags & G_PARAM_CONSTRUCT_ONLY) == 0);
+
       can_get = (spec->flags & G_PARAM_READABLE) != 0;
-      
+
       if (can_set || can_get)
 	{
 	  g_string_append_printf (xml, "    <property name=\"%s\" ", propname);
 	  g_string_append (xml, "type=\"");
 	  g_string_append (xml, dbus_type);
 	  g_string_append (xml, "\" access=\"");
 
 	  if (can_set && can_get)
 	    g_string_append (xml, "readwrite");
 	  else if (can_get)
 	    g_string_append (xml, "read");
 	  else
 	    {
 	      g_assert (can_set);
 	      g_string_append (xml, "write");
 	    }
           
 	  g_string_append (xml, "\"/>\n");
 	}
-      
-      g_free (dbus_type);
 
-      g_string_append (xml, "    </property>\n");
+      g_free (dbus_type);
     }
   g_slist_free (values->properties);
 
   g_free (values);
   g_string_append (xml, "  </interface>\n");
 }
 
@@ -513,76 +721,78 @@ static void
 introspect_interfaces (GObject *object, GString *xml)
 {
   GList *info_list;
   const GList *info_list_walk;
   const DBusGObjectInfo *info;
   DBusGLibWriteIterfaceData data;
   int i;
   GHashTable *interfaces;
   DBusGLibWriteInterfaceValues *values;
   const char *propsig;
 
   info_list = lookup_object_info (object);
 
   g_assert (info_list != NULL);
 
   /* Gather a list of all interfaces, indexed into their methods */
   for (info_list_walk = info_list; info_list_walk != NULL; info_list_walk = g_list_next (info_list_walk))
     {
       info = (DBusGObjectInfo *) info_list_walk->data;
       interfaces = g_hash_table_new (g_str_hash, g_str_equal);
       
       g_assert (info != NULL);
 
       for (i = 0; i < info->n_method_infos; i++)
         {
           const char *method_name;
           const char *method_interface;
           const char *method_args;
           const DBusGMethodInfo *method;
 
           method = &(info->method_infos[i]);
 
           method_interface = method_interface_from_object_info (info, method);
           method_name = method_name_from_object_info (info, method);
           method_args = method_arg_info_from_object_info (info, method);
 
           values = lookup_values (interfaces, method_interface);
           values->methods = g_slist_prepend (values->methods, (gpointer) method);
         }
 
       propsig = info->exported_signals;
       while (*propsig)
         {
           const char *iface;
           const char *signame;
 
-          propsig = propsig_iterate (propsig, &iface, &signame);
+          propsig = signal_iterate (propsig, &iface, &signame);
 
           values = lookup_values (interfaces, iface);
           values->signals = g_slist_prepend (values->signals, (gpointer) signame);
         }
 
       propsig = info->exported_properties;
       while (*propsig)
         {
           const char *iface;
           const char *propname;
+          const char *propname_uscore;
+          const char *access_type;
 
-          propsig = propsig_iterate (propsig, &iface, &propname);
+          propsig = property_iterate (propsig, info->format_version, &iface, &propname, &propname_uscore, &access_type);
 
           values = lookup_values (interfaces, iface);
-          values->properties = g_slist_prepend (values->properties, (gpointer) propname);
+          values->properties = g_slist_prepend (values->properties, (gpointer)iface);
         }
-      
+
       memset (&data, 0, sizeof (data));
       data.xml = xml;
       data.gtype = G_TYPE_FROM_INSTANCE (object);
       data.object_info = info;
 
       g_hash_table_foreach (interfaces, write_interface, &data);
       g_hash_table_destroy (interfaces);
     }
 
   g_list_free (info_list);
 }
 
@@ -1271,115 +1481,189 @@ invoke_object_method (GObject         *object,
   goto done;
 }
 
+static gboolean
+check_property_access (DBusConnection  *connection,
+                       DBusMessage     *message,
+                       GObject         *object,
+                       const char      *wincaps_propiface,
+                       const char      *requested_propname,
+                       const char      *uscore_propname,
+                       gboolean         is_set)
+{
+  const DBusGObjectInfo *object_info;
+  const char *access_type;
+  DBusMessage *ret;
+
+  if (!is_set && !disable_legacy_property_access)
+    return TRUE;
+
+  object_info = lookup_object_info_by_iface (object, wincaps_propiface, TRUE, NULL);
+  if (!object_info)
+    {
+      ret = dbus_message_new_error_printf (message,
+                                           DBUS_ERROR_ACCESS_DENIED,
+                                           "Interface \"%s\" isn't exported (or may not exist), can't access property \"%s\"",
+                                           wincaps_propiface,
+                                           requested_propname);
+      dbus_connection_send (connection, ret, NULL);
+      dbus_message_unref (ret);
+      return FALSE;
+    }
+
+  /* Try both forms of property names: "foo_bar" or "FooBar"; for historical
+   * reasons we accept both.
+   */
+  if (object_info
+      && !(property_info_from_object_info (object_info, wincaps_propiface, requested_propname, &access_type)
+           || property_info_from_object_info (object_info, wincaps_propiface, uscore_propname, &access_type)))
+    {
+      ret = dbus_message_new_error_printf (message,
+                                           DBUS_ERROR_ACCESS_DENIED,
+                                           "Property \"%s\" of interface \"%s\" isn't exported (or may not exist)",
+                                           requested_propname,
+                                           wincaps_propiface);
+      dbus_connection_send (connection, ret, NULL);
+      dbus_message_unref (ret);
+      return FALSE;
+    }
+
+  if (strcmp (access_type, "readwrite") == 0)
+    return TRUE;
+  else if (is_set ? strcmp (access_type, "read") == 0
+             : strcmp (access_type, "write") == 0)
+    {
+       ret = dbus_message_new_error_printf (message,
+                                           DBUS_ERROR_ACCESS_DENIED,
+                                           "Property \"%s\" of interface \"%s\" is not %s",
+                                           requested_propname,
+                                           wincaps_propiface,
+                                           is_set ? "settable" : "readable");
+      dbus_connection_send (connection, ret, NULL);
+      dbus_message_unref (ret);
+      return FALSE;
+    }
+  return TRUE;
+}
+
 static DBusHandlerResult
 gobject_message_function (DBusConnection  *connection,
                           DBusMessage     *message,
                           void            *user_data)
 {
   GParamSpec *pspec;
   GObject *object;
   gboolean setter;
   gboolean getter;
   char *s;
-  const char *wincaps_propname;
-  /* const char *wincaps_propiface; */
+  const char *requested_propname;
+  const char *wincaps_propiface;
   DBusMessageIter iter;
   const DBusGMethodInfo *method;
   const DBusGObjectInfo *object_info;
 
   object = G_OBJECT (user_data);
 
   if (dbus_message_is_method_call (message,
                                    DBUS_INTERFACE_INTROSPECTABLE,
                                    "Introspect"))
     return handle_introspect (connection, message, object);
   
   /* Try the metainfo, which lets us invoke methods */
   if (lookup_object_and_method (object, message, &object_info, &method))
     return invoke_object_method (object, object_info, method, connection, message);
 
   /* If no metainfo, we can still do properties and signals
-   * via standard GLib introspection
+   * via standard GLib introspection.  Note we do now check
+   * property access against the metainfo if available.
    */
   getter = FALSE;
   setter = FALSE;
   if (dbus_message_is_method_call (message,
                                    DBUS_INTERFACE_PROPERTIES,
                                    "Get"))
     getter = TRUE;
   else if (dbus_message_is_method_call (message,
                                         DBUS_INTERFACE_PROPERTIES,
                                         "Set"))
     setter = TRUE;
 
   if (!(setter || getter))
     return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 
   dbus_message_iter_init (message, &iter);
 
   if (dbus_message_iter_get_arg_type (&iter) != DBUS_TYPE_STRING)
     {
       g_warning ("Property get or set does not have an interface string as first arg\n");
       return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
     }
-  /* We never use the interface name; if we did, we'd need to
-   * remember that it can be empty string for "pick one for me"
-   */
-  /* dbus_message_iter_get_basic (&iter, &wincaps_propiface); */
+
+  dbus_message_iter_get_basic (&iter, &wincaps_propiface);
   dbus_message_iter_next (&iter);
 
   if (dbus_message_iter_get_arg_type (&iter) != DBUS_TYPE_STRING)
     {
       g_warning ("Property get or set does not have a property name string as second arg\n");
       return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
     }
-  dbus_message_iter_get_basic (&iter, &wincaps_propname);
+
+  dbus_message_iter_get_basic (&iter, &requested_propname);
   dbus_message_iter_next (&iter);
-  
-  s = _dbus_gutils_wincaps_to_uscore (wincaps_propname);
 
-  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (object),
-                                        s);
+  s = _dbus_gutils_wincaps_to_uscore (requested_propname);
+
+  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (object), s);
+
+  if (!check_property_access (connection, message, object, wincaps_propiface, requested_propname, s, setter))
+    {
+      g_free (s);
+      return DBUS_HANDLER_RESULT_HANDLED;
+    }
 
   g_free (s);
 
   if (pspec != NULL)
     {
       DBusMessage *ret;
 
       if (setter)
         {
           if (dbus_message_iter_get_arg_type (&iter) != DBUS_TYPE_VARIANT)
             {
               g_warning ("Property set does not have a variant value as third arg\n");
               return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
             }
           
           ret = set_object_property (connection, message, &iter,
                                      object, pspec);
           dbus_message_iter_next (&iter);
         }
       else if (getter)
         {
           ret = get_object_property (connection, message,
                                      object, pspec);
         }
-      else
-        {
-          g_assert_not_reached ();
-          ret = NULL;
-        }
 
       g_assert (ret != NULL);
 
       if (dbus_message_iter_get_arg_type (&iter) != DBUS_TYPE_INVALID)
         g_warning ("Property get or set had too many arguments\n");
 
       dbus_connection_send (connection, ret, NULL);
       dbus_message_unref (ret);
       return DBUS_HANDLER_RESULT_HANDLED;
     }
+  else
+    {
+      DBusMessage *ret;
+
+      ret = dbus_message_new_error_printf (message,
+                                           DBUS_ERROR_INVALID_ARGS,
+                                           "No such property %s", requested_propname);
+      dbus_connection_send (connection, ret, NULL);
+      dbus_message_unref (ret);
+    }
 
   return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 }
 
@@ -1477,62 +1761,62 @@ static void
 export_signals (DBusGConnection *connection, const GList *info_list, GObject *object)
 {
   GType gtype;
   const char *sigdata;
   const char *iface;
   const char *signame;
   const DBusGObjectInfo *info;
 
   gtype = G_TYPE_FROM_INSTANCE (object);
 
   for (; info_list != NULL; info_list = g_list_next (info_list))
     {
       info = (DBusGObjectInfo *) info_list->data;
       
       sigdata = info->exported_signals;
       
       while (*sigdata != '\0')
         {
           guint id;
           GSignalQuery query;
           GClosure *closure;
           char *s;
 
-          sigdata = propsig_iterate (sigdata, &iface, &signame);
-          
+          sigdata = signal_iterate (sigdata, &iface, &signame);
+
           s = _dbus_gutils_wincaps_to_uscore (signame);
 
           id = g_signal_lookup (s, gtype);
           if (id == 0)
             {
               g_warning ("signal \"%s\" (from \"%s\") exported but not found in object class \"%s\"",
                      s, signame, g_type_name (gtype));
               g_free (s);
               continue;
             }
 
           g_signal_query (id, &query);
 
           if (query.return_type != G_TYPE_NONE)
             {
               g_warning ("Not exporting signal \"%s\" for object class \"%s\" as it has a return type \"%s\"",
                      s, g_type_name (gtype), g_type_name (query.return_type));
               g_free (s);
               continue; /* FIXME: these could be listed as methods ? */
             }
           
           closure = dbus_g_signal_closure_new (connection, object, signame, (char*) iface);
           g_closure_set_marshal (closure, signal_emitter_marshaller);
 
           g_signal_connect_closure_by_id (object,
                           id,
                           0,
                           closure,
                           FALSE);
 
           g_closure_add_finalize_notifier (closure, NULL,
                            dbus_g_signal_closure_finalize);
           g_free (s);
         }
     }
 }
 
@@ -1640,34 +1924,60 @@ static void
 dbus_g_error_info_free (gpointer p)
 {
   DBusGErrorInfo *info;
 
   info = p;
 
   g_free (info->default_iface);
   g_free (info);
 }
 
 /**
  * SECTION:dbus-gobject
  * @short_description: Exporting a #GObject remotely
  * @see_also: #GObject
  * @stability: Stable
  *
  * FIXME
  */
 
 /**
+ * dbus_glib_global_set_disable_legacy_property_access:
+ *
+ * Historically, DBus-GLib allowed read/write access to any property
+ * regardless of the access flags specified in the introspection XML,
+ * and regardless of the DBus interface given.
+ * 
+ * As of version 0.88, DBus-GLib by default allows read-only access to
+ * every GObject property of an object exported to the bus, regardless
+ * of whether or not the property is listed in the type info installed
+ * with dbus_g_object_type_install_info() and regardless of whether
+ * the correct interface is specified.  Write access is denied.
+ *
+ * After calling this method, it will be required that the property is
+ * exported on the given interface, and even read-only access will be
+ * checked.  This method changes behavior globally for the entire
+ * process.
+ *
+ * Since: 0.88
+ */
+void
+dbus_glib_global_set_disable_legacy_property_access (void)
+{
+  disable_legacy_property_access = TRUE;
+}
+
+/**
  * dbus_g_object_type_install_info:
  * @object_type: #GType for the object
  * @info: introspection data generated by #dbus-glib-tool
  *
  * Install introspection information about the given object #GType
  * sufficient to allow methods on the object to be invoked by name.
  * The introspection information is normally generated by
  * dbus-glib-tool, then this function is called in the
  * class_init() for the object class.
  *
  * Once introspection information has been installed, instances of the
  * object registered with #dbus_g_connection_register_g_object() can have
  * their methods invoked remotely.
  */
@@ -2219,147 +2529,147 @@ gboolean
 _dbus_gobject_test (const char *test_data_dir)
 {
   int i;
   const char *arg;
   const char *arg_name;
   gboolean arg_in;
   gboolean constval;
   RetvalType retval;
   const char *arg_signature;
   const char *sigdata;
   const char *iface;
   const char *signame;
   
   static struct { const char *wincaps; const char *uscore; } name_pairs[] = {
     { "SetFoo", "set_foo" },
     { "Foo", "foo" },
     { "GetFooBar", "get_foo_bar" },
     { "Hello", "hello" }
     
     /* Impossible-to-handle cases */
     /* { "FrobateUIHandler", "frobate_ui_handler" } */
   };
 
   /* Test lookup in our hardcoded object info; if these tests fail
    * then it likely means you changed the generated object info in an
    * incompatible way and broke the lookup functions.  In that case
    * you need to bump the version and use a new structure instead. */
   /* DoNothing */
   arg = method_arg_info_from_object_info (&dbus_glib_internal_test_object_info,
 					  &(dbus_glib_internal_test_methods[0]));
   g_assert (*arg == '\0');
 
   /* Increment */
   arg = method_arg_info_from_object_info (&dbus_glib_internal_test_object_info,
 					  &(dbus_glib_internal_test_methods[1]));
   g_assert (*arg != '\0');
   arg = arg_iterate (arg, &arg_name, &arg_in, &constval, &retval, &arg_signature);
   g_assert (!strcmp (arg_name, "x"));
   g_assert (arg_in == TRUE);
   g_assert (!strcmp (arg_signature, "u"));
   g_assert (*arg != '\0');
   arg = arg_iterate (arg, &arg_name, &arg_in, &constval, &retval, &arg_signature);
   g_assert (arg_in == FALSE);
   g_assert (retval == RETVAL_NONE);
   g_assert (!strcmp (arg_signature, "u"));
   g_assert (*arg == '\0');
 
   /* IncrementRetval */
   arg = method_arg_info_from_object_info (&dbus_glib_internal_test_object_info,
 					  &(dbus_glib_internal_test_methods[2]));
   g_assert (*arg != '\0');
   arg = arg_iterate (arg, &arg_name, &arg_in, &constval, &retval, &arg_signature);
   g_assert (!strcmp (arg_name, "x"));
   g_assert (arg_in == TRUE);
   g_assert (!strcmp (arg_signature, "u"));
   g_assert (*arg != '\0');
   arg = arg_iterate (arg, &arg_name, &arg_in, &constval, &retval, &arg_signature);
   g_assert (retval == RETVAL_NOERROR);
   g_assert (arg_in == FALSE);
   g_assert (!strcmp (arg_signature, "u"));
   g_assert (*arg == '\0');
 
   /* IncrementRetvalError */
   arg = method_arg_info_from_object_info (&dbus_glib_internal_test_object_info,
 					  &(dbus_glib_internal_test_methods[3]));
   g_assert (*arg != '\0');
   arg = arg_iterate (arg, &arg_name, &arg_in, &constval, &retval, &arg_signature);
   g_assert (!strcmp (arg_name, "x"));
   g_assert (arg_in == TRUE);
   g_assert (!strcmp (arg_signature, "u"));
   g_assert (*arg != '\0');
   arg = arg_iterate (arg, &arg_name, &arg_in, &constval, &retval, &arg_signature);
   g_assert (retval == RETVAL_ERROR);
   g_assert (arg_in == FALSE);
   g_assert (!strcmp (arg_signature, "u"));
   g_assert (*arg == '\0');
   
   /* Stringify */
   arg = method_arg_info_from_object_info (&dbus_glib_internal_test_object_info,
 					  &(dbus_glib_internal_test_methods[8]));
   g_assert (*arg != '\0');
   arg = arg_iterate (arg, &arg_name, &arg_in, &constval, &retval, &arg_signature);
   g_assert (!strcmp (arg_name, "val"));
   g_assert (arg_in == TRUE);
   g_assert (!strcmp (arg_signature, "v"));
   g_assert (*arg != '\0');
   arg = arg_iterate (arg, &arg_name, &arg_in, &constval, &retval, &arg_signature);
   g_assert (retval == RETVAL_NONE);
   g_assert (arg_in == FALSE);
   g_assert (!strcmp (arg_signature, "s"));
   g_assert (*arg == '\0');
 
   sigdata = dbus_glib_internal_test_object_info.exported_signals;
   g_assert (*sigdata != '\0');
-  sigdata = propsig_iterate (sigdata, &iface, &signame);
+  sigdata = signal_iterate (sigdata, &iface, &signame);
   g_assert (!strcmp (iface, "org.freedesktop.DBus.Tests.MyObject"));
   g_assert (!strcmp (signame, "Frobnicate"));
   g_assert (*sigdata != '\0');
-  sigdata = propsig_iterate (sigdata, &iface, &signame);
+  sigdata = signal_iterate (sigdata, &iface, &signame);
   g_assert (!strcmp (iface, "org.freedesktop.DBus.Tests.FooObject"));
   g_assert (!strcmp (signame, "Sig0"));
   g_assert (*sigdata != '\0');
-  sigdata = propsig_iterate (sigdata, &iface, &signame);
+  sigdata = signal_iterate (sigdata, &iface, &signame);
   g_assert (!strcmp (iface, "org.freedesktop.DBus.Tests.FooObject"));
   g_assert (!strcmp (signame, "Sig1"));
   g_assert (*sigdata != '\0');
-  sigdata = propsig_iterate (sigdata, &iface, &signame);
+  sigdata = signal_iterate (sigdata, &iface, &signame);
   g_assert (!strcmp (iface, "org.freedesktop.DBus.Tests.FooObject"));
   g_assert (!strcmp (signame, "Sig2"));
   g_assert (*sigdata == '\0');
-  
+
 
   i = 0;
   while (i < (int) G_N_ELEMENTS (name_pairs))
     {
       char *uscore;
       char *wincaps;
 
       uscore = _dbus_gutils_wincaps_to_uscore (name_pairs[i].wincaps);
       wincaps = uscore_to_wincaps (name_pairs[i].uscore);
 
       if (strcmp (uscore, name_pairs[i].uscore) != 0)
         {
           g_printerr ("\"%s\" should have been converted to \"%s\" not \"%s\"\n",
                       name_pairs[i].wincaps, name_pairs[i].uscore,
                       uscore);
           exit (1);
         }
       
       if (strcmp (wincaps, name_pairs[i].wincaps) != 0)
         {
           g_printerr ("\"%s\" should have been converted to \"%s\" not \"%s\"\n",
                       name_pairs[i].uscore, name_pairs[i].wincaps,
                       wincaps);
           exit (1);
         }
       
       g_free (uscore);
       g_free (wincaps);
 
       ++i;
     }
   
   return TRUE;
 }
 
 #endif /* DBUS_BUILD_TESTS */
diff --git a/test/core/Makefile.am b/test/core/Makefile.am
index 7ffda78..6216afe 100644
--- a/test/core/Makefile.am
+++ b/test/core/Makefile.am
@@ -50,7 +50,9 @@ BUILT_SOURCES = test-service-glib-glue.h test-service-glib-bindings.h my-object-
 
 test_service_glib_SOURCES=				\
 	my-object-marshal.c                             \
-	test-service-glib.c 
+	my-object.c \
+	my-object.h \
+	test-service-glib.c
 
 test-service-glib-glue.h: test-service-glib.xml $(top_builddir)/dbus/dbus-binding-tool
 	$(top_builddir)/dbus/dbus-binding-tool --prefix=my_object --mode=glib-server --output=test-service-glib-glue.h $(srcdir)/test-service-glib.xml
diff --git a/test/core/my-object.c b/test/core/my-object.c
new file mode 100644
index 0000000..a633b05
--- /dev/null
+++ b/test/core/my-object.c
@@ -0,0 +1,853 @@
+#include <config.h>
+#include <string.h>
+#include <glib/gi18n.h>
+#include <glib-object.h>
+#include "my-object.h"
+#include "my-object-marshal.h"
+
+#include "test-service-glib-glue.h"
+
+/* Properties */
+enum
+{
+  PROP_0,
+  PROP_THIS_IS_A_STRING,
+  PROP_NO_TOUCHING,
+  PROP_SUPER_STUDLY,
+  PROP_SHOULD_BE_HIDDEN
+};
+
+enum
+{
+  FROBNICATE,
+  SIG0,
+  SIG1,
+  SIG2,
+  LAST_SIGNAL
+};
+
+static guint signals[LAST_SIGNAL] = { 0 };
+
+G_DEFINE_TYPE(MyObject, my_object, G_TYPE_OBJECT)
+
+static void
+my_object_finalize (GObject *object)
+{
+  MyObject *mobject = MY_OBJECT (object);
+
+  g_free (mobject->this_is_a_string);
+
+  (G_OBJECT_CLASS (my_object_parent_class)->finalize) (object);
+}
+
+static void
+my_object_set_property (GObject      *object,
+                        guint         prop_id,
+                        const GValue *value,
+                        GParamSpec   *pspec)
+{
+  MyObject *mobject;
+
+  mobject = MY_OBJECT (object);
+
+  switch (prop_id)
+    {
+    case PROP_THIS_IS_A_STRING:
+      g_free (mobject->this_is_a_string);
+      mobject->this_is_a_string = g_value_dup_string (value);
+      break;
+
+    case PROP_NO_TOUCHING:
+      mobject->notouching = g_value_get_uint (value);
+      break;
+
+    case PROP_SUPER_STUDLY:
+      mobject->super_studly = g_value_get_double (value);
+      break;
+
+    case PROP_SHOULD_BE_HIDDEN:
+      mobject->should_be_hidden = g_value_get_boolean (value);
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+}
+
+static void
+my_object_get_property (GObject      *object,
+                        guint         prop_id,
+                        GValue       *value,
+                        GParamSpec   *pspec)
+{
+  MyObject *mobject;
+
+  mobject = MY_OBJECT (object);
+
+  switch (prop_id)
+    {
+    case PROP_THIS_IS_A_STRING:
+      g_value_set_string (value, mobject->this_is_a_string);
+      break;
+
+    case PROP_NO_TOUCHING:
+      g_value_set_uint (value, mobject->notouching);
+      break;
+
+    case PROP_SUPER_STUDLY:
+      g_value_set_double (value, mobject->super_studly);
+      break;
+
+    case PROP_SHOULD_BE_HIDDEN:
+      g_value_set_boolean (value, mobject->should_be_hidden);
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+}
+
+static void
+my_object_init (MyObject *obj)
+{
+  obj->val = 0;
+  obj->notouching = 42;
+}
+
+static void
+my_object_class_init (MyObjectClass *mobject_class)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (mobject_class);
+
+  dbus_g_object_type_install_info (MY_TYPE_OBJECT,
+				   &dbus_glib_my_object_object_info);
+
+  gobject_class->finalize = my_object_finalize;
+  gobject_class->set_property = my_object_set_property;
+  gobject_class->get_property = my_object_get_property;
+
+  g_object_class_install_property (gobject_class,
+				   PROP_THIS_IS_A_STRING,
+				   g_param_spec_string ("this_is_a_string",
+                                                        _("Sample string"),
+                                                        _("Example of a string property"),
+                                                        "default value",
+                                                        G_PARAM_READWRITE));
+  g_object_class_install_property (gobject_class,
+                                   PROP_NO_TOUCHING,
+                                   g_param_spec_uint ("no_touching",
+                                                      _("Don't touch"),
+                                                      _("Example of a readonly property (for export)"),
+                                                      0, 100, 42,
+                                                      G_PARAM_READWRITE));
+
+  g_object_class_install_property (gobject_class,
+                				   PROP_SUPER_STUDLY,
+				                   g_param_spec_double ("super-studly",
+                                                        _("In Studly Caps"),
+                                                        _("Example of a StudlyCaps property"),
+                                                        0, 256, 128,
+                                                        G_PARAM_READWRITE));
+
+  g_object_class_install_property (gobject_class,
+                				   PROP_SHOULD_BE_HIDDEN,
+				                   g_param_spec_boolean ("should-be-hidden",
+                                                        _("A non-exported property"),
+                                                        _("Example of a property we don't want exported"),
+                                                        FALSE,
+                                                        G_PARAM_READWRITE));
+
+  signals[FROBNICATE] =
+    g_signal_new ("frobnicate",
+		  G_OBJECT_CLASS_TYPE (mobject_class),
+                  G_SIGNAL_RUN_LAST | G_SIGNAL_DETAILED,
+                  0,
+                  NULL, NULL,
+                  g_cclosure_marshal_VOID__INT,
+                  G_TYPE_NONE, 1, G_TYPE_INT);
+
+  signals[SIG0] =
+    g_signal_new ("sig0",
+		  G_OBJECT_CLASS_TYPE (mobject_class),
+                  G_SIGNAL_RUN_LAST | G_SIGNAL_DETAILED,
+                  0,
+                  NULL, NULL,
+                  my_object_marshal_VOID__STRING_INT_STRING,
+                  G_TYPE_NONE, 3, G_TYPE_STRING, G_TYPE_INT, G_TYPE_STRING);
+
+  signals[SIG1] =
+    g_signal_new ("sig1",
+		  G_OBJECT_CLASS_TYPE (mobject_class),
+                  G_SIGNAL_RUN_LAST | G_SIGNAL_DETAILED,
+                  0,
+                  NULL, NULL,
+                  my_object_marshal_VOID__STRING_BOXED,
+                  G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_VALUE);
+
+  signals[SIG2] =
+    g_signal_new ("sig2",
+		  G_OBJECT_CLASS_TYPE (mobject_class),
+                  G_SIGNAL_RUN_LAST | G_SIGNAL_DETAILED,
+                  0,
+                  NULL, NULL,
+                  g_cclosure_marshal_VOID__BOXED,
+                  G_TYPE_NONE, 1, DBUS_TYPE_G_STRING_STRING_HASHTABLE);
+}
+
+GQuark
+my_object_error_quark (void)
+{
+  static GQuark quark = 0;
+  if (!quark)
+    quark = g_quark_from_static_string ("my_object_error");
+
+  return quark;
+}
+
+/* This should really be standard. */
+#define ENUM_ENTRY(NAME, DESC) { NAME, "" #NAME "", DESC }
+
+GType
+my_object_error_get_type (void)
+{
+	static GType etype = 0;
+
+	if (etype == 0)
+	{
+		static const GEnumValue values[] =
+		{
+
+			ENUM_ENTRY (MY_OBJECT_ERROR_FOO, "Foo"),
+			ENUM_ENTRY (MY_OBJECT_ERROR_BAR, "Bar"),
+			ENUM_ENTRY (MY_OBJECT_ERROR_MULTI_WORD, "Multi-word"),
+			{ 0, 0, 0 }
+		};
+
+		etype = g_enum_register_static ("MyObjectError", values);
+	}
+
+	return etype;
+}
+
+gboolean
+my_object_do_nothing (MyObject *obj, GError **error)
+{
+  return TRUE;
+}
+
+gboolean
+my_object_increment (MyObject *obj, gint32 x, gint32 *ret, GError **error)
+{
+  *ret = x +1;
+  return TRUE;
+}
+
+gint32
+my_object_increment_retval (MyObject *obj, gint32 x)
+{
+  return x + 1;
+}
+
+gint32
+my_object_increment_retval_error (MyObject *obj, gint32 x, GError **error)
+{
+  if (x + 1 > 10)
+    {
+      g_set_error (error,
+		   MY_OBJECT_ERROR,
+		   MY_OBJECT_ERROR_FOO,
+		   "%s",
+		   "x is bigger than 9");
+      return FALSE;
+    }
+  return x + 1;
+}
+
+gboolean
+my_object_throw_error (MyObject *obj, GError **error)
+{
+  g_set_error (error,
+	       MY_OBJECT_ERROR,
+	       MY_OBJECT_ERROR_FOO,
+	       "%s",
+	       "this method always loses");
+  return FALSE;
+}
+
+gboolean
+my_object_throw_not_supported (MyObject *obj, GError **error)
+{
+  g_set_error (error,
+	       DBUS_GERROR,
+	       DBUS_GERROR_NOT_SUPPORTED,
+	       "%s",
+	       "this method always loses");
+  return FALSE;
+}
+
+gboolean
+my_object_throw_error_multi_word (MyObject *obj, GError **error)
+{
+  g_set_error (error,
+	       MY_OBJECT_ERROR,
+	       MY_OBJECT_ERROR_MULTI_WORD,
+	       "%s",
+	       "this method's error has a hyphen");
+  return FALSE;
+}
+
+gboolean
+my_object_throw_unregistered_error (MyObject *obj, GError **error)
+{
+  /* Unregistered errors shouldn't cause a dbus abort.  See
+   * https://bugzilla.redhat.com/show_bug.cgi?id=581794
+   */
+  g_set_error (error, 0, 0,
+	       "%s",
+	       "this method always loses more");
+  return FALSE;
+}
+
+
+gboolean
+my_object_uppercase (MyObject *obj, const char *str, char **ret, GError **error)
+{
+  *ret = g_ascii_strup (str, -1);
+  return TRUE;
+}
+
+gboolean
+my_object_many_args (MyObject *obj, guint32 x, const char *str, double trouble, double *d_ret, char **str_ret, GError **error)
+{
+  *d_ret = trouble + (x * 2);
+  *str_ret = g_ascii_strup (str, -1);
+  return TRUE;
+}
+
+gboolean
+my_object_many_return (MyObject *obj, guint32 *arg0, char **arg1, gint32 *arg2, guint32 *arg3, guint32 *arg4, const char **arg5, GError **error)
+{
+  *arg0 = 42;
+  *arg1 = g_strdup ("42");
+  *arg2 = -67;
+  *arg3 = 2;
+  *arg4 = 26;
+  *arg5 = "hello world"; /* Annotation specifies as const */
+  return TRUE;
+}
+
+gboolean
+my_object_stringify (MyObject *obj, GValue *value, char **ret, GError **error)
+{
+  GValue valstr = {0, };
+
+  g_value_init (&valstr, G_TYPE_STRING);
+  if (!g_value_transform (value, &valstr))
+    {
+      g_set_error (error,
+		   MY_OBJECT_ERROR,
+		   MY_OBJECT_ERROR_FOO,
+		   "couldn't transform value");
+      return FALSE;
+    }
+  *ret = g_value_dup_string (&valstr);
+  g_value_unset (&valstr);
+  return TRUE;
+}
+
+gboolean
+my_object_unstringify (MyObject *obj, const char *str, GValue *value, GError **error)
+{
+  if (str[0] == '\0' || !g_ascii_isdigit (str[0])) {
+    g_value_init (value, G_TYPE_STRING);
+    g_value_set_string (value, str);
+  } else {
+    g_value_init (value, G_TYPE_INT);
+    g_value_set_int (value, (int) g_ascii_strtoull (str, NULL, 10));
+  }
+  return TRUE;
+}
+
+gboolean
+my_object_recursive1 (MyObject *obj, GArray *array, guint32 *len_ret, GError **error)
+{
+  *len_ret = array->len;
+  return TRUE;
+}
+
+gboolean
+my_object_recursive2 (MyObject *obj, guint32 reqlen, GArray **ret, GError **error)
+{
+  guint32 val;
+  GArray *array;
+
+  array = g_array_new (FALSE, TRUE, sizeof (guint32));
+
+  while (reqlen > 0) {
+    val = 42;
+    g_array_append_val (array, val);
+    val = 26;
+    g_array_append_val (array, val);
+    reqlen--;
+  }
+  val = 2;
+  g_array_append_val (array, val);
+  *ret = array;
+  return TRUE;
+}
+
+gboolean
+my_object_many_uppercase (MyObject *obj, const char * const *in, char ***out, GError **error)
+{
+  int len;
+  int i;
+
+  len = g_strv_length ((char**) in);
+
+  *out = g_new0 (char *, len + 1);
+  for (i = 0; i < len; i++)
+    {
+      (*out)[i] = g_ascii_strup (in[i], -1);
+    }
+  (*out)[i] = NULL;
+
+  return TRUE;
+}
+
+static void
+hash_foreach_stringify (gpointer key, gpointer val, gpointer user_data)
+{
+  const char *keystr = key;
+  const GValue *value = val;
+  GValue *sval;
+  GHashTable *ret = user_data;
+
+  sval = g_new0 (GValue, 1);
+  g_value_init (sval, G_TYPE_STRING);
+  if (!g_value_transform (value, sval))
+    g_assert_not_reached ();
+
+  g_hash_table_insert (ret, g_strdup (keystr), sval);
+}
+
+static void
+unset_and_free_gvalue (gpointer val)
+{
+  g_value_unset (val);
+  g_free (val);
+}
+
+gboolean
+my_object_many_stringify (MyObject *obj, GHashTable /* char * -> GValue * */ *vals, GHashTable /* char * -> GValue * */ **ret, GError **error)
+{
+  *ret = g_hash_table_new_full (g_str_hash, g_str_equal,
+				g_free, unset_and_free_gvalue);
+  g_hash_table_foreach (vals, hash_foreach_stringify, *ret);
+  return TRUE;
+}
+
+gboolean
+my_object_rec_arrays (MyObject *obj, GPtrArray *in, GPtrArray **ret, GError **error)
+{
+  char **strs;
+  GArray *ints;
+  guint v_UINT;
+
+  if (in->len != 2)
+    {
+      g_set_error (error,
+		   MY_OBJECT_ERROR,
+		   MY_OBJECT_ERROR_FOO,
+		   "invalid array len");
+      return FALSE;
+    }
+
+  strs = g_ptr_array_index (in, 0);
+  if (!*strs || strcmp (*strs, "foo"))
+    {
+      g_set_error (error,
+		   MY_OBJECT_ERROR,
+		   MY_OBJECT_ERROR_FOO,
+		   "invalid string 0");
+      return FALSE;
+    }
+  strs++;
+  if (!*strs || strcmp (*strs, "bar"))
+    {
+      g_set_error (error,
+		   MY_OBJECT_ERROR,
+		   MY_OBJECT_ERROR_FOO,
+		   "invalid string 1");
+      return FALSE;
+    }
+  strs++;
+  if (*strs)
+    {
+      g_set_error (error,
+		   MY_OBJECT_ERROR,
+		   MY_OBJECT_ERROR_FOO,
+		   "invalid string array len in pos 0");
+      return FALSE;
+    }
+  strs = g_ptr_array_index (in, 1);
+  if (!*strs || strcmp (*strs, "baz"))
+    {
+      g_set_error (error,
+		   MY_OBJECT_ERROR,
+		   MY_OBJECT_ERROR_FOO,
+		   "invalid string 0");
+      return FALSE;
+    }
+  strs++;
+  if (!*strs || strcmp (*strs, "whee"))
+    {
+      g_set_error (error,
+		   MY_OBJECT_ERROR,
+		   MY_OBJECT_ERROR_FOO,
+		   "invalid string 1");
+      return FALSE;
+    }
+  strs++;
+  if (!*strs || strcmp (*strs, "moo"))
+    {
+      g_set_error (error,
+		   MY_OBJECT_ERROR,
+		   MY_OBJECT_ERROR_FOO,
+		   "invalid string 2");
+      return FALSE;
+    }
+  strs++;
+  if (*strs)
+    {
+      g_set_error (error,
+		   MY_OBJECT_ERROR,
+		   MY_OBJECT_ERROR_FOO,
+		   "invalid string array len in pos 1");
+      return FALSE;
+    }
+
+  *ret = g_ptr_array_new ();
+
+  ints = g_array_new (TRUE, TRUE, sizeof (guint));
+  v_UINT = 10;
+  g_array_append_val (ints, v_UINT);
+  v_UINT = 42;
+  g_array_append_val (ints, v_UINT);
+  v_UINT = 27;
+  g_array_append_val (ints, v_UINT);
+  g_ptr_array_add (*ret, ints);
+
+  ints = g_array_new (TRUE, TRUE, sizeof (guint));
+  v_UINT = 30;
+  g_array_append_val (ints, v_UINT);
+  g_ptr_array_add (*ret, ints);
+  return TRUE;
+}
+
+gboolean
+my_object_objpath (MyObject *obj, const char *incoming, const char **outgoing, GError **error)
+{
+  if (strcmp (incoming, "/org/freedesktop/DBus/GLib/Tests/MyTestObject"))
+    {
+      g_set_error (error,
+		   MY_OBJECT_ERROR,
+		   MY_OBJECT_ERROR_FOO,
+		   "invalid incoming object");
+      return FALSE;
+    }
+  *outgoing = "/org/freedesktop/DBus/GLib/Tests/MyTestObject2";
+  return TRUE;
+}
+
+gboolean
+my_object_get_objs (MyObject *obj, GPtrArray **objs, GError **error)
+{
+  *objs = g_ptr_array_new ();
+
+  g_ptr_array_add (*objs, g_strdup ("/org/freedesktop/DBus/GLib/Tests/MyTestObject"));
+  g_ptr_array_add (*objs, g_strdup ("/org/freedesktop/DBus/GLib/Tests/MyTestObject2"));
+
+  return TRUE;
+}
+
+static void
+hash_foreach (gpointer key, gpointer val, gpointer user_data)
+{
+  const char *keystr = key;
+  const char *valstr = val;
+  guint *count = user_data;
+
+  *count += (strlen (keystr) + strlen (valstr));
+  g_print ("%s -> %s\n", keystr, valstr);
+}
+
+gboolean
+my_object_str_hash_len (MyObject *obj, GHashTable *table, guint *len, GError **error)
+{
+  *len = 0;
+  g_hash_table_foreach (table, hash_foreach, len);
+  return TRUE;
+}
+
+gboolean
+my_object_send_car (MyObject *obj, GValueArray *invals, GValueArray **outvals, GError **error)
+{
+  if (invals->n_values != 3
+      || G_VALUE_TYPE (g_value_array_get_nth (invals, 0)) != G_TYPE_STRING
+      || G_VALUE_TYPE (g_value_array_get_nth (invals, 1)) != G_TYPE_UINT
+      || G_VALUE_TYPE (g_value_array_get_nth (invals, 2)) != G_TYPE_VALUE)
+    {
+      g_set_error (error,
+		   MY_OBJECT_ERROR,
+		   MY_OBJECT_ERROR_FOO,
+		   "invalid incoming values");
+      return FALSE;
+    }
+  *outvals = g_value_array_new (2);
+  g_value_array_append (*outvals, NULL);
+  g_value_init (g_value_array_get_nth (*outvals, (*outvals)->n_values - 1), G_TYPE_UINT);
+  g_value_set_uint (g_value_array_get_nth (*outvals, (*outvals)->n_values - 1),
+		    g_value_get_uint (g_value_array_get_nth (invals, 1)) + 1);
+  g_value_array_append (*outvals, NULL);
+  g_value_init (g_value_array_get_nth (*outvals, (*outvals)->n_values - 1), DBUS_TYPE_G_OBJECT_PATH);
+  g_value_set_boxed (g_value_array_get_nth (*outvals, (*outvals)->n_values - 1),
+		     g_strdup ("/org/freedesktop/DBus/GLib/Tests/MyTestObject2"));
+  return TRUE;
+}
+
+gboolean
+my_object_get_hash (MyObject *obj, GHashTable **ret, GError **error)
+{
+  GHashTable *table;
+
+  table = g_hash_table_new (g_str_hash, g_str_equal);
+  g_hash_table_insert (table, "foo", "bar");
+  g_hash_table_insert (table, "baz", "whee");
+  g_hash_table_insert (table, "cow", "crack");
+  *ret = table;
+  return TRUE;
+}
+
+gboolean
+my_object_increment_val (MyObject *obj, GError **error)
+{
+  obj->val++;
+  return TRUE;
+}
+
+gboolean
+my_object_get_val (MyObject *obj, guint *ret, GError **error)
+{
+  *ret = obj->val;
+  return TRUE;
+}
+
+gboolean
+my_object_get_value (MyObject *obj, guint *ret, GError **error)
+{
+  *ret = obj->val;
+  return TRUE;
+}
+
+gboolean
+my_object_echo_variant (MyObject *obj, GValue *variant, GValue *ret, GError **error)
+{
+    GType t;
+    t = G_VALUE_TYPE(variant);
+    g_value_init (ret, t);
+    g_value_copy (variant, ret);
+
+    return TRUE;
+}
+
+gboolean
+my_object_echo_signature (MyObject *obj, const gchar *in, gchar **out, GError **error)
+{
+  *out = g_strdup (in);
+  return TRUE;
+}
+
+gboolean
+my_object_process_variant_of_array_of_ints123 (MyObject *obj, GValue *variant, GError **error)
+{
+  GArray *array;
+  int i;
+  int j;
+
+  j = 0;
+
+  array = (GArray *)g_value_get_boxed (variant);
+
+  for (i = 0; i <= 2; i++)
+    {
+      j = g_array_index (array, int, i);
+      if (j != i + 1)
+        goto error;
+    }
+
+  return TRUE;
+
+error:
+  *error = g_error_new (MY_OBJECT_ERROR,
+		       MY_OBJECT_ERROR_FOO,
+		       "Error decoding a variant of type ai (i + 1 = %i, j = %i)",
+		       i, j + 1);
+  return FALSE;
+}
+
+
+typedef struct _HashAndString HashAndString;
+
+struct _HashAndString
+{
+  GHashTable *hash;
+  gchar* string;
+};
+
+static void
+hash_foreach_prepend_string (gpointer key, gpointer val, gpointer user_data)
+{
+  HashAndString *data = (HashAndString*) user_data;
+  gchar *in = (gchar*) val;
+  g_hash_table_insert (data->hash, g_strdup ((gchar*) key),
+                       g_strjoin (" ", data->string, in, NULL));
+}
+
+
+static void
+hash_foreach_mangle_dict_of_strings (gpointer key, gpointer val, gpointer user_data)
+{
+  GHashTable *out = (GHashTable*) user_data;
+  GHashTable *in_dict = (GHashTable *) val;
+  HashAndString *data = g_new0 (HashAndString, 1);
+
+  data->string = (gchar*) key;
+  data->hash = g_hash_table_new_full (g_str_hash, g_str_equal,
+                                            g_free, g_free);
+  g_hash_table_foreach (in_dict, hash_foreach_prepend_string, data);
+
+  g_hash_table_insert(out, g_strdup ((gchar*) key), data->hash);
+}
+
+gboolean
+my_object_dict_of_dicts (MyObject *obj, GHashTable *in,
+                                GHashTable **out, GError **error)
+{
+  *out = g_hash_table_new_full (g_str_hash, g_str_equal,
+				(GDestroyNotify) g_free,
+                                (GDestroyNotify) g_hash_table_destroy);
+  g_hash_table_foreach (in, hash_foreach_mangle_dict_of_strings, *out);
+  return TRUE;
+}
+
+void
+my_object_dict_of_sigs (MyObject *obj,
+                        GHashTable *dict,
+                        DBusGMethodInvocation *context)
+{
+  dbus_g_method_return (context, dict);
+}
+
+void
+my_object_dict_of_objs (MyObject *obj,
+                        GHashTable *dict,
+                        DBusGMethodInvocation *context)
+{
+  dbus_g_method_return (context, dict);
+}
+
+gboolean
+my_object_emit_frobnicate (MyObject *obj, GError **error)
+{
+  g_signal_emit (obj, signals[FROBNICATE], 0, 42);
+  return TRUE;
+}
+
+gboolean
+my_object_emit_signals (MyObject *obj, GError **error)
+{
+  GValue val = {0, };
+
+  g_signal_emit (obj, signals[SIG0], 0, "foo", 22, "moo");
+
+  g_value_init (&val, G_TYPE_STRING);
+  g_value_set_string (&val, "bar");
+  g_signal_emit (obj, signals[SIG1], 0, "baz", &val);
+  g_value_unset (&val);
+
+  return TRUE;
+}
+
+gboolean
+my_object_emit_signal2 (MyObject *obj, GError **error)
+{
+  GHashTable *table;
+
+  table = g_hash_table_new (g_str_hash, g_str_equal);
+  g_hash_table_insert (table, "baz", "cow");
+  g_hash_table_insert (table, "bar", "foo");
+  g_signal_emit (obj, signals[SIG2], 0, table);
+  g_hash_table_destroy (table);
+  return TRUE;
+}
+
+typedef struct {
+  gint32 x;
+  DBusGMethodInvocation *context;
+} IncrementData;
+
+static gboolean
+do_async_increment (IncrementData *data)
+{
+  gint32 newx = data->x + 1;
+  dbus_g_method_return (data->context, newx);
+  g_free (data);
+  return FALSE;
+}
+
+void
+my_object_async_increment (MyObject *obj, gint32 x, DBusGMethodInvocation *context)
+{
+  IncrementData *data = g_new0 (IncrementData, 1);
+  data->x = x;
+  data->context = context;
+  g_idle_add ((GSourceFunc)do_async_increment, data);
+}
+
+static gboolean
+do_async_error (IncrementData *data)
+{
+  GError *error;
+  error = g_error_new (MY_OBJECT_ERROR,
+		       MY_OBJECT_ERROR_FOO,
+		       "%s",
+		       "this method always loses");
+  dbus_g_method_return_error (data->context, error);
+  g_free (data);
+  return FALSE;
+}
+
+void
+my_object_async_throw_error (MyObject *obj, DBusGMethodInvocation *context)
+{
+  IncrementData *data = g_new0(IncrementData, 1);
+  data->context = context;
+  g_idle_add ((GSourceFunc)do_async_error,  data);
+}
+
+extern GMainLoop *loop;
+
+gboolean
+my_object_terminate (MyObject *obj, GError **error)
+{
+  g_main_loop_quit (loop);
+  return TRUE;
+}
+
+void
+my_object_unsafe_disable_legacy_property_access (MyObject *obj)
+{
+  dbus_glib_global_set_disable_legacy_property_access ();
+}
diff --git a/test/core/my-object.h b/test/core/my-object.h
new file mode 100644
index 0000000..28f8704
--- /dev/null
+++ b/test/core/my-object.h
@@ -0,0 +1,118 @@
+#ifndef __MY_OBJECT_H__
+#define __MY_OBJECT_H__
+
+#include <glib-object.h>
+#include <dbus/dbus-glib.h>
+
+typedef struct MyObject MyObject;
+typedef struct MyObjectClass MyObjectClass;
+
+GType my_object_get_type (void);
+
+struct MyObject
+{
+  GObject parent;
+  char *this_is_a_string;
+  guint notouching;
+  guint val;
+  gdouble super_studly;
+  gboolean should_be_hidden;
+};
+
+struct MyObjectClass
+{
+  GObjectClass parent;
+};
+
+#define MY_TYPE_OBJECT              (my_object_get_type ())
+#define MY_OBJECT(object)           (G_TYPE_CHECK_INSTANCE_CAST ((object), MY_TYPE_OBJECT, MyObject))
+#define MY_OBJECT_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST ((klass), MY_TYPE_OBJECT, MyObjectClass))
+#define MY_IS_OBJECT(object)        (G_TYPE_CHECK_INSTANCE_TYPE ((object), MY_TYPE_OBJECT))
+#define MY_IS_OBJECT_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE ((klass), MY_TYPE_OBJECT))
+#define MY_OBJECT_GET_CLASS(obj)    (G_TYPE_INSTANCE_GET_CLASS ((obj), MY_TYPE_OBJECT, MyObjectClass))
+
+typedef enum
+{
+  MY_OBJECT_ERROR_FOO,
+  MY_OBJECT_ERROR_BAR,
+  MY_OBJECT_ERROR_MULTI_WORD
+} MyObjectError;
+
+#define MY_OBJECT_ERROR (my_object_error_quark ())
+#define MY_TYPE_ERROR (my_object_error_get_type ())
+
+GQuark my_object_error_quark (void);
+GType my_object_error_get_type (void);
+
+gboolean my_object_do_nothing (MyObject *obj, GError **error);
+
+gboolean my_object_increment (MyObject *obj, gint32 x, gint32 *ret, GError **error);
+
+gint32   my_object_increment_retval (MyObject *obj, gint32 x);
+
+gint32   my_object_increment_retval_error (MyObject *obj, gint32 x, GError **error);
+
+gboolean my_object_throw_error (MyObject *obj, GError **error);
+gboolean my_object_throw_not_supported (MyObject *obj, GError **error);
+gboolean my_object_throw_error_multi_word (MyObject *obj, GError **error);
+gboolean my_object_throw_unregistered_error (MyObject *obj, GError **error);
+
+gboolean my_object_uppercase (MyObject *obj, const char *str, char **ret, GError **error);
+
+gboolean my_object_many_args (MyObject *obj, guint32 x, const char *str, double trouble, double *d_ret, char **str_ret, GError **error);
+
+gboolean my_object_many_return (MyObject *obj, guint32 *arg0, char **arg1, gint32 *arg2, guint32 *arg3, guint32 *arg4, const char **arg5, GError **error);
+
+gboolean my_object_recursive1 (MyObject *obj, GArray *array, guint32 *len_ret, GError **error);
+gboolean my_object_recursive2 (MyObject *obj, guint32 reqlen, GArray **array, GError **error);
+
+gboolean my_object_many_stringify (MyObject *obj, GHashTable *vals, GHashTable **ret, GError **error);
+
+gboolean my_object_rec_arrays (MyObject *obj, GPtrArray *in, GPtrArray **ret, GError **error);
+
+gboolean my_object_objpath (MyObject *obj, const char *in, const char **arg1, GError **error);
+
+gboolean my_object_get_objs (MyObject *obj, GPtrArray **objs, GError **error);
+
+gboolean my_object_stringify (MyObject *obj, GValue *value, char **ret, GError **error);
+gboolean my_object_unstringify (MyObject *obj, const char *str, GValue *value, GError **error);
+
+gboolean my_object_many_uppercase (MyObject *obj, const char * const *in, char ***out, GError **error);
+
+gboolean my_object_str_hash_len (MyObject *obj, GHashTable *table, guint *len, GError **error);
+
+gboolean my_object_send_car (MyObject *obj, GValueArray *invals, GValueArray **outvals, GError **error);
+
+gboolean my_object_get_hash (MyObject *obj, GHashTable **table, GError **error);
+
+gboolean my_object_increment_val (MyObject *obj, GError **error);
+
+gboolean my_object_get_val (MyObject *obj, guint *ret, GError **error);
+
+gboolean my_object_get_value (MyObject *obj, guint *ret, GError **error);
+
+gboolean my_object_emit_signals (MyObject *obj, GError **error);
+gboolean my_object_emit_signal2 (MyObject *obj, GError **error);
+
+gboolean my_object_emit_frobnicate (MyObject *obj, GError **error);
+
+gboolean my_object_echo_variant (MyObject *obj, GValue *variant, GValue *ret, GError **error);
+gboolean my_object_echo_signature (MyObject *obj, const gchar *in, gchar **out, GError **error);
+
+gboolean my_object_process_variant_of_array_of_ints123 (MyObject *obj, GValue *variant, GError **error);
+
+gboolean my_object_dict_of_dicts (MyObject *obj, GHashTable *dict, GHashTable **ret, GError **error);
+
+void my_object_dict_of_sigs (MyObject *obj, GHashTable *dict, DBusGMethodInvocation *ctx);
+
+void my_object_dict_of_objs (MyObject *obj, GHashTable *dict, DBusGMethodInvocation *ctx);
+
+gboolean my_object_terminate (MyObject *obj, GError **error);
+
+void my_object_async_increment (MyObject *obj, gint32 x, DBusGMethodInvocation *context);
+
+void my_object_async_throw_error (MyObject *obj, DBusGMethodInvocation *context);
+
+void my_object_unsafe_disable_legacy_property_access (MyObject *obj);
+
+#endif
diff --git a/test/core/test-dbus-glib.c b/test/core/test-dbus-glib.c
index f32b2d4..d78ce58 100644
--- a/test/core/test-dbus-glib.c
+++ b/test/core/test-dbus-glib.c
@@ -256,19 +256,18 @@ static void
 increment_async_cb (DBusGProxy *proxy, guint val, GError *error, gpointer data)
 {
   if (error)
     lose_gerror ("Failed to complete (wrapped async) Increment call", error);
 
   if (data != NULL)
     lose ("(wrapped async) Increment call gave unexpected data");
   if (val != 43)
     lose ("(wrapped async) Increment call returned %d, should be 43", val);
 
   g_print ("(wrapped async) increment gave \"%d\"\n", val); 
   g_main_loop_quit (loop);
   g_source_remove (exit_timeout);
 }
 
-
 static void
 lose (const char *str, ...)
 {
@@ -309,1369 +308,1646 @@ int
 main (int argc, char **argv)
 {
   DBusGConnection *connection;
   GError *error;
   DBusGProxy *driver;
   DBusGProxy *proxy;
   DBusGProxy *proxy2;
+  DBusGProxy *property_proxy;
   char **name_list;
   guint name_list_len;
   guint i;
   DBusGProxyCall *call;
   guint32 result;
   char *v_STRING_2;
   guint32 v_UINT32_2;
   double v_DOUBLE_2;
     
   g_type_init ();
 
   g_log_set_always_fatal (G_LOG_LEVEL_WARNING);
   
   loop = g_main_loop_new (NULL, FALSE);
 
   error = NULL;
   connection = dbus_g_bus_get (DBUS_BUS_SESSION,
                                &error);
   if (connection == NULL)
     lose_gerror ("Failed to open connection to bus", error);
 
   /* should always get the same one */
   g_assert (connection == dbus_g_bus_get (DBUS_BUS_SESSION, NULL));
   g_assert (connection == dbus_g_bus_get (DBUS_BUS_SESSION, NULL));
   g_assert (connection == dbus_g_bus_get (DBUS_BUS_SESSION, NULL));
   
   /* Create a proxy object for the "bus driver" */
   
   driver = dbus_g_proxy_new_for_name (connection,
 				      DBUS_SERVICE_DBUS,
 				      DBUS_PATH_DBUS,
 				      DBUS_INTERFACE_DBUS);
 
   dbus_g_proxy_add_signal (driver,
 			   "NameOwnerChanged",
 			   G_TYPE_STRING,
 			   G_TYPE_STRING,
 			   G_TYPE_STRING,
 			   G_TYPE_INVALID);
   
   dbus_g_proxy_connect_signal (driver,
 			       "NameOwnerChanged", 
 			       G_CALLBACK (name_owner_changed),
 			       NULL,
 			       NULL);
   /* Call ListNames method */
   
   error = NULL;
   if (!dbus_g_proxy_call (driver, "ListNames", &error,
 			  G_TYPE_INVALID,
 			  G_TYPE_STRV, &name_list,
 			  G_TYPE_INVALID))
     lose_gerror ("Failed to complete ListNames call", error);
 
   g_print ("Names on the message bus:\n");
   i = 0;
   name_list_len = g_strv_length (name_list);
   while (i < name_list_len)
     {
       g_assert (name_list[i] != NULL);
       g_print ("  %s\n", name_list[i]);
       ++i;
     }
   g_assert (name_list[i] == NULL);
 
   g_strfreev (name_list);
 
   g_print ("calling ThisMethodDoesNotExist\n");
   /* Test handling of unknown method */
   if (dbus_g_proxy_call (driver, "ThisMethodDoesNotExist", &error,
 			 G_TYPE_STRING,
 			 "blah blah blah blah blah",
 			 G_TYPE_INT,
 			 10,
 			 G_TYPE_INVALID, G_TYPE_INVALID) != FALSE)
     lose ("Calling nonexistent method succeeded!");
 
   g_print ("Got EXPECTED error from calling unknown method: %s\n", error->message);
   g_clear_error (&error);
 
   run_mainloop ();
   
   /* Activate a service */
   g_print ("Activating echo service\n");
   if (!dbus_g_proxy_call (driver, "StartServiceByName", &error,
 			  G_TYPE_STRING,
 			  "org.freedesktop.DBus.GLib.TestEchoService",
 			  G_TYPE_UINT, 0,
 			  G_TYPE_INVALID,
 			  G_TYPE_UINT, &result,
 			  G_TYPE_INVALID))
     lose_gerror ("Failed to complete Activate call", error);
 
   g_print ("Starting echo service result = 0x%x\n", result);
 
   /* Activate a service again */
   g_print ("Activating echo service again\n");
   if (!dbus_g_proxy_call (driver, "StartServiceByName", &error,
 			  G_TYPE_STRING,
 			  "org.freedesktop.DBus.GLib.TestEchoService",
 			  G_TYPE_UINT,
 			  0,
 			  G_TYPE_INVALID,
 			  G_TYPE_UINT, &result,
 			  G_TYPE_INVALID))
     lose_gerror ("Failed to complete Activate call", error);
 
   g_print ("Duplicate start of echo service = 0x%x\n", result);
 
   /* Talk to the new service */
   
   g_print ("Creating proxy for echo service\n");
   proxy = dbus_g_proxy_new_for_name_owner (connection,
                                            "org.freedesktop.DBus.GLib.TestEchoService",
                                            "/org/freedesktop/DBus/GLib/TestSuite",
                                            "org.freedesktop.DBus.GLib.TestSuite",
                                            &error);
   
   if (proxy == NULL)
     lose_gerror ("Failed to create proxy for name owner", error);
 
   run_mainloop ();
 
   g_print ("Calling Echo\n");
   if (!dbus_g_proxy_call (proxy, "Echo", &error,
 			  G_TYPE_STRING, "my string hello",
 			  G_TYPE_INVALID,
 			  G_TYPE_STRING, &v_STRING_2,
 			  G_TYPE_INVALID))
     lose_gerror ("Failed to complete Echo call", error);
 
   g_print ("String echoed = \"%s\"\n", v_STRING_2);
   g_free (v_STRING_2);
 
   g_print ("Calling Echo (async)\n");
   echo_call = dbus_g_proxy_begin_call (proxy, "Echo",
 				       echo_received_cb, NULL, NULL,
 				       G_TYPE_STRING, "my string hello",
 				       G_TYPE_INVALID);
   dbus_g_connection_flush (connection);
   exit_timeout = g_timeout_add (5000, timed_exit, loop);
   g_main_loop_run (loop);
 
   /* Test oneway call and signal handling */
 
   g_print ("Testing Foo emission\n");
   dbus_g_proxy_add_signal (proxy, "Foo", G_TYPE_DOUBLE, G_TYPE_INVALID);
   
   dbus_g_proxy_connect_signal (proxy, "Foo",
                                G_CALLBACK (foo_signal_handler),
                                NULL, NULL);
   
   dbus_g_proxy_call_no_reply (proxy, "EmitFoo",
                               G_TYPE_INVALID);
   
   dbus_g_connection_flush (connection);
   exit_timeout = g_timeout_add (5000, timed_exit, loop);
   g_main_loop_run (loop);
 
   if (n_times_foo_received != 1)
     lose ("Foo signal received %d times, should have been 1", n_times_foo_received);
   
   /* Activate test servie */ 
   g_print ("Activating GLib.TestService\n");
   error = NULL;
   if (!dbus_g_proxy_call (driver, "StartServiceByName", &error,
 			  G_TYPE_STRING,
 			  "org.freedesktop.DBus.GLib.TestService",
 			  G_TYPE_UINT,
 			  0,
 			  G_TYPE_INVALID,
 			  G_TYPE_UINT, &result,
 			  G_TYPE_INVALID)) {
     lose_gerror ("Failed to complete Activate call", error);
   }
 
   g_print ("GLib.TestService activated\n");
 
   if (getenv ("DBUS_GLIB_TEST_SLEEP_AFTER_ACTIVATION"))
     g_usleep (8 * G_USEC_PER_SEC);
 
   g_object_unref (G_OBJECT (proxy));
 
   run_mainloop ();
 
   proxy = dbus_g_proxy_new_for_name_owner (connection,
                                            "org.freedesktop.DBus.GLib.TestService",
                                            "/org/freedesktop/DBus/GLib/Tests/MyTestObject",
                                            "org.freedesktop.DBus.GLib.Tests.MyObject",
                                            &error);
   
   if (proxy == NULL)
     lose_gerror ("Failed to create proxy for name owner", error);
 
   g_print ("Calling DoNothing\n");
   if (!dbus_g_proxy_call (proxy, "DoNothing", &error,
 			  G_TYPE_INVALID, G_TYPE_INVALID))
     lose_gerror ("Failed to complete DoNothing call", error);
 
   g_print ("Calling Increment\n");
   error = NULL;
   if (!dbus_g_proxy_call (proxy, "Increment", &error,
 			  G_TYPE_UINT, 42,
 			  G_TYPE_INVALID,
 			  G_TYPE_UINT, &v_UINT32_2,
 			  G_TYPE_INVALID))
     lose_gerror ("Failed to complete Increment call", error);
   if (v_UINT32_2 != 43)
     lose ("Increment call returned %d, should be 43", v_UINT32_2);
 
   v_UINT32_2 = 0;
   g_print ("Calling Increment (async)\n");
   call = dbus_g_proxy_begin_call (proxy, "Increment",
 				  increment_received_cb, g_strdup ("moo"), g_free,
 				  G_TYPE_UINT, 42,
 				  G_TYPE_INVALID);
   dbus_g_connection_flush (connection);
   exit_timeout = g_timeout_add (5000, timed_exit, loop);
   g_main_loop_run (loop);
 
   g_print ("Calling IncrementRetval\n");
   error = NULL;
   v_UINT32_2 = 0;
   if (!dbus_g_proxy_call (proxy, "IncrementRetval", &error,
 			  G_TYPE_UINT, 42,
 			  G_TYPE_INVALID,
 			  G_TYPE_UINT, &v_UINT32_2,
 			  G_TYPE_INVALID))
     lose_gerror ("Failed to complete Increment call", error);
   if (v_UINT32_2 != 43)
     lose ("IncrementRetval call returned %d, should be 43", v_UINT32_2);
 
   g_print ("Calling IncrementRetvalError\n");
   error = NULL;
   v_UINT32_2 = 0;
   if (!dbus_g_proxy_call (proxy, "IncrementRetvalError", &error,
 			  G_TYPE_UINT, 5,
 			  G_TYPE_INVALID,
 			  G_TYPE_UINT, &v_UINT32_2,
 			  G_TYPE_INVALID))
     lose_gerror ("Failed to complete Increment call", error);
   if (v_UINT32_2 != 6)
     lose ("IncrementRetval call returned %d, should be 6", v_UINT32_2);
 
   g_print ("Calling ThrowError\n");
   if (dbus_g_proxy_call (proxy, "ThrowError", &error,
 			 G_TYPE_INVALID, G_TYPE_INVALID) != FALSE)
     lose ("ThrowError call unexpectedly succeeded!");
 
   if (!dbus_g_error_has_name (error, "org.freedesktop.DBus.GLib.Tests.MyObject.Foo"))
     lose ("ThrowError call returned unexpected error \"%s\": %s", dbus_g_error_get_name (error),
 	  error->message);
 
   g_print ("ThrowError failed (as expected) returned error: %s\n", error->message);
   g_clear_error (&error);
 
   g_print ("Calling IncrementRetvalError (for error)\n");
   error = NULL;
   v_UINT32_2 = 0;
   if (dbus_g_proxy_call (proxy, "IncrementRetvalError", &error,
 			 G_TYPE_UINT, 20,
 			 G_TYPE_INVALID,
 			 G_TYPE_UINT, &v_UINT32_2,
 			 G_TYPE_INVALID) != FALSE)
     lose ("IncrementRetvalError call unexpectedly succeeded!");
   if (!dbus_g_error_has_name (error, "org.freedesktop.DBus.GLib.Tests.MyObject.Foo"))
     lose ("IncrementRetvalError call returned unexpected error \"%s\": %s", dbus_g_error_get_name (error), error->message);
   g_clear_error (&error);
 
   error = NULL;
   g_print ("Calling Uppercase\n");
   if (!dbus_g_proxy_call (proxy, "Uppercase", &error,
 			  G_TYPE_STRING, "foobar",
 			  G_TYPE_INVALID,
 			  G_TYPE_STRING, &v_STRING_2,
 			  G_TYPE_INVALID))
     lose_gerror ("Failed to complete Uppercase call", error);
   if (strcmp ("FOOBAR", v_STRING_2) != 0)
     lose ("Uppercase call returned unexpected string %s", v_STRING_2);
   g_free (v_STRING_2);
 
   run_mainloop ();
 
   g_print ("Calling ManyArgs\n");
   if (!dbus_g_proxy_call (proxy, "ManyArgs", &error,
 			  G_TYPE_UINT, 26,
 			  G_TYPE_STRING, "bazwhee",
 			  G_TYPE_DOUBLE, G_PI,
 			  G_TYPE_INVALID,
 			  G_TYPE_DOUBLE, &v_DOUBLE_2,
 			  G_TYPE_STRING, &v_STRING_2,
 			  G_TYPE_INVALID))
     lose_gerror ("Failed to complete ManyArgs call", error);
   if (v_DOUBLE_2 < 55 || v_DOUBLE_2 > 56)
     lose ("ManyArgs call returned unexpected double value %f", v_DOUBLE_2);
   if (strcmp ("BAZWHEE", v_STRING_2) != 0)
     lose ("ManyArgs call returned unexpected string %s", v_STRING_2);
   g_free (v_STRING_2);
 
   g_print ("Calling (wrapped) do_nothing\n");
   if (!org_freedesktop_DBus_GLib_Tests_MyObject_do_nothing (proxy, &error))
     lose_gerror ("Failed to complete (wrapped) DoNothing call", error);
 
   g_print ("Calling (wrapped) increment\n");
   if (!org_freedesktop_DBus_GLib_Tests_MyObject_increment (proxy, 42, &v_UINT32_2, &error))
     lose_gerror ("Failed to complete (wrapped) Increment call", error);
 
   if (v_UINT32_2 != 43)
     lose ("(wrapped) increment call returned %d, should be 43", v_UINT32_2);
 
   g_print ("Calling (wrapped async) increment\n");
   if (!org_freedesktop_DBus_GLib_Tests_MyObject_increment_async (proxy, 42, increment_async_cb, NULL))
     lose_gerror ("Failed to complete (wrapped) Increment call", error);
   dbus_g_connection_flush (connection);
   exit_timeout = g_timeout_add (5000, timed_exit, loop);
   g_main_loop_run (loop);
 
   v_UINT32_2 = 0;
   if (!org_freedesktop_DBus_GLib_Tests_MyObject_async_increment (proxy, 42, &v_UINT32_2, &error))
     lose_gerror ("Failed to complete (wrapped) AsyncIncrement call", error);
 
   if (v_UINT32_2 != 43)
     lose ("(wrapped) async increment call returned %d, should be 43", v_UINT32_2);
 
   g_print ("Calling (wrapped) throw_error\n");
   if (org_freedesktop_DBus_GLib_Tests_MyObject_throw_error (proxy, &error) != FALSE)
     lose ("(wrapped) ThrowError call unexpectedly succeeded!");
 
   g_print ("(wrapped) ThrowError failed (as expected) returned error: %s\n", error->message);
   g_clear_error (&error);
 
   if (org_freedesktop_DBus_GLib_Tests_MyObject_async_throw_error (proxy, &error) != FALSE)
     lose ("(wrapped) AsyncThrowError call unexpectedly succeeded!");
 
   g_print ("(wrapped) AsyncThrowError failed (as expected) returned error: %s\n", error->message);
   g_clear_error (&error);
 
   g_print ("Calling (wrapped) uppercase\n");
   if (!org_freedesktop_DBus_GLib_Tests_MyObject_uppercase (proxy, "foobar", &v_STRING_2, &error)) 
     lose_gerror ("Failed to complete (wrapped) Uppercase call", error);
   if (strcmp ("FOOBAR", v_STRING_2) != 0)
     lose ("(wrapped) Uppercase call returned unexpected string %s", v_STRING_2);
   g_free (v_STRING_2);
 
   g_print ("Calling (wrapped) many_args\n");
   if (!org_freedesktop_DBus_GLib_Tests_MyObject_many_args (proxy, 26, "bazwhee", G_PI,
 						      &v_DOUBLE_2, &v_STRING_2, &error))
     lose_gerror ("Failed to complete (wrapped) ManyArgs call", error);
 
   if (v_DOUBLE_2 < 55 || v_DOUBLE_2 > 56)
     
     lose ("(wrapped) ManyArgs call returned unexpected double value %f", v_DOUBLE_2);
 
   if (strcmp ("BAZWHEE", v_STRING_2) != 0)
     lose ("(wrapped) ManyArgs call returned unexpected string %s", v_STRING_2);
   g_free (v_STRING_2);
 
   {
     guint32 arg0;
     char *arg1;
     gint32 arg2;
     guint32 arg3;
     guint32 arg4;
     char *arg5;
     
     g_print ("Calling (wrapped) many_return\n");
     if (!org_freedesktop_DBus_GLib_Tests_MyObject_many_return (proxy, &arg0, &arg1, &arg2, &arg3, &arg4, &arg5, &error))
       lose_gerror ("Failed to complete (wrapped) ManyReturn call", error);
 
     if (arg0 != 42)
       lose ("(wrapped) ManyReturn call returned unexpected guint32 value %u", arg0);
 
     if (strcmp ("42", arg1) != 0)
       lose ("(wrapped) ManyReturn call returned unexpected string %s", arg1);
     g_free (arg1);
 
     if (arg2 != -67)
       lose ("(wrapped) ManyReturn call returned unexpected gint32 value %u", arg2);
 
     if (arg3 != 2)
       lose ("(wrapped) ManyReturn call returned unexpected guint32 value %u", arg3);
 
     if (arg4 != 26)
       lose ("(wrapped) ManyReturn call returned unexpected guint32 value %u", arg4);
 
     if (strcmp ("hello world", arg5))
       lose ("(wrapped) ManyReturn call returned unexpected string %s", arg5);
     g_free (arg5);
   }
 
   run_mainloop ();
 
   {
     GValue value = {0, };
 
     g_value_init (&value, G_TYPE_STRING);
     g_value_set_string (&value, "foo");
 
     g_print ("Calling (wrapped) stringify, with string\n");
     if (!org_freedesktop_DBus_GLib_Tests_MyObject_stringify (proxy,
 							&value,
 							&v_STRING_2,
 							&error))
       lose_gerror ("Failed to complete (wrapped) stringify call", error);
     if (strcmp ("foo", v_STRING_2) != 0)
       lose ("(wrapped) stringify call returned unexpected string %s", v_STRING_2);
     g_free (v_STRING_2);
 
     g_value_unset (&value);
     g_value_init (&value, G_TYPE_INT);
     g_value_set_int (&value, 42);
 
     g_print ("Calling (wrapped) stringify, with int\n");
     if (!org_freedesktop_DBus_GLib_Tests_MyObject_stringify (proxy,
 							&value,
 							&v_STRING_2,
 							&error))
       lose_gerror ("Failed to complete (wrapped) stringify call 2", error);
     if (strcmp ("42", v_STRING_2) != 0)
       lose ("(wrapped) stringify call 2 returned unexpected string %s", v_STRING_2);
     g_value_unset (&value);
     g_free (v_STRING_2);
 
     g_value_init (&value, G_TYPE_INT);
     g_value_set_int (&value, 88);
     g_print ("Calling (wrapped) stringify, with another int\n");
     if (!org_freedesktop_DBus_GLib_Tests_MyObject_stringify (proxy,
 							&value,
 							NULL,
 							&error))
       lose_gerror ("Failed to complete (wrapped) stringify call 3", error);
     g_value_unset (&value);
 
     g_print ("Calling (wrapped) unstringify, for string\n");
     if (!org_freedesktop_DBus_GLib_Tests_MyObject_unstringify (proxy,
 							  "foo",
 							  &value,
 							  &error))
       lose_gerror ("Failed to complete (wrapped) unstringify call", error);
     if (!G_VALUE_HOLDS_STRING (&value))
       lose ("(wrapped) unstringify call returned unexpected value type %d", (int) G_VALUE_TYPE (&value));
     if (strcmp (g_value_get_string (&value), "foo"))
       lose ("(wrapped) unstringify call returned unexpected string %s",
 	    g_value_get_string (&value));
 	
     g_value_unset (&value);
 
     g_print ("Calling (wrapped) unstringify, for int\n");
     if (!org_freedesktop_DBus_GLib_Tests_MyObject_unstringify (proxy,
 							  "10",
 							  &value,
 							  &error))
       lose_gerror ("Failed to complete (wrapped) unstringify call", error);
     if (!G_VALUE_HOLDS_INT (&value))
       lose ("(wrapped) unstringify call returned unexpected value type %d", (int) G_VALUE_TYPE (&value));
     if (g_value_get_int (&value) != 10)
       lose ("(wrapped) unstringify call returned unexpected integer %d",
 	    g_value_get_int (&value));
 
     g_value_unset (&value);
   }
 
   run_mainloop ();
 
   {
     GArray *array;
     guint32 arraylen;
 
     array = g_array_new (FALSE, TRUE, sizeof (guint32));
 
     arraylen = 0;
     g_print ("Calling (wrapped) zero-length recursive1\n");
     if (!org_freedesktop_DBus_GLib_Tests_MyObject_recursive1 (proxy, array,
 							 &arraylen, &error))
       lose_gerror ("Failed to complete (wrapped) zero-length recursive1 call", error);
     if (arraylen != 0)
       lose ("(wrapped) zero-length recursive1 call returned invalid length %u", arraylen);
   }
 
   {
     GArray *array;
     guint32 val;
     guint32 arraylen;
 
     array = g_array_new (FALSE, TRUE, sizeof (guint32));
     val = 42;
     g_array_append_val (array, val);
     val = 69;
     g_array_append_val (array, val);
     val = 88;
     g_array_append_val (array, val);
     val = 26;
     g_array_append_val (array, val);
     val = 2;
     g_array_append_val (array, val);
 
     arraylen = 0;
     g_print ("Calling (wrapped) recursive1\n");
     if (!org_freedesktop_DBus_GLib_Tests_MyObject_recursive1 (proxy, array,
 							 &arraylen, &error))
       lose_gerror ("Failed to complete (wrapped) recursive1 call", error);
     if (arraylen != 5)
       lose ("(wrapped) recursive1 call returned invalid length %u", arraylen);
   }
 
   {
     GArray *array = NULL;
     guint32 *arrayvals;
     
     g_print ("Calling (wrapped) recursive2\n");
     if (!org_freedesktop_DBus_GLib_Tests_MyObject_recursive2 (proxy, 2, &array, &error))
       lose_gerror ("Failed to complete (wrapped) Recursive2 call", error);
 
     if (array == NULL)
       lose ("(wrapped) Recursive2 call returned NULL");
     if (array->len != 5)
       lose ("(wrapped) Recursive2 call returned unexpected array length %u", array->len);
 
     arrayvals = (guint32*) array->data;
     if (arrayvals[0] != 42)
       lose ("(wrapped) Recursive2 call returned unexpected value %d in position 0", arrayvals[0]);
     if (arrayvals[1] != 26)
       lose ("(wrapped) Recursive2 call returned unexpected value %d in position 1", arrayvals[1]);
     if (arrayvals[4] != 2)
       lose ("(wrapped) Recursive2 call returned unexpected value %d in position 4", arrayvals[4]);
 
     g_array_free (array, TRUE);
   }
 
   run_mainloop ();
 
   {
     const char *strs[] = { "hello", "HellO", "HELLO", NULL };
     char **strs_ret;
 
     strs_ret = NULL;
     g_print ("Calling (wrapped) many_uppercase\n");
     if (!org_freedesktop_DBus_GLib_Tests_MyObject_many_uppercase (proxy, strs, &strs_ret, &error)) 
       lose_gerror ("Failed to complete (wrapped) ManyUppercase call", error);
     g_assert (strs_ret != NULL);
     if (strcmp ("HELLO", strs_ret[0]) != 0)
       lose ("(wrapped) ManyUppercase call returned unexpected string %s", strs_ret[0]);
     if (strcmp ("HELLO", strs_ret[1]) != 0)
       lose ("(wrapped) ManyUppercase call returned unexpected string %s", strs_ret[1]);
     if (strcmp ("HELLO", strs_ret[2]) != 0)
       lose ("(wrapped) ManyUppercase call returned unexpected string %s", strs_ret[2]);
 
     g_strfreev (strs_ret);
   }
 
   {
     GHashTable *table;
     guint len;
 
     table = g_hash_table_new (g_str_hash, g_str_equal);
     g_hash_table_insert (table, "moooo", "b");
     g_hash_table_insert (table, "xxx", "cow!");
 
     len = 0;
     g_print ("Calling (wrapped) str_hash_len\n");
     if (!org_freedesktop_DBus_GLib_Tests_MyObject_str_hash_len (proxy, table, &len, &error))
       lose_gerror ("(wrapped) StrHashLen call failed", error);
     if (len != 13) 
       lose ("(wrapped) StrHashLen returned unexpected length %u", len);
     g_hash_table_destroy (table);
   }
 
   {
     GHashTable *table;
     const char *val;
 
     g_print ("Calling (wrapped) get_hash\n");
     if (!org_freedesktop_DBus_GLib_Tests_MyObject_get_hash (proxy, &table, &error))
       lose_gerror ("(wrapped) GetHash call failed", error);
     val = g_hash_table_lookup (table, "foo");
     if (val == NULL || strcmp ("bar", val))
       lose ("(wrapped) StrHashLen returned invalid value %s for key \"foo\"",
 	    val ? val : "(null)");
     val = g_hash_table_lookup (table, "baz");
     if (val == NULL || strcmp ("whee", val))
       lose ("(wrapped) StrHashLen returned invalid value %s for key \"whee\"",
 	    val ? val : "(null)");
     val = g_hash_table_lookup (table, "cow");
     if (val == NULL || strcmp ("crack", val))
       lose ("(wrapped) StrHashLen returned invalid value %s for key \"cow\"",
 	    val ? val : "(null)");
     if (g_hash_table_size (table) != 3)
       lose ("(wrapped) StrHashLen returned unexpected hash size %u",
 	    g_hash_table_size (table));
 
     g_hash_table_destroy (table);
   }
 
   run_mainloop ();
 
   {
     GValueArray *vals;
     GValueArray *vals_ret;
     GValue *val;
 
     vals = g_value_array_new (3);
 
     g_value_array_append (vals, NULL);
     g_value_init (g_value_array_get_nth (vals, vals->n_values - 1), G_TYPE_STRING);
     g_value_set_string (g_value_array_get_nth (vals, 0), "foo");
 
     g_value_array_append (vals, NULL);
     g_value_init (g_value_array_get_nth (vals, vals->n_values - 1), G_TYPE_UINT);
     g_value_set_uint (g_value_array_get_nth (vals, vals->n_values - 1), 42);
 
     g_value_array_append (vals, NULL);
     g_value_init (g_value_array_get_nth (vals, vals->n_values - 1), G_TYPE_VALUE);
     val = g_new0 (GValue, 1);
     g_value_init (val, G_TYPE_UCHAR);
     g_value_set_uchar (val, '!');
     g_value_set_boxed (g_value_array_get_nth (vals, vals->n_values - 1), val);
 
     vals_ret = NULL;
     g_print ("Calling SendCar\n");
     if (!dbus_g_proxy_call (proxy, "SendCar", &error,
 			    G_TYPE_VALUE_ARRAY, vals,
 			    G_TYPE_INVALID,
 			    G_TYPE_VALUE_ARRAY, &vals_ret,
 			    G_TYPE_INVALID))
       lose_gerror ("Failed to complete SendCar call", error);
 
     g_assert (vals_ret != NULL);
     g_assert (vals_ret->n_values == 2);
 
     g_assert (G_VALUE_HOLDS_UINT (g_value_array_get_nth (vals_ret, 0)));
     g_assert (g_value_get_uint (g_value_array_get_nth (vals_ret, 0)) == 43);
     
     g_assert (G_VALUE_TYPE (g_value_array_get_nth (vals_ret, 1)) == DBUS_TYPE_G_OBJECT_PATH);
     g_assert (!strcmp ("/org/freedesktop/DBus/GLib/Tests/MyTestObject2",
 		       g_value_get_boxed (g_value_array_get_nth (vals_ret, 1))));
 
     g_value_array_free (vals);
     g_value_array_free (vals_ret);
   }
 
   {
     GValue *val;
     GHashTable *table;
     GHashTable *ret_table;
 
     table = g_hash_table_new_full (g_str_hash, g_str_equal,
 				   g_free, unset_and_free_gvalue);
     
     val = g_new0 (GValue, 1);
     g_value_init (val, G_TYPE_UINT);
     g_value_set_uint (val, 42);
     g_hash_table_insert (table, g_strdup ("foo"), val);
 
     val = g_new0 (GValue, 1);
     g_value_init (val, G_TYPE_STRING);
     g_value_set_string (val, "hello");
     g_hash_table_insert (table, g_strdup ("bar"), val);
 
     ret_table = NULL;
     g_print ("Calling ManyStringify\n");
     if (!dbus_g_proxy_call (proxy, "ManyStringify", &error,
 			    dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE), table,
 			    G_TYPE_INVALID,
 			    dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE), &ret_table,
 			    G_TYPE_INVALID))
       lose_gerror ("Failed to complete ManyStringify call", error);
 
     g_assert (ret_table != NULL);
     g_assert (g_hash_table_size (ret_table) == 2);
 
     val = g_hash_table_lookup (ret_table, "foo");
     g_assert (val != NULL);
     g_assert (G_VALUE_HOLDS_STRING (val));
     g_assert (!strcmp ("42", g_value_get_string (val)));
 
     val = g_hash_table_lookup (ret_table, "bar");
     g_assert (val != NULL);
     g_assert (G_VALUE_HOLDS_STRING (val));
     g_assert (!strcmp ("hello", g_value_get_string (val)));
 
     g_hash_table_destroy (table);
     g_hash_table_destroy (ret_table);
   }
 
   {
     GPtrArray *in_array;
     GPtrArray *out_array;
     char **strs;
     GArray *uints;
 
     in_array = g_ptr_array_new ();
 
     strs = g_new0 (char *, 3);
     strs[0] = "foo";
     strs[1] = "bar";
     strs[2] = NULL;
     g_ptr_array_add (in_array, strs);
 
     strs = g_new0 (char *, 4);
     strs[0] = "baz";
     strs[1] = "whee";
     strs[2] = "moo";
     strs[3] = NULL;
     g_ptr_array_add (in_array, strs);
 
     out_array = NULL;
     g_print ("Calling RecArrays\n");
     if (!dbus_g_proxy_call (proxy, "RecArrays", &error,
 			    dbus_g_type_get_collection ("GPtrArray", G_TYPE_STRV), in_array,
 			    G_TYPE_INVALID,
 			    dbus_g_type_get_collection ("GPtrArray",
 							dbus_g_type_get_collection ("GPtrArray",
 										    G_TYPE_UINT)), &out_array, 
 			    G_TYPE_INVALID))
       lose_gerror ("Failed to complete RecArrays call", error);
     g_free (g_ptr_array_index (in_array, 0));
     g_free (g_ptr_array_index (in_array, 1));
 
     g_assert (out_array);
     g_assert (out_array->len == 2);
     uints = g_ptr_array_index (out_array, 0);
     g_assert (uints);
     g_assert (uints->len == 3);
     g_assert (g_array_index (uints, guint, 0) == 10);
     g_assert (g_array_index (uints, guint, 1) == 42);
     g_assert (g_array_index (uints, guint, 2) == 27);
     g_array_free (uints, TRUE);
     uints = g_ptr_array_index (out_array, 1);
     g_assert (uints);
     g_assert (uints->len == 1);
     g_assert (g_array_index (uints, guint, 0) == 30);
     g_array_free (uints, TRUE);
     g_ptr_array_free (out_array, TRUE);
   }
 
   {
     guint val;
     char *ret_path;
     DBusGProxy *ret_proxy;
 
     g_print ("Calling (wrapped) objpath\n");
     if (!dbus_g_proxy_call (proxy, "Objpath", &error,
 			    DBUS_TYPE_G_PROXY, proxy, G_TYPE_INVALID,
 			    DBUS_TYPE_G_PROXY, &ret_proxy, G_TYPE_INVALID))
       lose_gerror ("Failed to complete Objpath call", error);
     if (strcmp ("/org/freedesktop/DBus/GLib/Tests/MyTestObject2",
 		dbus_g_proxy_get_path (ret_proxy)) != 0)
       lose ("(wrapped) objpath call returned unexpected proxy %s",
 	    dbus_g_proxy_get_path (ret_proxy));
 
     g_print ("Doing get/increment val tests\n");
     val = 1;
     if (!org_freedesktop_DBus_GLib_Tests_MyObject_get_val (ret_proxy, &val, &error))
       lose_gerror ("Failed to complete (wrapped) GetVal call", error);
     if (val != 0)
       lose ("(wrapped) GetVal returned invalid value %d", val);
 
     if (!org_freedesktop_DBus_GLib_Tests_MyObject_increment_val (ret_proxy, &error))
       lose_gerror ("Failed to complete (wrapped) IncrementVal call", error);
 
     if (!org_freedesktop_DBus_GLib_Tests_MyObject_increment_val (ret_proxy, &error))
       lose_gerror ("Failed to complete (wrapped) IncrementVal call", error);
 
     if (!org_freedesktop_DBus_GLib_Tests_MyObject_increment_val (ret_proxy, &error))
       lose_gerror ("Failed to complete (wrapped) IncrementVal call", error);
 
     if (!org_freedesktop_DBus_GLib_Tests_MyObject_get_val (ret_proxy, &val, &error))
       lose_gerror ("Failed to complete (wrapped) GetVal call", error);
     if (val != 3)
       lose ("(wrapped) GetVal returned invalid value %d", val);
 
     if (!org_freedesktop_DBus_GLib_Tests_MyObject_get_val (proxy, &val, &error))
       lose_gerror ("Failed to complete (wrapped) GetVal call", error);
     if (val != 0)
       lose ("(wrapped) GetVal returned invalid value %d", val);
 
     if (!org_freedesktop_DBus_GLib_Tests_MyObject_increment_val (proxy, &error))
       lose_gerror ("Failed to complete (wrapped) IncrementVal call", error);
 
     if (!org_freedesktop_DBus_GLib_Tests_MyObject_get_val (proxy, &val, &error))
       lose_gerror ("Failed to complete (wrapped) GetVal call", error);
     if (val != 1)
       lose ("(wrapped) GetVal returned invalid value %d", val);
 
     if (!org_freedesktop_DBus_GLib_Tests_MyObject_get_val (ret_proxy, &val, &error))
       lose_gerror ("Failed to complete (wrapped) GetVal call", error);
     if (val != 3)
       lose ("(wrapped) GetVal returned invalid value %d", val);
 
     g_object_unref (G_OBJECT (ret_proxy));
 
     g_print ("Calling objpath again\n");
     ret_proxy = NULL;
 
     if (!dbus_g_proxy_call (proxy, "Objpath", &error,
 			    DBUS_TYPE_G_OBJECT_PATH,
 			    dbus_g_proxy_get_path (proxy),
 			    G_TYPE_INVALID,
 			    DBUS_TYPE_G_OBJECT_PATH,
 			    &ret_path,
 			    G_TYPE_INVALID))
       lose_gerror ("Failed to complete Objpath call 2", error);
     if (strcmp ("/org/freedesktop/DBus/GLib/Tests/MyTestObject2", ret_path) != 0)
       lose ("Objpath call 2 returned unexpected path %s",
 	    ret_path);
 
     ret_proxy = dbus_g_proxy_new_for_name_owner (connection,
 						 "org.freedesktop.DBus.GLib.TestService",
 						 ret_path,
 						 "org.freedesktop.DBus.GLib.Tests.FooObject",
 						 &error);
     g_free (ret_path);
     
     val = 0;
     if (!org_freedesktop_DBus_GLib_Tests_FooObject_get_value (ret_proxy, &val, &error))
       lose_gerror ("Failed to complete (wrapped) GetValue call", error);
     if (val != 3)
       lose ("(wrapped) GetValue returned invalid value %d", val);
   }
 
   run_mainloop ();
 
   {
     GPtrArray *objs;
     guint i;
 
     g_print ("Calling GetObjs\n");
 
     if (!dbus_g_proxy_call (proxy, "GetObjs", &error, G_TYPE_INVALID,
 			    dbus_g_type_get_collection ("GPtrArray", DBUS_TYPE_G_OBJECT_PATH),
 			    &objs,
 			    G_TYPE_INVALID))
       lose_gerror ("Failed to complete GetObjs call", error);
     if (objs->len != 2)
       lose ("GetObjs call returned unexpected number of objects %d, expected 2",
 	    objs->len);
 
     if (strcmp ("/org/freedesktop/DBus/GLib/Tests/MyTestObject",
 		g_ptr_array_index (objs, 0)) != 0)
       lose ("GetObjs call returned unexpected path \"%s\" in position 0; expected /org/freedesktop/DBus/GLib/Tests/MyTestObject", (char*) g_ptr_array_index (objs, 0));
 
     if (strcmp ("/org/freedesktop/DBus/GLib/Tests/MyTestObject2",
 		g_ptr_array_index (objs, 1)) != 0)
       lose ("GetObjs call returned unexpected path \"%s\" in position 1; expected /org/freedesktop/DBus/GLib/Tests/MyTestObject2", (char*) g_ptr_array_index (objs, 1));
 
     for (i = 0; i < objs->len; i++)
       g_free (g_ptr_array_index (objs, i));
     g_ptr_array_free (objs, TRUE);
   }
   
   {
     GValue *variant;
     GArray *array;
     gint i;
 
     g_print ("Calling ProcessVariantOfArrayOfInts123\n");
 
     array = g_array_sized_new (FALSE, FALSE, sizeof(gint), 3);
     i = 1;
     g_array_append_val (array, i);
     i++;
     g_array_append_val (array, i);
     i++;
     g_array_append_val (array, i);
 
     variant = g_new0 (GValue, 1);
     g_value_init (variant, dbus_g_type_get_collection ("GArray", G_TYPE_INT));
     g_value_set_boxed_take_ownership (variant, array);
 
     if (!dbus_g_proxy_call (proxy, "ProcessVariantOfArrayOfInts123", &error,
                             G_TYPE_VALUE, variant,
                             G_TYPE_INVALID,
 			    G_TYPE_INVALID))
       lose_gerror ("Failed to send a vairant of array of ints 1, 2 and 3!", error);
 
     g_value_unset (variant);
   }
 
   for (i=0; i<3; i++)
   {
     gchar *val;
     GHashTable *table;
     GHashTable *subtable;
     GHashTable *ret_table;
 
     table = g_hash_table_new_full (g_str_hash, g_str_equal,
 				   (GDestroyNotify) (g_free),
                                    (GDestroyNotify) (g_hash_table_destroy));
 
     subtable = g_hash_table_new_full (g_str_hash, g_str_equal,
                                       (GDestroyNotify) (g_free),
                                       (GDestroyNotify) (g_free));
     g_hash_table_insert (subtable, g_strdup ("foo"), g_strdup("1"));
     g_hash_table_insert (subtable, g_strdup ("bar"), g_strdup("2"));
     g_hash_table_insert (subtable, g_strdup ("baz"), g_strdup("3"));
 
     g_hash_table_insert (table, g_strdup("dict1"), subtable);
 
     subtable = g_hash_table_new_full (g_str_hash, g_str_equal,
                                       (GDestroyNotify) (g_free),
                                       (GDestroyNotify) (g_free));
     g_hash_table_insert (subtable, g_strdup ("foo"), g_strdup("4"));
     g_hash_table_insert (subtable, g_strdup ("bar"), g_strdup("5"));
     g_hash_table_insert (subtable, g_strdup ("baz"), g_strdup("6"));
 
     g_hash_table_insert (table, g_strdup("dict2"), subtable);
 
     subtable = NULL;
 
     ret_table = NULL;
 
     g_print ("Calling DictOfDicts\n");
     if (!dbus_g_proxy_call (proxy, "DictOfDicts", &error,
 			    dbus_g_type_get_map ("GHashTable", G_TYPE_STRING,
                               dbus_g_type_get_map ("GHashTable", G_TYPE_STRING,
                                 G_TYPE_STRING)), table,
 			    G_TYPE_INVALID,
 			    dbus_g_type_get_map ("GHashTable", G_TYPE_STRING,
                               dbus_g_type_get_map ("GHashTable", G_TYPE_STRING,
                                 G_TYPE_STRING)), &ret_table,
 			    G_TYPE_INVALID))
       lose_gerror ("Failed to complete DictOfDicts call", error);
 
     g_assert (ret_table != NULL);
     g_assert (g_hash_table_size (ret_table) == 2);
 
     subtable = g_hash_table_lookup (ret_table, "dict1");
     g_assert(subtable);
     g_assert (g_hash_table_size (subtable) == 3);
 
     val = g_hash_table_lookup (subtable, "foo");
     g_assert (val != NULL);
     g_assert (!strcmp ("dict1 1", val));
 
     val = g_hash_table_lookup (subtable, "bar");
     g_assert (val != NULL);
     g_assert (!strcmp ("dict1 2", val));
 
     val = g_hash_table_lookup (subtable, "baz");
     g_assert (val != NULL);
     g_assert (!strcmp ("dict1 3", val));
 
     subtable = g_hash_table_lookup (ret_table, "dict2");
     g_assert(subtable);
     g_assert (g_hash_table_size (subtable) == 3);
 
     val = g_hash_table_lookup (subtable, "foo");
     g_assert (val != NULL);
     g_assert (!strcmp ("dict2 4", val));
 
     val = g_hash_table_lookup (subtable, "bar");
     g_assert (val != NULL);
     g_assert (!strcmp ("dict2 5", val));
 
     val = g_hash_table_lookup (subtable, "baz");
     g_assert (val != NULL);
     g_assert (!strcmp ("dict2 6", val));
 
     g_hash_table_destroy (table);
     g_hash_table_destroy (ret_table);
 
     g_mem_profile ();
   }
 
 
 
   /* Signal handling tests */
   
   g_print ("Testing signal handling\n");
   dbus_g_proxy_add_signal (proxy, "Frobnicate", G_TYPE_INT, G_TYPE_INVALID);
   
   dbus_g_proxy_connect_signal (proxy, "Frobnicate",
                                G_CALLBACK (frobnicate_signal_handler),
                                NULL, NULL);
   
   g_print ("Calling EmitFrobnicate\n");
   if (!dbus_g_proxy_call (proxy, "EmitFrobnicate", &error,
 			  G_TYPE_INVALID, G_TYPE_INVALID))
     lose_gerror ("Failed to complete EmitFrobnicate call", error);
 
   
   dbus_g_connection_flush (connection);
   exit_timeout = g_timeout_add (5000, timed_exit, loop);
   g_main_loop_run (loop);
 
   if (n_times_frobnicate_received != 1)
     lose ("Frobnicate signal received %d times, should have been 1", n_times_frobnicate_received);
 
   g_print ("Calling EmitFrobnicate again\n");
   if (!dbus_g_proxy_call (proxy, "EmitFrobnicate", &error,
 			  G_TYPE_INVALID, G_TYPE_INVALID))
     lose_gerror ("Failed to complete EmitFrobnicate call", error);
   
   dbus_g_connection_flush (connection);
   exit_timeout = g_timeout_add (5000, timed_exit, loop);
   g_main_loop_run (loop);
 
   if (n_times_frobnicate_received != 2)
     lose ("Frobnicate signal received %d times, should have been 2", n_times_frobnicate_received);
 
   g_object_unref (G_OBJECT (proxy));
 
   run_mainloop ();
 
   g_print ("Creating proxy for FooObject interface\n");
   proxy = dbus_g_proxy_new_for_name_owner (connection,
                                            "org.freedesktop.DBus.GLib.TestService",
                                            "/org/freedesktop/DBus/GLib/Tests/MyTestObject",
                                            "org.freedesktop.DBus.GLib.Tests.FooObject",
                                            &error);
   
   if (proxy == NULL)
     lose_gerror ("Failed to create proxy for name owner", error);
 
   dbus_g_object_register_marshaller (my_object_marshal_VOID__STRING_INT_STRING, 
 				     G_TYPE_NONE, G_TYPE_STRING, G_TYPE_INT, G_TYPE_STRING, G_TYPE_INVALID);
 
   dbus_g_object_register_marshaller (my_object_marshal_VOID__STRING_BOXED, 
 				     G_TYPE_NONE, G_TYPE_STRING, G_TYPE_VALUE, G_TYPE_INVALID);
 
   dbus_g_proxy_add_signal (proxy, "Sig0", G_TYPE_STRING, G_TYPE_INT, G_TYPE_STRING, G_TYPE_INVALID);
   dbus_g_proxy_add_signal (proxy, "Sig1", G_TYPE_STRING, G_TYPE_VALUE, G_TYPE_INVALID);
   dbus_g_proxy_add_signal (proxy, "Sig2", DBUS_TYPE_G_STRING_STRING_HASHTABLE, G_TYPE_INVALID);
   
   dbus_g_proxy_connect_signal (proxy, "Sig0",
                                G_CALLBACK (sig0_signal_handler),
                                NULL, NULL);
   dbus_g_proxy_connect_signal (proxy, "Sig1",
                                G_CALLBACK (sig1_signal_handler),
                                NULL, NULL);
   dbus_g_proxy_connect_signal (proxy, "Sig2",
                                G_CALLBACK (sig2_signal_handler),
                                NULL, NULL);
 
   g_print ("Calling FooObject EmitSignals\n");
   dbus_g_proxy_call_no_reply (proxy, "EmitSignals", G_TYPE_INVALID);
 
   dbus_g_connection_flush (connection);
   exit_timeout = g_timeout_add (5000, timed_exit, loop);
   g_main_loop_run (loop);
   exit_timeout = g_timeout_add (5000, timed_exit, loop);
   g_main_loop_run (loop);
 
   if (n_times_sig0_received != 1)
     lose ("Sig0 signal received %d times, should have been 1", n_times_sig0_received);
   if (n_times_sig1_received != 1)
     lose ("Sig1 signal received %d times, should have been 1", n_times_sig1_received);
 
   g_print ("Calling FooObject EmitSignals and EmitSignal2\n");
   dbus_g_proxy_call_no_reply (proxy, "EmitSignal2", G_TYPE_INVALID);
   dbus_g_connection_flush (connection);
 
   exit_timeout = g_timeout_add (5000, timed_exit, loop);
   g_main_loop_run (loop);
 
   if (n_times_sig2_received != 1)
     lose ("Sig2 signal received %d times, should have been 1", n_times_sig2_received);
 
   g_print ("Calling FooObject EmitSignals two more times\n");
   dbus_g_proxy_call_no_reply (proxy, "EmitSignals", G_TYPE_INVALID);
   dbus_g_proxy_call_no_reply (proxy, "EmitSignals", G_TYPE_INVALID);
 
   dbus_g_connection_flush (connection);
   exit_timeout = g_timeout_add (5000, timed_exit, loop);
   g_main_loop_run (loop);
   exit_timeout = g_timeout_add (5000, timed_exit, loop);
   g_main_loop_run (loop);
   exit_timeout = g_timeout_add (5000, timed_exit, loop);
   g_main_loop_run (loop);
   exit_timeout = g_timeout_add (5000, timed_exit, loop);
   g_main_loop_run (loop);
 
   if (n_times_sig0_received != 3)
     lose ("Sig0 signal received %d times, should have been 3", n_times_sig0_received);
   if (n_times_sig1_received != 3)
     lose ("Sig1 signal received %d times, should have been 3", n_times_sig1_received);
 
   /* Terminate again */
   g_print ("Terminating service\n");
   await_terminating_service = "org.freedesktop.DBus.GLib.TestService";
   dbus_g_proxy_call_no_reply (proxy, "Terminate", G_TYPE_INVALID);
 
   proxy_destroyed = FALSE;
   proxy_destroy_and_nameowner = TRUE;
   proxy_destroy_and_nameowner_complete = FALSE;
 
   g_signal_connect (G_OBJECT (proxy),
 		    "destroy",
 		    G_CALLBACK (proxy_destroyed_cb),
 		    NULL);
 
   dbus_g_connection_flush (connection);
   exit_timeout = g_timeout_add (5000, timed_exit, loop);
   g_main_loop_run (loop);
 
   if (await_terminating_service != NULL)
     lose ("Didn't see name loss for \"org.freedesktop.DBus.GLib.TestService\"");
   if (!proxy_destroyed)
     lose ("Didn't get proxy_destroyed");
   g_print ("Proxy destroyed successfully\n");
 
   /* Don't need to unref, proxy was destroyed */
 
   run_mainloop ();
 
   /* Create a new proxy for the name; should not be associated */
   proxy = dbus_g_proxy_new_for_name (connection,
 				     "org.freedesktop.DBus.GLib.TestService",
 				     "/org/freedesktop/DBus/GLib/Tests/MyTestObject",
 				     "org.freedesktop.DBus.GLib.Tests.MyObject");
   g_assert (proxy != NULL);
 
   proxy_destroyed = FALSE;
   proxy_destroy_and_nameowner = FALSE;
   proxy_destroy_and_nameowner_complete = FALSE;
 
   g_signal_connect (G_OBJECT (proxy),
 		    "destroy",
 		    G_CALLBACK (proxy_destroyed_cb),
 		    NULL);
   
   if (!dbus_g_proxy_call (driver, "GetNameOwner", &error,
 			  G_TYPE_STRING,
 			  "org.freedesktop.DBus.GLib.TestService",
 			  G_TYPE_INVALID,
 			  G_TYPE_STRING,
 			  &v_STRING_2,
 			  G_TYPE_INVALID)) {
     if (error->domain == DBUS_GERROR && error->code == DBUS_GERROR_NAME_HAS_NO_OWNER)
       g_print ("Got expected error \"org.freedesktop.DBus.Error.NameHasNoOwner\"\n");
     else
       lose_gerror ("Unexpected error from GetNameOwner", error);
   } else
     lose ("GetNameOwner unexpectedly succeeded!");
   g_clear_error (&error);
 
   /* This will have the side-effect of activating the service, thus
    * causing a NameOwnerChanged, which should let our name proxy
    * get signals
    */
   g_print ("Calling Uppercase for name proxy\n");
   if (!dbus_g_proxy_call (proxy, "Uppercase", &error,
 			  G_TYPE_STRING, "bazwhee",
 			  G_TYPE_INVALID,
 			  G_TYPE_STRING, &v_STRING_2,
 			  G_TYPE_INVALID))
     lose_gerror ("Failed to complete Uppercase call", error);
   g_free (v_STRING_2);
 
   if (getenv ("DBUS_GLIB_TEST_SLEEP_AFTER_ACTIVATION1"))
     g_usleep (8 * G_USEC_PER_SEC);
 
   dbus_g_proxy_add_signal (proxy, "Frobnicate", G_TYPE_INT, G_TYPE_INVALID);
   
   dbus_g_proxy_connect_signal (proxy, "Frobnicate",
                                G_CALLBACK (frobnicate_signal_handler),
                                NULL, NULL);
   
   g_print ("Calling EmitFrobnicate\n");
   if (!dbus_g_proxy_call (proxy, "EmitFrobnicate", &error,
 			  G_TYPE_INVALID, G_TYPE_INVALID))
     lose_gerror ("Failed to complete EmitFrobnicate call", error);
 
   n_times_frobnicate_received = 0;
 
   dbus_g_connection_flush (connection);
   exit_timeout = g_timeout_add (5000, timed_exit, loop);
   g_main_loop_run (loop);
 
   if (n_times_frobnicate_received != 1)
     lose ("Frobnicate signal received %d times, should have been 1", n_times_frobnicate_received);
 
   /* Now terminate the service, then start it again (implicitly) and wait for signals */
   g_print ("Terminating service (2)\n");
   await_terminating_service = "org.freedesktop.DBus.GLib.TestService";
   dbus_g_proxy_call_no_reply (proxy, "Terminate", G_TYPE_INVALID);
   dbus_g_connection_flush (connection);
   exit_timeout = g_timeout_add (5000, timed_exit, loop);
   g_main_loop_run (loop);
   if (await_terminating_service != NULL)
     lose ("Didn't see name loss for \"org.freedesktop.DBus.GLib.TestService\"");
 
   if (proxy_destroyed)
     lose ("Unexpectedly got proxy_destroyed!");
 
   n_times_frobnicate_received = 0;
 
   g_print ("Calling EmitFrobnicate (2)\n");
   if (!dbus_g_proxy_call (proxy, "EmitFrobnicate", &error,
 			  G_TYPE_INVALID, G_TYPE_INVALID))
     lose_gerror ("Failed to complete EmitFrobnicate call", error);
 
   if (getenv ("DBUS_GLIB_TEST_SLEEP_AFTER_ACTIVATION2"))
     g_usleep (8 * G_USEC_PER_SEC);
 
   dbus_g_connection_flush (connection);
   exit_timeout = g_timeout_add (5000, timed_exit, loop);
   g_main_loop_run (loop);
 
   if (n_times_frobnicate_received != 1)
     lose ("Frobnicate signal received %d times, should have been 1", n_times_frobnicate_received);
 
   if (proxy_destroyed)
     lose ("Unexpectedly got proxy_destroyed!");
   
   /* Create another proxy for the name; should be associated immediately */
   proxy2 = dbus_g_proxy_new_for_name (connection,
 				     "org.freedesktop.DBus.GLib.TestService",
 				     "/org/freedesktop/DBus/GLib/Tests/MyTestObject",
 				     "org.freedesktop.DBus.GLib.Tests.MyObject");
   g_assert (proxy2 != NULL);
 
   dbus_g_proxy_add_signal (proxy2, "Frobnicate", G_TYPE_INT, G_TYPE_INVALID);
   
   dbus_g_proxy_connect_signal (proxy2, "Frobnicate",
                                G_CALLBACK (frobnicate_signal_handler_2),
                                NULL, NULL);
 
   g_print ("Calling EmitFrobnicate (3)\n");
   if (!dbus_g_proxy_call (proxy, "EmitFrobnicate", &error,
 			  G_TYPE_INVALID, G_TYPE_INVALID))
     lose_gerror ("Failed to complete EmitFrobnicate call", error);
 
   dbus_g_connection_flush (connection);
   exit_timeout = g_timeout_add (5000, timed_exit, loop);
   g_main_loop_run (loop);
 
   if (n_times_frobnicate_received != 2)
     lose ("Frobnicate signal received %d times for 1st proxy, should have been 2", n_times_frobnicate_received);
   if (n_times_frobnicate_received_2 != 1)
     lose ("Frobnicate signal received %d times for 2nd proxy, should have been 1", n_times_frobnicate_received_2);
 
   g_object_unref (G_OBJECT (proxy));
   g_object_unref (G_OBJECT (proxy2));
 
   run_mainloop ();
 
   /* Test introspection */
   proxy = dbus_g_proxy_new_for_name_owner (connection,
                                            "org.freedesktop.DBus.GLib.TestService",
                                            "/org/freedesktop/DBus/GLib/Tests/MyTestObject",
                                            "org.freedesktop.DBus.Introspectable",
                                            &error);
   if (proxy == NULL)
     lose_gerror ("Failed to create proxy for name owner", error);
 
   g_print ("Testing introspect\n");
   if (!dbus_g_proxy_call (proxy, "Introspect", &error,
 			  G_TYPE_INVALID,
 			  G_TYPE_STRING, &v_STRING_2,
 			  G_TYPE_INVALID))
     lose_gerror ("Failed to complete Introspect call", error);
 
   /* Could just do strcmp(), but that seems more fragile */
   {
     NodeInfo *node;
     GSList *elt;
     gboolean found_introspectable;
     gboolean found_properties;
     gboolean found_myobject;
     gboolean found_fooobject;
 
     node = description_load_from_string (v_STRING_2, strlen (v_STRING_2), &error);
     if (!node)
-      lose_gerror ("Failed to parse introspection data: %s", error);
+      {
+        g_printerr ("===\n%s\n===\n", v_STRING_2);
+        lose_gerror ("Failed to parse introspection data: %s", error);
+      }
 
     found_introspectable = FALSE;
     found_properties = FALSE;
     found_myobject = FALSE;
     found_fooobject = FALSE;
     for (elt = node_info_get_interfaces (node); elt ; elt = elt->next)
       {
 	InterfaceInfo *iface = elt->data;
 
 	if (!found_introspectable && strcmp (interface_info_get_name (iface), "org.freedesktop.DBus.Introspectable") == 0)
 	  found_introspectable = TRUE;
 	else if (!found_properties && strcmp (interface_info_get_name (iface), "org.freedesktop.DBus.Properties") == 0)
 	  found_properties = TRUE;
 	else if (!found_myobject && strcmp (interface_info_get_name (iface), "org.freedesktop.DBus.GLib.Tests.MyObject") == 0)
 	  {
 	    GSList *elt;
 	    gboolean found_manyargs;
-	    
+	    gboolean found_no_touching = FALSE;
+
 	    found_myobject = TRUE;
-	    
+
 	    found_manyargs = FALSE;
 	    for (elt = interface_info_get_methods (iface); elt; elt = elt->next)
 	      {
 		MethodInfo *method;
 
 		method = elt->data;
 		if (strcmp (method_info_get_name (method), "ManyArgs") == 0)
 		  {
 		    found_manyargs = TRUE;
 		    break;
 		  }
 	      }
 	    if (!found_manyargs)
 	      lose ("Missing method org.freedesktop.DBus.GLib.Tests.MyObject.ManyArgs");
+	    for (elt = interface_info_get_properties (iface); elt; elt = elt->next)
+	      {
+	        PropertyInfo *prop = elt->data;
+
+	        if (strcmp (property_info_get_name (prop), "no-touching") == 0)
+	          {
+	            if (property_info_get_access (prop) != PROPERTY_READ)
+	              lose ("property no-touching had incorrect access %d", property_info_get_access (prop));
+	            else
+	              {
+	                found_no_touching = TRUE;
+	                break;
+	              }
+	          }
+	      }
+	    if (!found_no_touching)
+	      lose ("didn't find property \"no-touching\" in org.freedesktop.DBus.GLib.Tests.MyObject");
 	  }
 	else if (!found_fooobject && strcmp (interface_info_get_name (iface), "org.freedesktop.DBus.GLib.Tests.FooObject") == 0)
 	  found_fooobject = TRUE;
 	else
 	  lose ("Unexpected or duplicate interface %s", interface_info_get_name (iface));
       }
 
     if (!(found_introspectable && found_myobject && found_properties))
       lose ("Missing interface"); 
   }
   g_free (v_STRING_2);
-  
+
+  /* Properties tests */
+  property_proxy = dbus_g_proxy_new_from_proxy (proxy, DBUS_INTERFACE_PROPERTIES, NULL);
+  g_object_unref (proxy);
+  proxy = NULL;
+
+  g_print ("Calling GetProperty (1)\n");
+  {
+    GValue value = {0,};
+    if (!dbus_g_proxy_call (property_proxy, "Get", &error,
+                            G_TYPE_STRING, "org.freedesktop.DBus.GLib.Tests.MyObject",
+                            G_TYPE_STRING, "this_is_a_string",
+                            G_TYPE_INVALID,
+                            G_TYPE_VALUE, &value, G_TYPE_INVALID))
+      lose_gerror ("Failed to complete GetProperty call", error);
+    g_assert (G_VALUE_HOLDS (&value, G_TYPE_STRING));
+    g_assert (!strcmp (g_value_get_string (&value), ""));
+    g_value_unset (&value);
+  }
+
+  g_print ("Calling SetProperty (1)\n");
+  {
+    GValue value = {0,};
+    g_value_init (&value, G_TYPE_STRING);
+    g_value_set_string (&value, "testing value");
+    if (!dbus_g_proxy_call (property_proxy, "Set", &error,
+                            G_TYPE_STRING, "org.freedesktop.DBus.GLib.Tests.MyObject",
+                            G_TYPE_STRING, "this_is_a_string",
+                            G_TYPE_VALUE, &value, G_TYPE_INVALID, G_TYPE_INVALID))
+      lose_gerror ("Failed to complete SetProperty call", error);
+    g_value_unset (&value);
+  }
+
+  g_print ("Calling GetProperty of read-only property\n");
+  {
+    GValue value = {0,};
+    if (!dbus_g_proxy_call (property_proxy, "Get", &error,
+                            G_TYPE_STRING, "org.freedesktop.DBus.GLib.Tests.MyObject",
+                            G_TYPE_STRING, "no-touching",
+                            G_TYPE_INVALID,
+                            G_TYPE_VALUE, &value, G_TYPE_INVALID))
+      lose_gerror ("Failed to complete GetProperty no-touching call", error);
+    g_assert (G_VALUE_HOLDS (&value, G_TYPE_UINT));
+    g_assert (g_value_get_uint (&value) == 42);
+    g_value_unset (&value);
+  }
+
+  g_print ("Calling SetProperty (1)\n");
+  {
+    GValue value = {0,};
+    g_value_init (&value, G_TYPE_UINT);
+    g_value_set_uint (&value, 40);
+    if (dbus_g_proxy_call (property_proxy, "Set", &error,
+                           G_TYPE_STRING, "org.freedesktop.DBus.GLib.Tests.MyObject",
+                           G_TYPE_STRING, "no-touching",
+                           G_TYPE_VALUE, &value, G_TYPE_INVALID, G_TYPE_INVALID))
+      lose ("Unexpected success from SetProperty call for read-only value \"no-touching\"");
+    g_clear_error (&error);
+    g_value_unset (&value);
+  }
+
+  g_print ("Calling GetProperty of read-only property (again)\n");
+  {
+    GValue value = {0,};
+    if (!dbus_g_proxy_call (property_proxy, "Get", &error,
+                            G_TYPE_STRING, "org.freedesktop.DBus.GLib.Tests.MyObject",
+                            G_TYPE_STRING, "no-touching",
+                            G_TYPE_INVALID,
+                            G_TYPE_VALUE, &value, G_TYPE_INVALID))
+      lose_gerror ("Failed to complete GetProperty call", error);
+    g_assert (G_VALUE_HOLDS (&value, G_TYPE_UINT));
+    g_assert (g_value_get_uint (&value) == 42);
+    g_value_unset (&value);
+  }
+
+  g_print ("Calling GetProperty (2)\n");
+  {
+    GValue value = {0,};
+    if (!dbus_g_proxy_call (property_proxy, "Get", &error,
+                            G_TYPE_STRING, "org.freedesktop.DBus.GLib.Tests.MyObject",
+                            G_TYPE_STRING, "this_is_a_string",
+                            G_TYPE_INVALID,
+                            G_TYPE_VALUE, &value, G_TYPE_INVALID))
+      lose_gerror ("Failed to complete GetProperty call", error);
+    g_assert (G_VALUE_HOLDS (&value, G_TYPE_STRING));
+    g_assert (!strcmp (g_value_get_string (&value), "testing value"));
+    g_value_unset (&value);
+  }
+
+  g_print ("Calling GetProperty: SuperStudly\n");
+  {
+    GValue value = {0,};
+    if (!dbus_g_proxy_call (property_proxy, "Get", &error,
+                            G_TYPE_STRING, "org.freedesktop.DBus.GLib.Tests.MyObject",
+                            G_TYPE_STRING, "SuperStudly",
+                            G_TYPE_INVALID,
+                            G_TYPE_VALUE, &value, G_TYPE_INVALID))
+      lose_gerror ("Failed to complete GetProperty call", error);
+    g_assert (G_VALUE_HOLDS (&value, G_TYPE_DOUBLE));
+    g_value_unset (&value);
+  }
+
+  g_print ("Calling GetProperty: super-studly\n");
+  {
+    GValue value = {0,};
+    if (!dbus_g_proxy_call (property_proxy, "Get", &error,
+                            G_TYPE_STRING, "org.freedesktop.DBus.GLib.Tests.MyObject",
+                            G_TYPE_STRING, "super-studly",
+                            G_TYPE_INVALID,
+                            G_TYPE_VALUE, &value, G_TYPE_INVALID))
+      lose_gerror ("Failed to complete GetProperty call", error);
+    g_assert (G_VALUE_HOLDS (&value, G_TYPE_DOUBLE));
+    g_value_unset (&value);
+  }
+
+  g_print ("Calling GetProperty: super_studly\n");
+  {
+    GValue value = {0,};
+    if (!dbus_g_proxy_call (property_proxy, "Get", &error,
+                            G_TYPE_STRING, "org.freedesktop.DBus.GLib.Tests.MyObject",
+                            G_TYPE_STRING, "super_studly",
+                            G_TYPE_INVALID,
+                            G_TYPE_VALUE, &value, G_TYPE_INVALID))
+      lose_gerror ("Failed to complete GetProperty call", error);
+    g_assert (G_VALUE_HOLDS (&value, G_TYPE_DOUBLE));
+    g_value_unset (&value);
+  }
+
+  g_print ("Calling GetProperty on unknown property\n");
+  {
+    GValue value = {0,};
+    if (dbus_g_proxy_call (property_proxy, "Get", &error,
+                            G_TYPE_STRING, "org.freedesktop.DBus.GLib.Tests.MyObject",
+                            G_TYPE_STRING, "SomeUnknownProperty",
+                            G_TYPE_INVALID,
+                            G_TYPE_VALUE, &value, G_TYPE_INVALID))
+      lose ("Unexpected success for GetProperty call of unknown property");
+
+    g_clear_error (&error);
+  }
+
+  /* These two are expected to pass unless we call disable_legacy_property_access */
+
+  g_print ("Calling GetProperty on not-exported property (legacy enabled)\n");
+  {
+    GValue value = {0,};
+    if (!dbus_g_proxy_call (property_proxy, "Get", &error,
+                            G_TYPE_STRING, "org.freedesktop.DBus.GLib.Tests.MyObject",
+                            G_TYPE_STRING, "should-be-hidden",
+                            G_TYPE_INVALID,
+                            G_TYPE_VALUE, &value, G_TYPE_INVALID))
+      lose_gerror ("Failed GetProperty call of \"should-be-hidden\" property", error);
+    g_assert (G_VALUE_HOLDS_BOOLEAN (&value));
+    g_assert (g_value_get_boolean (&value) == FALSE);
+    g_value_unset (&value);
+  }
+
+  g_print ("Calling GetProperty on not-exported property (legacy enabled)\n");
+  {
+    GValue value = {0,};
+    if (!dbus_g_proxy_call (property_proxy, "Get", &error,
+                            G_TYPE_STRING, "org.freedesktop.DBus.GLib.Tests.MyObject",
+                            G_TYPE_STRING, "ShouldBeHidden",
+                            G_TYPE_INVALID,
+                            G_TYPE_VALUE, &value, G_TYPE_INVALID))
+      lose_gerror ("Failed GetProperty call of \"ShouldBeHidden\" property", error);
+
+    g_value_unset (&value);
+  }
+
+  g_print ("Calling SetProperty on not-exported property (legacy enabled)\n");
+  {
+    GValue value = {0,};
+    g_value_init (&value, G_TYPE_BOOLEAN);
+    g_value_set_boolean (&value, TRUE);
+    if (dbus_g_proxy_call (property_proxy, "Set", &error,
+                            G_TYPE_STRING, "org.freedesktop.DBus.GLib.Tests.MyObject",
+                            G_TYPE_STRING, "should-be-hidden",
+                            G_TYPE_VALUE, &value,
+                            G_TYPE_INVALID, G_TYPE_INVALID))
+      lose ("Unexpected success from SetProperty call of \"should-be-hidden\" property");
+    g_value_unset (&value);
+    g_clear_error (&error);
+  }
+
+  g_print ("Calling GetProperty on not-exported property (legacy enabled)\n");
+  {
+    GValue value = {0,};
+    if (!dbus_g_proxy_call (property_proxy, "Get", &error,
+                            G_TYPE_STRING, "org.freedesktop.DBus.GLib.Tests.MyObject",
+                            G_TYPE_STRING, "should-be-hidden",
+                            G_TYPE_INVALID,
+                            G_TYPE_VALUE, &value, G_TYPE_INVALID))
+      lose_gerror ("Failed GetProperty call of \"should-be-hidden\" property", error);
+    g_assert (G_VALUE_HOLDS_BOOLEAN (&value));
+    g_assert (g_value_get_boolean (&value) == FALSE);
+    g_value_unset (&value);
+  }
+
+  /* Now, call disable_legacy_property_access */
+
+  g_assert (proxy == NULL);
+  proxy = dbus_g_proxy_new_for_name_owner (connection,
+                                           "org.freedesktop.DBus.GLib.TestService",
+                                           "/org/freedesktop/DBus/GLib/Tests/MyTestObject",
+                                           "org.freedesktop.DBus.GLib.Tests.MyObject",
+                                           &error);
+
+  if (!dbus_g_proxy_call (proxy, "UnsafeDisableLegacyPropertyAccess", &error,
+                          G_TYPE_INVALID, G_TYPE_INVALID))
+    lose_gerror ("Failed to invoke UnsafeDisableLegacyPropertyAccess", error);
+
+  g_object_unref (proxy);
+  proxy = NULL;
+
+  g_print ("Calling GetProperty on not-exported property (legacy *disabled*)\n");
+  {
+    GValue value = {0,};
+    if (dbus_g_proxy_call (property_proxy, "Get", &error,
+                            G_TYPE_STRING, "org.freedesktop.DBus.GLib.Tests.MyObject",
+                            G_TYPE_STRING, "should-be-hidden",
+                            G_TYPE_INVALID,
+                            G_TYPE_VALUE, &value, G_TYPE_INVALID))
+      lose ("Unexpected success from GetProperty call of \"should-be-hidden\" property");
+    g_clear_error (&error);
+  }
+
+  g_print ("Calling GetProperty on not-exported property (legacy *disabled*)\n");
+  {
+    GValue value = {0,};
+    if (dbus_g_proxy_call (property_proxy, "Get", &error,
+                            G_TYPE_STRING, "org.freedesktop.DBus.GLib.Tests.MyObject",
+                            G_TYPE_STRING, "ShouldBeHidden",
+                            G_TYPE_INVALID,
+                            G_TYPE_VALUE, &value, G_TYPE_INVALID))
+      lose ("Unexpected success from GetProperty call of \"ShouldBeHidden\" property");
+    g_clear_error (&error);
+  }
+
+  g_print ("Calling SetProperty on not-exported property (legacy *disabled*)\n");
+  {
+    GValue value = {0,};
+    g_value_init (&value, G_TYPE_BOOLEAN);
+    g_value_set_boolean (&value, FALSE);
+    if (dbus_g_proxy_call (property_proxy, "Set", &error,
+                            G_TYPE_STRING, "org.freedesktop.DBus.GLib.Tests.MyObject",
+                            G_TYPE_STRING, "should-be-hidden",
+                            G_TYPE_VALUE, &value,
+                            G_TYPE_INVALID, G_TYPE_INVALID))
+      lose ("Unexpected success from SetProperty call of \"should-be-hidden\" property");
+    g_value_unset (&value);
+    g_clear_error (&error);
+  }
+
+  g_object_unref (property_proxy);
+  property_proxy = NULL;
 
   test_terminate_proxy1 = dbus_g_proxy_new_for_name_owner (connection,
                             "org.freedesktop.DBus.GLib.TestService",
                             "/org/freedesktop/DBus/GLib/Tests/MyTestObject",
                             "org.freedesktop.DBus.GLib.Tests.MyObject",
                             &error);
 
   if (test_terminate_proxy1 == NULL)
     lose_gerror ("Failed to create proxy for name owner", error);
 
   test_terminate_proxy2 = dbus_g_proxy_new_for_name_owner (connection,
                             "org.freedesktop.DBus.GLib.TestService",
                             "/org/freedesktop/DBus/GLib/Tests/MyTestObject",
                             "org.freedesktop.DBus.GLib.Tests.MyObject",
                             &error);
 
   if (test_terminate_proxy2 == NULL)
     lose_gerror ("Failed to create proxy for name owner", error);
 
   g_print ("Testing duplicate proxy destruction\n");
   await_terminating_service = "org.freedesktop.DBus.GLib.TestService";
   dbus_g_proxy_call_no_reply (test_terminate_proxy1, "Terminate", G_TYPE_INVALID);
 
   proxy_destroyed = FALSE;
   proxy_destroy_and_nameowner = TRUE;
   proxy_destroy_and_nameowner_complete = FALSE;
 
   g_signal_connect (G_OBJECT (test_terminate_proxy1),
 		    "destroy",
 		    G_CALLBACK (test_terminate_proxy1_destroyed_cb),
 		    NULL);
 
   dbus_g_connection_flush (connection);
   exit_timeout = g_timeout_add (5000, timed_exit, loop);
   g_main_loop_run (loop);
 
   if (await_terminating_service != NULL)
     lose ("Didn't see name loss for \"org.freedesktop.DBus.GLib.TestService\"");
   if (!proxy_destroyed)
     lose ("Didn't get proxy_destroyed");
   if (test_terminate_proxy2)
     lose ("Duplicate proxy wasn'tdestroyed");
 
   g_print ("Proxy and duplicate destroyed successfully\n");
 
   g_object_unref (G_OBJECT (driver));
 
   g_print ("Successfully completed %s\n", argv[0]);
 
   return 0;
 }
diff --git a/test/core/test-service-glib.c b/test/core/test-service-glib.c
index 222db17..bb9157e 100644
--- a/test/core/test-service-glib.c
+++ b/test/core/test-service-glib.c
@@ -1,846 +1,21 @@
 /* -*- mode: C; c-file-style: "gnu" -*- */
 #include <dbus/dbus-glib.h>
 /* NOTE - outside of D-BUS core this would be
  * include <dbus/dbus-glib-bindings.h>
  */
 #include "tools/dbus-glib-bindings.h"
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <glib/gi18n.h>
 #include <glib-object.h>
 #include <glib/gquark.h>
-#include "my-object-marshal.h"
 
-typedef struct MyObject MyObject;
-typedef struct MyObjectClass MyObjectClass;
-
-GType my_object_get_type (void);
-
-struct MyObject
-{
-  GObject parent;
-  char *this_is_a_string;
-  guint val;
-};
-
-struct MyObjectClass
-{
-  GObjectClass parent;
-};
-
-#define MY_TYPE_OBJECT              (my_object_get_type ())
-#define MY_OBJECT(object)           (G_TYPE_CHECK_INSTANCE_CAST ((object), MY_TYPE_OBJECT, MyObject))
-#define MY_OBJECT_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST ((klass), MY_TYPE_OBJECT, MyObjectClass))
-#define MY_IS_OBJECT(object)        (G_TYPE_CHECK_INSTANCE_TYPE ((object), MY_TYPE_OBJECT))
-#define MY_IS_OBJECT_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE ((klass), MY_TYPE_OBJECT))
-#define MY_OBJECT_GET_CLASS(obj)    (G_TYPE_INSTANCE_GET_CLASS ((obj), MY_TYPE_OBJECT, MyObjectClass))
-
-G_DEFINE_TYPE(MyObject, my_object, G_TYPE_OBJECT)
-
-typedef enum
-{
-  MY_OBJECT_ERROR_FOO,
-  MY_OBJECT_ERROR_BAR
-} MyObjectError;
-
-#define MY_OBJECT_ERROR (my_object_error_quark ())
-
-#define MY_TYPE_ERROR (my_object_error_get_type ()) 
-
-gboolean my_object_do_nothing (MyObject *obj, GError **error);
-
-gboolean my_object_increment (MyObject *obj, gint32 x, gint32 *ret, GError **error);
-
-gint32   my_object_increment_retval (MyObject *obj, gint32 x);
-
-gint32   my_object_increment_retval_error (MyObject *obj, gint32 x, GError **error);
-
-gboolean my_object_throw_error (MyObject *obj, GError **error);
-
-gboolean my_object_uppercase (MyObject *obj, const char *str, char **ret, GError **error);
-
-gboolean my_object_many_args (MyObject *obj, guint32 x, const char *str, double trouble, double *d_ret, char **str_ret, GError **error);
-
-gboolean my_object_many_return (MyObject *obj, guint32 *arg0, char **arg1, gint32 *arg2, guint32 *arg3, guint32 *arg4, const char **arg5, GError **error);
-
-gboolean my_object_recursive1 (MyObject *obj, GArray *array, guint32 *len_ret, GError **error);
-gboolean my_object_recursive2 (MyObject *obj, guint32 reqlen, GArray **array, GError **error);
-
-gboolean my_object_many_stringify (MyObject *obj, GHashTable *vals, GHashTable **ret, GError **error);
-
-gboolean my_object_rec_arrays (MyObject *obj, GPtrArray *in, GPtrArray **ret, GError **error);
-
-gboolean my_object_objpath (MyObject *obj, const char *in, const char **arg1, GError **error);
-
-gboolean my_object_get_objs (MyObject *obj, GPtrArray **objs, GError **error);
-
-gboolean my_object_stringify (MyObject *obj, GValue *value, char **ret, GError **error);
-gboolean my_object_unstringify (MyObject *obj, const char *str, GValue *value, GError **error);
-
-gboolean my_object_many_uppercase (MyObject *obj, const char * const *in, char ***out, GError **error);
-
-gboolean my_object_str_hash_len (MyObject *obj, GHashTable *table, guint *len, GError **error);
-
-gboolean my_object_send_car (MyObject *obj, GValueArray *invals, GValueArray **outvals, GError **error);
-
-gboolean my_object_get_hash (MyObject *obj, GHashTable **table, GError **error);
-
-gboolean my_object_increment_val (MyObject *obj, GError **error);
-
-gboolean my_object_get_val (MyObject *obj, guint *ret, GError **error);
-
-gboolean my_object_get_value (MyObject *obj, guint *ret, GError **error);
-
-gboolean my_object_emit_signals (MyObject *obj, GError **error);
-gboolean my_object_emit_signal2 (MyObject *obj, GError **error);
-
-gboolean my_object_emit_frobnicate (MyObject *obj, GError **error);
-
-gboolean my_object_echo_variant (MyObject *obj, GValue *variant, GValue *ret, GError **error);
-
-gboolean my_object_process_variant_of_array_of_ints123 (MyObject *obj, GValue *variant, GError **error);
-
-gboolean my_object_dict_of_dicts (MyObject *obj, GHashTable *dict, GHashTable **ret, GError **error);
-
-gboolean my_object_terminate (MyObject *obj, GError **error);
-
-void my_object_async_increment (MyObject *obj, gint32 x, DBusGMethodInvocation *context);
-
-void my_object_async_throw_error (MyObject *obj, DBusGMethodInvocation *context);
-
-#include "test-service-glib-glue.h"
-
-GQuark my_object_error_quark (void);
-
-GType my_object_error_get_type (void);
-
-/* Properties */
-enum
-{
-  PROP_0,
-  PROP_THIS_IS_A_STRING
-};
-
-enum
-{
-  FROBNICATE,
-  SIG0,
-  SIG1,
-  SIG2,
-  LAST_SIGNAL
-};
-
-static guint signals[LAST_SIGNAL] = { 0 };
-
-static void
-my_object_finalize (GObject *object)
-{
-  MyObject *mobject = MY_OBJECT (object);
-
-  g_free (mobject->this_is_a_string);
-
-  (G_OBJECT_CLASS (my_object_parent_class)->finalize) (object);
-}
-
-static void
-my_object_set_property (GObject      *object,
-                        guint         prop_id,
-                        const GValue *value,
-                        GParamSpec   *pspec)
-{
-  MyObject *mobject;
-
-  mobject = MY_OBJECT (object);
-  
-  switch (prop_id)
-    {
-    case PROP_THIS_IS_A_STRING:
-      g_free (mobject->this_is_a_string);
-      mobject->this_is_a_string = g_value_dup_string (value);
-      break;
-      
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-      break;
-    }
-}
-
-static void
-my_object_get_property (GObject      *object,
-                        guint         prop_id,
-                        GValue       *value,
-                        GParamSpec   *pspec)
-{
-  MyObject *mobject;
-
-  mobject = MY_OBJECT (object);
-  
-  switch (prop_id)
-    {
-    case PROP_THIS_IS_A_STRING:
-      g_value_set_string (value, mobject->this_is_a_string);
-      break;
-      
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-      break;
-    }
-}
-
-static void
-my_object_init (MyObject *obj)
-{
-  obj->val = 0;
-}
-
-static void
-my_object_class_init (MyObjectClass *mobject_class)
-{
-  GObjectClass *gobject_class = G_OBJECT_CLASS (mobject_class);
-
-  gobject_class->finalize = my_object_finalize;
-  gobject_class->set_property = my_object_set_property;
-  gobject_class->get_property = my_object_get_property;
-  
-  g_object_class_install_property (gobject_class,
-				   PROP_THIS_IS_A_STRING,
-				   g_param_spec_string ("this_is_a_string",
-                                                        _("Sample string"),
-                                                        _("Example of a string property"),
-                                                        "default value",
-                                                        G_PARAM_READWRITE));
-  signals[FROBNICATE] =
-    g_signal_new ("frobnicate",
-		  G_OBJECT_CLASS_TYPE (mobject_class),
-                  G_SIGNAL_RUN_LAST | G_SIGNAL_DETAILED,
-                  0,
-                  NULL, NULL,
-                  g_cclosure_marshal_VOID__INT,
-                  G_TYPE_NONE, 1, G_TYPE_INT);
-
-  signals[SIG0] =
-    g_signal_new ("sig0",
-		  G_OBJECT_CLASS_TYPE (mobject_class),
-                  G_SIGNAL_RUN_LAST | G_SIGNAL_DETAILED,
-                  0,
-                  NULL, NULL,
-                  my_object_marshal_VOID__STRING_INT_STRING,
-                  G_TYPE_NONE, 3, G_TYPE_STRING, G_TYPE_INT, G_TYPE_STRING);
-
-  signals[SIG1] =
-    g_signal_new ("sig1",
-		  G_OBJECT_CLASS_TYPE (mobject_class),
-                  G_SIGNAL_RUN_LAST | G_SIGNAL_DETAILED,
-                  0,
-                  NULL, NULL,
-                  my_object_marshal_VOID__STRING_BOXED,
-                  G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_VALUE);
-
-  signals[SIG2] =
-    g_signal_new ("sig2",
-		  G_OBJECT_CLASS_TYPE (mobject_class),
-                  G_SIGNAL_RUN_LAST | G_SIGNAL_DETAILED,
-                  0,
-                  NULL, NULL,
-                  g_cclosure_marshal_VOID__BOXED,
-                  G_TYPE_NONE, 1, DBUS_TYPE_G_STRING_STRING_HASHTABLE);
-}
-
-GQuark
-my_object_error_quark (void)
-{
-  static GQuark quark = 0;
-  if (!quark)
-    quark = g_quark_from_static_string ("my_object_error");
-
-  return quark;
-}
-
-/* This should really be standard. */
-#define ENUM_ENTRY(NAME, DESC) { NAME, "" #NAME "", DESC }
-
-GType
-my_object_error_get_type (void)
-{
-	static GType etype = 0;
-
-	if (etype == 0)
-	{
-		static const GEnumValue values[] =
-		{
-
-			ENUM_ENTRY (MY_OBJECT_ERROR_FOO, "Foo"),
-			ENUM_ENTRY (MY_OBJECT_ERROR_BAR, "Bar"),
-			{ 0, 0, 0 }
-		};
-
-		etype = g_enum_register_static ("MyObjectError", values);
-	}
-
-	return etype;
-}
+#include "my-object.h"
 
 static GObject *obj;
 static GObject *obj2;
-
-gboolean
-my_object_do_nothing (MyObject *obj, GError **error)
-{
-  return TRUE;
-}
-
-gboolean
-my_object_increment (MyObject *obj, gint32 x, gint32 *ret, GError **error)
-{
-  *ret = x +1;
-  return TRUE;
-}
-
-gint32
-my_object_increment_retval (MyObject *obj, gint32 x)
-{
-  return x + 1;
-}
-
-gint32
-my_object_increment_retval_error (MyObject *obj, gint32 x, GError **error)
-{
-  if (x + 1 > 10)
-    {
-      g_set_error (error,
-		   MY_OBJECT_ERROR,
-		   MY_OBJECT_ERROR_FOO,
-		   "%s",
-		   "x is bigger than 9");    
-      return FALSE;
-    }
-  return x + 1;
-}
-
-gboolean
-my_object_throw_error (MyObject *obj, GError **error)
-{
-  g_set_error (error,
-	       MY_OBJECT_ERROR,
-	       MY_OBJECT_ERROR_FOO,
-	       "%s",
-	       "this method always loses");    
-  return FALSE;
-}
-
-gboolean
-my_object_uppercase (MyObject *obj, const char *str, char **ret, GError **error)
-{
-  *ret = g_ascii_strup (str, -1);
-  return TRUE;
-}
-
-gboolean
-my_object_many_args (MyObject *obj, guint32 x, const char *str, double trouble, double *d_ret, char **str_ret, GError **error)
-{
-  *d_ret = trouble + (x * 2);
-  *str_ret = g_ascii_strup (str, -1);
-  return TRUE;
-}
-
-gboolean
-my_object_many_return (MyObject *obj, guint32 *arg0, char **arg1, gint32 *arg2, guint32 *arg3, guint32 *arg4, const char **arg5, GError **error)
-{
-  *arg0 = 42;
-  *arg1 = g_strdup ("42");
-  *arg2 = -67;
-  *arg3 = 2;
-  *arg4 = 26;
-  *arg5 = "hello world"; /* Annotation specifies as const */
-  return TRUE;
-}
-
-gboolean
-my_object_stringify (MyObject *obj, GValue *value, char **ret, GError **error)
-{
-  GValue valstr = {0, };
-
-  g_value_init (&valstr, G_TYPE_STRING);
-  if (!g_value_transform (value, &valstr))
-    {
-      g_set_error (error,
-		   MY_OBJECT_ERROR,
-		   MY_OBJECT_ERROR_FOO,
-		   "couldn't transform value");
-      return FALSE;
-    }
-  *ret = g_value_dup_string (&valstr);
-  g_value_unset (&valstr);
-  return TRUE;
-}
-
-gboolean
-my_object_unstringify (MyObject *obj, const char *str, GValue *value, GError **error)
-{
-  if (str[0] == '\0' || !g_ascii_isdigit (str[0])) {
-    g_value_init (value, G_TYPE_STRING);
-    g_value_set_string (value, str);
-  } else {
-    g_value_init (value, G_TYPE_INT);
-    g_value_set_int (value, (int) g_ascii_strtoull (str, NULL, 10));
-  } 
-  return TRUE;
-}
-
-gboolean
-my_object_recursive1 (MyObject *obj, GArray *array, guint32 *len_ret, GError **error)
-{
-  *len_ret = array->len;
-  return TRUE;
-}
-
-gboolean
-my_object_recursive2 (MyObject *obj, guint32 reqlen, GArray **ret, GError **error)
-{
-  guint32 val;
-  GArray *array;
-  
-  array = g_array_new (FALSE, TRUE, sizeof (guint32));
-
-  while (reqlen > 0) {
-    val = 42;
-    g_array_append_val (array, val);
-    val = 26;
-    g_array_append_val (array, val);
-    reqlen--;
-  }
-  val = 2;
-  g_array_append_val (array, val);
-  *ret = array;
-  return TRUE;
-}
-
-gboolean
-my_object_many_uppercase (MyObject *obj, const char * const *in, char ***out, GError **error)
-{
-  int len;
-  int i;
-
-  len = g_strv_length ((char**) in);
-
-  *out = g_new0 (char *, len + 1);
-  for (i = 0; i < len; i++)
-    {
-      (*out)[i] = g_ascii_strup (in[i], -1);
-    }
-  (*out)[i] = NULL;
-  
-  return TRUE;
-}
-
-static void
-hash_foreach_stringify (gpointer key, gpointer val, gpointer user_data)
-{
-  const char *keystr = key;
-  const GValue *value = val;
-  GValue *sval;
-  GHashTable *ret = user_data;
-
-  sval = g_new0 (GValue, 1);
-  g_value_init (sval, G_TYPE_STRING);
-  if (!g_value_transform (value, sval))
-    g_assert_not_reached ();
-
-  g_hash_table_insert (ret, g_strdup (keystr), sval);
-}
-
-static void
-unset_and_free_gvalue (gpointer val)
-{
-  g_value_unset (val);
-  g_free (val);
-}
-
-gboolean
-my_object_many_stringify (MyObject *obj, GHashTable /* char * -> GValue * */ *vals, GHashTable /* char * -> GValue * */ **ret, GError **error)
-{
-  *ret = g_hash_table_new_full (g_str_hash, g_str_equal,
-				g_free, unset_and_free_gvalue);
-  g_hash_table_foreach (vals, hash_foreach_stringify, *ret);
-  return TRUE;
-}
-
-gboolean
-my_object_rec_arrays (MyObject *obj, GPtrArray *in, GPtrArray **ret, GError **error)
-{
-  char **strs;
-  GArray *ints;
-  guint v_UINT;
-  
-  if (in->len != 2)
-    {
-      g_set_error (error,
-		   MY_OBJECT_ERROR,
-		   MY_OBJECT_ERROR_FOO,
-		   "invalid array len");
-      return FALSE;
-    }
-  
-  strs = g_ptr_array_index (in, 0);
-  if (!*strs || strcmp (*strs, "foo"))
-    {
-      g_set_error (error,
-		   MY_OBJECT_ERROR,
-		   MY_OBJECT_ERROR_FOO,
-		   "invalid string 0");
-      return FALSE;
-    }
-  strs++;
-  if (!*strs || strcmp (*strs, "bar"))
-    {
-      g_set_error (error,
-		   MY_OBJECT_ERROR,
-		   MY_OBJECT_ERROR_FOO,
-		   "invalid string 1");
-      return FALSE;
-    }
-  strs++;
-  if (*strs)
-    {
-      g_set_error (error,
-		   MY_OBJECT_ERROR,
-		   MY_OBJECT_ERROR_FOO,
-		   "invalid string array len in pos 0");
-      return FALSE;
-    }
-  strs = g_ptr_array_index (in, 1);
-  if (!*strs || strcmp (*strs, "baz"))
-    {
-      g_set_error (error,
-		   MY_OBJECT_ERROR,
-		   MY_OBJECT_ERROR_FOO,
-		   "invalid string 0");
-      return FALSE;
-    }
-  strs++;
-  if (!*strs || strcmp (*strs, "whee"))
-    {
-      g_set_error (error,
-		   MY_OBJECT_ERROR,
-		   MY_OBJECT_ERROR_FOO,
-		   "invalid string 1");
-      return FALSE;
-    }
-  strs++;
-  if (!*strs || strcmp (*strs, "moo"))
-    {
-      g_set_error (error,
-		   MY_OBJECT_ERROR,
-		   MY_OBJECT_ERROR_FOO,
-		   "invalid string 2");
-      return FALSE;
-    }
-  strs++;
-  if (*strs)
-    {
-      g_set_error (error,
-		   MY_OBJECT_ERROR,
-		   MY_OBJECT_ERROR_FOO,
-		   "invalid string array len in pos 1");
-      return FALSE;
-    }
-
-  *ret = g_ptr_array_new ();
-
-  ints = g_array_new (TRUE, TRUE, sizeof (guint));
-  v_UINT = 10;
-  g_array_append_val (ints, v_UINT);
-  v_UINT = 42;
-  g_array_append_val (ints, v_UINT);
-  v_UINT = 27;
-  g_array_append_val (ints, v_UINT);
-  g_ptr_array_add (*ret, ints);
-
-  ints = g_array_new (TRUE, TRUE, sizeof (guint));
-  v_UINT = 30;
-  g_array_append_val (ints, v_UINT);
-  g_ptr_array_add (*ret, ints);
-  return TRUE;
-}
-
-gboolean
-my_object_objpath (MyObject *obj, const char *incoming, const char **outgoing, GError **error)
-{
-  if (strcmp (incoming, "/org/freedesktop/DBus/GLib/Tests/MyTestObject"))
-    {
-      g_set_error (error,
-		   MY_OBJECT_ERROR,
-		   MY_OBJECT_ERROR_FOO,
-		   "invalid incoming object");
-      return FALSE;
-    }
-  *outgoing = "/org/freedesktop/DBus/GLib/Tests/MyTestObject2";
-  return TRUE;
-}
-
-gboolean
-my_object_get_objs (MyObject *obj, GPtrArray **objs, GError **error)
-{
-  *objs = g_ptr_array_new ();
-
-  g_ptr_array_add (*objs, g_strdup ("/org/freedesktop/DBus/GLib/Tests/MyTestObject"));
-  g_ptr_array_add (*objs, g_strdup ("/org/freedesktop/DBus/GLib/Tests/MyTestObject2"));
-
-  return TRUE;
-}
-
-static void
-hash_foreach (gpointer key, gpointer val, gpointer user_data)
-{
-  const char *keystr = key;
-  const char *valstr = val;
-  guint *count = user_data;
-
-  *count += (strlen (keystr) + strlen (valstr));
-  g_print ("%s -> %s\n", keystr, valstr);
-}
-
-gboolean
-my_object_str_hash_len (MyObject *obj, GHashTable *table, guint *len, GError **error)
-{
-  *len = 0;
-  g_hash_table_foreach (table, hash_foreach, len);
-  return TRUE;
-}
-
-gboolean
-my_object_send_car (MyObject *obj, GValueArray *invals, GValueArray **outvals, GError **error)
-{
-  if (invals->n_values != 3
-      || G_VALUE_TYPE (g_value_array_get_nth (invals, 0)) != G_TYPE_STRING
-      || G_VALUE_TYPE (g_value_array_get_nth (invals, 1)) != G_TYPE_UINT
-      || G_VALUE_TYPE (g_value_array_get_nth (invals, 2)) != G_TYPE_VALUE)
-    {
-      g_set_error (error,
-		   MY_OBJECT_ERROR,
-		   MY_OBJECT_ERROR_FOO,
-		   "invalid incoming values");
-      return FALSE;
-    }
-  *outvals = g_value_array_new (2);
-  g_value_array_append (*outvals, NULL);
-  g_value_init (g_value_array_get_nth (*outvals, (*outvals)->n_values - 1), G_TYPE_UINT);
-  g_value_set_uint (g_value_array_get_nth (*outvals, (*outvals)->n_values - 1),
-		    g_value_get_uint (g_value_array_get_nth (invals, 1)) + 1);
-  g_value_array_append (*outvals, NULL);
-  g_value_init (g_value_array_get_nth (*outvals, (*outvals)->n_values - 1), DBUS_TYPE_G_OBJECT_PATH);
-  g_value_set_boxed (g_value_array_get_nth (*outvals, (*outvals)->n_values - 1),
-		     g_strdup ("/org/freedesktop/DBus/GLib/Tests/MyTestObject2"));
-  return TRUE;
-}
-
-gboolean
-my_object_get_hash (MyObject *obj, GHashTable **ret, GError **error)
-{
-  GHashTable *table;
-
-  table = g_hash_table_new (g_str_hash, g_str_equal);
-  g_hash_table_insert (table, "foo", "bar");
-  g_hash_table_insert (table, "baz", "whee");
-  g_hash_table_insert (table, "cow", "crack");
-  *ret = table;
-  return TRUE;
-}
-
-gboolean
-my_object_increment_val (MyObject *obj, GError **error)
-{
-  obj->val++;
-  return TRUE;
-}
-
-gboolean
-my_object_get_val (MyObject *obj, guint *ret, GError **error)
-{
-  *ret = obj->val;
-  return TRUE;
-}
-
-gboolean
-my_object_get_value (MyObject *obj, guint *ret, GError **error)
-{
-  *ret = obj->val;
-  return TRUE;
-}
-
-gboolean
-my_object_echo_variant (MyObject *obj, GValue *variant, GValue *ret, GError **error)
-{
-    GType t;
-    t = G_VALUE_TYPE(variant);
-    g_value_init (ret, t);
-    g_value_copy (variant, ret);
-
-    return TRUE;
-}
-
-gboolean 
-my_object_process_variant_of_array_of_ints123 (MyObject *obj, GValue *variant, GError **error)
-{
-  GArray *array;
-  int i;
-  int j;
-
-  j = 0;
-
-  array = (GArray *)g_value_get_boxed (variant);
-
-  for (i = 0; i <= 2; i++)
-    {
-      j = g_array_index (array, int, i);
-      if (j != i + 1)
-        goto error;
-    }
-
-  return TRUE;
-
-error:
-  *error = g_error_new (MY_OBJECT_ERROR,
-		       MY_OBJECT_ERROR_FOO,
-		       "Error decoding a variant of type ai (i + 1 = %i, j = %i)",
-		       i, j + 1);
-  return FALSE;
-}
-
-
-typedef struct _HashAndString HashAndString;
-
-struct _HashAndString
-{
-  GHashTable *hash;
-  gchar* string;
-};
-
-static void
-hash_foreach_prepend_string (gpointer key, gpointer val, gpointer user_data)
-{
-  HashAndString *data = (HashAndString*) user_data;
-  gchar *in = (gchar*) val;
-  g_hash_table_insert (data->hash, g_strdup ((gchar*) key),
-                       g_strjoin (" ", data->string, in, NULL));
-}
-
-
-static void
-hash_foreach_mangle_dict_of_strings (gpointer key, gpointer val, gpointer user_data)
-{
-  GHashTable *out = (GHashTable*) user_data;
-  GHashTable *in_dict = (GHashTable *) val;
-  HashAndString *data = g_new0 (HashAndString, 1);
-
-  data->string = (gchar*) key;
-  data->hash = g_hash_table_new_full (g_str_hash, g_str_equal,
-                                            g_free, g_free);
-  g_hash_table_foreach (in_dict, hash_foreach_prepend_string, data);
-
-  g_hash_table_insert(out, g_strdup ((gchar*) key), data->hash);
-}
-
-gboolean
-my_object_dict_of_dicts (MyObject *obj, GHashTable *in,
-                                GHashTable **out, GError **error)
-{
-  *out = g_hash_table_new_full (g_str_hash, g_str_equal,
-				(GDestroyNotify) g_free,
-                                (GDestroyNotify) g_hash_table_destroy);
-  g_hash_table_foreach (in, hash_foreach_mangle_dict_of_strings, *out);
-  return TRUE;
-}
-
-gboolean
-my_object_emit_frobnicate (MyObject *obj, GError **error)
-{
-  g_signal_emit (obj, signals[FROBNICATE], 0, 42);
-  return TRUE;
-}
-
-gboolean
-my_object_emit_signals (MyObject *obj, GError **error)
-{
-  GValue val = {0, };
-
-  g_signal_emit (obj, signals[SIG0], 0, "foo", 22, "moo");
-
-  g_value_init (&val, G_TYPE_STRING);
-  g_value_set_string (&val, "bar");
-  g_signal_emit (obj, signals[SIG1], 0, "baz", &val);
-  g_value_unset (&val);
-
-  return TRUE;
-}
-
-gboolean
-my_object_emit_signal2 (MyObject *obj, GError **error)
-{
-  GHashTable *table;
-
-  table = g_hash_table_new (g_str_hash, g_str_equal);
-  g_hash_table_insert (table, "baz", "cow");
-  g_hash_table_insert (table, "bar", "foo");
-  g_signal_emit (obj, signals[SIG2], 0, table);
-  g_hash_table_destroy (table);
-  return TRUE;
-}
-
-typedef struct {
-  gint32 x;
-  DBusGMethodInvocation *context;
-} IncrementData;
-
-static gboolean
-do_async_increment (IncrementData *data)
-{
-  gint32 newx = data->x + 1;
-  dbus_g_method_return (data->context, newx);
-  g_free (data);
-  return FALSE;
-}
-
-void
-my_object_async_increment (MyObject *obj, gint32 x, DBusGMethodInvocation *context)
-{
-  IncrementData *data = g_new0 (IncrementData, 1);
-  data->x = x;
-  data->context = context;
-  g_idle_add ((GSourceFunc)do_async_increment, data);
-}
-
-static gboolean
-do_async_error (IncrementData *data)
-{
-  GError *error;
-  error = g_error_new (MY_OBJECT_ERROR,
-		       MY_OBJECT_ERROR_FOO,
-		       "%s",
-		       "this method always loses");
-  dbus_g_method_return_error (data->context, error);
-  g_free (data);
-  return FALSE;
-}
-
-void
-my_object_async_throw_error (MyObject *obj, DBusGMethodInvocation *context)
-{
-  IncrementData *data = g_new0(IncrementData, 1);
-  data->context = context;
-  g_idle_add ((GSourceFunc)do_async_error,  data);
-}
-
-
-static GMainLoop *loop;
-
-gboolean
-my_object_terminate (MyObject *obj, GError **error)
-{
-  g_main_loop_quit (loop);
-  return TRUE;
-}
+GMainLoop *loop;
 
 #define TEST_SERVICE_NAME "org.freedesktop.DBus.GLib.TestService"
 
@@ -848,81 +23,78 @@ int
 main (int argc, char **argv)
 {
   DBusGConnection *connection;
   GError *error;
   DBusGProxy *driver_proxy;
   guint32 request_name_ret;
 
   g_type_init ();
   g_thread_init (NULL); dbus_g_thread_init ();
 
-  dbus_g_object_type_install_info (MY_TYPE_OBJECT,
-				   &dbus_glib_my_object_object_info);
-
   dbus_g_error_domain_register (MY_OBJECT_ERROR,
 				NULL,
 				MY_TYPE_ERROR);
 
   g_printerr ("Launching test-service-glib\n");
 
   loop = g_main_loop_new (NULL, FALSE);
 
   {
     GLogLevelFlags fatal_mask;
     
     fatal_mask = g_log_set_always_fatal (G_LOG_FATAL_MASK);
     fatal_mask |= G_LOG_LEVEL_WARNING | G_LOG_LEVEL_CRITICAL;
     g_log_set_always_fatal (fatal_mask);
   }
 
   error = NULL;
   connection = dbus_g_bus_get (DBUS_BUS_STARTER,
                                &error);
   if (connection == NULL)
     {
       g_printerr ("Failed to open connection to bus: %s\n",
                   error->message);
       g_error_free (error);
       exit (1);
     }
 
   obj = g_object_new (MY_TYPE_OBJECT, NULL);
   obj2 = g_object_new (MY_TYPE_OBJECT, NULL);
 
   dbus_g_connection_register_g_object (connection,
                                        "/org/freedesktop/DBus/GLib/Tests/MyTestObject",
                                        obj);
   dbus_g_connection_register_g_object (connection,
                                        "/org/freedesktop/DBus/GLib/Tests/MyTestObject2",
                                        obj2);
 
   driver_proxy = dbus_g_proxy_new_for_name (connection,
                                             DBUS_SERVICE_DBUS,
                                             DBUS_PATH_DBUS,
                                             DBUS_INTERFACE_DBUS);
 
   if (!org_freedesktop_DBus_request_name (driver_proxy,
 					  TEST_SERVICE_NAME,
 					  0, &request_name_ret, &error))
     {
       g_assert (error != NULL);
       g_printerr ("Failed to get name: %s\n",
 		  error->message);
       g_clear_error (&error);
       exit (1);
     }
 
   if (!(request_name_ret == DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER))
     {
       g_printerr ("Got result code %u from requesting name\n", request_name_ret);
       exit (1);
     }
 
   g_printerr ("GLib test service has name '%s'\n", TEST_SERVICE_NAME);
   g_printerr ("GLib test service entering main loop\n");
 
   g_main_loop_run (loop);
   
   g_printerr ("Successfully completed %s\n", argv[0]);
   
   return 0;
 }
diff --git a/test/core/test-service-glib.xml b/test/core/test-service-glib.xml
index fca02af..be262d6 100644
--- a/test/core/test-service-glib.xml
+++ b/test/core/test-service-glib.xml
@@ -1,179 +1,186 @@
 <?xml version="1.0" encoding="UTF-8" ?>
 
 <node name="/org/freedesktop/DBus/GLib/Tests/MyTestObject">
   <interface name="org.freedesktop.DBus.GLib.Tests.MyObject">
+    <property name="this_is_a_string" type="s" access="readwrite"/>
+    <property name="no-touching" type="u" access="read"/>
+    <property name="SuperStudly" type="d" access="readwrite"/>
+
     <method name="DoNothing">
     </method>
 
     <method name="Increment">
       <arg type="u" name="x" />
       <arg type="u" direction="out" />
     </method>
 
     <method name="IncrementRetval">
       <arg type="u" name="x" />
       <arg type="u" direction="out">
 	<annotation name="org.freedesktop.DBus.GLib.ReturnVal" value=""/>
       </arg>
     </method>
 
     <method name="IncrementRetvalError">
       <arg type="u" name="x" />
       <arg type="u" direction="out">
 	<annotation name="org.freedesktop.DBus.GLib.ReturnVal" value="error"/>
       </arg>
     </method>
 
     <method name="ThrowError">
     </method>
 
     <method name="Uppercase">
       <arg type="s" direction="in" />
       <arg type="s" direction="out" />
     </method>
 
     <method name="ManyArgs">
       <arg type="u" name="x" direction="in" />
       <arg type="s" name="str" direction="in" />
       <arg type="d" name="trouble" direction="in" />
       <arg type="d" name="d_ret" direction="out" />
       <arg type="s" name="str_ret" direction="out" />
     </method>
 
     <method name="ManyReturn">
       <arg type="u" direction="out" />
       <arg type="s" direction="out" />
       <arg type="i" direction="out" />
       <arg type="u" direction="out" />
       <arg type="u" direction="out" />
       <arg type="s" direction="out">
 	<annotation name="org.freedesktop.DBus.GLib.Const" value=""/>
       </arg>
     </method>
 
     <method name="Stringify">
       <arg type="v" name="val" direction="in"/>
       <arg type="s" direction="out"/>
     </method>
 
     <method name="Unstringify">
       <arg type="s" name="val" direction="in"/>
       <arg type="v" direction="out"/>
     </method>
 
     <method name="Recursive1">
       <arg type="au" direction="in"/>
       <arg type="u" direction="out"/>
     </method>
 
     <method name="Recursive2">
       <arg type="u" direction="in"/>
       <arg type="au" direction="out"/>
     </method>
 
     <method name="ManyUppercase">
       <arg type="as" direction="in"/>
       <arg type="as" direction="out"/>
     </method>
 
     <method name="StrHashLen">
       <arg type="a{ss}" direction="in"/>
       <arg type="u" direction="out"/>
     </method>
 
     <method name="SendCar">
       <arg type="(suv)" direction="in"/>
       <arg type="(uo)" direction="out"/>
     </method>
 
     <method name="GetHash">
       <arg type="a{ss}" direction="out"/>
     </method>
 
     <method name="RecArrays">
       <arg type="aas" name="val" direction="in"/>
       <arg type="aau" direction="out"/>
     </method>
 
     <method name="Objpath">
       <arg type="o" direction="in"/>
       <arg type="o" direction="out">
 	<annotation name="org.freedesktop.DBus.GLib.Const" value=""/>
       </arg>
     </method>
 
     <method name="GetObjs">
       <arg type="ao" direction="out"/>
     </method>
 
     <method name="IncrementVal">
     </method>
 
     <method name="AsyncIncrement">
       <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
       <arg type="u" name="x" />
       <arg type="u" direction="out" />
     </method>
 
     <method name="AsyncThrowError">
       <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
     </method>
     
     <method name="GetVal">
       <arg type="u" direction="out" />
     </method>
 
     <method name="ManyStringify">
       <arg type="a{sv}" direction="in"/>
       <arg type="a{sv}" direction="out"/>
     </method>
 
     <method name="EchoVariant">
       <arg type="v" direction="in" />
       <arg type="v" direction="out" />
     </method>
 
     <method name="ProcessVariantOfArrayOfInts123">
       <arg type="v" direction="in" />
     </method>
 
     <method name="DictOfDicts">
       <arg type="a{sa{ss}}" direction="in"/>
       <arg type="a{sa{ss}}" direction="out"/>
     </method>
 
     <method name="EmitFrobnicate">
     </method>
 
+    <method name="UnsafeDisableLegacyPropertyAccess">
+    </method>
+
     <!-- Export signals -->
     <signal name="Frobnicate"/>
 
     <method name="Terminate">
     </method>
   </interface>
 
   <!-- Test multiple interfaces on the same object -->
 
   <interface name="org.freedesktop.DBus.GLib.Tests.FooObject">
     <method name="GetValue">
       <arg type="u" direction="out" />
     </method>
 
     <method name="EmitSignals">
     </method>
 
     <signal name="Sig0"/>
 
     <signal name="Sig1"/>
 
     <method name="EmitSignal2">
     </method>
 
     <signal name="Sig2"/>
 
     <method name="Terminate">
     </method>
 
   </interface>
 
 </node>
