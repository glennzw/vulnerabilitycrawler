   CIFS: Fix a malicious redirect problem in the DNS lookup code
   
   Fix the security problem in the CIFS filesystem DNS lookup code in which a
   malicious redirect could be installed by a random user by simply adding a
   result record into one of their keyrings with add_key() and then invoking a
   CIFS CFS lookup [CVE-2010-2524].
   
   This is done by creating an internal keyring specifically for the caching of
   DNS lookups.  To enforce the use of this keyring, the module init routine
   creates a set of override credentials with the keyring installed as the thread
   keyring and instructs request_key() to only install lookup result keys in that
   keyring.
   
   The override is then applied around the call to request_key().
   
   This has some additional benefits when a kernel service uses this module to
   request a key:
   
    (1) The result keys are owned by root, not the user that caused the lookup.
   
    (2) The result keys don't pop up in the user's keyrings.
   
    (3) The result keys don't come out of the quota of the user that caused the
        lookup.
   
   The keyring can be viewed as root by doing cat /proc/keys:
   
   2a0ca6c3 I-----     1 perm 1f030000     0     0 keyring   .dns_resolver: 1/4
   
   It can then be listed with 'keyctl list' by root.
   
   	# keyctl list 0x2a0ca6c3
   	1 key in keyring:
   	726766307: --alswrv     0     0 dns_resolver: foo.bar.com
   
   Signed-off-by: David Howells <dhowells@redhat.com>
   Reviewed-and-Tested-by: Jeff Layton <jlayton@redhat.com>
   Acked-by: Steve French <smfrench@gmail.com>
   Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
		goto out_unregister_filesystem;
#endif
#ifdef CONFIG_CIFS_DFS_UPCALL
	rc = register_key_type(&key_type_dns_resolver);
	if (rc)
		goto out_unregister_key_type;
#endif

 out_unregister_resolver_key:
#ifdef CONFIG_CIFS_DFS_UPCALL
	unregister_key_type(&key_type_dns_resolver);
 out_unregister_key_type:
#endif
#ifdef CONFIG_CIFS_UPCALL
	cifs_proc_clean();
#ifdef CONFIG_CIFS_DFS_UPCALL
	cifs_dfs_release_automount_timer();
	unregister_key_type(&key_type_dns_resolver);
#endif
#ifdef CONFIG_CIFS_UPCALL
	unregister_key_type(&cifs_spnego_key_type);
 */

#include <linux/slab.h>
#include <keys/user-type.h>
#include "dns_resolve.h"
#include "cifsglob.h"
#include "cifsproto.h"
#include "cifs_debug.h"

/* Checks if supplied name is IP address
 * returns:
 * 		1 - name is IP
int
dns_resolve_server_name_to_ip(const char *unc, char **ip_addr)
{
	int rc = -EAGAIN;
	struct key *rkey = ERR_PTR(-EAGAIN);
	char *name;
		goto skip_upcall;
	}

	rkey = request_key(&key_type_dns_resolver, name, "");
	if (!IS_ERR(rkey)) {
		len = rkey->type_data.x[0];
		data = rkey->payload.data;
	} else {
	return rc;
}


#define _DNS_RESOLVE_H

#ifdef __KERNEL__
#include <linux/key-type.h>
extern struct key_type key_type_dns_resolver;
extern int dns_resolve_server_name_to_ip(const char *unc, char **ip_addr);
#endif /* KERNEL */

