commit ae6df5f96a51818d6376da5307d773baeece4014
Author: Kees Cook <kees.cook@canonical.com>
Date:   Thu Oct 7 10:03:48 2010 +0000

    net: clear heap allocation for ETHTOOL_GRXCLSRLALL
    
    Calling ETHTOOL_GRXCLSRLALL with a large rule_cnt will allocate kernel
    heap without clearing it. For the one driver (niu) that implements it,
    it will leave the unused portion of heap unchanged and copy the full
    contents back to userspace.
    
    Signed-off-by: Kees Cook <kees.cook@canonical.com>
    Acked-by: Ben Hutchings <bhutchings@solarflare.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/core/ethtool.c b/net/core/ethtool.c
index 7a85367..4016ac6 100644
--- a/net/core/ethtool.c
+++ b/net/core/ethtool.c
@@ -325,49 +325,49 @@ static noinline_for_stack int ethtool_set_rxnfc(struct net_device *dev,
 static noinline_for_stack int ethtool_get_rxnfc(struct net_device *dev,
 						u32 cmd, void __user *useraddr)
 {
 	struct ethtool_rxnfc info;
 	size_t info_size = sizeof(info);
 	const struct ethtool_ops *ops = dev->ethtool_ops;
 	int ret;
 	void *rule_buf = NULL;
 
 	if (!ops->get_rxnfc)
 		return -EOPNOTSUPP;
 
 	/* struct ethtool_rxnfc was originally defined for
 	 * ETHTOOL_{G,S}RXFH with only the cmd, flow_type and data
 	 * members.  User-space might still be using that
 	 * definition. */
 	if (cmd == ETHTOOL_GRXFH)
 		info_size = (offsetof(struct ethtool_rxnfc, data) +
 			     sizeof(info.data));
 
 	if (copy_from_user(&info, useraddr, info_size))
 		return -EFAULT;
 
 	if (info.cmd == ETHTOOL_GRXCLSRLALL) {
 		if (info.rule_cnt > 0) {
 			if (info.rule_cnt <= KMALLOC_MAX_SIZE / sizeof(u32))
-				rule_buf = kmalloc(info.rule_cnt * sizeof(u32),
+				rule_buf = kzalloc(info.rule_cnt * sizeof(u32),
 						   GFP_USER);
 			if (!rule_buf)
 				return -ENOMEM;
 		}
 	}
 
 	ret = ops->get_rxnfc(dev, &info, rule_buf);
 	if (ret < 0)
 		goto err_out;
 
 	ret = -EFAULT;
 	if (copy_to_user(useraddr, &info, info_size))
 		goto err_out;
 
 	if (rule_buf) {
 		useraddr += offsetof(struct ethtool_rxnfc, rule_locs);
 		if (copy_to_user(useraddr, rule_buf,
 				 info.rule_cnt * sizeof(u32)))
 			goto err_out;
 	}
 	ret = 0;
 
