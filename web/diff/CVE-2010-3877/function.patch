commit 88f8a5e3e7defccd3925cabb1ee4d3994e5cdb52
Author: Kulikov Vasiliy <segooon@gmail.com>
Date:   Sun Oct 31 07:10:32 2010 +0000

    net: tipc: fix information leak to userland
    
    Structure sockaddr_tipc is copied to userland with padding bytes after
    "id" field in union field "name" unitialized.  It leads to leaking of
    contents of kernel stack memory.  We have to initialize them to zero.
    
    Signed-off-by: Vasiliy Kulikov <segooon@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/socket.c b/net/tipc/socket.c
index 33217fc..e9f0d50 100644
--- a/net/tipc/socket.c
+++ b/net/tipc/socket.c
@@ -393,66 +393,67 @@ static int bind(struct socket *sock, struct sockaddr *uaddr, int uaddr_len)
 static int get_name(struct socket *sock, struct sockaddr *uaddr,
 		    int *uaddr_len, int peer)
 {
 	struct sockaddr_tipc *addr = (struct sockaddr_tipc *)uaddr;
 	struct tipc_sock *tsock = tipc_sk(sock->sk);
 
+	memset(addr, 0, sizeof(*addr));
 	if (peer) {
 		if ((sock->state != SS_CONNECTED) &&
 			((peer != 2) || (sock->state != SS_DISCONNECTING)))
 			return -ENOTCONN;
 		addr->addr.id.ref = tsock->peer_name.ref;
 		addr->addr.id.node = tsock->peer_name.node;
 	} else {
 		tipc_ownidentity(tsock->p->ref, &addr->addr.id);
 	}
 
 	*uaddr_len = sizeof(*addr);
 	addr->addrtype = TIPC_ADDR_ID;
 	addr->family = AF_TIPC;
 	addr->scope = 0;
 	addr->addr.name.domain = 0;
 
 	return 0;
 }
 
 /**
  * poll - read and possibly block on pollmask
  * @file: file structure associated with the socket
  * @sock: socket for which to calculate the poll bits
  * @wait: ???
  *
  * Returns pollmask value
  *
  * COMMENTARY:
  * It appears that the usual socket locking mechanisms are not useful here
  * since the pollmask info is potentially out-of-date the moment this routine
  * exits.  TCP and other protocols seem to rely on higher level poll routines
  * to handle any preventable race conditions, so TIPC will do the same ...
  *
  * TIPC sets the returned events as follows:
  *
  * socket state		flags set
  * ------------		---------
  * unconnected		no read flags
  *			no write flags
  *
  * connecting		POLLIN/POLLRDNORM if ACK/NACK in rx queue
  *			no write flags
  *
  * connected		POLLIN/POLLRDNORM if data in rx queue
  *			POLLOUT if port is not congested
  *
  * disconnecting	POLLIN/POLLRDNORM/POLLHUP
  *			no write flags
  *
  * listening		POLLIN if SYN in rx queue
  *			no write flags
  *
  * ready		POLLIN/POLLRDNORM if data in rx queue
  * [connectionless]	POLLOUT (since port cannot be congested)
  *
  * IMPORTANT: The fact that a read or write operation is indicated does NOT
  * imply that the operation will succeed, merely that it should be performed
  * and will not block.
  */
 
