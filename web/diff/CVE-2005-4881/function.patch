commit b3563c4fbff906991a1b4ef4609f99cca2a0de6a
Author: Patrick McHardy <kaber@trash.net>
Date:   Tue Jun 28 12:54:43 2005 -0700

    [NETLINK]: Clear padding in netlink messages
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 3029cad..27e4d16 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -160,34 +160,35 @@ static __inline__ struct nlmsghdr *
 __nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)
 {
 	struct nlmsghdr *nlh;
 	int size = NLMSG_LENGTH(len);
 
 	nlh = (struct nlmsghdr*)skb_put(skb, NLMSG_ALIGN(size));
 	nlh->nlmsg_type = type;
 	nlh->nlmsg_len = size;
 	nlh->nlmsg_flags = flags;
 	nlh->nlmsg_pid = pid;
 	nlh->nlmsg_seq = seq;
+	memset(NLMSG_DATA(nlh) + len, 0, NLMSG_ALIGN(size) - size);
 	return nlh;
 }
 
 #define NLMSG_NEW(skb, pid, seq, type, len, flags) \
 ({	if (skb_tailroom(skb) < (int)NLMSG_SPACE(len)) \
 		goto nlmsg_failure; \
 	__nlmsg_put(skb, pid, seq, type, len, flags); })
 
 #define NLMSG_PUT(skb, pid, seq, type, len) \
 	NLMSG_NEW(skb, pid, seq, type, len, 0)
 
 #define NLMSG_NEW_ANSWER(skb, cb, type, len, flags) \
 	NLMSG_NEW(skb, NETLINK_CB((cb)->skb).pid, \
 		  (cb)->nlh->nlmsg_seq, type, len, flags)
 
 #define NLMSG_END(skb, nlh) \
 ({	(nlh)->nlmsg_len = (skb)->tail - (unsigned char *) (nlh); \
 	(skb)->len; })
 
 #define NLMSG_CANCEL(skb, nlh) \
 ({	skb_trim(skb, (unsigned char *) (nlh) - (skb)->data); \
 	-1; })
 
diff --git a/include/linux/rtnetlink.h b/include/linux/rtnetlink.h
index d021888..dc26e82 100644
--- a/include/linux/rtnetlink.h
+++ b/include/linux/rtnetlink.h
@@ -888,84 +888,86 @@ extern int rtnetlink_put_metrics(struct sk_buff *skb, u32 *metrics);
 extern void __rta_fill(struct sk_buff *skb, int attrtype, int attrlen, const void *data);
 
 #define RTA_PUT(skb, attrtype, attrlen, data) \
 ({	if (unlikely(skb_tailroom(skb) < (int)RTA_SPACE(attrlen))) \
 		 goto rtattr_failure; \
    	__rta_fill(skb, attrtype, attrlen, data); }) 
 
 #define RTA_APPEND(skb, attrlen, data) \
 ({	if (unlikely(skb_tailroom(skb) < (int)(attrlen))) \
 		goto rtattr_failure; \
 	memcpy(skb_put(skb, attrlen), data, attrlen); })
 
 #define RTA_PUT_NOHDR(skb, attrlen, data) \
-	RTA_APPEND(skb, RTA_ALIGN(attrlen), data)
+({	RTA_APPEND(skb, RTA_ALIGN(attrlen), data); \
+	memset(skb->tail - (RTA_ALIGN(attrlen) - attrlen), 0, \
+	       RTA_ALIGN(attrlen) - attrlen); })
 
 #define RTA_PUT_U8(skb, attrtype, value) \
 ({	u8 _tmp = (value); \
 	RTA_PUT(skb, attrtype, sizeof(u8), &_tmp); })
 
 #define RTA_PUT_U16(skb, attrtype, value) \
 ({	u16 _tmp = (value); \
 	RTA_PUT(skb, attrtype, sizeof(u16), &_tmp); })
 
 #define RTA_PUT_U32(skb, attrtype, value) \
 ({	u32 _tmp = (value); \
 	RTA_PUT(skb, attrtype, sizeof(u32), &_tmp); })
 
 #define RTA_PUT_U64(skb, attrtype, value) \
 ({	u64 _tmp = (value); \
 	RTA_PUT(skb, attrtype, sizeof(u64), &_tmp); })
 
 #define RTA_PUT_SECS(skb, attrtype, value) \
 	RTA_PUT_U64(skb, attrtype, (value) / HZ)
 
 #define RTA_PUT_MSECS(skb, attrtype, value) \
 	RTA_PUT_U64(skb, attrtype, jiffies_to_msecs(value))
 
 #define RTA_PUT_STRING(skb, attrtype, value) \
 	RTA_PUT(skb, attrtype, strlen(value) + 1, value)
 
 #define RTA_PUT_FLAG(skb, attrtype) \
 	RTA_PUT(skb, attrtype, 0, NULL);
 
 #define RTA_NEST(skb, type) \
 ({	struct rtattr *__start = (struct rtattr *) (skb)->tail; \
 	RTA_PUT(skb, type, 0, NULL); \
 	__start;  })
 
 #define RTA_NEST_END(skb, start) \
 ({	(start)->rta_len = ((skb)->tail - (unsigned char *) (start)); \
 	(skb)->len; })
 
 #define RTA_NEST_CANCEL(skb, start) \
 ({	if (start) \
 		skb_trim(skb, (unsigned char *) (start) - (skb)->data); \
 	-1; })
 
 #define RTA_GET_U8(rta) \
 ({	if (!rta || RTA_PAYLOAD(rta) < sizeof(u8)) \
 		goto rtattr_failure; \
 	*(u8 *) RTA_DATA(rta); })
 
 #define RTA_GET_U16(rta) \
 ({	if (!rta || RTA_PAYLOAD(rta) < sizeof(u16)) \
 		goto rtattr_failure; \
 	*(u16 *) RTA_DATA(rta); })
 
 #define RTA_GET_U32(rta) \
 ({	if (!rta || RTA_PAYLOAD(rta) < sizeof(u32)) \
 		goto rtattr_failure; \
 	*(u32 *) RTA_DATA(rta); })
 
 #define RTA_GET_U64(rta) \
 ({	u64 _tmp; \
 	if (!rta || RTA_PAYLOAD(rta) < sizeof(u64)) \
 		goto rtattr_failure; \
 	memcpy(&_tmp, RTA_DATA(rta), sizeof(_tmp)); \
 	_tmp; })
 
 #define RTA_GET_FLAG(rta) (!!(rta))
 
 #define RTA_GET_SECS(rta) ((unsigned long) RTA_GET_U64(rta) * HZ)
 #define RTA_GET_MSECS(rta) (msecs_to_jiffies((unsigned long) RTA_GET_U64(rta)))
 		
@@ -973,16 +975,17 @@ static inline struct rtattr *
 __rta_reserve(struct sk_buff *skb, int attrtype, int attrlen)
 {
 	struct rtattr *rta;
 	int size = RTA_LENGTH(attrlen);
 
 	rta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));
 	rta->rta_type = attrtype;
 	rta->rta_len = size;
+	memset(RTA_DATA(rta) + attrlen, 0, RTA_ALIGN(size) - size);
 	return rta;
 }
 
 #define __RTA_PUT(skb, attrtype, attrlen) \
 ({ 	if (unlikely(skb_tailroom(skb) < (int)RTA_SPACE(attrlen))) \
 		goto rtattr_failure; \
    	__rta_reserve(skb, attrtype, attrlen); })
 
diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
index e013d83..879237c 100644
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -120,12 +120,13 @@ static const int rta_max[RTM_NR_FAMILIES] =
 void __rta_fill(struct sk_buff *skb, int attrtype, int attrlen, const void *data)
 {
 	struct rtattr *rta;
 	int size = RTA_LENGTH(attrlen);
 
 	rta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));
 	rta->rta_type = attrtype;
 	rta->rta_len = size;
 	memcpy(RTA_DATA(rta), data, attrlen);
+	memset(RTA_DATA(rta) + attrlen, 0, RTA_ALIGN(size) - size);
 }
 
 size_t rtattr_strlcpy(char *dest, const struct rtattr *rta, size_t size)
