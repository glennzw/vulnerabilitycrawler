commit bd968d260aef322fb32e254a3de0d2036c57bd56
Author: Mans Rullgard <mans@mansr.com>
Date:   Wed Aug 10 18:52:11 2011 +0100

    cavs: fix some crashes with invalid bitstreams
    
    This removes all valgrind-reported invalid writes with one
    specific test file.
    
    Fixes http://www.ocert.org/advisories/ocert-2011-002.html
    
    Signed-off-by: Mans Rullgard <mans@mansr.com>
    (cherry picked from commit 4a71da0f3ab7f5542decd11c81994f849d5b2c78)

diff --git a/libavcodec/cavsdec.c b/libavcodec/cavsdec.c
index a9e4d37..35c37d0 100644
--- a/libavcodec/cavsdec.c
+++ b/libavcodec/cavsdec.c
@@ -115,37 +115,39 @@ static inline int get_ue_code(GetBitContext *gb, int order) {
 static int decode_residual_block(AVSContext *h, GetBitContext *gb,
                                  const struct dec_2dvlc *r, int esc_golomb_order,
                                  int qp, uint8_t *dst, int stride) {
     int i, level_code, esc_code, level, run, mask;
     DCTELEM level_buf[65];
     uint8_t run_buf[65];
     DCTELEM *block = h->block;
 
     for(i=0;i<65;i++) {
         level_code = get_ue_code(gb,r->golomb_order);
         if(level_code >= ESCAPE_CODE) {
             run = ((level_code - ESCAPE_CODE) >> 1) + 1;
             esc_code = get_ue_code(gb,esc_golomb_order);
             level = esc_code + (run > r->max_run ? 1 : r->level_add[run]);
             while(level > r->inc_limit)
                 r++;
             mask = -(level_code & 1);
             level = (level^mask) - mask;
-        } else {
+        } else if (level_code >= 0) {
             level = r->rltab[level_code][0];
             if(!level) //end of block signal
                 break;
             run   = r->rltab[level_code][1];
             r += r->rltab[level_code][2];
+        } else {
+            break;
         }
         level_buf[i] = level;
         run_buf[i] = run;
     }
     if(dequant(h,level_buf, run_buf, block, ff_cavs_dequant_mul[qp],
                ff_cavs_dequant_shift[qp], i))
         return -1;
     h->cdsp.cavs_idct8_add(dst,block,stride);
     h->s.dsp.clear_block(block);
     return 0;
 }
 
 
@@ -189,67 +191,68 @@ static inline int decode_residual_inter(AVSContext *h) {
 
 static int decode_mb_i(AVSContext *h, int cbp_code) {
     GetBitContext *gb = &h->s.gb;
-    int block, pred_mode_uv;
+    unsigned pred_mode_uv;
+    int block;
     uint8_t top[18];
     uint8_t *left = NULL;
     uint8_t *d;
 
     ff_cavs_init_mb(h);
 
     /* get intra prediction modes from stream */
     for(block=0;block<4;block++) {
         int nA,nB,predpred;
         int pos = ff_cavs_scan3x3[block];
 
         nA = h->pred_mode_Y[pos-1];
         nB = h->pred_mode_Y[pos-3];
         predpred = FFMIN(nA,nB);
         if(predpred == NOT_AVAIL) // if either is not available
             predpred = INTRA_L_LP;
         if(!get_bits1(gb)){
             int rem_mode= get_bits(gb, 2);
             predpred = rem_mode + (rem_mode >= predpred);
         }
         h->pred_mode_Y[pos] = predpred;
     }
     pred_mode_uv = get_ue_golomb(gb);
     if(pred_mode_uv > 6) {
         av_log(h->s.avctx, AV_LOG_ERROR, "illegal intra chroma pred mode\n");
         return -1;
     }
     ff_cavs_modify_mb_i(h, &pred_mode_uv);
 
     /* get coded block pattern */
     if(h->pic_type == AV_PICTURE_TYPE_I)
         cbp_code = get_ue_golomb(gb);
     if(cbp_code > 63){
         av_log(h->s.avctx, AV_LOG_ERROR, "illegal intra cbp\n");
         return -1;
     }
     h->cbp = cbp_tab[cbp_code][0];
     if(h->cbp && !h->qp_fixed)
         h->qp = (h->qp + get_se_golomb(gb)) & 63; //qp_delta
 
     /* luma intra prediction interleaved with residual decode/transform/add */
     for(block=0;block<4;block++) {
         d = h->cy + h->luma_scan[block];
         ff_cavs_load_intra_pred_luma(h, top, &left, block);
         h->intra_pred_l[h->pred_mode_Y[ff_cavs_scan3x3[block]]]
             (d, top, left, h->l_stride);
         if(h->cbp & (1<<block))
             decode_residual_block(h,gb,ff_cavs_intra_dec,1,h->qp,d,h->l_stride);
     }
 
     /* chroma intra prediction */
     ff_cavs_load_intra_pred_chroma(h);
     h->intra_pred_c[pred_mode_uv](h->cu, &h->top_border_u[h->mbx*10],
                                   h->left_border_u, h->c_stride);
     h->intra_pred_c[pred_mode_uv](h->cv, &h->top_border_v[h->mbx*10],
                                   h->left_border_v, h->c_stride);
 
     decode_residual_chroma(h);
     ff_cavs_filter(h,I_8X8);
     set_mv_intra(h);
     return 0;
 }
 
@@ -435,25 +438,27 @@ static inline int decode_slice_header(AVSContext *h, GetBitContext *gb) {
 static inline int check_for_slice(AVSContext *h) {
     GetBitContext *gb = &h->s.gb;
     int align;
 
     if(h->mbx)
         return 0;
     align = (-get_bits_count(gb)) & 7;
     /* check for stuffing byte */
     if(!align && (show_bits(gb,8) == 0x80))
         align = 8;
     if((show_bits_long(gb,24+align) & 0xFFFFFF) == 0x000001) {
         skip_bits_long(gb,24+align);
         h->stc = get_bits(gb,8);
+        if (h->stc >= h->mb_height)
+            return 0;
         decode_slice_header(h,gb);
         return 1;
     }
     return 0;
 }
 
 /*****************************************************************************
  *
  * frame level
  *
  ****************************************************************************/
 
@@ -636,76 +641,76 @@ static void cavs_flush(AVCodecContext * avctx) {
 static int cavs_decode_frame(AVCodecContext * avctx,void *data, int *data_size,
                              AVPacket *avpkt) {
     const uint8_t *buf = avpkt->data;
     int buf_size = avpkt->size;
     AVSContext *h = avctx->priv_data;
     MpegEncContext *s = &h->s;
     int input_size;
     const uint8_t *buf_end;
     const uint8_t *buf_ptr;
     AVFrame *picture = data;
     uint32_t stc = -1;
 
     s->avctx = avctx;
 
     if (buf_size == 0) {
         if(!s->low_delay && h->DPB[0].data[0]) {
             *data_size = sizeof(AVPicture);
             *picture = *(AVFrame *) &h->DPB[0];
         }
         return 0;
     }
 
     buf_ptr = buf;
     buf_end = buf + buf_size;
     for(;;) {
         buf_ptr = ff_find_start_code(buf_ptr,buf_end, &stc);
-        if(stc & 0xFFFFFE00)
+        if((stc & 0xFFFFFE00) || buf_ptr == buf_end)
             return FFMAX(0, buf_ptr - buf - s->parse_context.last_index);
         input_size = (buf_end - buf_ptr)*8;
         switch(stc) {
         case CAVS_START_CODE:
             init_get_bits(&s->gb, buf_ptr, input_size);
             decode_seq_header(h);
             break;
         case PIC_I_START_CODE:
             if(!h->got_keyframe) {
                 if(h->DPB[0].data[0])
                     avctx->release_buffer(avctx, (AVFrame *)&h->DPB[0]);
                 if(h->DPB[1].data[0])
                     avctx->release_buffer(avctx, (AVFrame *)&h->DPB[1]);
                 h->got_keyframe = 1;
             }
         case PIC_PB_START_CODE:
             *data_size = 0;
             if(!h->got_keyframe)
                 break;
             init_get_bits(&s->gb, buf_ptr, input_size);
             h->stc = stc;
             if(decode_pic(h))
                 break;
             *data_size = sizeof(AVPicture);
             if(h->pic_type != AV_PICTURE_TYPE_B) {
                 if(h->DPB[1].data[0]) {
                     *picture = *(AVFrame *) &h->DPB[1];
                 } else {
                     *data_size = 0;
                 }
             } else
                 *picture = *(AVFrame *) &h->picture;
             break;
         case EXT_START_CODE:
             //mpeg_decode_extension(avctx,buf_ptr, input_size);
             break;
         case USER_START_CODE:
             //mpeg_decode_user_data(avctx,buf_ptr, input_size);
             break;
         default:
             if (stc <= SLICE_MAX_START_CODE) {
                 init_get_bits(&s->gb, buf_ptr, input_size);
                 decode_slice_header(h, &s->gb);
             }
             break;
         }
     }
 }
 
