commit 67fee9128e54c6c3fc3eae306b5b501f3029c3be
Author: Fabio M. Di Nitto <fdinitto@redhat.com>
Date:   Wed Oct 29 09:07:33 2008 +0100

    ccsais: fix buffer overflow when reading huge config files
    
    it was possible to overflow a buffer when adding more than 52 entries
    within the same xml block:
    
    <block>
     <entry1...
     <entry2...
    ....
     <entry53.. <-
    </block>
    
    fix the overflow by increasing the limit to 1024 and fail to start if
    we hit the limit.
    
    Signed-off-by: Fabio M. Di Nitto <fdinitto@redhat.com>

diff --git a/config/plugins/ccsais/config.c b/config/plugins/ccsais/config.c
index 6ee1c0b..ad3c40a 100644
--- a/config/plugins/ccsais/config.c
+++ b/config/plugins/ccsais/config.c
@@ -19,6 +19,10 @@
 #define CONFIG_VERSION_PATH	"/cluster/@config_version"
 #define CONFIG_NAME_PATH	"/cluster/@name"
 
+#ifndef MAXXMLNODES
+#define MAXXMLNODES 1024
+#endif
+
 static int ccs_readconfig(struct objdb_iface_ver0 *objdb, char **error_string);
 static int ccs_reloadconfig(struct objdb_iface_ver0 *objdb, int flush, char **error_string);
 static int init_config(struct objdb_iface_ver0 *objdb, char *error_string);
@@ -86,95 +90,101 @@ static int should_alloc(int ccs_fd, char *key)
 static int read_config_for(int ccs_fd, struct objdb_iface_ver0 *objdb, unsigned int parent,
 			   char *object, char *key, int always_create)
 {
 	int error;
 	char *str;
 	unsigned int object_handle = 0;
 	char path[256];
 	int gotcount = 0;
-	char *subkeys[52];
+	char *subkeys[MAXXMLNODES];
 	int subkeycount = 0;
 	int i;
 
 	if (should_alloc(ccs_fd, key) || always_create)
 		objdb->object_create(parent, &object_handle, object, strlen(object));
 
 	sprintf(path, "%s/@*", key);
 
 	/* Get the keys */
 	for (;;)
 	{
 		char *equal;
 
 		error = ccs_get_list(ccs_fd, path, &str);
 		if (error || !str)
                         break;
 
 		equal = strchr(str, '=');
 		if (equal)
 		{
 			*equal = 0;
 			objdb->object_key_create(object_handle, str, strlen(str),
 						 equal+1, strlen(equal+1)+1);
 			gotcount++;
 		}
 		free(str);
 	}
 
 	/* Now look for sub-objects.
 	   CCS can't cope with recursive queries so we have to store the result of
 	   the subkey search */
 	memset(subkeys, 0, sizeof(subkeys));
 	sprintf(path, "%s/child::*", key);
 	for (;;)
 	{
 		char *equal;
 
 		error = ccs_get_list(ccs_fd, path, &str);
 		if (error || !str)
                         break;
 
 		/* CCS returns duplicate values for the numbered entries we use below.
 		   eg. if there are 4 <clusternode/> entries it will return
 		     clusternode=
 		     clusternode=
 		     clusternode=
 		     clusternode=
 		   which is not helpful to us cos we retrieve them as
 		     clusternode[1]
 		     clusternode[2]
 		     clusternode[3]
 		     clusternode[4]
 		   so we just store unique keys.
 		*/
 		equal = strchr(str, '=');
 		if (equal)
 			*equal = 0;
 
 		if (subkeycount > 0 && strcmp(str, subkeys[subkeycount-1]) == 0)
 		{
 			free(str);
 			continue;
 		}
 		subkeys[subkeycount++] = str;
+		if (subkeycount >= MAXXMLNODES)
+			return -1;
 	}
 
 	for (i=0; i<subkeycount; i++)
 	{
 		int count = 0;
 		str = subkeys[i];
 		gotcount++;
 
 		for (;;)
 		{
 			char subpath[1024];
+			int res;
 
 			/* Found a subkey, iterate through it's sub sections */
 			sprintf(subpath, "%s/%s[%d]", key, str, ++count);
-			if (!read_config_for(ccs_fd, objdb, object_handle, str, subpath, 0))
+			res = read_config_for(ccs_fd, objdb, object_handle, str, subpath, 0);
+			if (!res)
 				break;
+			if (res < 0)
+				return -1;
 		}
 		free(str);
 	}
 	return gotcount;
 }
 
@@ -203,21 +213,24 @@ static int ccs_readconfig(struct objdb_iface_ver0 *objdb, char **error_string)
 static int init_config(struct objdb_iface_ver0 *objdb, char *error_string)
 {
 	int cd;
 	char *cname = NULL;
 
 	/* Connect to ccsd */
 	if (getenv("CCS_CLUSTER_NAME")) {
 		cname = getenv("CCS_CLUSTER_NAME");
 	}
 
 	cd = ccs_force_connect(cname, 0);
 	if (cd < 0) {
 		strcpy(error_string, "Error connecting to CCS to get configuration. Check ccsd is running");
 		return -1;
 	}
 
-	read_config_for(cd, objdb, OBJECT_PARENT_HANDLE, "cluster", "/cluster", 1);
+	if(read_config_for(cd, objdb, OBJECT_PARENT_HANDLE, "cluster", "/cluster", 1) < 0) {
+		strcpy(error_string, "Error: too many nodes within the same XML block\n");
+		return -1;
+	}
 
 	ccs_disconnect(cd);
 	return 0;
 }
