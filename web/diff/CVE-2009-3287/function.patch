commit 7bd027914c5ffd36bb408ef47dc749de3b6e063a
Author: macournoyer <macournoyer@gmail.com>
Date:   Wed Aug 12 17:28:38 2009 -0400

    Fix Remote address spoofing vulnerability in Connection#remote_address [Alexey Borzenkov]

diff --git a/CHANGELOG b/CHANGELOG
index 595de22..4cc2b5a 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -1,260 +1,261 @@
 == 1.2.3
+ * Fix Remote address spoofing vulnerability in Connection#remote_address [Alexey Borzenkov]
  * Fix uninitialized constant ActionController::Dispatcher error with Rails 1.2.3 [Chris Anderton] [#103 state:resolved]
 
 == 1.2.2 I Find Your Lack of Sauce Disturbing release
  * Fix force kill under 1.9 [Alexey Chebotar]
  * Fix regression when --only option is used w/ --socket.
  * Add process name 'tag' functionality. Easier to distinguish thin daemons 
    from eachother in process listing [ctcherry]
 
 == 1.2.1 Asynctilicious Ultra Supreme release
  * Require Rack 1.0.0
  * Require EventMachine 0.12.6
  * Use Rails Rack based dispatcher when available
  * Allow String for response body
  * Require openssl before eventmachine to prevent crash in 1.9
 
 == 1.2.0 Asynctilicious Supreme release 
  * Add support for Windows mingw Ruby distro [Juan C. Rodriguez]
  * Add async response support, see example/async_*.ru [raggi]
 
 == 1.1.1 Super Disco Power Plus release 
  * Fix bug when running with only options [hasimo]
 
 == 1.1.0 Super Disco Power release
  * Require EventMachine 0.12.4
  * Remove Thin handler, now part of Rack 0.9.1
  * Fix Rack protocol version to 0.1 in environment hash.
  * Fix error when passing no_epoll option to a cluster.
  * Omit parsing #defined strings [Jérémy Zurcher]
  * Defaults SERVER_NAME to localhost like webrick does [#87 state:resolved]
  * Namespace parser to prevent error when mongrel is required [cliffmoon]
  * Set RACK_ENV based on environment option when loading rackup file [Curtis Summers] [#83 state:resolved]
  * Fixes a warning RE relative_url_root when using a prefix with Rails 2.1.1 [seriph] [#85 state:resolved]
  * --only can work as a sequence number (if < 80) or a port number (if >= 80) [jmay] [#81 state:resolved]
 
 == 1.0.0 That's What She Said release
  * Fixed vlad.rake to allow TCP or socket [hellekin]
  * Updated Mack adapter to handle both <0.8.0 and >0.8.0 [Mark Bates]
  * rails rack adapter uses File.readable_real? so it recognizes ACL permissions [Ricardo Chimal]
  * Log a warning if Rack application returns nil body [Michael S. Klishin]
  * Handle nil and Time header values correctly [#76 state:resolved] [tmm1]
  * Add Content-Length header to response automatically when possible [#74 state:resolved] [dkubb]
  * Runner now remembers -r, -D and -V parameters so that clustered servers inherit those and
    `restart` keep your parameters.
  * Make Set-Cookie header, in Rails adapter, compatible with current Rack spec [Pedro Belo]
    [#73, state:resolved]
  * Add --no-epoll option to disable epoll usage on Linux [#61 state:resolved]
  * Add --force (-f) option to force stopping of a daemonized server [#72 state:resolved]
  * Update halycon adapter loader [mtodd]
 
 == 0.8.2 Double Margarita release
  * Require EventMachine 0.12.0
  * [bug] Fix timeout handling when running command
  * [bug] Fix hanging when restarting and no process is running in single server move, fixes #67
  * Added Mack adapter [markbates]
  * Allow rackup .rb files by getting a conventionally named constant as the app [bmizerany]
 
 == 0.8.1 Rebel Porpoise release
  * [bug] Rescue all types of errors when processing request, fixes #62
  * [bug] Use Swiftiply backend when -y option is specified, fixes #63 and #64
  * Allow passing port as a string in Server.new
  * Define deferred?(env) in your Rack application to set if a request is handled in a
 	 thread (return true) or not (return false).
 
 == 0.8.0 Dodgy Dentist release
  * [bug] Fix server crash when header too large.
  * Add --require (-r) option to require a library, before executing your script.
  * Rename --rackup short option to -R, warn and load as rackup when file ends with .ru.
  * List supported adapters in command usage.
  * Add file adapter to built-in adapter, serve static files in current directory.
  * Allow disabling signal handling in Server with :signals => false
  * Make Server.new arguments more flexible, can now specify any of host, port, app or hash options.
  * Add --backend option to specified which backend to use, closes #55
  * [bug] Serve static file only on GET and HEAD requests in Rails adapter, fixes #58
  * Add threaded option to run server in threaded mode, calling the application in a
    thread allowing for concurrency in the Rack adapter, closes #46
  * Guess which adapter to use from directory (chdir option)
    or use specified one in 'adapter' option, re #47.
 
 == 0.7.1 Fancy Pants release
  * Clean stale PID files when starting as daemon, fixes #53 [Chu Yeow]
  * Require EventMachine 0.11.0 for UNIX domain sockets. Until it's released, install from:
    gem install eventmachine --source http://code.macournoyer.com
  * Ruby 1.8.5 compatibility, closes #49 [Wincent Colaiuta]
  * Move all EventMachine stuff out of Server, you can now create a Thin Backend that
    does not depend on EventMachine.
  * Rename Connector to Backend. Extend Thin::Backends::Base to implement your own.
  * Fix high memory usage with big POST body, fixes #48
 
 == 0.7.0 Spherical Cow release
  * Add --max-persistent-conns option to sets the maximum number of persistent connections.
    Set to 0 to disable Keep-Alive.
  * INT signal now force stop and QUIT signal gracefully stops.
  * Warn when descriptors table size can't be set as high as expected.
  * Eval Rackup config file using top level bindings.
  * Remove daemons gem dependency on Windows plateform, fixes #45.
  * Change default timeout from 60 to 30 seconds.
  * Add --max-conns option to sets the maximum number of file or socket descriptors that
    your process may open, defaults to 1024.
  * Tail logfile when stopping and restarting a demonized server, fixes #26.
  * Wrap application in a Rack::CommonLogger adapter in debug mode.
  * --debug (-D) option no longer set $DEBUG so logging will be less verbose
    and Ruby won't be too strict, fixes #36.
  * Deprecate Server#silent in favour of Logging.silent.
  * Persistent connection (keep-alive) support.
  * Fix -s option not being included in generated config file, fixes #37.
  * Add Swiftiply support. Use w/ the --swiftiply (-y) option in the thin script,
    closes #28 [Alex MacCaw]
 
 == 0.6.4 Sexy Lobster release
  * Fix error when stopping server on UNIX domain socket, fixes #42
  * Rescue errors in Connection#get_peername more gracefully, setting REMOTE_ADDR to nil, fixes #43
 
 == 0.6.3 Ninja Cookie release
  * Add tasks for Vlad the Deployer in example/vlad.rake [cnantais]
  * Add Ramaze Rackup config file in example dir [tmm1]
    Use like this from you Ramaze app dir:
    
      thin start -r /path/to/thin/example/ramaze.ru
    
  * Add the --rackup option to load a Rack config file instead of the Rails adapter.
    So you can use any framework with the thin script and start cluster and stuff like that.
    A Rack config file is one that is usable through the rackup command and looks like this:
      
      use Rack::CommonLogger
      run MyCrazyRackAdapter.new(:uterly, 'cool')
      
    Then use it with thin like this:
      
      thin start --rackup config.ru
      
  * thin config --chrdir ... -C thin/yml do not change current directory anymore, fixes #33.
  * Add a better sample god config file in example/thin.god that loads all info from config
    files in /etc/thin. Drop-in replacement for the thin runlevel service [Gump].
  * Add support for specifying a custom Connector to the server and add more doc about Server
    configuration.
  * Add a script to run thin as a runlevel service that can start at startup, closes #31 [Gump]
    Setup the service like this:
    
      sudo thin install /etc/thin
    
    This will install the boot script under /etc/init.d/thin. Then copy your config files to
    /etc/thin. Works only under Linux.
  * Set process name to 'thin server (0.0.0.0:3000)' when running as a daemon, closes #32.
  * Make sure chdir option from config file is used when present.
  * Raise an error when starting a server as a daemon and pid file already exist, fixes #27.
 
 == 0.6.2 Rambo release
  * Server now let current connections finish before stopping, fixes #18
  * Fix uploading hanging bug when body is moved to a tempfile,
    also delete the tempfile properly upon completion, fixes #25
  * 'thin restart' now sends HUP signals rather then stopping & starting, closes #17
  * HUP signal now launches a new process with the same options.
  * Add PID and more info from the last request to the Stats adapter
    mostly taken from Rack::ShowException.
  * pid and log files in cluster are no longer required to be relative to the
    app directory (chdir option), fixes #24
  * Revert to using #each when building response headers under Ruby 1.8,
    solves an issue w/ Camping adapter, fixes #22
  * Restructure thin script options in 3 sections: server, daemon and cluster
  * Add --only (-o) option to control only one server of a cluster.
  * Stylize stats page and make the url configurable from the thin script.
  * Raise error if attempting to use unix sockets on windows.
  * Add example config files for http://www.tildeslash.com/monit usage.
    Include the example file using "include /path/to/thin/monit/file" in your monitrc file.
    The group settings let you do this to manage your clusters:
    
      sudo monit -g blog restart all
     
    There are examples of thin listening on sockets and thin listening on unix sockets.
 
 == 0.6.1 Cheesecake release
  * Remove socket file when server stops.
  * Set back cluster to use 'thin' command to launch servers.
 
 == 0.6.0 Big Pony release
  * Add support for connection through UNIX domain socket.
    Use the --socket (-S) option w/ the thin script to configure the socket filename.
    Nginx support binding to a UNIX socket like this:
    
      upstream  backend {
        server   unix:/tmp/thin.0.sock;
        server   unix:/tmp/thin.1.sock;
        server   unix:/tmp/thin.2.sock;
      }
   
    Start your servers like this:
    
      thin start -s3 -S/tmp/thin.sock
    
  * Remove Server#listen! method. Use Server#start instead.
  * Server can now yield a Rack::Builder to allow building an app in one call:
  
      Server.start '0.0.0.0', 3000 do
        use Rack::CommonLogger
        use Rack::ShowExceptions
        map "/lobster" do
          use Rack::Lint
          run Rack::Lobster.new
        end
      end
      
  * Add a very basic stats page through Stats adapter, load w/ --stats and browse to /stats.
  * Add --trace (-V) option to trace request/response and get backtrace w/out all Ruby debug stuff.
  * Add --config (-C) option to load options from a config file in thin script [Matt Todd].
  * Alter response headers to output directly to a string.
  * Improve specs stability.
  * Move request body to a Tempfile if too big (> 112 MB)
  * Remove useless check for max header size in Request (already done in the parser)
 
 == 0.5.4 Flying Mustard release
  * Don't read the full body, use direct streaming when sending response.
    See: Response#each
    As a result, the Content-Length can not be calculated anymore.
    You have to do set this in your adapter. All frameworks do it anyway.
    It improve memory usage and boost speed for low concurrency.
    Thanks to Kent Sibilev and Ezra for their help on that one.
  * Add 'Server' response header
  * Fix --user and --group option not changing daemon process privileges
  
 == 0.5.3 Purple Yogurt release
  * win32 pre-compiled gem now available
  * change rake task configuration to allow win32 gem build
  * Add prefix option to thin script to mount app under a given path.
 
 == 0.5.2 Cheezburger release
  * Add cluster support through the -s option in the thin script, start 3 thins like this:
     thin start -s3 -p3000
    3 thin servers will be started on port 3000, 3001, 3002, also the port number will be
    injected in the pid and log filenames.
  * Fix IOError when writing to logger when starting server as a daemon.
  * Really change directory when the -c option is specified.
  * Add restart command to thin script.
  * Fix typos in thin script usage message and expand chdir path.
  * Rename thin script options to be the same as mongrel_rails script [thronedrk]:
      -o --host  => -a --address
      --log-file => --log
      --pid-file => --pid
      --env      => --environment
  
 == 0.5.1 LOLCAT release
  * Add URL rewriting to Rails adapter so that page caching works and / fetches index.html if present.
  * Fix bug in multiline response header parsing.
  * Add specs for the Rails adapter.
  * Fix Set-Cookie headers in Rails adapter to handle multiple values correctly.
  * Fix Ruby 1.9 incompatibility in Response#headers= and Rakefile.
  * Fix parser to be Ruby 1.9 compatible [Aman Gupta]
  * Set gemspec to use EventMachine version 0.8.1 as it's the latest one having precompiled windows binaries.
    [Francis Cianfrocca].
  * Add -D option to thin script to set debugging on.
  * Output incoming data and response when debugging is on.
 
 == 0.5.0
  * Full rewrite to use EventMachine, Rack and Mongrel parser
  
 == 0.4.1
  * Fix Rails environment option not being used in thin script.
  
 == 0.4.0
  * First alphaish release as a gem.
diff --git a/lib/thin/connection.rb b/lib/thin/connection.rb
index 1da7d1e..7ead989 100644
--- a/lib/thin/connection.rb
+++ b/lib/thin/connection.rb
@@ -3,219 +3,219 @@ require 'socket'
 module Thin
   # Connection between the server and client.
   # This class is instanciated by EventMachine on each new connection
   # that is opened.
   class Connection < EventMachine::Connection
     CONTENT_LENGTH    = 'Content-Length'.freeze
     TRANSFER_ENCODING = 'Transfer-Encoding'.freeze
     CHUNKED_REGEXP    = /\bchunked\b/i.freeze
 
     include Logging
     
     # This is a template async response. N.B. Can't use string for body on 1.9
     AsyncResponse = [-1, {}, []].freeze
     
     # Rack application (adapter) served by this connection.
     attr_accessor :app
 
     # Backend to the server
     attr_accessor :backend
 
     # Current request served by the connection
     attr_accessor :request
 
     # Next response sent through the connection
     attr_accessor :response
 
     # Calling the application in a threaded allowing
     # concurrent processing of requests.
     attr_writer :threaded
 
     # Get the connection ready to process a request.
     def post_init
       @request  = Request.new
       @response = Response.new
     end
 
     # Called when data is received from the client.
     def receive_data(data)
       trace { data }
       process if @request.parse(data)
     rescue InvalidRequest => e
       log "!! Invalid request"
       log_error e
       close_connection
     end
 
     # Called when all data was received and the request
     # is ready to be processed.
     def process
       if threaded?
         @request.threaded = true
         EventMachine.defer(method(:pre_process), method(:post_process))
       else
         @request.threaded = false
         post_process(pre_process)
       end
     end
 
     def pre_process
       # Add client info to the request env
       @request.remote_address = remote_address
 
       # Connection may be closed unless the App#call response was a [-1, ...]
       # It should be noted that connection objects will linger until this 
       # callback is no longer referenced, so be tidy!
       @request.async_callback = method(:post_process)
       
       # When we're under a non-async framework like rails, we can still spawn
       # off async responses using the callback info, so there's little point
       # in removing this.
       response = AsyncResponse
       catch(:async) do
         # Process the request calling the Rack adapter
         response = @app.call(@request.env)
       end
       response
     rescue Exception
       handle_error
       terminate_request
       nil # Signal to post_process that the request could not be processed
     end
 
     def post_process(result)
       return unless result
       result = result.to_a
       
       # Status code -1 indicates that we're going to respond later (async).
       return if result.first == AsyncResponse.first
 
       # Set the Content-Length header if possible
       set_content_length(result) if need_content_length?(result)
       
       @response.status, @response.headers, @response.body = *result
 
       log "!! Rack application returned nil body. Probably you wanted it to be an empty string?" if @response.body.nil?
 
       # Make the response persistent if requested by the client
       @response.persistent! if @request.persistent?
 
       # Send the response
       @response.each do |chunk|
         trace { chunk }
         send_data chunk
       end
 
     rescue Exception
       handle_error
     ensure
       # If the body is being deferred, then terminate afterward.
       if @response.body.respond_to?(:callback) && @response.body.respond_to?(:errback)
         @response.body.callback { terminate_request }
         @response.body.errback  { terminate_request }
       else
         # Don't terminate the response if we're going async.
         terminate_request unless result && result.first == AsyncResponse.first
       end
     end
 
     # Logs catched exception and closes the connection.
     def handle_error
       log "!! Unexpected error while processing request: #{$!.message}"
       log_error
       close_connection rescue nil
     end
 
     def close_request_response
       @request.async_close.succeed if @request.async_close
       @request.close  rescue nil
       @response.close rescue nil
     end
 
     # Does request and response cleanup (closes open IO streams and
     # deletes created temporary files).
     # Re-initializes response and request if client supports persistent
     # connection.
     def terminate_request
       unless persistent?
         close_connection_after_writing rescue nil
         close_request_response
       else
         close_request_response
         # Prepare the connection for another request if the client
         # supports HTTP pipelining (persistent connection).
         post_init
       end
     end
 
     # Called when the connection is unbinded from the socket
     # and can no longer be used to process requests.
     def unbind
       @request.async_close.succeed if @request.async_close
       @response.body.fail if @response.body.respond_to?(:fail)
       @backend.connection_finished(self)
     end
 
     # Allows this connection to be persistent.
     def can_persist!
       @can_persist = true
     end
 
     # Return +true+ if this connection is allowed to stay open and be persistent.
     def can_persist?
       @can_persist
     end
 
     # Return +true+ if the connection must be left open
     # and ready to be reused for another request.
     def persistent?
       @can_persist && @response.persistent?
     end
 
     # +true+ if <tt>app.call</tt> will be called inside a thread.
     # You can set all requests as threaded setting <tt>Connection#threaded=true</tt>
     # or on a per-request case returning +true+ in <tt>app.deferred?</tt>.
     def threaded?
       @threaded || (@app.respond_to?(:deferred?) && @app.deferred?(@request.env))
     end
 
     # IP Address of the remote client.
     def remote_address
-      @request.forwarded_for || socket_address
+      socket_address
     rescue Exception
       log_error
       nil
     end
 
     protected
 
       # Returns IP address of peer as a string.
       def socket_address
         Socket.unpack_sockaddr_in(get_peername)[1]
       end
 
     private
       def need_content_length?(result)
         status, headers, body = result
         return false if status == -1
         return false if headers.has_key?(CONTENT_LENGTH)
         return false if (100..199).include?(status) || status == 204 || status == 304
         return false if headers.has_key?(TRANSFER_ENCODING) && headers[TRANSFER_ENCODING] =~ CHUNKED_REGEXP
         return false unless body.kind_of?(String) || body.kind_of?(Array)
         true
       end
 
       def set_content_length(result)
         headers, body = result[1..2]
         case body
         when String
           # See http://redmine.ruby-lang.org/issues/show/203
           headers[CONTENT_LENGTH] = (body.respond_to?(:bytesize) ? body.bytesize : body.size).to_s
         when Array
            bytes = 0
            body.each do |p|
              bytes += p.respond_to?(:bytesize) ? p.bytesize : p.size
            end
            headers[CONTENT_LENGTH] = bytes.to_s
         end
       end
   end
diff --git a/lib/thin/request.rb b/lib/thin/request.rb
index 60adae7..0add8a6 100644
--- a/lib/thin/request.rb
+++ b/lib/thin/request.rb
@@ -4,154 +4,149 @@ require 'tempfile'
 module Thin
   # Raised when an incoming request is not valid
   # and the server can not process it.
   class InvalidRequest < IOError; end
 
   # A request sent by the client to the server.
   class Request
     # Maximum request body size before it is moved out of memory
     # and into a tempfile for reading.
     MAX_BODY          = 1024 * (80 + 32)
     BODY_TMPFILE      = 'thin-body'.freeze
     MAX_HEADER        = 1024 * (80 + 32)
 
     # Freeze some HTTP header names & values
     SERVER_SOFTWARE   = 'SERVER_SOFTWARE'.freeze
     SERVER_NAME       = 'SERVER_NAME'.freeze
     LOCALHOST         = 'localhost'.freeze
     HTTP_VERSION      = 'HTTP_VERSION'.freeze
     HTTP_1_0          = 'HTTP/1.0'.freeze
     REMOTE_ADDR       = 'REMOTE_ADDR'.freeze
-    FORWARDED_FOR     = 'HTTP_X_FORWARDED_FOR'.freeze
     CONTENT_LENGTH    = 'CONTENT_LENGTH'.freeze
     CONNECTION        = 'HTTP_CONNECTION'.freeze
     KEEP_ALIVE_REGEXP = /\bkeep-alive\b/i.freeze
     CLOSE_REGEXP      = /\bclose\b/i.freeze
     
     # Freeze some Rack header names
     RACK_INPUT        = 'rack.input'.freeze
     RACK_VERSION      = 'rack.version'.freeze
     RACK_ERRORS       = 'rack.errors'.freeze
     RACK_MULTITHREAD  = 'rack.multithread'.freeze
     RACK_MULTIPROCESS = 'rack.multiprocess'.freeze
     RACK_RUN_ONCE     = 'rack.run_once'.freeze
     ASYNC_CALLBACK    = 'async.callback'.freeze
     ASYNC_CLOSE       = 'async.close'.freeze
 
     # CGI-like request environment variables
     attr_reader :env
 
     # Unparsed data of the request
     attr_reader :data
 
     # Request body
     attr_reader :body
 
     def initialize
       @parser   = Thin::HttpParser.new
       @data     = ''
       @nparsed  = 0
       @body     = StringIO.new
       @env      = {
         SERVER_SOFTWARE   => SERVER,
         SERVER_NAME       => LOCALHOST,
 
         # Rack stuff
         RACK_INPUT        => @body,
 
         RACK_VERSION      => VERSION::RACK,
         RACK_ERRORS       => STDERR,
 
         RACK_MULTITHREAD  => false,
         RACK_MULTIPROCESS => false,
         RACK_RUN_ONCE     => false
       }
     end
 
     # Parse a chunk of data into the request environment
     # Raises a +InvalidRequest+ if invalid.
     # Returns +true+ if the parsing is complete.
     def parse(data)
       if @parser.finished?  # Header finished, can only be some more body
         body << data
       else                  # Parse more header using the super parser
         @data << data
         raise InvalidRequest, 'Header longer than allowed' if @data.size > MAX_HEADER
 
         @nparsed = @parser.execute(@env, @data, @nparsed)
 
         # Transfert to a tempfile if body is very big
         move_body_to_tempfile if @parser.finished? && content_length > MAX_BODY
       end
 
 
       if finished?   # Check if header and body are complete
         @data = nil
         @body.rewind
         true         # Request is fully parsed
       else
         false        # Not finished, need more data
       end
     end
 
     # +true+ if headers and body are finished parsing
     def finished?
       @parser.finished? && @body.size >= content_length
     end
 
     # Expected size of the body
     def content_length
       @env[CONTENT_LENGTH].to_i
     end
 
     # Returns +true+ if the client expect the connection to be persistent.
     def persistent?
       # Clients and servers SHOULD NOT assume that a persistent connection
       # is maintained for HTTP versions less than 1.1 unless it is explicitly
       # signaled. (http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html)
       if @env[HTTP_VERSION] == HTTP_1_0
         @env[CONNECTION] =~ KEEP_ALIVE_REGEXP
 
       # HTTP/1.1 client intends to maintain a persistent connection unless
       # a Connection header including the connection-token "close" was sent
       # in the request
       else
         @env[CONNECTION].nil? || @env[CONNECTION] !~ CLOSE_REGEXP
       end
     end
 
     def remote_address=(address)
       @env[REMOTE_ADDR] = address
     end
 
-    def forwarded_for
-      @env[FORWARDED_FOR]
-    end
-
     def threaded=(value)
       @env[RACK_MULTITHREAD] = value
     end
     
     def async_callback=(callback)
       @env[ASYNC_CALLBACK] = callback
       @env[ASYNC_CLOSE] = EventMachine::DefaultDeferrable.new
     end
     
     def async_close
       @async_close ||= @env[ASYNC_CLOSE]
     end
 
     # Close any resource used by the request
     def close
       @body.delete if @body.class == Tempfile
     end
 
     private
       def move_body_to_tempfile
         current_body = @body
         current_body.rewind
         @body = Tempfile.new(BODY_TMPFILE)
         @body.binmode
         @body << current_body.read
         @env[RACK_INPUT] = @body
       end
   end
diff --git a/lib/thin/version.rb b/lib/thin/version.rb
index bcab7e6..c6242d2 100644
--- a/lib/thin/version.rb
+++ b/lib/thin/version.rb
@@ -1,31 +1,31 @@
 module Thin  
   # Raised when a feature is not supported on the
   # current platform.
   class PlatformNotSupported < RuntimeError; end
   
   module VERSION #:nodoc:
     MAJOR    = 1
     MINOR    = 2
-    TINY     = 2
+    TINY     = 3
     
     STRING   = [MAJOR, MINOR, TINY].join('.')
     
-    CODENAME = "I Find Your Lack of Sauce Disturbing".freeze
+    CODENAME = "Astroboy".freeze
     
     RACK     = [1, 0].freeze # Rack protocol version
   end
   
   NAME    = 'thin'.freeze
   SERVER  = "#{NAME} #{VERSION::STRING} codename #{VERSION::CODENAME}".freeze  
   
   def self.win?
     RUBY_PLATFORM =~ /mswin|mingw/
   end
   
   def self.linux?
     RUBY_PLATFORM =~ /linux/
   end
   
   def self.ruby_18?
     RUBY_VERSION =~ /^1\.8/
   end
diff --git a/spec/connection_spec.rb b/spec/connection_spec.rb
index 151e783..1167211 100644
--- a/spec/connection_spec.rb
+++ b/spec/connection_spec.rb
@@ -3,102 +3,103 @@ require File.dirname(__FILE__) + '/spec_helper'
 describe Connection do
   before do
     @connection = Connection.new(mock('EM', :null_object => true))
     @connection.post_init
     @connection.app = proc do |env|
       [200, {}, ['']]
     end
   end
   
   it "should parse on receive_data" do
     @connection.request.should_receive(:parse).with('GET')
     @connection.receive_data('GET')
   end
 
   it "should close connection on InvalidRequest error in receive_data" do
     @connection.request.stub!(:parse).and_raise(InvalidRequest)
     @connection.should_receive(:close_connection)
     @connection.receive_data('')
   end
   
   it "should process when parsing complete" do
     @connection.request.should_receive(:parse).and_return(true)
     @connection.should_receive(:process)
     @connection.receive_data('GET')
   end
   
   it "should process" do
     @connection.process
   end
   
   it "should rescue error in process" do
     @connection.app.should_receive(:call).and_raise(StandardError)
     @connection.process
   end
   
   it "should rescue Timeout error in process" do
     @connection.app.should_receive(:call).and_raise(Timeout::Error.new("timeout error not rescued"))
     @connection.process
   end
   
-  it "should return HTTP_X_FORWARDED_FOR as remote_address" do
+  it "should not return HTTP_X_FORWARDED_FOR as remote_address" do
     @connection.request.env['HTTP_X_FORWARDED_FOR'] = '1.2.3.4'
-    @connection.remote_address.should == '1.2.3.4'
+    @connection.stub!(:socket_address).and_return("127.0.0.1")
+    @connection.remote_address.should == "127.0.0.1"
   end
   
   it "should return nil on error retreiving remote_address" do
     @connection.stub!(:get_peername).and_raise(RuntimeError)
     @connection.remote_address.should be_nil
   end
   
   it "should return nil on nil get_peername" do
     @connection.stub!(:get_peername).and_return(nil)
     @connection.remote_address.should be_nil
   end
   
   it "should return nil on empty get_peername" do
     @connection.stub!(:get_peername).and_return('')
     @connection.remote_address.should be_nil
   end
   
   it "should return remote_address" do
     @connection.stub!(:get_peername).and_return(Socket.pack_sockaddr_in(3000, '127.0.0.1'))
     @connection.remote_address.should == '127.0.0.1'
   end
   
   it "should not be persistent" do
     @connection.should_not be_persistent
   end
 
   it "should be persistent when response is and allowed" do
     @connection.response.stub!(:persistent?).and_return(true)
     @connection.can_persist!
     @connection.should be_persistent
   end
 
   it "should not be persistent when response is but not allowed" do
     @connection.response.persistent!
     @connection.should_not be_persistent
   end
   
   it "should set request env as rack.multithread" do
     EventMachine.should_receive(:defer)
     
     @connection.threaded = true
     @connection.process
     
     @connection.request.env["rack.multithread"].should == true
   end
   
   it "should set as threaded when app.deferred? is true" do
     @connection.app.should_receive(:deferred?).and_return(true)
     @connection.should be_threaded
   end
   
   it "should not set as threaded when app.deferred? is false" do
     @connection.app.should_receive(:deferred?).and_return(false)
     @connection.should_not be_threaded
   end
 
   it "should not set as threaded when app do not respond to deferred?" do
     @connection.should_not be_threaded
   end
