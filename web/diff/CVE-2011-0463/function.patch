commit 272b62c1f0f6f742046e45b50b6fec98860208a0
Author: Goldwyn Rodrigues <rgoldwyn@gmail.com>
Date:   Thu Feb 17 09:44:40 2011 -0600

    Treat writes as new when holes span across page boundaries
    
    When a hole spans across page boundaries, the next write forces
    a read of the block. This could end up reading existing garbage
    data from the disk in ocfs2_map_page_blocks. This leads to
    non-zero holes. In order to avoid this, mark the writes as new
    when the holes span across page boundaries.
    
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.de>
    Signed-off-by: jlbec <jlbec@evilplan.org>

diff --git a/fs/ocfs2/aops.c b/fs/ocfs2/aops.c
index 0d44b77..b5d7fb9 100644
--- a/fs/ocfs2/aops.c
+++ b/fs/ocfs2/aops.c
@@ -1004,71 +1004,77 @@ static void ocfs2_write_failure(struct inode *inode,
 static int ocfs2_prepare_page_for_write(struct inode *inode, u64 *p_blkno,
 					struct ocfs2_write_ctxt *wc,
 					struct page *page, u32 cpos,
 					loff_t user_pos, unsigned user_len,
 					int new)
 {
 	int ret;
 	unsigned int map_from = 0, map_to = 0;
 	unsigned int cluster_start, cluster_end;
 	unsigned int user_data_from = 0, user_data_to = 0;
 
 	ocfs2_figure_cluster_boundaries(OCFS2_SB(inode->i_sb), cpos,
 					&cluster_start, &cluster_end);
 
+	/* treat the write as new if the a hole/lseek spanned across
+	 * the page boundary.
+	 */
+	new = new | ((i_size_read(inode) <= page_offset(page)) &&
+			(page_offset(page) <= user_pos));
+
 	if (page == wc->w_target_page) {
 		map_from = user_pos & (PAGE_CACHE_SIZE - 1);
 		map_to = map_from + user_len;
 
 		if (new)
 			ret = ocfs2_map_page_blocks(page, p_blkno, inode,
 						    cluster_start, cluster_end,
 						    new);
 		else
 			ret = ocfs2_map_page_blocks(page, p_blkno, inode,
 						    map_from, map_to, new);
 		if (ret) {
 			mlog_errno(ret);
 			goto out;
 		}
 
 		user_data_from = map_from;
 		user_data_to = map_to;
 		if (new) {
 			map_from = cluster_start;
 			map_to = cluster_end;
 		}
 	} else {
 		/*
 		 * If we haven't allocated the new page yet, we
 		 * shouldn't be writing it out without copying user
 		 * data. This is likely a math error from the caller.
 		 */
 		BUG_ON(!new);
 
 		map_from = cluster_start;
 		map_to = cluster_end;
 
 		ret = ocfs2_map_page_blocks(page, p_blkno, inode,
 					    cluster_start, cluster_end, new);
 		if (ret) {
 			mlog_errno(ret);
 			goto out;
 		}
 	}
 
 	/*
 	 * Parts of newly allocated pages need to be zero'd.
 	 *
 	 * Above, we have also rewritten 'to' and 'from' - as far as
 	 * the rest of the function is concerned, the entire cluster
 	 * range inside of a page needs to be written.
 	 *
 	 * We can skip this if the page is up to date - it's already
 	 * been zero'd from being read in as a hole.
 	 */
 	if (new && !PageUptodate(page))
 		ocfs2_clear_page_regions(page, OCFS2_SB(inode->i_sb),
 					 cpos, user_data_from, user_data_to);
 
 	flush_dcache_page(page);
 
