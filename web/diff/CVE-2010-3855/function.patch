commit 59eb9f8cfe7d1df379a2318316d1f04f80fba54a
Author: Werner Lemberg <wl@gnu.org>
Date:   Tue Oct 12 07:49:17 2010 +0200

    Fix Savannah bug #31310.
    
    * src/truetype/ttgxvar.c (ft_var_readpackedpoints): Protect against
    invalid `runcnt' values.

diff --git a/ChangeLog b/ChangeLog
index c4f2132..fb8085e 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,1233 +1,1240 @@
+2010-10-12  Werner Lemberg  <wl@gnu.org>
+
+	Fix Savannah bug #31310.
+
+	* src/truetype/ttgxvar.c (ft_var_readpackedpoints): Protect against
+	invalid `runcnt' values.
+
 2010-10-08  Chris Liddell  <chris.liddell@artifex.com>
 
 	Fix Savannah bug #31275.
 
 	* src/sfnt/ttpost.c: Include FT_INTERNAL_DEBUG_H.
 
 2010-10-06  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Improve error handling of `SHZ' bytecode instruction.
 	Problem reported by Chris Evans <scarybeasts@gmail.com>.
 
 	* src/truetype/ttinterp.c (Ins_SHZ): Check `last_point'.
 
 2010-10-05  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #31253.
 	Patch submitted by an anonymous reporter.
 
 	* configure: Use `awk' instead of `sed' to manipulate output of `ls
 	-id'.
 
 2010-10-03  Werner Lemberg  <wl@gnu.org>
 
 	* Version 2.4.3 released.
 	=========================
 
 
 	Tag sources with `VER-2-4-3'.
 
 	* docs/CHANGES: Updated.
 
 	* docs/VERSION.DLL: Update documentation and bump version number to
 	2.4.3
 
 	* README, Jamfile (RefDoc),
 	builds/win32/vc2005/freetype.vcproj, builds/win32/vc2005/index.html,
 	builds/win32/vc2008/freetype.vcproj, builds/win32/vc2008/index.html,
 	builds/win32/visualc/freetype.dsp,
 	builds/win32/visualc/freetype.vcproj,
 	builds/win32/visualc/index.html, builds/win32/visualce/freetype.dsp,
 	builds/win32/visualce/freetype.vcproj,
 	builds/win32/visualce/index.html,
 	builds/wince/vc2005-ce/freetype.vcproj,
 	builds/wince/vc2005-ce/index.html,
 	builds/wince/vc2008-ce/freetype.vcproj,
 	builds/wince/vc2008-ce/index.html: s/2.4.2/2.4.3/, s/242/243/.
 
 	* include/freetype/freetype.h (FREETYPE_PATCH): Set to 3.
 
 	* builds/unix/configure.raw (version_info): Set to 12:1:6.
 
 2010-10-03  Werner Lemberg  <wl@gnu.org>
 
 	Avoid `configure' issues with symbolic links.
 	Based on a patch from Alexander Stohr <Alexander.Stohr@gmx.de>.
 
 	* configure: Compare directories using `ls -id'.
 	Check existence of `reference' subdirectory before creating it.
 
 2010-10-02  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #31088 (sort of).
 
 	* src/sfnt/ttload.c (tt_face_load_maxp): Always allocate at least 64
 	function entries.
 
 2010-10-02  Werner Lemberg  <wl@gnu.org>
 
 	[smooth] Fix splitting of cubics for negative values.
 
 	Reported by Róbert Márki <gsmiko@gmail.com>; see
 	http://lists.gnu.org/archive/html/freetype/2010-09/msg00019.html.
 
 	* src/smooth/ftgrays.c (gray_render_cubic): Fix thinko.
 
 2010-10-01  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Fix Savannah bug #31040.
 
 	* src/truetype/ttinterp.c (free_buffer_in_size): Remove.
 	(TT_RunIns): Updated.
 
 2010-09-20  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	[sfnt] Make error message filling NULL names less verbose.
 
 	* src/sfnt/ttpost.c (load_format_20): Showing 1 summary message
 	when we fill `post' names by NULL, instead of per-entry message.
 
 2010-09-20  Graham Asher  <graham.asher@btinternet.com>
 	    David Bevan  <david.bevan@pb.com>
 
 	[smooth] Fix and improve spline flattening.
 
 	This fixes the flattening of cubic, S-shaped curves and speeds up
 	the handling of both the conic and cubic arcs.
 
 	See the discussions on the freetype-devel mailing list in late
 	August and September 2010 for details.
 
 	* src/smooth/ftgrays.c (FT_MAX_CURVE_DEVIATION): New macro.
 	(TWorker): Remove `conic_level' and `cubic_level' elements.
 	(gray_render_conic): Simplify algorithm.
 	(gray_render_cubic): New algorithm; details are given in the code
 	comments.
 	(gray_convert_glyph): Remove heuristics.
 
 2010-09-19  Werner Lemberg  <wl@gnu.org>
 
 	Minor fixes.
 
 	* src/cff/cffload.c (cff_charset_compute_cids): `charset->sids[i]'
 	is `FT_UShort'.
 	(cff_index_access_element): Don't use additions in comparison.
 	* src/sfnt/ttpost.c (load_format_20): Make `post_limit' of type
 	`FT_Long'.
 	Don't use additions in comparison.
 	Improve tracing messages.
 	(load_format_25, load_post_names): Make `post_limit' of type
 	`FT_Long'.
 
 2010-09-19  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	[cff] Truncate the element length at the end of the stream.
 	See Savannah bug #30975.
 
 	* src/cff/cffload.c (cff_index_access_element): `off2', the offset
 	to the next element is truncated at the end of the stream to prevent
 	invalid I/O.  As `off1', the offset to the requested element has
 	been checked by FT_STREAM_SEEK(), `off2' should be checked
 	similarly.
 
 2010-09-19  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	[cff] Ignore CID > 0xFFFFU.
 	See Savannah bug #30975.
 
 	* src/cff/cffload.c (cff_charset_compute_cids): Ignore CID if
 	greater than 0xFFFFU.  CFF font spec does not mention maximum CID in
 	the font, but PostScript and PDF spec define that maximum CID is
 	0xFFFFU.
 
 2010-09-19  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	[cff] Make trace message in cff_charset_load() verbose.
 	See Savannah bug #30975.
 
 	* src/cff/cffload.c (cff_charset_load): Report the original `nleft'
 	and truncated `nleft'.
 
 2010-09-19  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	[cff] Correct `max_cid' from CID array length to max CID.
 	See Savannah bug #30975.
 
 	* src/cff/cffload.c (cff_charset_compute_cids): Don't increment
 	max_cid after detecting max CID.  The array CFF_Charset->cids is
 	allocated by max_cid + 1.
 	(cff_charset_cid_to_gindex): Permit CID is less than or equal to
 	CFF_Charset->max_cid.
 	* src/cff/cffobjs.c (cff_face_init): FT_Face->num_glyphs is
 	calculated as CFF_Charset->max_cid + 1.
 
 2010-09-19  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	[truetype] Sanitize the broken offsets in `loca'.
 	See Savannah bug #31040.
 
 	* src/truetype/ttpload.c (tt_face_get_location): If `pos1', the
 	offset to the requested entry in `glyf' exceeds the end of the
 	table, return offset=0, length=0.  If `pos2', the offset to the next
 	entry in `glyf' exceeds the end of the table, truncate the entry
 	length at the end of `glyf' table.
 
 2010-09-19  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	[sfnt] Prevent overrunning in `post' table parser.
 	See Savannah bug #31040.
 
 	* src/sfnt/ttpost.c (load_post_names): Get the length of `post'
 	table and pass the limit of `post' table to load_format_20() and
 	load_format_25().
 	(load_format_20): Stop the parsing when we reached at the limit of
 	`post' table.  If more glyph names are required, they are filled by
 	NULL names.
 
 2010-09-17  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	[truetype] Don't duplicate size->twilight structure to be freed.
 	See Savannah bug #31040 for detail.
 
 	* src/truetype/ttinterp.c (free_buffer_in_size): Don't duplicate
 	FT_GlyphZoneRec size->twilight to be freed.  If duplicated,
 	FT_FREE() erases the duplicated pointers only and leave original
 	pointers.  They can cause the double-free crash when the burst
 	errors occur in TrueType interpreter and free_buffer_in_size() is
 	invoked repeatedly.
 
 2010-09-15  Werner Lemberg  <wl@gnu.org>
 
 	Make bytecode debugging with FontForge work again.
 
 	* src/truetype/ttinterp.c (TT_RunIns): Don't call
 	`free_buffer_in_size' in case of error if a debugger is active.
 
 2010-09-14  Werner Lemberg  <wl@gnu.org>
 
 	Improve tracing messages.
 
 	* src/truetype/ttinterp.c (TT_RunIns): Improve wording of tracing
 	message.
 	* src/truetype/ttobjs.c (tt_size_run_fpgm, tt_size_run_prep): Add
 	tracing message.
 	* src/truetype/ttgload.c (tt_loader_init): Add tracing message.
 	* src/cache/ftcsbits.c (ftc_snode_load): Emit tracing message if
 	glyph doesn't fit into a small bitmap container.
 
 2010-09-13  Werner Lemberg  <wl@gnu.org>
 
 	Fix minor issues reported by <muktha.narayan@wipro.com>.
 
 	* src/autofit/aflatin.c (af_latin_compute_stem_width): Remove
 	redundant conditional check.
 	* src/base/ftsynth.c (FT_GlyphSlot_Embolden): Ditto.
 	* src/cff/cffload.c (cff_encoding_load): Remove conditional check
 	which always evaluates to `true'.
 	* src/pshinter/pshalgo.c (ps_glyph_interpolate_strong_points):
 	Ditto.
 	* src/truetype/ttinterp.c (Ins_IUP): Ditto.
 	* src/cid/cidgload.c (cid_slot_load_glyph): Don't check for NULL if
 	value is already dereferenced.
 	* src/winfonts/winfnt.c (FNT_Load_Glyph): Fix check of `face'.
 
 2010-08-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Ignore the environmental setting of LIBTOOL.
 	Patch is suggested by Adrian Bunk, to prevent unexpected
 	reflection of environmental LIBTOOL.  See:
 	http://savannah.nongnu.org/patch/?7290
 
 	* builds/unix/unix-cc.in: LIBTOOL is unconditionally set to
 	$(FT_LIBTOOL_DIR)/libtool.  FT_LIBTOOL_DIR is set to $(BUILD_DIR)
 	by default.
 	* configure: When configured for the building out of source tee,
 	FT_LIBTOOL_DIR is set to $(OBJ_DIR).
 
 2010-08-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	[truetype] Decrease the trace level catching the interpreter error.
 
 	* src/truetype/ttinterp.c (TT_RunIns): Decrease the trace level
 	showing the error when the interpreter returns with an error,
 	from FT_TRACE7() to FT_TRACE1().
 
 2010-08-30  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	[truetype] Prevent bytecode reuse after the interpretation error.
 
 	* src/truetype/ttinterp.c (free_buffer_in_size): New function to
 	free the buffer allocated during the interpretation of this glyph.
 	(TT_RunIns): Unset FT_Face->size->{cvt_ready,bytecode_ready} if
 	an error occurs in the bytecode interpretation.  The interpretation
 	of invalid bytecode may break the function definitions and referring
 	them in later interpretation is danger.  By unsetting these flags,
 	`fpgm' and `prep' tables are executed again in next interpretation.
 
 	This fixes Savannah bug #30798, reported by Robert Święcki.
 
 2010-08-29  Werner Lemberg  <wl@gnu.org>
 
 	[ftraster] Pacify compiler.
 
 	* src/raster/ftraster.c (ft_black_new) [_STANDALONE_]: `memory' is
 	not used.
 
 2010-08-29  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Allow SIDs >= 65000.
 
 	* src/cff/cffload.c (cff_charset_load): Fix change from 2009-03-20:
 	The threshold for SIDs is not applicable here.  I misinterpreted the
 	`SID values 65000 and above are available for implementation use'
 	sentence in the CFF specification.
 
 	Problem reported by Ivan Ninčić <inincic@pdftron.com>.
 
 2010-08-28  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Force hinting when the font lacks its familyname.
 
 	In Type42 or Type11 font embedded in PostScript & PDF, TrueType sfnt
 	stream may lack `name' table because they are not required.  Hinting
 	for nameless fonts is safer for PDFs including embedded Chinese
 	fonts.  Written by David Bevan, see:
 
 	http://lists.gnu.org/archive/html/freetype-devel/2010-08/msg00021.html
 	http://lists.freedesktop.org/archives/poppler/2010-August/006310.html
 
 	* src/truetype/ttobjs.c (tt_check_trickyness): If a NULL pointer by
 	nameless font is given, TRUE is returned to enable hinting.
 
 2010-08-28  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Register yet another tricky TrueType font.
 
 	* src/truetype/ttobjs.c (tt_check_trickyness): Add `HuaTianKaiTi?',
 	a Kaishu typeface paired with `HuaTianSongTi?' by Huatian
 	Information Industry.
 
 2010-08-17  Teijo Kinnunen <Teijo.Kinnunen@nuance.com>
 
 	Fix Savannah bug #30788.
 
 	* src/cache/ftccache.c (FTC_Cache_Clear): Check `cache->buckets' for
 	NULL too.
 
 2010-08-10  Werner Lemberg  <wl@gnu.org>
 
 	Try to fix Savannah bug #30717 (and probably #30719 too).
 
 	* src/smooth/ftsmooth.c (ft_smooth_render_generic): Add another
 	overflow test for `width' and `height'.
 
 2010-08-06  Werner Lemberg  <wl@gnu.org>
 
 	* Version 2.4.2 released.
 	=========================
 
 
 	Tag sources with `VER-2-4-2'.
 
 	* docs/CHANGES: Updated.
 
 	* docs/VERSION.DLL: Update documentation and bump version number to
 	2.4.2
 
 	* README, Jamfile (RefDoc),
 	builds/win32/vc2005/freetype.vcproj, builds/win32/vc2005/index.html,
 	builds/win32/vc2008/freetype.vcproj, builds/win32/vc2008/index.html,
 	builds/win32/visualc/freetype.dsp,
 	builds/win32/visualc/freetype.vcproj,
 	builds/win32/visualc/index.html, builds/win32/visualce/freetype.dsp,
 	builds/win32/visualce/freetype.vcproj,
 	builds/win32/visualce/index.html,
 	builds/wince/vc2005-ce/freetype.vcproj,
 	builds/wince/vc2005-ce/index.html,
 	builds/wince/vc2008-ce/freetype.vcproj,
 	builds/wince/vc2008-ce/index.html: s/2.4.1/2.4.2/, s/241/242/.
 
 	* include/freetype/freetype.h (FREETYPE_PATCH): Set to 2.
 
 	* builds/unix/configure.raw (version_info): Set to 12:0:6.
 
 2010-08-06  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Fix Savannah bug #30648.
 
 	* src/base/ftobjs.c (FT_Done_Library): Specify the order of font
 	drivers during the face closing process.  Type42 faces should be
 	closed before TrueType faces, because a Type42 face refers to
 	another internal TrueType face which is created from sfnt[] array on
 	the memory.
 
 2010-08-06  Yuriy Kaminskiy  <yumkam@mail.ru>
 
 	[raster] Fix valgrind warning.
 
 	* src/raster/ftraster.c (Decompose_Curve) <default>: Access point[0]
 	only if we don't hit `limit'.
 
 2010-08-06  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Fix Savannah bug #30658.
 
 	* src/base/ftobjs.c (Mac_Read_POST_Resource): Check that the total
 	length of collected POST segments does not overrun the allocated
 	buffer.
 
 2010-08-06  Yuriy Kaminskiy  <yumkam@mail.ru>
 
 	Fix conditional usage of FT_MulFix_i386.
 	With -ansi flag, gcc does not define `i386', only `__i386__'.
 
 	* include/freetype/config/ftconfig.h, builds/unix/ftconfig.in:
 	s/i386/__i386__/.
 
 2010-08-05  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30657.
 
 	* src/truetype/ttinterp.c (BOUNDSL): New macro.
 	Change `BOUNDS' to `BOUNDSL' where appropriate.
 
 	* src/truetype/ttinterp.h (TT_ExecContextRec): Fix type of
 	`cvtSize'.
 
 2010-08-05  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30656.
 
 	* src/type42/t42parse.c (t42_parse_sfnts): Protect against negative
 	string_size.
 	Fix comparison.
 
 2010-08-05  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	[cff] Don't use any values in decoder after parsing error.
 
 	* src/cff/cffgload.c (cff_slot_load): Skip the evaluations
 	of the values in decoder, if cff_decoder_parse_charstrings()
 	returns any error.
 
 2010-08-04  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30644.
 
 	* src/base/ftstream.c (FT_Stream_EnterFrame): Fix comparison.
 
 2010-08-04  Werner Lemberg  <wl@gnu.org>
 
 	`make devel' fails if FT_CONFIG_OPTION_OLD_INTERNALS is set.
 
 	* devel/ftoption.h: Synchronize with
 	include/freetype/config/ftoption.h.
 
 2010-08-04  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	[cff] Improve stack overflow test.
 
 	* src/cff/cffgload.c (cff_decoder_parse_charstrings): Check stack
 	after execution of operations too.
 
 2010-07-18  Werner Lemberg  <wl@gnu.org>
 
 	Add reference counters and to FT_Library and FT_Face objects.
 
 	* include/freetype/freetype.h (FT_Reference_Face): New function.
 	* include/freetype/ftmodapi.h (FT_Rererence_Library): New function.
 
 	* include/freetype/internal/ftobjs.h (FT_Face_InternalRec,
 	FT_LibraryRec): New field `refcount'.
 
 	* src/base/ftobjs.c (FT_Open_Face, FT_New_Library): Handle
 	`refcount'.
 	(FT_Reference_Face, FT_Reference_Library): Implement new functions.
 	(FT_Done_Face, FT_Done_Library): Handle `refcount'.
 
 	* docs/CHANGES: Updated.
 
 2010-07-18  Werner Lemberg  <wl@gnu.org>
 
 	* Version 2.4.1 released.
 	=========================
 
 
 	Tag sources with `VER-2-4-1'.
 
 	* docs/CHANGES: Updated.
 
 	* docs/VERSION.DLL: Update documentation and bump version number to
 	2.4.1.
 
 	* README, Jamfile (RefDoc),
 	builds/win32/vc2005/freetype.vcproj, builds/win32/vc2005/index.html,
 	builds/win32/vc2008/freetype.vcproj, builds/win32/vc2008/index.html,
 	builds/win32/visualc/freetype.dsp,
 	builds/win32/visualc/freetype.vcproj,
 	builds/win32/visualc/index.html, builds/win32/visualce/freetype.dsp,
 	builds/win32/visualce/freetype.vcproj,
 	builds/win32/visualce/index.html,
 	builds/wince/vc2005-ce/freetype.vcproj,
 	builds/wince/vc2005-ce/index.html,
 	builds/wince/vc2008-ce/freetype.vcproj,
 	builds/wince/vc2008-ce/index.html: s/2.4.0/2.4.1/, s/240/241/.
 
 	* include/freetype/freetype.h (FREETYPE_PATCH): Set to 1.
 
 	* builds/unix/configure.raw (version_info): Set to 11:1:5.
 
 2010-07-17  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Final try to fix `hintmask' and `cntrmask' limit check.
 
 	Problem reported by Tobias Wolf <towolf@gmail.com>.
 
 	* src/cff/cffgload.c (cff_decoder_parse_charstrings)
 	<cff_op_hintmask>: Sigh.  I'm apparently too silly to fix this
 	correctly in less than three tries.
 
 2010-07-12  Werner Lemberg  <wl@gnu.org>
 
 	* Version 2.4.0 released.
 	=========================
 
 
 	Tag sources with `VER-2-4-0'.
 
 	* docs/CHANGES: Updated.
 
 	* docs/VERSION.DLL: Update documentation and bump version number to
 	2.4.0.
 
 	* README, Jamfile (RefDoc),
 	builds/win32/vc2005/freetype.vcproj, builds/win32/vc2005/index.html,
 	builds/win32/vc2008/freetype.vcproj, builds/win32/vc2008/index.html,
 	builds/win32/visualc/freetype.dsp,
 	builds/win32/visualc/freetype.vcproj,
 	builds/win32/visualc/index.html, builds/win32/visualce/freetype.dsp,
 	builds/win32/visualce/freetype.vcproj,
 	builds/win32/visualce/index.html,
 	builds/wince/vc2005-ce/freetype.vcproj,
 	builds/wince/vc2005-ce/index.html,
 	builds/wince/vc2008-ce/freetype.vcproj,
 	builds/wince/vc2008-ce/index.html: s/2.3.12/2.4.0/, s/2312/240/.
 
 	* include/freetype/freetype.h (FREETYPE_MINOR): Set to 4.
 	(FREETYPE_PATCH): Set to 0.
 
 	* builds/unix/configure.raw (version_info): Set to 11:0:5.
 
 2010-07-12  Werner Lemberg  <wl@gnu.org>
 
 	Remove C++ warnings.
 
 	*/*: Initialize pointers where necessary to make g++ happy.
 
 2010-07-12  malc  <av1474@comtv.ru>
 	    Richard Henderson  <rth@redhat.com>
 
 	Fix type-punning issues with C++.
 
 	* include/freetype/internal/ftmemory.h (FT_ASSIGNP) [__cplusplus]:
 	Emulate a `typeof' operator with an inline template which uses
 	`static_cast'.
 
 2010-07-11  Werner Lemberg  <wl@gnu.org>
 
 	Fix C++ compilation issue.
 
 	* src/tools/apinames.c (names_dump) <OUTPUT_WATCOM_LBC>: Fix
 	type of `dot' variable.
 
 2010-07-10  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Fix another case reported in Savannah bug #30373.
 	Permit a face for Type1, Type42 and CFF without charmap,
 	patch by Tor Andersson.
 
 	* src/type1/t1objs.c (T1_Face_Init): Reset the error if it
 	is FT_Err_No_Unicode_Glyph_Name.
 	* src/type42/t42objs.c (T42_Face_Init): Ditto.
 	* src/cff/cffobjs.c (cff_face_init): Ditto.
 
 2010-07-09  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Use defined macros to set {platform,encoding}_id.
 
 	* src/bdf/bdfdrivr.c: Include ttnameid.h and use macros to
 	set charmap.{platfom,encoding}_id.
 	* src/pcf/pcfdrivr.c: Ditto.
 	* src/winfonts/winfnt.c: Ditto.
 	* src/type1/t1objs.c: Ditto.
 	* src/type42/t42objs.c: Ditto.
 	* src/cff/cffobjs.c: Ditto.
 	* src/pfr/pfrobjs.c: Ditto.
 
 2010-07-09  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Fix Savannah bug #30373.
 	Too serious check of errors by `FT_CMap_New' since 2010-07-04
 	is fixed. Reported by Tor Andersson.
 
 	* include/freetype/fterrdef.h
 	(PSnames_Err_No_Unicode_Glyph_Name): New error code to
 	indicate the Unicode charmap synthesis failed because
 	no Unicode glyph name is found.
 
 	* src/psnames/psmodule.c (ps_unicodes_init): Return
 	PSnames_Err_No_Unicode_Glyph_Name when no Unicode glyph name
 	is found in the font.
 	* src/cff/cffcmap.c (cff_cmap_unicode_init): Return
 	CFF_Err_No_Unicode_Glyph_Name when no SID is available.
 
 	* src/type1/t1objs.c (T1_Face_Init): Proceed if `FT_CMap_New'
 	is failed by the lack of Unicode glyph name.
 	* src/type42/t42objs.c (T42_Face_Init): Ditto.
 	* src/cff/cffobjs.c (cff_face_init): Ditto.
 
 2010-07-09  Ken Sharp  <ken.sharp@artifex.com>
 
 	Make ftraster.c compile in stand-alone mode with MSVC compiler.
 
 	* src/raster/ftmisc.h (FT_Int64) [_WIN32, _WIN64]: Fix typedef
 	since there is no `inttypes.h' for MSVC.
 
 2010-07-08  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30361.
 
 	* src/truetype/ttinterp.c (Ins_IUP): Fix bounds check.
 
 2010-07-06  Werner Lemberg  <wl@gnu.org>
 
 	Pacify compiler.
 
 	* src/cff/cffload.c (cff_index_get_pointers): Initialize
 	`new_bytes'.
 
 2010-07-05  Eugene A. Shatokhin  <spectre@ispras.ru>
 
 	Fix Savannah bug #27648.
 
 	* src/base/ftobjs.c (ft_remove_renderer, FT_Add_Module): Call
 	`raster_done' only if we have an outline glyph format.
 
 2010-07-05  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30030.
 
 	* builds/win32/*/freetype.vcproj: Add ftxf86.c.
 
 2010-07-05  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Next try to fix `hintmask' and `cntrmask' limit check.
 
 	Problem reported by malc <av1474@comtv.ru>.
 
 	* src/cff/cffgload.c (cff_decoder_parse_charstrings)
 	<cff_op_hintmask>: It is possible that there is just a single byte
 	after the `hintmask' or `cntrmask', e.g., a `return' instruction.
 
 2010-07-04  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Restrict the number of the charmaps in a rogue-compatible mode.
 	Fix for Savannah bug #30059.
 
 	* src/cache/ftccmap.c (FTC_CMapCache_Lookup): Replace `16' the
 	minimum character code passed by a legacy rogue client by...
 	* include/freetype/config/ftoption.h (FT_MAX_CHARMAP_CACHEABLE):
 	This.  It is undefined when FT_CONFIG_OPTION_OLD_INTERNALS is
 	undefined (thus the rogue client compatibility is not required).
 
 	* src/cff/cffobjs.c (cff_face_init): Abort the automatic
 	selection or synthesis of Unicode cmap subtable when the charmap
 	index exceeds FT_MAX_CHARMAP_CACHEABLE.
 	* src/sfnt/ttcmap.c (tt_face_build_cmaps): Issue error message
 	when the charmap index exceeds FT_MAX_CHARMAP_CACHEABLE.
 
 	* src/base/ftobjs.c (find_unicode_charmap): When Unicode charmap
 	is found after FT_MAX_CHARMAP_CACHEABLE, ignore it and search
 	earlier one.
 	(find_variant_selector_charmap): When UVS charmap is found after
 	FT_MAX_CHARMAP_CACHEABLE, ignore it and search earlier one.
 	(FT_Select_Charmap): When a charmap matching with requested
 	encoding but after FT_MAX_CHARMAP_CACHEABLE, ignore and search
 	earlier one.
 	(FT_Set_Charmap): When a charmap matching with requested
 	charmap but after FT_MAX_CHARMAP_CACHEABLE, ignore and search
 	earlier one.
 	(FT_Get_Charmap_Index): When a requested charmap is found
 	after FT_MAX_CHARMAP_CACHEABLE, return the inverted charmap
 	index.
 
 2010-07-04  Werner Lemberg  <wl@gnu.org>
 
 	TrueType hinting is no longer patented.
 
 	* include/freetype/config/ftoption.h, devel/ftoption.h
 	(TT_CONFIG_OPTION_BYTECODE_INTERPRETER): Define.
 	(TT_CONFIG_OPTION_UNPATENTED_HINTING): Undefine.
 
 	* docs/CHANGES, docs/INSTALL, include/freetype/freetype.h: Updated.
 	* docs/TRUETYPE, docs/PATENTS: Removed.
 
 2010-07-04  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Check error value by `FT_CMap_New'.
 
 	* src/cff/cffobjs.c (cff_face_init): Check error value by
 	`FT_CMap_New'.
 	* src/pfr/pfrobjs.c (pfr_face_init): Ditto.
 	* src/type1/t1jobjs.c (T1_Face_Init): Ditto.
 	* src/type42/t42jobjs.c (T42_Face_Init): Ditto.
 
 2010-07-03  Werner Lemberg  <wl@gnu.org>
 
 	Make ftgrays.c compile stand-alone again.
 
 	* src/smooth/ftgrays.c [_STANDALONE_]: Include `stddef.h'.
 	(FT_INT_MAX, FT_PtrDist)[_STANDALONE_]: Define.
 
 2010-07-02  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Additional fix for Savannah bug #30306.
 
 	* src/base/ftobjs.c (Mac_Read_POST_Resource): If the type of the
 	POST fragment is 0, the segment is completely ignored.  The declared
 	length of the segment is not cared at all.  According to Adobe
 	Technical Note 5040, type 0 segment is a comment only and should not
 	be loaded for the interpreter.  Reported by Robert Święcki.
 
 2010-07-01  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Protect against code range underflow.
 
 	* src/truetype/ttinterp.c (DO_JROT, DO_JMPR, DO_JROF): Don't allow
 	negative IP values.
 
 2010-07-01  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Add rudimentary tracing for bytecode instructions.
 
 	* src/truetype/ttinterp.c (opcode_name) [FT_DEBUG_LEVEL_TRACE]: New
 	array.
 	(TT_RunIns): Trace opcodes.
 
 2010-06-30  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30263.
 
 	* src/smooth/ftgrays.c (gray_render_span): Use cast to `unsigned
 	int' to avoid integer overflow.
 
 	* src/smooth/ftsmooth.c (ft_smooth_render_generic): Use smaller
 	threshold values for `width' and `height'.  This is not directly
 	related to the bug fix but makes sense anyway.
 
 2010-07-01  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Initial fix for Savannah bug #30306.
 
 	* src/base/ftobjs.c (Mac_Read_POST_Resource): Check `rlen', the
 	length of fragment declared in the POST fragment header, and prevent
 	an underflow in length calculation.  Some fonts set the length to
 	zero in spite of the existence of a following 16bit `type'.
 	Reported by Robert Święcki.
 
 2010-07-01  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Additional fix for Savannah bug #30248 and #30249.
 
 	* src/base/ftobjs.c (Mac_Read_POST_Resource): Check the buffer size
 	during gathering PFB fragments embedded in LaserWriter PS font for
 	Macintosh.  Reported by Robert Święcki.
 
 2010-06-30  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	Minor optimizations by avoiding divisions.
 
 	* src/sfnt/ttkern.c (tt_face_load_kern, tt_face_get_kerning):
 	Replace divisions with multiplication in comparisons.
 
 2010-06-29  Werner Lemberg  <wl@gnu.org>
 
 	Fix minor tracing issues.
 
 	* src/cff/cffgload.c, src/truetype/ttgload.c: Adjust tracing levels.
 
 2010-06-27  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Really fix `hintmask' and `cntrmask' limit check.
 
 	* src/cff/cffgload.c (cff_decoder_parse_charstrings)
 	<cff_op_hintmask>: Fix thinko and handle tracing also.
 
 2010-06-27  Werner Lemberg  <wl@gnu.org>
 
 	Fix valgrind warning.
 
 	* src/base/ftoutln.c (FT_Outline_Get_Orientation): Initialize
 	`result' array.
 
 2010-06-27  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Fix memory leak.
 
 	* src/cff/cffgload.c (cff_operator_seac): Free charstrings even in
 	case of errors.
 
 2010-06-27  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Protect against invalid `hintmask' and `cntrmask' operators.
 
 	* src/cff/cffgload.c (cff_decoder_parse_charstrings)
 	<cff_op_hintmask>: Ensure that we don't exceed `limit' while parsing
 	the bit masks of the `hintmask' and `cntrmask' operators.
 
 2010-06-26  Werner Lemberg  <wl@gnu.org>
 
 	Fix PFR change 2010-06-24.
 
 	* src/pfr/pfrgload.c (pfr_glyph_load_simple): Really protect against
 	invalid indices.
 
 2010-06-26  Werner Lemberg  <wl@gnu.org>
 
 	Improve PFR tracing messages.
 
 	* src/pfr/pfrgload.c (pfr_glyph_load_rec): Emit tracing messages for
 	simple and compound glyph offsets.
 
 2010-06-26  Werner Lemberg  <wl@gnu.org>
 
 	Fix last PFR change.
 
 	* src/pfr/pfrobjs.c (pfr_face_init): Fix rejection logic.
 
 2010-06-26  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30262.
 
 	* src/sfnt/ttload.c (tt_face_load_maxp): Limit `maxComponentDepth'
 	arbitrarily to 100 to avoid stack exhaustion.
 
 2010-06-26  Werner Lemberg  <wl@gnu.org>
 
 	Add some memory checks (mainly for debugging).
 
 	* src/base/ftstream.c (FT_Stream_EnterFrame): Exit with error
 	if the frame size is larger than the stream size.
 
 	* src/base/ftsystem.c (ft_ansi_stream_io): Exit with error if
 	seeking a position larger than the stream size.
 
 2010-06-25  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30261.
 
 	* src/pfr/pfrobjs.c (pfr_face_init): Reject fonts which contain
 	neither outline nor bitmap glyphs.
 
 2010-06-25  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30254.
 
 	* src/cff/cffload.c (cff_index_get_pointers): Do sanity check for
 	first offset also.
 
 2010-06-25  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Initial fix for Savannah bug #30248 and #30249.
 
 	* src/base/ftobjs.c (Mac_Read_POST_Resource): Check the error during
 	reading a PFB fragment embedded in LaserWriter PS font for Macintosh.
 	Reported by Robert Święcki.
 
 2010-06-24  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30247.
 
 	* src/pcf/pcfread.c (pcf_get_metrics): Disallow (invalid) fonts with
 	zero metrics.
 
 2010-06-24  Graham Asher  <graham.asher@btinternet.com>
 
 	* src/smooth/ftgrays.c (gray_render_cubic): Fix algorithm.
 	The previous version was too aggressive, as demonstrated in
 	http://lists.gnu.org/archive/html/freetype-devel/2010-06/msg00020.html.
 
 2010-06-24  Werner Lemberg  <wl@gnu.org>
 
 	*/*: Use module specific error names where appropriate.
 
 2010-06-24  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30236.
 
 	* src/sfnt/ttcmap.c (tt_face_build_cmaps): Improve check for pointer
 	to `cmap_table'.
 
 2010-06-24  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30235.
 
 	* src/pfr/pfrgload.c (pfr_glyph_load_simple): Protect against
 	invalid indices if there aren't any coordinates for indexing.
 
 2010-06-24  Werner Lemberg  <wl@gnu.org>
 
 	[bdf]: Font properties are optional.
 
 	* src/bdf/bdflib.c (_bdf_readstream): Use special error code to
 	indicate a redo operation.
 	(_bdf_parse_start): Handle `CHARS' keyword here too and pass current
 	input line to `_bdf_parse_glyph'.
 
 2010-06-23  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30220.
 
 	* include/freetype/fterrdef.h
 	(BDF_Err_Missing_Fontboundingbox_Field): New error code.
 
 	* src/bdf/bdflib.c (_bdf_parse_start): Check for missing
 	`FONTBOUNDINGBOX' field.
 	Avoid memory leak if there are multiple `FONT' lines (which is
 	invalid but doesn't hurt).
 
 2010-06-21  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30168.
 
 	* src/pfr/pfrgload.c (pfr_glyph_load_compound): Limit the number of
 	subglyphs to avoid endless recursion.
 
 2010-06-20  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30145.
 
 	* src/psaux/psobjs.c (t1_builder_add_contour): Protect against
 	`outline == NULL' which might happen in invalid fonts.
 
 2010-06-19  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30135.
 
 	* src/bdf/bdflib.c (_bdf_list_join): Don't modify value in static
 	string `empty'.
 	(_bdf_parse_glyph): Avoid memory leak in case of error.
 
 2010-06-15  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30108.
 
 	* src/autofit/afglobal.c (af_face_globals_compute_script_coverage):
 	Properly mask AF_DIGIT bit in comparison.
 
 2010-06-11  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30106.
 
 	Point numbers for FreeType's implementation of hinting masks are
 	collected before the final number of points of a glyph has been
 	determined; in particular, the code for handling the `endchar'
 	opcode can reduce the number of points.
 
 	* src/pshinter/pshalgo.c (psh_glyph_find_strong_points): Assure that
 	`end_point' is not larger than `glyph->num_points'.
 
 2010-06-11  Werner Lemberg  <wl@gnu.org>
 
 	[cff]: Improve debugging output.
 
 	* src/cff/cffgload.c (cff_decoder_parse_charstrings)
 	<cff_op_hintmask>: Implement it.
 
 2010-06-10  Graham Asher  <graham.asher@btinternet.com>
 
 	ftgrays: Speed up rendering of small cubic splines.
 
 	* src/smooth/ftgrays.c (gray_render_cubic): Implement new,
 	simplified algorithm to find out whether the spline can be replaced
 	with two straight lines.  See this thread for more:
 
 	  http://lists.gnu.org/archive/html/freetype-devel/2010-06/msg00000.html
 
 2010-06-09  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30082.
 
 	* src/cff/cffgload.c (cff_decoder_parse_charstrings)
 	<cff_op_callothersubr>: Protect against stack underflow.
 
 2010-06-08  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30053.
 
 	* src/cff/cffparse.c (cff_parse_real): Handle border case where
 	`fraction_length' has value 10.
 
 2010-06-07  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30052.
 	This bug has been introduced with commit 2415cbf3.
 
 	* src/base/ftobjs.c (FT_Get_First_Char, FT_Get_Next_Char): Protect
 	against endless loop in case of corrupted font header data.
 
 2010-05-26  Werner Lemberg  <wl@gnu.org>
 
 	Remove unused variable.
 	Found by Graham.
 
 	* src/autofit/afhints.c (af_glyph_hints_reload): Remove unused
 	variable `first' in first block.
 
 2010-05-22  Werner Lemberg  <wl@gnu.org>
 
 	Fix various memory problems found by linuxtesting.org.
 
 	* src/base/ftgxval.c (FT_TrueTypeGX_Free, FT_ClassicKern_Free),
 	src/base/ftotval.c (FT_OpenType_Free), src/base/ftpfr.c
 	(ft_pfr_check): Check `face'.
 
 	* src/base/ftobjs.c (FT_Get_Charmap_Index): Check `charmap' and
 	`charmap->face'.
 	(FT_Render_Glyph): Check `slot->face'.
 	(FT_Get_SubGlyph_Info): Check `glyph->subglyphs'.
 
 2010-05-22  Werner Lemberg  <wl@gnu.org>
 
 	autofit: Remove dead code.
 	Suggested by Graham.
 
 	* src/autofit/afhints.c (af_glyph_hints_compute_inflections):
 	Removed.
 	(af_glyph_hints_reload): Remove third argument.
 	Update all callers.
 
 2010-05-21  Bram Tassyns  <bramt@enfocus.be>
 
 	Fix Savannah bug #27987.
 
 	* src/cff/cffobjs.c (remove_subset_prefix): New function.
 	(cff_face_init): Use it to adjust `cffface->family_name'.
 
 2010-05-20  Werner Lemberg  <wl@gnu.org>
 
 	TrueType: Make FreeType ignore maxSizeOfInstructions in `maxp'.
 
 	Acroread does the same.
 
 	* src/truetype/ttgload.c (TT_Process_Composite_Glyph): Call
 	`Update_Max' to adjust size of instructions array if necessary and
 	add a rough safety check.
 
 	(load_truetype_glyph): Save `loader->byte_len' before recursive
 	call.
 
 	* src/truetype/ttinterp.h, src/truetype/ttinterp.c (Update_Max):
 	Declare it as FT_LOCAL.
 
 2010-05-18  Hongbo Ni  <hongbo@njstar.com>
 
 	Apply Savannah patch #7196.
 
 	* src/cff/cffgload.c (cff_slot_load): Prevent crash if CFF subfont
 	index is out of range.
 
 2010-05-11  Werner Lemberg  <wl@gnu.org>
 
 	* docs/formats.txt: Give pointer to PCF documentation.
 	Information provided by Alan Coopersmith
 	<alan.coopersmith@oracle.com>.
 
 2010-05-10  Ken Sharp  <ken.sharp@artifex.com>
 
 	Fix Savannah bug #29846.
 
 	Previously we discovered fonts which used `setcurrentpoint' to set
 	the initial point of a contour to 0,0.  This caused FreeType to
 	raise an error, because the `setcurrentpoint' operator is only
 	supposed to be used with the results from an OtherSubr subroutine.
 
 	This was fixed by simply ignoring the error and carrying on.
 
 	Now we have found a font which uses setcurrentpoint to actually
 	establish a non-zero point for a contour during the course of a
 	glyph program.  FWIW, these files may be produced by an application
 	called `Intaglio' on the Mac, when converting TrueType fonts to
 	Type 1.
 
 	The fix allows the new invalid behaviour, the old invalid behaviour
 	and real proper usage of the operator to work the same way as Adobe
 	interpreters apparently do.
 
 	(t1_decoder_parse_charstrings): Make `setcurrentpoint' use the top
 	two elements of the stack to establish unconditionally the current x
 	and y coordinates.
 
 	Make the `flex' subroutine handling (OtherSubr 0) put the current
 	x,y coordinates onto the stack, instead of two dummy uninitialised
 	values.
 
 2010-04-14  Ken Sharp  <ken.sharp@artifex.com>
 
 	Fix Savannah bug #29444.
 
 	* src/psaux/psobjs.c (t1_builder_start_point): Accept (invalid)
 	`lineto' immediately after `hsbw', in accordance with Acrobat, GS,
 	and others.
 
 2010-04-14  Michał Cichoń  <thedmd@artifexmundi.com>
 
 	Fix Savannah bug #27999.
 
 	* src/cache/ftcmanag.c (FTC_Manager_RemoveFaceID): Only remove
 	selected entry, not all.
 
 2010-04-06  Jonathan Kew  <jfkthame@gmail.com>
 
 	Add overflow check to `fvar' table.
 
 	* src/truetype/ttgxvar.c (TT_Get_MM_Var): Check axis and instance
 	count.
 
 2010-04-05  Ken Sharp  <ken.sharp@artifex.com>
 
 	Fix Savannah bug #29335.
 
 	* src/raster/ftraster.c (Line_Up): Use slow multiplication to
 	prevent overflow.  This shouldn't have any serious impact on speed,
 	however.
 
 2010-04-05  Werner Lemberg  <wl@gnu.org>
 
 	Add new function `FT_Library_SetLcdFilterWeights'.
 
 	This is based on code written by Lifter
 	<http://unixforum.org/index.php?showuser=11691>.  It fixes
 	FreeDesktop bug #27386.
 
 	* src/base/ftlcdfil.c (FT_Library_SetLcdFilterWeights): New
 	function.
 
 	* include/freetype/ftlcdfil.h: Updated.
 
 	* docs/CHANGES: Updated.
 
 2010-04-01  John Tytgat  <John.Tytgat@esko.com>
 
 	Fix Savannah bug #29404.
 
 	* src/truetype/ttgload.c: Revert change 2752bd1a (check on bit 1
 	of `head' table of TrueType fonts).
 
 2010-03-14  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Fix `multi build' for Tytgat's CFF driver improvement.
 
 	* src/base/cffload.h (cff_index_get_name): Added.
 
 2010-03-12  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Remove duplicated inclusion of `FT_OUTLINE_H' in ftobjs.c.
 
 	* src/base/ftobjs.c: Remove 2nd inclusion of `FT_OUTLINE_H'.
 
 2010-03-11  Chris Liddell  <chris.liddell@artifex.com>
 
 	Fix Savannah bug #27442.
 
 	* src/raster/ftraster.c (ft_black_reset): Fix `buffer_size'.
 
 2010-03-09  Werner Lemberg  <wl@gnu.org>
 
 	Remove unused variable.
 	Reported by Graham.
 
 	* src/cff/cffparse.c (cff_parse_real): Remove `rest'.
 
 2010-03-02  John Tytgat  <John.Tytgat@esko.com>
 
 	Improve CFF string (especially glyphname) lookup performance.
 
 	We do this by avoiding memory allocation and file I/O.  This is
 	Savannah patch #7104.
 
 	* src/cff/cfftypes.h: Include PS cmaps service and
 	FT_INTERNAL_POSTSCRIPT_HINTS_H.
 	(CFF_SubFontRec): Remove `num_local_subrs'.
 	(CFF_FontRec): Add `num_strings', `strings', and `string_pool'
 	fields.
 	Remove `string_index' and `num_global_subrs' fields.
 	Use real types instead of `void' for `pshinter' and `psnames' fields.
 
 	* src/cff/cffload.c: Don't include PS cmaps service.
 	(cff_index_get_pointers): Add `pool' parameter which allows to
 	insert an extra NUL character for each String INDEX entry.
 	(cff_index_get_name): Make it a local function.
 	(cff_index_get_string): New function.
 	(cff_subfont_load): Updated.
 	(cff_font_load): Initialize `num_strings', `strings', and
 	`string_pool' fields in the `CFF_FontRec' structure.
 	(cff_index_get_sid_string): Use `cff_index_get_string' instead of
 	`cff_index_get_name'.
 	(cff_font_done): Updated.
 
 	* src/cff/cffload.h: Don't include PS cmaps service.
 	(cff_index_get_string): Added.
 	(cff_index_get_sid_string): Updated.
 
 	* src/cff/cffobjs.c: Don't include PS cmaps service and
 	FT_INTERNAL_POSTSCRIPT_HINTS_H.
 	(cff_size_get_globals_funcs, cff_slot_init): Updated.
 	(cff_face_init): Follow `cff_index_get_name',
 	`cff_index_get_string', and `cff_index_get_sid_string' changes.
 
 	* src/cff/cffcmap.c (cff_sid_free_glyph_name): Removed.
 	(cff_sid_to_glyph_name): Use `cff_index_get_cid_string'.
 	(cff_cmap_unicode_init): Updated.
 
 	* src/cff/cffdrivr.c: Don't include PS cmap service.
 	(cff_get_glyph_name): Avoid unnecessary lookup for POSTSCRIPT_CMAPS
 	service.
 	(cff_get_glyph_name, cff_ps_get_font_info, cff_get_ros): Follow API
 	`cff_index_get_sid_string' change.
 	(cff_get_name_index): Use `cff_index_get_string' instead of
 	`cff_index_get_name'.
 
 	* src/cff/cffgload.c: Don't include FT_INTERNAL_POSTSCRIPT_HINTS_H.
 	(cff_decoder_init, cff_decoder_prepare): Updated.
 
 2010-02-27  Werner Lemberg  <wl@gnu.org>
 
 	Simplify code.
 	Suggested by Behdad.
 
 	* src/base/ftobjs.c (FT_Get_First_Char): Don't use a loop since we
 	call FT_Get_Next_Char anyway if necessary.
 
 2010-02-26  Behdad Esfahbod  <behdad@behdad.org>
 
 	Improve handling of invalid glyph indices in char->index functions.
 
 	* src/base/ftobjs.c (FT_Get_First_Char, FT_Get_Next_Char): Use a
 	loop.
 
 2010-02-18  Chris Liddell  <chris.liddell@artifex.com>
 
 	Fix Savannah bug #28905.
 
 	Initialize phantom points before calling the incremental interface
 	to update glyph metrics.
 
 	* src/truetype/ttgload.c (tt_get_metrics_incr_overrides)
 	[FT_CONFIG_OPTION_INCREMENTAL]: New function, split off from...
 	(tt_get_metrics): This.
 	Updated.
 	(load_truetype_glyph): Use tt_get_metrics_incr_overrides.
 
 ----------------------------------------------------------------------------
 
diff --git a/src/truetype/ttgxvar.c b/src/truetype/ttgxvar.c
index 653d9d5..47bb9fc 100644
--- a/src/truetype/ttgxvar.c
+++ b/src/truetype/ttgxvar.c
@@ -1,1548 +1,1548 @@
 /***************************************************************************/
 /*                                                                         */
 /*  ttgxvar.c                                                              */
 /*                                                                         */
 /*    TrueType GX Font Variation loader                                    */
 /*                                                                         */
 /*  Copyright 2004, 2005, 2006, 2007, 2008, 2009, 2010 by                  */
 /*  David Turner, Robert Wilhelm, Werner Lemberg, and George Williams.     */
 /*                                                                         */
 /*  This file is part of the FreeType project, and may only be used,       */
 /*  modified, and distributed under the terms of the FreeType project      */
 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
 /*  this file you indicate that you have read the license and              */
 /*  understand and accept it fully.                                        */
 /*                                                                         */
 /***************************************************************************/
 
 
   /*************************************************************************/
   /*                                                                       */
   /* Apple documents the `fvar', `gvar', `cvar', and `avar' tables at      */
   /*                                                                       */
   /*   http://developer.apple.com/fonts/TTRefMan/RM06/Chap6[fgca]var.html  */
   /*                                                                       */
   /* The documentation for `fvar' is inconsistent.  At one point it says   */
   /* that `countSizePairs' should be 3, at another point 2.  It should     */
   /* be 2.                                                                 */
   /*                                                                       */
   /* The documentation for `gvar' is not intelligible; `cvar' refers you   */
   /* to `gvar' and is thus also incomprehensible.                          */
   /*                                                                       */
   /* The documentation for `avar' appears correct, but Apple has no fonts  */
   /* with an `avar' table, so it is hard to test.                          */
   /*                                                                       */
   /* Many thanks to John Jenkins (at Apple) in figuring this out.          */
   /*                                                                       */
   /*                                                                       */
   /* Apple's `kern' table has some references to tuple indices, but as     */
   /* there is no indication where these indices are defined, nor how to    */
   /* interpolate the kerning values (different tuples have different       */
   /* classes) this issue is ignored.                                       */
   /*                                                                       */
   /*************************************************************************/
 
 
 #include <ft2build.h>
 #include FT_INTERNAL_DEBUG_H
 #include FT_CONFIG_CONFIG_H
 #include FT_INTERNAL_STREAM_H
 #include FT_INTERNAL_SFNT_H
 #include FT_TRUETYPE_TAGS_H
 #include FT_MULTIPLE_MASTERS_H
 
 #include "ttpload.h"
 #include "ttgxvar.h"
 
 #include "tterrors.h"
 
 
 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 
 
 #define FT_Stream_FTell( stream )  \
           ( (stream)->cursor - (stream)->base )
 #define FT_Stream_SeekSet( stream, off ) \
               ( (stream)->cursor = (stream)->base+(off) )
 
 
   /*************************************************************************/
   /*                                                                       */
   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
   /* messages during execution.                                            */
   /*                                                                       */
 #undef  FT_COMPONENT
 #define FT_COMPONENT  trace_ttgxvar
 
 
   /*************************************************************************/
   /*************************************************************************/
   /*****                                                               *****/
   /*****                       Internal Routines                       *****/
   /*****                                                               *****/
   /*************************************************************************/
   /*************************************************************************/
 
 
   /*************************************************************************/
   /*                                                                       */
   /* The macro ALL_POINTS is used in `ft_var_readpackedpoints'.  It        */
   /* indicates that there is a delta for every point without needing to    */
   /* enumerate all of them.                                                */
   /*                                                                       */
 #define ALL_POINTS  (FT_UShort*)( -1 )
 
 
 #define GX_PT_POINTS_ARE_WORDS      0x80
 #define GX_PT_POINT_RUN_COUNT_MASK  0x7F
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    ft_var_readpackedpoints                                            */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Read a set of points to which the following deltas will apply.     */
   /*    Points are packed with a run length encoding.                      */
   /*                                                                       */
   /* <Input>                                                               */
   /*    stream    :: The data stream.                                      */
   /*                                                                       */
   /* <Output>                                                              */
   /*    point_cnt :: The number of points read.  A zero value means that   */
   /*                 all points in the glyph will be affected, without     */
   /*                 enumerating them individually.                        */
   /*                                                                       */
   /* <Return>                                                              */
   /*    An array of FT_UShort containing the affected points or the        */
   /*    special value ALL_POINTS.                                          */
   /*                                                                       */
   static FT_UShort*
   ft_var_readpackedpoints( FT_Stream  stream,
                            FT_UInt   *point_cnt )
   {
     FT_UShort *points;
     FT_Int     n;
     FT_Int     runcnt;
     FT_Int     i;
     FT_Int     j;
     FT_Int     first;
     FT_Memory  memory = stream->memory;
-    FT_Error   error = TT_Err_Ok;
+    FT_Error   error  = TT_Err_Ok;
 
     FT_UNUSED( error );
 
 
     *point_cnt = n = FT_GET_BYTE();
     if ( n == 0 )
       return ALL_POINTS;
 
     if ( n & GX_PT_POINTS_ARE_WORDS )
       n = FT_GET_BYTE() | ( ( n & GX_PT_POINT_RUN_COUNT_MASK ) << 8 );
 
     if ( FT_NEW_ARRAY( points, n ) )
       return NULL;
 
     i = 0;
     while ( i < n )
     {
       runcnt = FT_GET_BYTE();
       if ( runcnt & GX_PT_POINTS_ARE_WORDS )
       {
         runcnt = runcnt & GX_PT_POINT_RUN_COUNT_MASK;
         first  = points[i++] = FT_GET_USHORT();
 
-        if ( runcnt < 1 )
+        if ( runcnt < 1 || i + runcnt >= n )
           goto Exit;
 
         /* first point not included in runcount */
         for ( j = 0; j < runcnt; ++j )
           points[i++] = (FT_UShort)( first += FT_GET_USHORT() );
       }
       else
       {
         first = points[i++] = FT_GET_BYTE();
 
-        if ( runcnt < 1 )
+        if ( runcnt < 1 || i + runcnt >= n )
           goto Exit;
 
         for ( j = 0; j < runcnt; ++j )
           points[i++] = (FT_UShort)( first += FT_GET_BYTE() );
       }
     }
 
   Exit:
     return points;
   }
 
 
   enum
   {
     GX_DT_DELTAS_ARE_ZERO      = 0x80,
     GX_DT_DELTAS_ARE_WORDS     = 0x40,
     GX_DT_DELTA_RUN_COUNT_MASK = 0x3F
   };
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    ft_var_readpackeddeltas                                            */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Read a set of deltas.  These are packed slightly differently than  */
   /*    points.  In particular there is no overall count.                  */
   /*                                                                       */
   /* <Input>                                                               */
   /*    stream    :: The data stream.                                      */
   /*                                                                       */
   /*    delta_cnt :: The number of to be read.                             */
   /*                                                                       */
   /* <Return>                                                              */
   /*    An array of FT_Short containing the deltas for the affected        */
   /*    points.  (This only gets the deltas for one dimension.  It will    */
   /*    generally be called twice, once for x, once for y.  When used in   */
   /*    cvt table, it will only be called once.)                           */
   /*                                                                       */
   static FT_Short*
   ft_var_readpackeddeltas( FT_Stream  stream,
                            FT_Offset  delta_cnt )
   {
     FT_Short  *deltas = NULL;
     FT_UInt    runcnt;
     FT_Offset  i;
     FT_UInt    j;
     FT_Memory  memory = stream->memory;
     FT_Error   error  = TT_Err_Ok;
 
     FT_UNUSED( error );
 
 
     if ( FT_NEW_ARRAY( deltas, delta_cnt ) )
       return NULL;
 
     i = 0;
     while ( i < delta_cnt )
     {
       runcnt = FT_GET_BYTE();
       if ( runcnt & GX_DT_DELTAS_ARE_ZERO )
       {
         /* runcnt zeroes get added */
         for ( j = 0;
               j <= ( runcnt & GX_DT_DELTA_RUN_COUNT_MASK ) && i < delta_cnt;
               ++j )
           deltas[i++] = 0;
       }
       else if ( runcnt & GX_DT_DELTAS_ARE_WORDS )
       {
         /* runcnt shorts from the stack */
         for ( j = 0;
               j <= ( runcnt & GX_DT_DELTA_RUN_COUNT_MASK ) && i < delta_cnt;
               ++j )
           deltas[i++] = FT_GET_SHORT();
       }
       else
       {
         /* runcnt signed bytes from the stack */
         for ( j = 0;
               j <= ( runcnt & GX_DT_DELTA_RUN_COUNT_MASK ) && i < delta_cnt;
               ++j )
           deltas[i++] = FT_GET_CHAR();
       }
 
       if ( j <= ( runcnt & GX_DT_DELTA_RUN_COUNT_MASK ) )
       {
         /* Bad format */
         FT_FREE( deltas );
         return NULL;
       }
     }
 
     return deltas;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    ft_var_load_avar                                                   */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Parse the `avar' table if present.  It need not be, so we return   */
   /*    nothing.                                                           */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    face :: The font face.                                             */
   /*                                                                       */
   static void
   ft_var_load_avar( TT_Face  face )
   {
     FT_Stream       stream = FT_FACE_STREAM(face);
     FT_Memory       memory = stream->memory;
     GX_Blend        blend  = face->blend;
     GX_AVarSegment  segment;
     FT_Error        error = TT_Err_Ok;
     FT_ULong        version;
     FT_Long         axisCount;
     FT_Int          i, j;
     FT_ULong        table_len;
 
     FT_UNUSED( error );
 
 
     blend->avar_checked = TRUE;
     if ( (error = face->goto_table( face, TTAG_avar, stream, &table_len )) != 0 )
       return;
 
     if ( FT_FRAME_ENTER( table_len ) )
       return;
 
     version   = FT_GET_LONG();
     axisCount = FT_GET_LONG();
 
     if ( version != 0x00010000L                       ||
          axisCount != (FT_Long)blend->mmvar->num_axis )
       goto Exit;
 
     if ( FT_NEW_ARRAY( blend->avar_segment, axisCount ) )
       goto Exit;
 
     segment = &blend->avar_segment[0];
     for ( i = 0; i < axisCount; ++i, ++segment )
     {
       segment->pairCount = FT_GET_USHORT();
       if ( FT_NEW_ARRAY( segment->correspondence, segment->pairCount ) )
       {
         /* Failure.  Free everything we have done so far.  We must do */
         /* it right now since loading the `avar' table is optional.   */
 
         for ( j = i - 1; j >= 0; --j )
           FT_FREE( blend->avar_segment[j].correspondence );
 
         FT_FREE( blend->avar_segment );
         blend->avar_segment = NULL;
         goto Exit;
       }
 
       for ( j = 0; j < segment->pairCount; ++j )
       {
         segment->correspondence[j].fromCoord =
           FT_GET_SHORT() << 2;    /* convert to Fixed */
         segment->correspondence[j].toCoord =
           FT_GET_SHORT()<<2;    /* convert to Fixed */
       }
     }
 
   Exit:
     FT_FRAME_EXIT();
   }
 
 
   typedef struct  GX_GVar_Head_
   {
     FT_Long    version;
     FT_UShort  axisCount;
     FT_UShort  globalCoordCount;
     FT_ULong   offsetToCoord;
     FT_UShort  glyphCount;
     FT_UShort  flags;
     FT_ULong   offsetToData;
 
   } GX_GVar_Head;
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    ft_var_load_gvar                                                   */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Parses the `gvar' table if present.  If `fvar' is there, `gvar'    */
   /*    had better be there too.                                           */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    face :: The font face.                                             */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   static FT_Error
   ft_var_load_gvar( TT_Face  face )
   {
     FT_Stream     stream = FT_FACE_STREAM(face);
     FT_Memory     memory = stream->memory;
     GX_Blend      blend  = face->blend;
     FT_Error      error;
     FT_UInt       i, j;
     FT_ULong      table_len;
     FT_ULong      gvar_start;
     FT_ULong      offsetToData;
     GX_GVar_Head  gvar_head;
 
     static const FT_Frame_Field  gvar_fields[] =
     {
 
 #undef  FT_STRUCTURE
 #define FT_STRUCTURE  GX_GVar_Head
 
       FT_FRAME_START( 20 ),
         FT_FRAME_LONG  ( version ),
         FT_FRAME_USHORT( axisCount ),
         FT_FRAME_USHORT( globalCoordCount ),
         FT_FRAME_ULONG ( offsetToCoord ),
         FT_FRAME_USHORT( glyphCount ),
         FT_FRAME_USHORT( flags ),
         FT_FRAME_ULONG ( offsetToData ),
       FT_FRAME_END
     };
 
     if ( (error = face->goto_table( face, TTAG_gvar, stream, &table_len )) != 0 )
       goto Exit;
 
     gvar_start = FT_STREAM_POS( );
     if ( FT_STREAM_READ_FIELDS( gvar_fields, &gvar_head ) )
       goto Exit;
 
     blend->tuplecount  = gvar_head.globalCoordCount;
     blend->gv_glyphcnt = gvar_head.glyphCount;
     offsetToData       = gvar_start + gvar_head.offsetToData;
 
     if ( gvar_head.version   != (FT_Long)0x00010000L              ||
          gvar_head.axisCount != (FT_UShort)blend->mmvar->num_axis )
     {
       error = TT_Err_Invalid_Table;
       goto Exit;
     }
 
     if ( FT_NEW_ARRAY( blend->glyphoffsets, blend->gv_glyphcnt + 1 ) )
       goto Exit;
 
     if ( gvar_head.flags & 1 )
     {
       /* long offsets (one more offset than glyphs, to mark size of last) */
       if ( FT_FRAME_ENTER( ( blend->gv_glyphcnt + 1 ) * 4L ) )
         goto Exit;
 
       for ( i = 0; i <= blend->gv_glyphcnt; ++i )
         blend->glyphoffsets[i] = offsetToData + FT_GET_LONG();
 
       FT_FRAME_EXIT();
     }
     else
     {
       /* short offsets (one more offset than glyphs, to mark size of last) */
       if ( FT_FRAME_ENTER( ( blend->gv_glyphcnt + 1 ) * 2L ) )
         goto Exit;
 
       for ( i = 0; i <= blend->gv_glyphcnt; ++i )
         blend->glyphoffsets[i] = offsetToData + FT_GET_USHORT() * 2;
                                               /* XXX: Undocumented: `*2'! */
 
       FT_FRAME_EXIT();
     }
 
     if ( blend->tuplecount != 0 )
     {
       if ( FT_NEW_ARRAY( blend->tuplecoords,
                          gvar_head.axisCount * blend->tuplecount ) )
         goto Exit;
 
       if ( FT_STREAM_SEEK( gvar_start + gvar_head.offsetToCoord )       ||
            FT_FRAME_ENTER( blend->tuplecount * gvar_head.axisCount * 2L )                   )
         goto Exit;
 
       for ( i = 0; i < blend->tuplecount; ++i )
         for ( j = 0 ; j < (FT_UInt)gvar_head.axisCount; ++j )
           blend->tuplecoords[i * gvar_head.axisCount + j] =
             FT_GET_SHORT() << 2;                /* convert to FT_Fixed */
 
       FT_FRAME_EXIT();
     }
 
   Exit:
     return error;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    ft_var_apply_tuple                                                 */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Figure out whether a given tuple (design) applies to the current   */
   /*    blend, and if so, what is the scaling factor.                      */
   /*                                                                       */
   /* <Input>                                                               */
   /*    blend           :: The current blend of the font.                  */
   /*                                                                       */
   /*    tupleIndex      :: A flag saying whether this is an intermediate   */
   /*                       tuple or not.                                   */
   /*                                                                       */
   /*    tuple_coords    :: The coordinates of the tuple in normalized axis */
   /*                       units.                                          */
   /*                                                                       */
   /*    im_start_coords :: The initial coordinates where this tuple starts */
   /*                       to apply (for intermediate coordinates).        */
   /*                                                                       */
   /*    im_end_coords   :: The final coordinates after which this tuple no */
   /*                       longer applies (for intermediate coordinates).  */
   /*                                                                       */
   /* <Return>                                                              */
   /*    An FT_Fixed value containing the scaling factor.                   */
   /*                                                                       */
   static FT_Fixed
   ft_var_apply_tuple( GX_Blend   blend,
                       FT_UShort  tupleIndex,
                       FT_Fixed*  tuple_coords,
                       FT_Fixed*  im_start_coords,
                       FT_Fixed*  im_end_coords )
   {
     FT_UInt   i;
     FT_Fixed  apply;
     FT_Fixed  temp;
 
 
     apply = 0x10000L;
     for ( i = 0; i < blend->num_axis; ++i )
     {
       if ( tuple_coords[i] == 0 )
         /* It's not clear why (for intermediate tuples) we don't need     */
         /* to check against start/end -- the documentation says we don't. */
         /* Similarly, it's unclear why we don't need to scale along the   */
         /* axis.                                                          */
         continue;
 
       else if ( blend->normalizedcoords[i] == 0                           ||
                 ( blend->normalizedcoords[i] < 0 && tuple_coords[i] > 0 ) ||
                 ( blend->normalizedcoords[i] > 0 && tuple_coords[i] < 0 ) )
       {
         apply = 0;
         break;
       }
 
       else if ( !( tupleIndex & GX_TI_INTERMEDIATE_TUPLE ) )
         /* not an intermediate tuple */
         apply = FT_MulDiv( apply,
                            blend->normalizedcoords[i] > 0
                              ? blend->normalizedcoords[i]
                              : -blend->normalizedcoords[i],
                            0x10000L );
 
       else if ( blend->normalizedcoords[i] <= im_start_coords[i] ||
                 blend->normalizedcoords[i] >= im_end_coords[i]   )
       {
         apply = 0;
         break;
       }
 
       else if ( blend->normalizedcoords[i] < tuple_coords[i] )
       {
         temp = FT_MulDiv( blend->normalizedcoords[i] - im_start_coords[i],
                           0x10000L,
                           tuple_coords[i] - im_start_coords[i]);
         apply = FT_MulDiv( apply, temp, 0x10000L );
       }
 
       else
       {
         temp = FT_MulDiv( im_end_coords[i] - blend->normalizedcoords[i],
                           0x10000L,
                           im_end_coords[i] - tuple_coords[i] );
         apply = FT_MulDiv( apply, temp, 0x10000L );
       }
     }
 
     return apply;
   }
 
 
   /*************************************************************************/
   /*************************************************************************/
   /*****                                                               *****/
   /*****               MULTIPLE MASTERS SERVICE FUNCTIONS              *****/
   /*****                                                               *****/
   /*************************************************************************/
   /*************************************************************************/
 
 
   typedef struct  GX_FVar_Head_
   {
     FT_Long    version;
     FT_UShort  offsetToData;
     FT_UShort  countSizePairs;
     FT_UShort  axisCount;
     FT_UShort  axisSize;
     FT_UShort  instanceCount;
     FT_UShort  instanceSize;
 
   } GX_FVar_Head;
 
 
   typedef struct  fvar_axis_
   {
     FT_ULong   axisTag;
     FT_ULong   minValue;
     FT_ULong   defaultValue;
     FT_ULong   maxValue;
     FT_UShort  flags;
     FT_UShort  nameID;
 
   } GX_FVar_Axis;
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    TT_Get_MM_Var                                                      */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Check that the font's `fvar' table is valid, parse it, and return  */
   /*    those data.                                                        */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    face   :: The font face.                                           */
   /*              TT_Get_MM_Var initializes the blend structure.           */
   /*                                                                       */
   /* <Output>                                                              */
   /*    master :: The `fvar' data (must be freed by caller).               */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   TT_Get_MM_Var( TT_Face      face,
                  FT_MM_Var*  *master )
   {
     FT_Stream            stream = face->root.stream;
     FT_Memory            memory = face->root.memory;
     FT_ULong             table_len;
     FT_Error             error  = TT_Err_Ok;
     FT_ULong             fvar_start;
     FT_Int               i, j;
     FT_MM_Var*           mmvar;
     FT_Fixed*            next_coords;
     FT_String*           next_name;
     FT_Var_Axis*         a;
     FT_Var_Named_Style*  ns;
     GX_FVar_Head         fvar_head;
 
     static const FT_Frame_Field  fvar_fields[] =
     {
 
 #undef  FT_STRUCTURE
 #define FT_STRUCTURE  GX_FVar_Head
 
       FT_FRAME_START( 16 ),
         FT_FRAME_LONG  ( version ),
         FT_FRAME_USHORT( offsetToData ),
         FT_FRAME_USHORT( countSizePairs ),
         FT_FRAME_USHORT( axisCount ),
         FT_FRAME_USHORT( axisSize ),
         FT_FRAME_USHORT( instanceCount ),
         FT_FRAME_USHORT( instanceSize ),
       FT_FRAME_END
     };
 
     static const FT_Frame_Field  fvaraxis_fields[] =
     {
 
 #undef  FT_STRUCTURE
 #define FT_STRUCTURE  GX_FVar_Axis
 
       FT_FRAME_START( 20 ),
         FT_FRAME_ULONG ( axisTag ),
         FT_FRAME_ULONG ( minValue ),
         FT_FRAME_ULONG ( defaultValue ),
         FT_FRAME_ULONG ( maxValue ),
         FT_FRAME_USHORT( flags ),
         FT_FRAME_USHORT( nameID ),
       FT_FRAME_END
     };
 
 
     if ( face->blend == NULL )
     {
       /* both `fvar' and `gvar' must be present */
       if ( (error = face->goto_table( face, TTAG_gvar,
                                       stream, &table_len )) != 0 )
         goto Exit;
 
       if ( (error = face->goto_table( face, TTAG_fvar,
                                       stream, &table_len )) != 0 )
         goto Exit;
 
       fvar_start = FT_STREAM_POS( );
 
       if ( FT_STREAM_READ_FIELDS( fvar_fields, &fvar_head ) )
         goto Exit;
 
       if ( fvar_head.version != (FT_Long)0x00010000L                      ||
            fvar_head.countSizePairs != 2                                  ||
            fvar_head.axisSize != 20                                       ||
            /* axisCount limit implied by 16-bit instanceSize */
            fvar_head.axisCount > 0x3FFE                                   ||
            fvar_head.instanceSize != 4 + 4 * fvar_head.axisCount          ||
            /* instanceCount limit implied by limited range of name IDs */
            fvar_head.instanceCount > 0x7EFF                               ||
            fvar_head.offsetToData + fvar_head.axisCount * 20U +
              fvar_head.instanceCount * fvar_head.instanceSize > table_len )
       {
         error = TT_Err_Invalid_Table;
         goto Exit;
       }
 
       if ( FT_NEW( face->blend ) )
         goto Exit;
 
       /* cannot overflow 32-bit arithmetic because of limits above */
       face->blend->mmvar_len =
         sizeof ( FT_MM_Var ) +
         fvar_head.axisCount * sizeof ( FT_Var_Axis ) +
         fvar_head.instanceCount * sizeof ( FT_Var_Named_Style ) +
         fvar_head.instanceCount * fvar_head.axisCount * sizeof ( FT_Fixed ) +
         5 * fvar_head.axisCount;
 
       if ( FT_ALLOC( mmvar, face->blend->mmvar_len ) )
         goto Exit;
       face->blend->mmvar = mmvar;
 
       mmvar->num_axis =
         fvar_head.axisCount;
       mmvar->num_designs =
         (FT_UInt)-1;           /* meaningless in this context; each glyph */
                                /* may have a different number of designs  */
                                /* (or tuples, as called by Apple)         */
       mmvar->num_namedstyles =
         fvar_head.instanceCount;
       mmvar->axis =
         (FT_Var_Axis*)&(mmvar[1]);
       mmvar->namedstyle =
         (FT_Var_Named_Style*)&(mmvar->axis[fvar_head.axisCount]);
 
       next_coords =
         (FT_Fixed*)&(mmvar->namedstyle[fvar_head.instanceCount]);
       for ( i = 0; i < fvar_head.instanceCount; ++i )
       {
         mmvar->namedstyle[i].coords  = next_coords;
         next_coords                 += fvar_head.axisCount;
       }
 
       next_name = (FT_String*)next_coords;
       for ( i = 0; i < fvar_head.axisCount; ++i )
       {
         mmvar->axis[i].name  = next_name;
         next_name           += 5;
       }
 
       if ( FT_STREAM_SEEK( fvar_start + fvar_head.offsetToData ) )
         goto Exit;
 
       a = mmvar->axis;
       for ( i = 0; i < fvar_head.axisCount; ++i )
       {
         GX_FVar_Axis  axis_rec;
 
 
         if ( FT_STREAM_READ_FIELDS( fvaraxis_fields, &axis_rec ) )
           goto Exit;
         a->tag     = axis_rec.axisTag;
         a->minimum = axis_rec.minValue;     /* A Fixed */
         a->def     = axis_rec.defaultValue; /* A Fixed */
         a->maximum = axis_rec.maxValue;     /* A Fixed */
         a->strid   = axis_rec.nameID;
 
         a->name[0] = (FT_String)(   a->tag >> 24 );
         a->name[1] = (FT_String)( ( a->tag >> 16 ) & 0xFF );
         a->name[2] = (FT_String)( ( a->tag >>  8 ) & 0xFF );
         a->name[3] = (FT_String)( ( a->tag       ) & 0xFF );
         a->name[4] = 0;
 
         ++a;
       }
 
       ns = mmvar->namedstyle;
       for ( i = 0; i < fvar_head.instanceCount; ++i, ++ns )
       {
         if ( FT_FRAME_ENTER( 4L + 4L * fvar_head.axisCount ) )
           goto Exit;
 
         ns->strid       =    FT_GET_USHORT();
         (void) /* flags = */ FT_GET_USHORT();
 
         for ( j = 0; j < fvar_head.axisCount; ++j )
           ns->coords[j] = FT_GET_ULONG();     /* A Fixed */
 
         FT_FRAME_EXIT();
       }
     }
 
     if ( master != NULL )
     {
       FT_UInt  n;
 
 
       if ( FT_ALLOC( mmvar, face->blend->mmvar_len ) )
         goto Exit;
       FT_MEM_COPY( mmvar, face->blend->mmvar, face->blend->mmvar_len );
 
       mmvar->axis =
         (FT_Var_Axis*)&(mmvar[1]);
       mmvar->namedstyle =
         (FT_Var_Named_Style*)&(mmvar->axis[mmvar->num_axis]);
       next_coords =
         (FT_Fixed*)&(mmvar->namedstyle[mmvar->num_namedstyles]);
 
       for ( n = 0; n < mmvar->num_namedstyles; ++n )
       {
         mmvar->namedstyle[n].coords  = next_coords;
         next_coords                 += mmvar->num_axis;
       }
 
       a = mmvar->axis;
       next_name = (FT_String*)next_coords;
       for ( n = 0; n < mmvar->num_axis; ++n )
       {
         a->name = next_name;
 
         /* standard PostScript names for some standard apple tags */
         if ( a->tag == TTAG_wght )
           a->name = (char *)"Weight";
         else if ( a->tag == TTAG_wdth )
           a->name = (char *)"Width";
         else if ( a->tag == TTAG_opsz )
           a->name = (char *)"OpticalSize";
         else if ( a->tag == TTAG_slnt )
           a->name = (char *)"Slant";
 
         next_name += 5;
         ++a;
       }
 
       *master = mmvar;
     }
 
   Exit:
     return error;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    TT_Set_MM_Blend                                                    */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Set the blend (normalized) coordinates for this instance of the    */
   /*    font.  Check that the `gvar' table is reasonable and does some     */
   /*    initial preparation.                                               */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    face       :: The font.                                            */
   /*                  Initialize the blend structure with `gvar' data.     */
   /*                                                                       */
   /* <Input>                                                               */
   /*    num_coords :: Must be the axis count of the font.                  */
   /*                                                                       */
   /*    coords     :: An array of num_coords, each between [-1,1].         */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   TT_Set_MM_Blend( TT_Face    face,
                    FT_UInt    num_coords,
                    FT_Fixed*  coords )
   {
     FT_Error    error = TT_Err_Ok;
     GX_Blend    blend;
     FT_MM_Var*  mmvar;
     FT_UInt     i;
     FT_Memory   memory = face->root.memory;
 
     enum
     {
       mcvt_retain,
       mcvt_modify,
       mcvt_load
 
     } manageCvt;
 
 
     face->doblend = FALSE;
 
     if ( face->blend == NULL )
     {
       if ( (error = TT_Get_MM_Var( face, NULL)) != 0 )
         goto Exit;
     }
 
     blend = face->blend;
     mmvar = blend->mmvar;
 
     if ( num_coords != mmvar->num_axis )
     {
       error = TT_Err_Invalid_Argument;
       goto Exit;
     }
 
     for ( i = 0; i < num_coords; ++i )
       if ( coords[i] < -0x00010000L || coords[i] > 0x00010000L )
       {
         error = TT_Err_Invalid_Argument;
         goto Exit;
       }
 
     if ( blend->glyphoffsets == NULL )
       if ( (error = ft_var_load_gvar( face )) != 0 )
         goto Exit;
 
     if ( blend->normalizedcoords == NULL )
     {
       if ( FT_NEW_ARRAY( blend->normalizedcoords, num_coords ) )
         goto Exit;
 
       manageCvt = mcvt_modify;
 
       /* If we have not set the blend coordinates before this, then the  */
       /* cvt table will still be what we read from the `cvt ' table and  */
       /* we don't need to reload it.  We may need to change it though... */
     }
     else
     {
       manageCvt = mcvt_retain;
       for ( i = 0; i < num_coords; ++i )
       {
         if ( blend->normalizedcoords[i] != coords[i] )
         {
           manageCvt = mcvt_load;
           break;
         }
       }
 
       /* If we don't change the blend coords then we don't need to do  */
       /* anything to the cvt table.  It will be correct.  Otherwise we */
       /* no longer have the original cvt (it was modified when we set  */
       /* the blend last time), so we must reload and then modify it.   */
     }
 
     blend->num_axis = num_coords;
     FT_MEM_COPY( blend->normalizedcoords,
                  coords,
                  num_coords * sizeof ( FT_Fixed ) );
 
     face->doblend = TRUE;
 
     if ( face->cvt != NULL )
     {
       switch ( manageCvt )
       {
       case mcvt_load:
         /* The cvt table has been loaded already; every time we change the */
         /* blend we may need to reload and remodify the cvt table.         */
         FT_FREE( face->cvt );
         face->cvt = NULL;
 
         tt_face_load_cvt( face, face->root.stream );
         break;
 
       case mcvt_modify:
         /* The original cvt table is in memory.  All we need to do is */
         /* apply the `cvar' table (if any).                           */
         tt_face_vary_cvt( face, face->root.stream );
         break;
 
       case mcvt_retain:
         /* The cvt table is correct for this set of coordinates. */
         break;
       }
     }
 
   Exit:
     return error;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    TT_Set_Var_Design                                                  */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Set the coordinates for the instance, measured in the user         */
   /*    coordinate system.  Parse the `avar' table (if present) to convert */
   /*    from user to normalized coordinates.                               */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    face       :: The font face.                                       */
   /*                  Initialize the blend struct with `gvar' data.        */
   /*                                                                       */
   /* <Input>                                                               */
   /*    num_coords :: This must be the axis count of the font.             */
   /*                                                                       */
   /*    coords     :: A coordinate array with `num_coords' elements.       */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   TT_Set_Var_Design( TT_Face    face,
                      FT_UInt    num_coords,
                      FT_Fixed*  coords )
   {
     FT_Error        error      = TT_Err_Ok;
     FT_Fixed*       normalized = NULL;
     GX_Blend        blend;
     FT_MM_Var*      mmvar;
     FT_UInt         i, j;
     FT_Var_Axis*    a;
     GX_AVarSegment  av;
     FT_Memory       memory = face->root.memory;
 
 
     if ( face->blend == NULL )
     {
       if ( (error = TT_Get_MM_Var( face, NULL )) != 0 )
         goto Exit;
     }
 
     blend = face->blend;
     mmvar = blend->mmvar;
 
     if ( num_coords != mmvar->num_axis )
     {
       error = TT_Err_Invalid_Argument;
       goto Exit;
     }
 
     /* Axis normalization is a two stage process.  First we normalize */
     /* based on the [min,def,max] values for the axis to be [-1,0,1]. */
     /* Then, if there's an `avar' table, we renormalize this range.   */
 
     if ( FT_NEW_ARRAY( normalized, mmvar->num_axis ) )
       goto Exit;
 
     a = mmvar->axis;
     for ( i = 0; i < mmvar->num_axis; ++i, ++a )
     {
       if ( coords[i] > a->maximum || coords[i] < a->minimum )
       {
         error = TT_Err_Invalid_Argument;
         goto Exit;
       }
 
       if ( coords[i] < a->def )
       {
         normalized[i] = -FT_MulDiv( coords[i] - a->def,
                                     0x10000L,
                                     a->minimum - a->def );
       }
       else if ( a->maximum == a->def )
         normalized[i] = 0;
       else
       {
         normalized[i] = FT_MulDiv( coords[i] - a->def,
                                    0x10000L,
                                    a->maximum - a->def );
       }
     }
 
     if ( !blend->avar_checked )
       ft_var_load_avar( face );
 
     if ( blend->avar_segment != NULL )
     {
       av = blend->avar_segment;
       for ( i = 0; i < mmvar->num_axis; ++i, ++av )
       {
         for ( j = 1; j < (FT_UInt)av->pairCount; ++j )
           if ( normalized[i] < av->correspondence[j].fromCoord )
           {
             normalized[i] =
               FT_MulDiv(
                 FT_MulDiv(
                   normalized[i] - av->correspondence[j - 1].fromCoord,
                   0x10000L,
                   av->correspondence[j].fromCoord -
                     av->correspondence[j - 1].fromCoord ),
                 av->correspondence[j].toCoord -
                   av->correspondence[j - 1].toCoord,
                 0x10000L ) +
               av->correspondence[j - 1].toCoord;
             break;
           }
       }
     }
 
     error = TT_Set_MM_Blend( face, num_coords, normalized );
 
   Exit:
     FT_FREE( normalized );
     return error;
   }
 
 
   /*************************************************************************/
   /*************************************************************************/
   /*****                                                               *****/
   /*****                     GX VAR PARSING ROUTINES                   *****/
   /*****                                                               *****/
   /*************************************************************************/
   /*************************************************************************/
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    tt_face_vary_cvt                                                   */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Modify the loaded cvt table according to the `cvar' table and the  */
   /*    font's blend.                                                      */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    face   :: A handle to the target face object.                      */
   /*                                                                       */
   /* <Input>                                                               */
   /*    stream :: A handle to the input stream.                            */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   /*    Most errors are ignored.  It is perfectly valid not to have a      */
   /*    `cvar' table even if there is a `gvar' and `fvar' table.           */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   tt_face_vary_cvt( TT_Face    face,
                     FT_Stream  stream )
   {
     FT_Error    error;
     FT_Memory   memory = stream->memory;
     FT_ULong    table_start;
     FT_ULong    table_len;
     FT_UInt     tupleCount;
     FT_ULong    offsetToData;
     FT_ULong    here;
     FT_UInt     i, j;
     FT_Fixed*   tuple_coords    = NULL;
     FT_Fixed*   im_start_coords = NULL;
     FT_Fixed*   im_end_coords   = NULL;
     GX_Blend    blend           = face->blend;
     FT_UInt     point_count;
     FT_UShort*  localpoints;
     FT_Short*   deltas;
 
 
     FT_TRACE2(( "CVAR " ));
 
     if ( blend == NULL )
     {
       FT_TRACE2(( "tt_face_vary_cvt: no blend specified\n" ));
 
       error = TT_Err_Ok;
       goto Exit;
     }
 
     if ( face->cvt == NULL )
     {
       FT_TRACE2(( "tt_face_vary_cvt: no `cvt ' table\n" ));
 
       error = TT_Err_Ok;
       goto Exit;
     }
 
     error = face->goto_table( face, TTAG_cvar, stream, &table_len );
     if ( error )
     {
       FT_TRACE2(( "is missing\n" ));
 
       error = TT_Err_Ok;
       goto Exit;
     }
 
     if ( FT_FRAME_ENTER( table_len ) )
     {
       error = TT_Err_Ok;
       goto Exit;
     }
 
     table_start = FT_Stream_FTell( stream );
     if ( FT_GET_LONG() != 0x00010000L )
     {
       FT_TRACE2(( "bad table version\n" ));
 
       error = TT_Err_Ok;
       goto FExit;
     }
 
     if ( FT_NEW_ARRAY( tuple_coords, blend->num_axis )    ||
          FT_NEW_ARRAY( im_start_coords, blend->num_axis ) ||
          FT_NEW_ARRAY( im_end_coords, blend->num_axis )   )
       goto FExit;
 
     tupleCount   = FT_GET_USHORT();
     offsetToData = table_start + FT_GET_USHORT();
 
     /* The documentation implies there are flags packed into the        */
     /* tuplecount, but John Jenkins says that shared points don't apply */
     /* to `cvar', and no other flags are defined.                       */
 
     for ( i = 0; i < ( tupleCount & 0xFFF ); ++i )
     {
       FT_UInt   tupleDataSize;
       FT_UInt   tupleIndex;
       FT_Fixed  apply;
 
 
       tupleDataSize = FT_GET_USHORT();
       tupleIndex    = FT_GET_USHORT();
 
       /* There is no provision here for a global tuple coordinate section, */
       /* so John says.  There are no tuple indices, just embedded tuples.  */
 
       if ( tupleIndex & GX_TI_EMBEDDED_TUPLE_COORD )
       {
         for ( j = 0; j < blend->num_axis; ++j )
           tuple_coords[j] = FT_GET_SHORT() << 2; /* convert from        */
                                                  /* short frac to fixed */
       }
       else
       {
         /* skip this tuple; it makes no sense */
 
         if ( tupleIndex & GX_TI_INTERMEDIATE_TUPLE )
           for ( j = 0; j < 2 * blend->num_axis; ++j )
             (void)FT_GET_SHORT();
 
         offsetToData += tupleDataSize;
         continue;
       }
 
       if ( tupleIndex & GX_TI_INTERMEDIATE_TUPLE )
       {
         for ( j = 0; j < blend->num_axis; ++j )
           im_start_coords[j] = FT_GET_SHORT() << 2;
         for ( j = 0; j < blend->num_axis; ++j )
           im_end_coords[j] = FT_GET_SHORT() << 2;
       }
 
       apply = ft_var_apply_tuple( blend,
                                   (FT_UShort)tupleIndex,
                                   tuple_coords,
                                   im_start_coords,
                                   im_end_coords );
       if ( /* tuple isn't active for our blend */
            apply == 0                                    ||
            /* global points not allowed,           */
            /* if they aren't local, makes no sense */
            !( tupleIndex & GX_TI_PRIVATE_POINT_NUMBERS ) )
       {
         offsetToData += tupleDataSize;
         continue;
       }
 
       here = FT_Stream_FTell( stream );
 
       FT_Stream_SeekSet( stream, offsetToData );
 
       localpoints = ft_var_readpackedpoints( stream, &point_count );
       deltas      = ft_var_readpackeddeltas( stream,
                                              point_count == 0 ? face->cvt_size
                                                               : point_count );
       if ( localpoints == NULL || deltas == NULL )
         /* failure, ignore it */;
 
       else if ( localpoints == ALL_POINTS )
       {
         /* this means that there are deltas for every entry in cvt */
         for ( j = 0; j < face->cvt_size; ++j )
           face->cvt[j] = (FT_Short)( face->cvt[j] +
                                      FT_MulFix( deltas[j], apply ) );
       }
 
       else
       {
         for ( j = 0; j < point_count; ++j )
         {
           int  pindex = localpoints[j];
 
           face->cvt[pindex] = (FT_Short)( face->cvt[pindex] +
                                           FT_MulFix( deltas[j], apply ) );
         }
       }
 
       if ( localpoints != ALL_POINTS )
         FT_FREE( localpoints );
       FT_FREE( deltas );
 
       offsetToData += tupleDataSize;
 
       FT_Stream_SeekSet( stream, here );
     }
 
   FExit:
     FT_FRAME_EXIT();
 
   Exit:
     FT_FREE( tuple_coords );
     FT_FREE( im_start_coords );
     FT_FREE( im_end_coords );
 
     return error;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    TT_Vary_Get_Glyph_Deltas                                           */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Load the appropriate deltas for the current glyph.                 */
   /*                                                                       */
   /* <Input>                                                               */
   /*    face        :: A handle to the target face object.                 */
   /*                                                                       */
   /*    glyph_index :: The index of the glyph being modified.              */
   /*                                                                       */
   /*    n_points    :: The number of the points in the glyph, including    */
   /*                   phantom points.                                     */
   /*                                                                       */
   /* <Output>                                                              */
   /*    deltas      :: The array of points to change.                      */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   TT_Vary_Get_Glyph_Deltas( TT_Face      face,
                             FT_UInt      glyph_index,
                             FT_Vector*  *deltas,
                             FT_UInt      n_points )
   {
     FT_Stream   stream = face->root.stream;
     FT_Memory   memory = stream->memory;
     GX_Blend    blend  = face->blend;
     FT_Vector*  delta_xy;
 
     FT_Error    error;
     FT_ULong    glyph_start;
     FT_UInt     tupleCount;
     FT_ULong    offsetToData;
     FT_ULong    here;
     FT_UInt     i, j;
     FT_Fixed*   tuple_coords    = NULL;
     FT_Fixed*   im_start_coords = NULL;
     FT_Fixed*   im_end_coords   = NULL;
     FT_UInt     point_count, spoint_count = 0;
     FT_UShort*  sharedpoints = NULL;
     FT_UShort*  localpoints  = NULL;
     FT_UShort*  points;
     FT_Short    *deltas_x, *deltas_y;
 
 
     if ( !face->doblend || blend == NULL )
       return TT_Err_Invalid_Argument;
 
     /* to be freed by the caller */
     if ( FT_NEW_ARRAY( delta_xy, n_points ) )
       goto Exit;
     *deltas = delta_xy;
 
     if ( glyph_index >= blend->gv_glyphcnt      ||
          blend->glyphoffsets[glyph_index] ==
            blend->glyphoffsets[glyph_index + 1] )
       return TT_Err_Ok;               /* no variation data for this glyph */
 
     if ( FT_STREAM_SEEK( blend->glyphoffsets[glyph_index] )   ||
          FT_FRAME_ENTER( blend->glyphoffsets[glyph_index + 1] -
                            blend->glyphoffsets[glyph_index] ) )
       goto Fail1;
 
     glyph_start = FT_Stream_FTell( stream );
 
     /* each set of glyph variation data is formatted similarly to `cvar' */
     /* (except we get shared points and global tuples)                   */
 
     if ( FT_NEW_ARRAY( tuple_coords, blend->num_axis )    ||
          FT_NEW_ARRAY( im_start_coords, blend->num_axis ) ||
          FT_NEW_ARRAY( im_end_coords, blend->num_axis )   )
       goto Fail2;
 
     tupleCount   = FT_GET_USHORT();
     offsetToData = glyph_start + FT_GET_USHORT();
 
     if ( tupleCount & GX_TC_TUPLES_SHARE_POINT_NUMBERS )
     {
       here = FT_Stream_FTell( stream );
 
       FT_Stream_SeekSet( stream, offsetToData );
 
       sharedpoints = ft_var_readpackedpoints( stream, &spoint_count );
       offsetToData = FT_Stream_FTell( stream );
 
       FT_Stream_SeekSet( stream, here );
     }
 
     for ( i = 0; i < ( tupleCount & GX_TC_TUPLE_COUNT_MASK ); ++i )
     {
       FT_UInt   tupleDataSize;
       FT_UInt   tupleIndex;
       FT_Fixed  apply;
 
 
       tupleDataSize = FT_GET_USHORT();
       tupleIndex    = FT_GET_USHORT();
 
       if ( tupleIndex & GX_TI_EMBEDDED_TUPLE_COORD )
       {
         for ( j = 0; j < blend->num_axis; ++j )
           tuple_coords[j] = FT_GET_SHORT() << 2;  /* convert from        */
                                                   /* short frac to fixed */
       }
       else if ( ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) >= blend->tuplecount )
       {
         error = TT_Err_Invalid_Table;
         goto Fail3;
       }
       else
       {
         FT_MEM_COPY(
           tuple_coords,
           &blend->tuplecoords[(tupleIndex & 0xFFF) * blend->num_axis],
           blend->num_axis * sizeof ( FT_Fixed ) );
       }
 
       if ( tupleIndex & GX_TI_INTERMEDIATE_TUPLE )
       {
         for ( j = 0; j < blend->num_axis; ++j )
           im_start_coords[j] = FT_GET_SHORT() << 2;
         for ( j = 0; j < blend->num_axis; ++j )
           im_end_coords[j] = FT_GET_SHORT() << 2;
       }
 
       apply = ft_var_apply_tuple( blend,
                                   (FT_UShort)tupleIndex,
                                   tuple_coords,
                                   im_start_coords,
                                   im_end_coords );
 
       if ( apply == 0 )              /* tuple isn't active for our blend */
       {
         offsetToData += tupleDataSize;
         continue;
       }
 
       here = FT_Stream_FTell( stream );
 
       if ( tupleIndex & GX_TI_PRIVATE_POINT_NUMBERS )
       {
         FT_Stream_SeekSet( stream, offsetToData );
 
         localpoints = ft_var_readpackedpoints( stream, &point_count );
         points      = localpoints;
       }
       else
       {
         points      = sharedpoints;
         point_count = spoint_count;
       }
 
       deltas_x = ft_var_readpackeddeltas( stream,
                                           point_count == 0 ? n_points
                                                            : point_count );
       deltas_y = ft_var_readpackeddeltas( stream,
                                           point_count == 0 ? n_points
                                                            : point_count );
 
       if ( points == NULL || deltas_y == NULL || deltas_x == NULL )
         ; /* failure, ignore it */
 
       else if ( points == ALL_POINTS )
       {
         /* this means that there are deltas for every point in the glyph */
         for ( j = 0; j < n_points; ++j )
         {
           delta_xy[j].x += FT_MulFix( deltas_x[j], apply );
           delta_xy[j].y += FT_MulFix( deltas_y[j], apply );
         }
       }
 
       else
       {
         for ( j = 0; j < point_count; ++j )
         {
           delta_xy[localpoints[j]].x += FT_MulFix( deltas_x[j], apply );
           delta_xy[localpoints[j]].y += FT_MulFix( deltas_y[j], apply );
         }
       }
 
       if ( localpoints != ALL_POINTS )
         FT_FREE( localpoints );
       FT_FREE( deltas_x );
       FT_FREE( deltas_y );
 
       offsetToData += tupleDataSize;
 
       FT_Stream_SeekSet( stream, here );
     }
 
   Fail3:
     FT_FREE( tuple_coords );
     FT_FREE( im_start_coords );
     FT_FREE( im_end_coords );
 
   Fail2:
     FT_FRAME_EXIT();
 
   Fail1:
     if ( error )
     {
       FT_FREE( delta_xy );
       *deltas = NULL;
     }
 
   Exit:
     return error;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    tt_done_blend                                                      */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Frees the blend internal data structure.                           */
   /*                                                                       */
   FT_LOCAL_DEF( void )
   tt_done_blend( FT_Memory  memory,
                  GX_Blend   blend )
   {
     if ( blend != NULL )
     {
       FT_UInt  i;
 
 
       FT_FREE( blend->normalizedcoords );
       FT_FREE( blend->mmvar );
 
       if ( blend->avar_segment != NULL )
       {
         for ( i = 0; i < blend->num_axis; ++i )
           FT_FREE( blend->avar_segment[i].correspondence );
         FT_FREE( blend->avar_segment );
       }
 
       FT_FREE( blend->tuplecoords );
       FT_FREE( blend->glyphoffsets );
       FT_FREE( blend );
     }
   }
 
 #endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
 
 
 /* END */
