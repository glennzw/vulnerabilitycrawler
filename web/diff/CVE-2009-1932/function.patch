commit d9544bcc44adcef769cbdf7f6453e140058a3adc
Author: Jan Schmidt <thaytan@noraisin.net>
Date:   Wed May 27 17:06:34 2009 +0100

    pngdec: Avoid possible overflow in calculations
    
    A malformed (or simply huge) PNG file can lead to integer overflow in
    calculating the size of the output buffer, leading to crashes or buffer
    overflows later. Fixes SA35205 security advisory.

diff --git a/ext/libpng/gstpngdec.c b/ext/libpng/gstpngdec.c
index 524b468..dde459d 100644
--- a/ext/libpng/gstpngdec.c
+++ b/ext/libpng/gstpngdec.c
@@ -185,29 +185,36 @@ static void
 user_info_callback (png_structp png_ptr, png_infop info)
 {
   GstPngDec *pngdec = NULL;
   GstFlowReturn ret = GST_FLOW_OK;
   size_t buffer_size;
   GstBuffer *buffer = NULL;
 
   pngdec = GST_PNGDEC (png_ptr->io_ptr);
 
   GST_LOG ("info ready");
 
   /* Generate the caps and configure */
   ret = gst_pngdec_caps_create_and_set (pngdec);
   if (ret != GST_FLOW_OK) {
     goto beach;
   }
 
   /* Allocate output buffer */
   pngdec->rowbytes = png_get_rowbytes (pngdec->png, pngdec->info);
-  buffer_size = pngdec->height * GST_ROUND_UP_4 (pngdec->rowbytes);
+  if (pngdec->rowbytes > (G_MAXUINT32 - 3)
+      || pngdec->height > G_MAXUINT32 / pngdec->rowbytes) {
+    ret = GST_FLOW_ERROR;
+    goto beach;
+  }
+  pngdec->rowbytes = GST_ROUND_UP_4 (pngdec->rowbytes);
+  buffer_size = pngdec->height * pngdec->rowbytes;
+
   ret =
       gst_pad_alloc_buffer_and_set_caps (pngdec->srcpad, GST_BUFFER_OFFSET_NONE,
       buffer_size, GST_PAD_CAPS (pngdec->srcpad), &buffer);
   if (ret != GST_FLOW_OK) {
     goto beach;
   }
 
   pngdec->buffer_out = buffer;
 
@@ -219,22 +226,22 @@ static void
 user_endrow_callback (png_structp png_ptr, png_bytep new_row,
     png_uint_32 row_num, int pass)
 {
   GstPngDec *pngdec = NULL;
 
   pngdec = GST_PNGDEC (png_ptr->io_ptr);
 
   /* FIXME: implement interlaced pictures */
 
   /* If buffer_out doesn't exist, it means buffer_alloc failed, which 
    * will already have set the return code */
   if (GST_IS_BUFFER (pngdec->buffer_out)) {
-    size_t offset = row_num * GST_ROUND_UP_4 (pngdec->rowbytes);
+    size_t offset = row_num * pngdec->rowbytes;
 
     GST_LOG ("got row %u, copying in buffer %p at offset %" G_GSIZE_FORMAT,
         (guint) row_num, pngdec->buffer_out, offset);
     memcpy (GST_BUFFER_DATA (pngdec->buffer_out) + offset, new_row,
         pngdec->rowbytes);
     pngdec->ret = GST_FLOW_OK;
   }
 }
 
@@ -465,64 +472,69 @@ static void
 gst_pngdec_task (GstPad * pad)
 {
   GstPngDec *pngdec;
   GstBuffer *buffer = NULL;
   size_t buffer_size = 0;
   gint i = 0;
   png_bytep *rows, inp;
   png_uint_32 rowbytes;
   GstFlowReturn ret = GST_FLOW_OK;
 
   pngdec = GST_PNGDEC (GST_OBJECT_PARENT (pad));
 
   GST_LOG_OBJECT (pngdec, "read frame");
 
   /* Let libpng come back here on error */
   if (setjmp (png_jmpbuf (pngdec->png))) {
     ret = GST_FLOW_ERROR;
     goto pause;
   }
 
   /* Set reading callback */
   png_set_read_fn (pngdec->png, pngdec, user_read_data);
 
   /* Read info */
   png_read_info (pngdec->png, pngdec->info);
 
   /* Generate the caps and configure */
   ret = gst_pngdec_caps_create_and_set (pngdec);
   if (ret != GST_FLOW_OK) {
     goto pause;
   }
 
   /* Allocate output buffer */
   rowbytes = png_get_rowbytes (pngdec->png, pngdec->info);
-  buffer_size = pngdec->height * GST_ROUND_UP_4 (rowbytes);
+  if (rowbytes > (G_MAXUINT32 - 3) || pngdec->height > G_MAXUINT32 / rowbytes) {
+    ret = GST_FLOW_ERROR;
+    goto pause;
+  }
+  rowbytes = GST_ROUND_UP_4 (rowbytes);
+  buffer_size = pngdec->height * rowbytes;
   ret =
       gst_pad_alloc_buffer_and_set_caps (pngdec->srcpad, GST_BUFFER_OFFSET_NONE,
       buffer_size, GST_PAD_CAPS (pngdec->srcpad), &buffer);
   if (ret != GST_FLOW_OK)
     goto pause;
 
   rows = (png_bytep *) g_malloc (sizeof (png_bytep) * pngdec->height);
 
   inp = GST_BUFFER_DATA (buffer);
 
   for (i = 0; i < pngdec->height; i++) {
     rows[i] = inp;
-    inp += GST_ROUND_UP_4 (rowbytes);
+    inp += rowbytes;
   }
 
   /* Read the actual picture */
   png_read_image (pngdec->png, rows);
   g_free (rows);
 
   /* Push the raw RGB frame */
   ret = gst_pad_push (pngdec->srcpad, buffer);
   if (ret != GST_FLOW_OK)
     goto pause;
 
   /* And we are done */
   gst_pad_pause_task (pngdec->sinkpad);
   gst_pad_push_event (pngdec->srcpad, gst_event_new_eos ());
   return;
 
