commit c06da1ad34663da7b6fc39b030dc3ae185b96557
Author: Werner Lemberg <wl@gnu.org>
Date:   Thu Aug 5 23:15:26 2010 +0200

    Fix Savannah bug #30656.
    
    * src/type42/t42parse.c (t42_parse_sfnts): Protect against negative
    string_size.
    Fix comparison.

diff --git a/ChangeLog b/ChangeLog
index b042fc9..4235ffb 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,829 +1,837 @@
+2010-08-05  Werner Lemberg  <wl@gnu.org>
+
+	Fix Savannah bug #30656.
+
+	* src/type42/t42parse.c (t42_parse_sfnts): Protect against negative
+	string_size.
+	Fix comparison.
+
 2010-08-05  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	[cff] Don't use any values in decoder after parsing error.
 
 	* src/cff/cffgload.c (cff_slot_load): Skip the evaluations
 	of the values in decoder, if cff_decoder_parse_charstrings()
 	returns any error.
 
 2010-08-04  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30644.
 
 	* src/base/ftstream.c (FT_Stream_EnterFrame): Fix comparison.
 
 2010-08-04  Werner Lemberg  <wl@gnu.org>
 
 	`make devel' fails if FT_CONFIG_OPTION_OLD_INTERNALS is set.
 
 	* devel/ftoption.h: Synchronize with
 	include/freetype/config/ftoption.h.
 
 2010-08-04  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	[cff] Improve stack overflow test.
 
 	* src/cff/cffgload.c (cff_decoder_parse_charstrings): Check stack
 	after execution of operations too.
 
 2010-07-18  Werner Lemberg  <wl@gnu.org>
 
 	Add reference counters and to FT_Library and FT_Face objects.
 
 	* include/freetype/freetype.h (FT_Reference_Face): New function.
 	* include/freetype/ftmodapi.h (FT_Rererence_Library): New function.
 
 	* include/freetype/internal/ftobjs.h (FT_Face_InternalRec,
 	FT_LibraryRec): New field `refcount'.
 
 	* src/base/ftobjs.c (FT_Open_Face, FT_New_Library): Handle
 	`refcount'.
 	(FT_Reference_Face, FT_Reference_Library): Implement new functions.
 	(FT_Done_Face, FT_Done_Library): Handle `refcount'.
 
 	* docs/CHANGES: Updated.
 
 2010-07-18  Werner Lemberg  <wl@gnu.org>
 
 	* Version 2.4.1 released.
 	=========================
 
 
 	Tag sources with `VER-2-4-1'.
 
 	* docs/CHANGES: Updated.
 
 	* docs/VERSION.DLL: Update documentation and bump version number to
 	2.4.1.
 
 	* README, Jamfile (RefDoc),
 	builds/win32/vc2005/freetype.vcproj, builds/win32/vc2005/index.html,
 	builds/win32/vc2008/freetype.vcproj, builds/win32/vc2008/index.html,
 	builds/win32/visualc/freetype.dsp,
 	builds/win32/visualc/freetype.vcproj,
 	builds/win32/visualc/index.html, builds/win32/visualce/freetype.dsp,
 	builds/win32/visualce/freetype.vcproj,
 	builds/win32/visualce/index.html,
 	builds/wince/vc2005-ce/freetype.vcproj,
 	builds/wince/vc2005-ce/index.html,
 	builds/wince/vc2008-ce/freetype.vcproj,
 	builds/wince/vc2008-ce/index.html: s/2.4.0/2.4.1/, s/240/241/.
 
 	* include/freetype/freetype.h (FREETYPE_PATCH): Set to 1.
 
 	* builds/unix/configure.raw (version_info): Set to 11:1:5.
 
 2010-07-17  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Final try to fix `hintmask' and `cntrmask' limit check.
 
 	Problem reported by Tobias Wolf <towolf@gmail.com>.
 
 	* src/cff/cffgload.c (cff_decoder_parse_charstrings)
 	<cff_op_hintmask>: Sigh.  I'm apparently too silly to fix this
 	correctly in less than three tries.
 
 2010-07-12  Werner Lemberg  <wl@gnu.org>
 
 	* Version 2.4.0 released.
 	=========================
 
 
 	Tag sources with `VER-2-4-0'.
 
 	* docs/CHANGES: Updated.
 
 	* docs/VERSION.DLL: Update documentation and bump version number to
 	2.4.0.
 
 	* README, Jamfile (RefDoc),
 	builds/win32/vc2005/freetype.vcproj, builds/win32/vc2005/index.html,
 	builds/win32/vc2008/freetype.vcproj, builds/win32/vc2008/index.html,
 	builds/win32/visualc/freetype.dsp,
 	builds/win32/visualc/freetype.vcproj,
 	builds/win32/visualc/index.html, builds/win32/visualce/freetype.dsp,
 	builds/win32/visualce/freetype.vcproj,
 	builds/win32/visualce/index.html,
 	builds/wince/vc2005-ce/freetype.vcproj,
 	builds/wince/vc2005-ce/index.html,
 	builds/wince/vc2008-ce/freetype.vcproj,
 	builds/wince/vc2008-ce/index.html: s/2.3.12/2.4.0/, s/2312/240/.
 
 	* include/freetype/freetype.h (FREETYPE_MINOR): Set to 4.
 	(FREETYPE_PATCH): Set to 0.
 
 	* builds/unix/configure.raw (version_info): Set to 11:0:5.
 
 2010-07-12  Werner Lemberg  <wl@gnu.org>
 
 	Remove C++ warnings.
 
 	*/*: Initialize pointers where necessary to make g++ happy.
 
 2010-07-12  malc  <av1474@comtv.ru>
 	    Richard Henderson  <rth@redhat.com>
 
 	Fix type-punning issues with C++.
 
 	* include/freetype/internal/ftmemory.h (FT_ASSIGNP) [__cplusplus]:
 	Emulate a `typeof' operator with an inline template which uses
 	`static_cast'.
 
 2010-07-11  Werner Lemberg  <wl@gnu.org>
 
 	Fix C++ compilation issue.
 
 	* src/tools/apinames.c (names_dump) <OUTPUT_WATCOM_LBC>: Fix
 	type of `dot' variable.
 
 2010-07-10  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Fix another case reported in Savannah bug #30373.
 	Permit a face for Type1, Type42 and CFF without charmap,
 	patch by Tor Andersson.
 
 	* src/type1/t1objs.c (T1_Face_Init): Reset the error if it
 	is FT_Err_No_Unicode_Glyph_Name.
 	* src/type42/t42objs.c (T42_Face_Init): Ditto.
 	* src/cff/cffobjs.c (cff_face_init): Ditto.
 
 2010-07-09  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Use defined macros to set {platform,encoding}_id.
 
 	* src/bdf/bdfdrivr.c: Include ttnameid.h and use macros to
 	set charmap.{platfom,encoding}_id.
 	* src/pcf/pcfdrivr.c: Ditto.
 	* src/winfonts/winfnt.c: Ditto.
 	* src/type1/t1objs.c: Ditto.
 	* src/type42/t42objs.c: Ditto.
 	* src/cff/cffobjs.c: Ditto.
 	* src/pfr/pfrobjs.c: Ditto.
 
 2010-07-09  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Fix Savannah bug #30373.
 	Too serious check of errors by `FT_CMap_New' since 2010-07-04
 	is fixed. Reported by Tor Andersson.
 
 	* include/freetype/fterrdef.h
 	(PSnames_Err_No_Unicode_Glyph_Name): New error code to
 	indicate the Unicode charmap synthesis failed because
 	no Unicode glyph name is found.
 
 	* src/psnames/psmodule.c (ps_unicodes_init): Return
 	PSnames_Err_No_Unicode_Glyph_Name when no Unicode glyph name
 	is found in the font.
 	* src/cff/cffcmap.c (cff_cmap_unicode_init): Return
 	CFF_Err_No_Unicode_Glyph_Name when no SID is available.
 
 	* src/type1/t1objs.c (T1_Face_Init): Proceed if `FT_CMap_New'
 	is failed by the lack of Unicode glyph name.
 	* src/type42/t42objs.c (T42_Face_Init): Ditto.
 	* src/cff/cffobjs.c (cff_face_init): Ditto.
 
 2010-07-09  Ken Sharp  <ken.sharp@artifex.com>
 
 	Make ftraster.c compile in stand-alone mode with MSVC compiler.
 
 	* src/raster/ftmisc.h (FT_Int64) [_WIN32, _WIN64]: Fix typedef
 	since there is no `inttypes.h' for MSVC.
 
 2010-07-08  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30361.
 
 	* src/truetype/ttinterp.c (Ins_IUP): Fix bounds check.
 
 2010-07-06  Werner Lemberg  <wl@gnu.org>
 
 	Pacify compiler.
 
 	* src/cff/cffload.c (cff_index_get_pointers): Initialize
 	`new_bytes'.
 
 2010-07-05  Eugene A. Shatokhin  <spectre@ispras.ru>
 
 	Fix Savannah bug #27648.
 
 	* src/base/ftobjs.c (ft_remove_renderer, FT_Add_Module): Call
 	`raster_done' only if we have an outline glyph format.
 
 2010-07-05  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30030.
 
 	* builds/win32/*/freetype.vcproj: Add ftxf86.c.
 
 2010-07-05  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Next try to fix `hintmask' and `cntrmask' limit check.
 
 	Problem reported by malc <av1474@comtv.ru>.
 
 	* src/cff/cffgload.c (cff_decoder_parse_charstrings)
 	<cff_op_hintmask>: It is possible that there is just a single byte
 	after the `hintmask' or `cntrmask', e.g., a `return' instruction.
 
 2010-07-04  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Restrict the number of the charmaps in a rogue-compatible mode.
 	Fix for Savannah bug #30059.
 
 	* src/cache/ftccmap.c (FTC_CMapCache_Lookup): Replace `16' the
 	minimum character code passed by a legacy rogue client by...
 	* include/freetype/config/ftoption.h (FT_MAX_CHARMAP_CACHEABLE):
 	This.  It is undefined when FT_CONFIG_OPTION_OLD_INTERNALS is
 	undefined (thus the rogue client compatibility is not required).
 
 	* src/cff/cffobjs.c (cff_face_init): Abort the automatic
 	selection or synthesis of Unicode cmap subtable when the charmap
 	index exceeds FT_MAX_CHARMAP_CACHEABLE.
 	* src/sfnt/ttcmap.c (tt_face_build_cmaps): Issue error message
 	when the charmap index exceeds FT_MAX_CHARMAP_CACHEABLE.
 
 	* src/base/ftobjs.c (find_unicode_charmap): When Unicode charmap
 	is found after FT_MAX_CHARMAP_CACHEABLE, ignore it and search
 	earlier one.
 	(find_variant_selector_charmap): When UVS charmap is found after
 	FT_MAX_CHARMAP_CACHEABLE, ignore it and search earlier one.
 	(FT_Select_Charmap): When a charmap matching with requested
 	encoding but after FT_MAX_CHARMAP_CACHEABLE, ignore and search
 	earlier one.
 	(FT_Set_Charmap): When a charmap matching with requested
 	charmap but after FT_MAX_CHARMAP_CACHEABLE, ignore and search
 	earlier one.
 	(FT_Get_Charmap_Index): When a requested charmap is found
 	after FT_MAX_CHARMAP_CACHEABLE, return the inverted charmap
 	index.
 
 2010-07-04  Werner Lemberg  <wl@gnu.org>
 
 	TrueType hinting is no longer patented.
 
 	* include/freetype/config/ftoption.h, devel/ftoption.h
 	(TT_CONFIG_OPTION_BYTECODE_INTERPRETER): Define.
 	(TT_CONFIG_OPTION_UNPATENTED_HINTING): Undefine.
 
 	* docs/CHANGES, docs/INSTALL, include/freetype/freetype.h: Updated.
 	* docs/TRUETYPE, docs/PATENTS: Removed.
 
 2010-07-04  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Check error value by `FT_CMap_New'.
 
 	* src/cff/cffobjs.c (cff_face_init): Check error value by
 	`FT_CMap_New'.
 	* src/pfr/pfrobjs.c (pfr_face_init): Ditto.
 	* src/type1/t1jobjs.c (T1_Face_Init): Ditto.
 	* src/type42/t42jobjs.c (T42_Face_Init): Ditto.
 
 2010-07-03  Werner Lemberg  <wl@gnu.org>
 
 	Make ftgrays.c compile stand-alone again.
 
 	* src/smooth/ftgrays.c [_STANDALONE_]: Include `stddef.h'.
 	(FT_INT_MAX, FT_PtrDist)[_STANDALONE_]: Define.
 
 2010-07-02  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Additional fix for Savannah bug #30306.
 
 	* src/base/ftobjs.c (Mac_Read_POST_Resource): If the type of the
 	POST fragment is 0, the segment is completely ignored.  The declared
 	length of the segment is not cared at all.  According to Adobe
 	Technical Note 5040, type 0 segment is a comment only and should not
 	be loaded for the interpreter.  Reported by Robert Święcki.
 
 2010-07-01  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Protect against code range underflow.
 
 	* src/truetype/ttinterp.c (DO_JROT, DO_JMPR, DO_JROF): Don't allow
 	negative IP values.
 
 2010-07-01  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Add rudimentary tracing for bytecode instructions.
 
 	* src/truetype/ttinterp.c (opcode_name) [FT_DEBUG_LEVEL_TRACE]: New
 	array.
 	(TT_RunIns): Trace opcodes.
 
 2010-06-30  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30263.
 
 	* src/smooth/ftgrays.c (gray_render_span): Use cast to `unsigned
 	int' to avoid integer overflow.
 
 	* src/smooth/ftsmooth.c (ft_smooth_render_generic): Use smaller
 	threshold values for `width' and `height'.  This is not directly
 	related to the bug fix but makes sense anyway.
 
 2010-07-01  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Initial fix for Savannah bug #30306.
 
 	* src/base/ftobjs.c (Mac_Read_POST_Resource): Check `rlen', the
 	length of fragment declared in the POST fragment header, and prevent
 	an underflow in length calculation.  Some fonts set the length to
 	zero in spite of the existence of a following 16bit `type'. 
 	Reported by Robert Święcki.
 
 2010-07-01  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Additional fix for Savannah bug #30248 and #30249.
 
 	* src/base/ftobjs.c (Mac_Read_POST_Resource): Check the buffer size
 	during gathering PFB fragments embedded in LaserWriter PS font for
 	Macintosh.  Reported by Robert Święcki.
 
 2010-06-30  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	Minor optimizations by avoiding divisions.
 
 	* src/sfnt/ttkern.c (tt_face_load_kern, tt_face_get_kerning):
 	Replace divisions with multiplication in comparisons.
 
 2010-06-29  Werner Lemberg  <wl@gnu.org>
 
 	Fix minor tracing issues.
 
 	* src/cff/cffgload.c, src/truetype/ttgload.c: Adjust tracing levels.
 
 2010-06-27  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Really fix `hintmask' and `cntrmask' limit check.
 
 	* src/cff/cffgload.c (cff_decoder_parse_charstrings)
 	<cff_op_hintmask>: Fix thinko and handle tracing also.
 
 2010-06-27  Werner Lemberg  <wl@gnu.org>
 
 	Fix valgrind warning.
 
 	* src/base/ftoutln.c (FT_Outline_Get_Orientation): Initialize
 	`result' array.
 
 2010-06-27  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Fix memory leak.
 
 	* src/cff/cffgload.c (cff_operator_seac): Free charstrings even in
 	case of errors.
 
 2010-06-27  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Protect against invalid `hintmask' and `cntrmask' operators.
 
 	* src/cff/cffgload.c (cff_decoder_parse_charstrings)
 	<cff_op_hintmask>: Ensure that we don't exceed `limit' while parsing
 	the bit masks of the `hintmask' and `cntrmask' operators.
 
 2010-06-26  Werner Lemberg  <wl@gnu.org>
 
 	Fix PFR change 2010-06-24.
 
 	* src/pfr/pfrgload.c (pfr_glyph_load_simple): Really protect against
 	invalid indices.
 
 2010-06-26  Werner Lemberg  <wl@gnu.org>
 
 	Improve PFR tracing messages.
 
 	* src/pfr/pfrgload.c (pfr_glyph_load_rec): Emit tracing messages for
 	simple and compound glyph offsets.
 
 2010-06-26  Werner Lemberg  <wl@gnu.org>
 
 	Fix last PFR change.
 
 	* src/pfr/pfrobjs.c (pfr_face_init): Fix rejection logic.
 
 2010-06-26  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30262.
 
 	* src/sfnt/ttload.c (tt_face_load_maxp): Limit `maxComponentDepth'
 	arbitrarily to 100 to avoid stack exhaustion.
 
 2010-06-26  Werner Lemberg  <wl@gnu.org>
 
 	Add some memory checks (mainly for debugging).
 
 	* src/base/ftstream.c (FT_Stream_EnterFrame): Exit with error
 	if the frame size is larger than the stream size.
 
 	* src/base/ftsystem.c (ft_ansi_stream_io): Exit with error if
 	seeking a position larger than the stream size.
 
 2010-06-25  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30261.
 
 	* src/pfr/pfrobjs.c (pfr_face_init): Reject fonts which contain
 	neither outline nor bitmap glyphs.
 
 2010-06-25  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30254.
 
 	* src/cff/cffload.c (cff_index_get_pointers): Do sanity check for
 	first offset also.
 
 2010-06-25  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Initial fix for Savannah bug #30248 and #30249.
 
 	* src/base/ftobjs.c (Mac_Read_POST_Resource): Check the error during
 	reading a PFB fragment embedded in LaserWriter PS font for Macintosh.
 	Reported by Robert Święcki.
 
 2010-06-24  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30247.
 
 	* src/pcf/pcfread.c (pcf_get_metrics): Disallow (invalid) fonts with
 	zero metrics.
 
 2010-06-24  Graham Asher  <graham.asher@btinternet.com>
 
 	* src/smooth/ftgrays.c (gray_render_cubic): Fix algorithm.
 	The previous version was too aggressive, as demonstrated in
 	http://lists.gnu.org/archive/html/freetype-devel/2010-06/msg00020.html.
 
 2010-06-24  Werner Lemberg  <wl@gnu.org>
 
 	*/*: Use module specific error names where appropriate.
 
 2010-06-24  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30236.
 
 	* src/sfnt/ttcmap.c (tt_face_build_cmaps): Improve check for pointer
 	to `cmap_table'.
 
 2010-06-24  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30235.
 
 	* src/pfr/pfrgload.c (pfr_glyph_load_simple): Protect against
 	invalid indices if there aren't any coordinates for indexing.
 
 2010-06-24  Werner Lemberg  <wl@gnu.org>
 
 	[bdf]: Font properties are optional.
 
 	* src/bdf/bdflib.c (_bdf_readstream): Use special error code to
 	indicate a redo operation.
 	(_bdf_parse_start): Handle `CHARS' keyword here too and pass current
 	input line to `_bdf_parse_glyph'.
 
 2010-06-23  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30220.
 
 	* include/freetype/fterrdef.h
 	(BDF_Err_Missing_Fontboundingbox_Field): New error code.
 
 	* src/bdf/bdflib.c (_bdf_parse_start): Check for missing
 	`FONTBOUNDINGBOX' field.
 	Avoid memory leak if there are multiple `FONT' lines (which is
 	invalid but doesn't hurt).
 
 2010-06-21  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30168.
 
 	* src/pfr/pfrgload.c (pfr_glyph_load_compound): Limit the number of
 	subglyphs to avoid endless recursion.
 
 2010-06-20  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30145.
 
 	* src/psaux/psobjs.c (t1_builder_add_contour): Protect against
 	`outline == NULL' which might happen in invalid fonts.
 
 2010-06-19  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30135.
 
 	* src/bdf/bdflib.c (_bdf_list_join): Don't modify value in static
 	string `empty'.
 	(_bdf_parse_glyph): Avoid memory leak in case of error.
 
 2010-06-15  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30108.
 
 	* src/autofit/afglobal.c (af_face_globals_compute_script_coverage):
 	Properly mask AF_DIGIT bit in comparison.
 
 2010-06-11  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30106.
 
 	Point numbers for FreeType's implementation of hinting masks are
 	collected before the final number of points of a glyph has been
 	determined; in particular, the code for handling the `endchar'
 	opcode can reduce the number of points.
 
 	* src/pshinter/pshalgo.c (psh_glyph_find_strong_points): Assure that
 	`end_point' is not larger than `glyph->num_points'.
 
 2010-06-11  Werner Lemberg  <wl@gnu.org>
 
 	[cff]: Improve debugging output.
 
 	* src/cff/cffgload.c (cff_decoder_parse_charstrings)
 	<cff_op_hintmask>: Implement it.
 
 2010-06-10  Graham Asher  <graham.asher@btinternet.com>
 
 	ftgrays: Speed up rendering of small cubic splines.
 
 	* src/smooth/ftgrays.c (gray_render_cubic): Implement new,
 	simplified algorithm to find out whether the spline can be replaced
 	with two straight lines.  See this thread for more:
 
 	  http://lists.gnu.org/archive/html/freetype-devel/2010-06/msg00000.html
 
 2010-06-09  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30082.
 
 	* src/cff/cffgload.c (cff_decoder_parse_charstrings)
 	<cff_op_callothersubr>: Protect against stack underflow.
 
 2010-06-08  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30053.
 
 	* src/cff/cffparse.c (cff_parse_real): Handle border case where
 	`fraction_length' has value 10.
 
 2010-06-07  Werner Lemberg  <wl@gnu.org>
 
 	Fix Savannah bug #30052.
 	This bug has been introduced with commit 2415cbf3.
 
 	* src/base/ftobjs.c (FT_Get_First_Char, FT_Get_Next_Char): Protect
 	against endless loop in case of corrupted font header data.
 
 2010-05-26  Werner Lemberg  <wl@gnu.org>
 
 	Remove unused variable.
 	Found by Graham.
 
 	* src/autofit/afhints.c (af_glyph_hints_reload): Remove unused
 	variable `first' in first block.
 
 2010-05-22  Werner Lemberg  <wl@gnu.org>
 
 	Fix various memory problems found by linuxtesting.org.
 
 	* src/base/ftgxval.c (FT_TrueTypeGX_Free, FT_ClassicKern_Free),
 	src/base/ftotval.c (FT_OpenType_Free), src/base/ftpfr.c
 	(ft_pfr_check): Check `face'.
 
 	* src/base/ftobjs.c (FT_Get_Charmap_Index): Check `charmap' and
 	`charmap->face'.
 	(FT_Render_Glyph): Check `slot->face'.
 	(FT_Get_SubGlyph_Info): Check `glyph->subglyphs'.
 
 2010-05-22  Werner Lemberg  <wl@gnu.org>
 
 	autofit: Remove dead code.
 	Suggested by Graham.
 
 	* src/autofit/afhints.c (af_glyph_hints_compute_inflections):
 	Removed.
 	(af_glyph_hints_reload): Remove third argument.
 	Update all callers.
 
 2010-05-21  Bram Tassyns  <bramt@enfocus.be>
 
 	Fix Savannah bug #27987.
 
 	* src/cff/cffobjs.c (remove_subset_prefix): New function.
 	(cff_face_init): Use it to adjust `cffface->family_name'.
 
 2010-05-20  Werner Lemberg  <wl@gnu.org>
 
 	TrueType: Make FreeType ignore maxSizeOfInstructions in `maxp'.
 
 	Acroread does the same.
 
 	* src/truetype/ttgload.c (TT_Process_Composite_Glyph): Call
 	`Update_Max' to adjust size of instructions array if necessary and
 	add a rough safety check.
 
 	(load_truetype_glyph): Save `loader->byte_len' before recursive
 	call.
 
 	* src/truetype/ttinterp.h, src/truetype/ttinterp.c (Update_Max):
 	Declare it as FT_LOCAL.
 
 2010-05-18  Hongbo Ni  <hongbo@njstar.com>
 
 	Apply Savannah patch #7196.
 
 	* src/cff/cffgload.c (cff_slot_load): Prevent crash if CFF subfont
 	index is out of range.
 
 2010-05-11  Werner Lemberg  <wl@gnu.org>
 
 	* docs/formats.txt: Give pointer to PCF documentation.
 	Information provided by Alan Coopersmith
 	<alan.coopersmith@oracle.com>.
 
 2010-05-10  Ken Sharp  <ken.sharp@artifex.com>
 
 	Fix Savannah bug #29846.
 
 	Previously we discovered fonts which used `setcurrentpoint' to set
 	the initial point of a contour to 0,0.  This caused FreeType to
 	raise an error, because the `setcurrentpoint' operator is only
 	supposed to be used with the results from an OtherSubr subroutine.
 
 	This was fixed by simply ignoring the error and carrying on.
 
 	Now we have found a font which uses setcurrentpoint to actually
 	establish a non-zero point for a contour during the course of a
 	glyph program.  FWIW, these files may be produced by an application
 	called `Intaglio' on the Mac, when converting TrueType fonts to
 	Type 1.
 
 	The fix allows the new invalid behaviour, the old invalid behaviour
 	and real proper usage of the operator to work the same way as Adobe
 	interpreters apparently do.
 
 	(t1_decoder_parse_charstrings): Make `setcurrentpoint' use the top
 	two elements of the stack to establish unconditionally the current x
 	and y coordinates.
 
 	Make the `flex' subroutine handling (OtherSubr 0) put the current
 	x,y coordinates onto the stack, instead of two dummy uninitialised
 	values.
 
 2010-04-14  Ken Sharp  <ken.sharp@artifex.com>
 
 	Fix Savannah bug #29444.
 
 	* src/psaux/psobjs.c (t1_builder_start_point): Accept (invalid)
 	`lineto' immediately after `hsbw', in accordance with Acrobat, GS,
 	and others.
 
 2010-04-14  Michał Cichoń  <thedmd@artifexmundi.com>
 
 	Fix Savannah bug #27999.
 
 	* src/cache/ftcmanag.c (FTC_Manager_RemoveFaceID): Only remove
 	selected entry, not all.
 
 2010-04-06  Jonathan Kew  <jfkthame@gmail.com>
 
 	Add overflow check to `fvar' table.
 
 	* src/truetype/ttgxvar.c (TT_Get_MM_Var): Check axis and instance
 	count.
 
 2010-04-05  Ken Sharp  <ken.sharp@artifex.com>
 
 	Fix Savannah bug #29335.
 
 	* src/raster/ftraster.c (Line_Up): Use slow multiplication to
 	prevent overflow.  This shouldn't have any serious impact on speed,
 	however.
 
 2010-04-05  Werner Lemberg  <wl@gnu.org>
 
 	Add new function `FT_Library_SetLcdFilterWeights'.
 
 	This is based on code written by Lifter
 	<http://unixforum.org/index.php?showuser=11691>.  It fixes
 	FreeDesktop bug #27386.
 
 	* src/base/ftlcdfil.c (FT_Library_SetLcdFilterWeights): New
 	function.
 
 	* include/freetype/ftlcdfil.h: Updated.
 
 	* docs/CHANGES: Updated.
 
 2010-04-01  John Tytgat  <John.Tytgat@esko.com>
 
 	Fix Savannah bug #29404.
 
 	* src/truetype/ttgload.c: Revert change 2752bd1a (check on bit 1
 	of `head' table of TrueType fonts).
 
 2010-03-14  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Fix `multi build' for Tytgat's CFF driver improvement.
 
 	* src/base/cffload.h (cff_index_get_name): Added.
 
 2010-03-12  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Remove duplicated inclusion of `FT_OUTLINE_H' in ftobjs.c.
 
 	* src/base/ftobjs.c: Remove 2nd inclusion of `FT_OUTLINE_H'.
 
 2010-03-11  Chris Liddell  <chris.liddell@artifex.com>
 
 	Fix Savannah bug #27442.
 
 	* src/raster/ftraster.c (ft_black_reset): Fix `buffer_size'.
 
 2010-03-09  Werner Lemberg  <wl@gnu.org>
 
 	Remove unused variable.
 	Reported by Graham.
 
 	* src/cff/cffparse.c (cff_parse_real): Remove `rest'.
 
 2010-03-02  John Tytgat  <John.Tytgat@esko.com>
 
 	Improve CFF string (especially glyphname) lookup performance.
 
 	We do this by avoiding memory allocation and file I/O.  This is
 	Savannah patch #7104.
 
 	* src/cff/cfftypes.h: Include PS cmaps service and
 	FT_INTERNAL_POSTSCRIPT_HINTS_H.
 	(CFF_SubFontRec): Remove `num_local_subrs'.
 	(CFF_FontRec): Add `num_strings', `strings', and `string_pool'
 	fields.
 	Remove `string_index' and `num_global_subrs' fields.
 	Use real types instead of `void' for `pshinter' and `psnames' fields.
 
 	* src/cff/cffload.c: Don't include PS cmaps service.
 	(cff_index_get_pointers): Add `pool' parameter which allows to
 	insert an extra NUL character for each String INDEX entry.
 	(cff_index_get_name): Make it a local function.
 	(cff_index_get_string): New function.
 	(cff_subfont_load): Updated.
 	(cff_font_load): Initialize `num_strings', `strings', and
 	`string_pool' fields in the `CFF_FontRec' structure.
 	(cff_index_get_sid_string): Use `cff_index_get_string' instead of
 	`cff_index_get_name'.
 	(cff_font_done): Updated.
 
 	* src/cff/cffload.h: Don't include PS cmaps service.
 	(cff_index_get_string): Added.
 	(cff_index_get_sid_string): Updated.
 
 	* src/cff/cffobjs.c: Don't include PS cmaps service and
 	FT_INTERNAL_POSTSCRIPT_HINTS_H.
 	(cff_size_get_globals_funcs, cff_slot_init): Updated.
 	(cff_face_init): Follow `cff_index_get_name',
 	`cff_index_get_string', and `cff_index_get_sid_string' changes.
 
 	* src/cff/cffcmap.c (cff_sid_free_glyph_name): Removed.
 	(cff_sid_to_glyph_name): Use `cff_index_get_cid_string'.
 	(cff_cmap_unicode_init): Updated.
 
 	* src/cff/cffdrivr.c: Don't include PS cmap service.
 	(cff_get_glyph_name): Avoid unnecessary lookup for POSTSCRIPT_CMAPS
 	service.
 	(cff_get_glyph_name, cff_ps_get_font_info, cff_get_ros): Follow API
 	`cff_index_get_sid_string' change.
 	(cff_get_name_index): Use `cff_index_get_string' instead of
 	`cff_index_get_name'.
 
 	* src/cff/cffgload.c: Don't include FT_INTERNAL_POSTSCRIPT_HINTS_H.
 	(cff_decoder_init, cff_decoder_prepare): Updated.
 
 2010-02-27  Werner Lemberg  <wl@gnu.org>
 
 	Simplify code.
 	Suggested by Behdad.
 
 	* src/base/ftobjs.c (FT_Get_First_Char): Don't use a loop since we
 	call FT_Get_Next_Char anyway if necessary.
 
 2010-02-26  Behdad Esfahbod  <behdad@behdad.org>
 
 	Improve handling of invalid glyph indices in char->index functions.
 
 	* src/base/ftobjs.c (FT_Get_First_Char, FT_Get_Next_Char): Use a
 	loop.
 
 2010-02-18  Chris Liddell  <chris.liddell@artifex.com>
 
 	Fix Savannah bug #28905.
 
 	Initialize phantom points before calling the incremental interface
 	to update glyph metrics.
 
 	* src/truetype/ttgload.c (tt_get_metrics_incr_overrides)
 	[FT_CONFIG_OPTION_INCREMENTAL]: New function, split off from...
 	(tt_get_metrics): This.
 	Updated.
 	(load_truetype_glyph): Use tt_get_metrics_incr_overrides.
 
 ----------------------------------------------------------------------------
 
diff --git a/src/type42/t42parse.c b/src/type42/t42parse.c
index 4dc7203..5774269 100644
--- a/src/type42/t42parse.c
+++ b/src/type42/t42parse.c
@@ -1,1180 +1,1187 @@
 /***************************************************************************/
 /*                                                                         */
 /*  t42parse.c                                                             */
 /*                                                                         */
 /*    Type 42 font parser (body).                                          */
 /*                                                                         */
-/*  Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by            */
+/*  Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 by      */
 /*  Roberto Alameda.                                                       */
 /*                                                                         */
 /*  This file is part of the FreeType project, and may only be used,       */
 /*  modified, and distributed under the terms of the FreeType project      */
 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
 /*  this file you indicate that you have read the license and              */
 /*  understand and accept it fully.                                        */
 /*                                                                         */
 /***************************************************************************/
 
 
 #include "t42parse.h"
 #include "t42error.h"
 #include FT_INTERNAL_DEBUG_H
 #include FT_INTERNAL_STREAM_H
 #include FT_INTERNAL_POSTSCRIPT_AUX_H
 
 
   /*************************************************************************/
   /*                                                                       */
   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
   /* messages during execution.                                            */
   /*                                                                       */
 #undef  FT_COMPONENT
 #define FT_COMPONENT  trace_t42
 
 
   static void
   t42_parse_font_matrix( T42_Face    face,
                          T42_Loader  loader );
   static void
   t42_parse_encoding( T42_Face    face,
                       T42_Loader  loader );
 
   static void
   t42_parse_charstrings( T42_Face    face,
                          T42_Loader  loader );
 
   static void
   t42_parse_sfnts( T42_Face    face,
                    T42_Loader  loader );
 
 
   /* as Type42 fonts have no Private dict,         */
   /* we set the last argument of T1_FIELD_XXX to 0 */
   static const
   T1_FieldRec  t42_keywords[] =
   {
 
 #undef  FT_STRUCTURE
 #define FT_STRUCTURE  T1_FontInfo
 #undef  T1CODE
 #define T1CODE        T1_FIELD_LOCATION_FONT_INFO
 
     T1_FIELD_STRING( "version",            version,             0 )
     T1_FIELD_STRING( "Notice",             notice,              0 )
     T1_FIELD_STRING( "FullName",           full_name,           0 )
     T1_FIELD_STRING( "FamilyName",         family_name,         0 )
     T1_FIELD_STRING( "Weight",             weight,              0 )
     T1_FIELD_NUM   ( "ItalicAngle",        italic_angle,        0 )
     T1_FIELD_BOOL  ( "isFixedPitch",       is_fixed_pitch,      0 )
     T1_FIELD_NUM   ( "UnderlinePosition",  underline_position,  0 )
     T1_FIELD_NUM   ( "UnderlineThickness", underline_thickness, 0 )
 
 #undef  FT_STRUCTURE
 #define FT_STRUCTURE  PS_FontExtraRec
 #undef  T1CODE
 #define T1CODE        T1_FIELD_LOCATION_FONT_EXTRA
 
     T1_FIELD_NUM   ( "FSType",             fs_type,             0 )
 
 #undef  FT_STRUCTURE
 #define FT_STRUCTURE  T1_FontRec
 #undef  T1CODE
 #define T1CODE        T1_FIELD_LOCATION_FONT_DICT
 
     T1_FIELD_KEY  ( "FontName",    font_name,    0 )
     T1_FIELD_NUM  ( "PaintType",   paint_type,   0 )
     T1_FIELD_NUM  ( "FontType",    font_type,    0 )
     T1_FIELD_FIXED( "StrokeWidth", stroke_width, 0 )
 
 #undef  FT_STRUCTURE
 #define FT_STRUCTURE  FT_BBox
 #undef  T1CODE
 #define T1CODE        T1_FIELD_LOCATION_BBOX
 
     T1_FIELD_BBOX("FontBBox", xMin, 0 )
 
     T1_FIELD_CALLBACK( "FontMatrix",  t42_parse_font_matrix, 0 )
     T1_FIELD_CALLBACK( "Encoding",    t42_parse_encoding,    0 )
     T1_FIELD_CALLBACK( "CharStrings", t42_parse_charstrings, 0 )
     T1_FIELD_CALLBACK( "sfnts",       t42_parse_sfnts,       0 )
 
     { 0, T1_FIELD_LOCATION_CID_INFO, T1_FIELD_TYPE_NONE, 0, 0, 0, 0, 0, 0 }
   };
 
 
 #define T1_Add_Table( p, i, o, l )  (p)->funcs.add( (p), i, o, l )
 #define T1_Done_Table( p )          \
           do                        \
           {                         \
             if ( (p)->funcs.done )  \
               (p)->funcs.done( p ); \
           } while ( 0 )
 #define T1_Release_Table( p )          \
           do                           \
           {                            \
             if ( (p)->funcs.release )  \
               (p)->funcs.release( p ); \
           } while ( 0 )
 
 #define T1_Skip_Spaces( p )    (p)->root.funcs.skip_spaces( &(p)->root )
 #define T1_Skip_PS_Token( p )  (p)->root.funcs.skip_PS_token( &(p)->root )
 
 #define T1_ToInt( p )                          \
           (p)->root.funcs.to_int( &(p)->root )
 #define T1_ToBytes( p, b, m, n, d )                          \
           (p)->root.funcs.to_bytes( &(p)->root, b, m, n, d )
 
 #define T1_ToFixedArray( p, m, f, t )                           \
           (p)->root.funcs.to_fixed_array( &(p)->root, m, f, t )
 #define T1_ToToken( p, t )                          \
           (p)->root.funcs.to_token( &(p)->root, t )
 
 #define T1_Load_Field( p, f, o, m, pf )                         \
           (p)->root.funcs.load_field( &(p)->root, f, o, m, pf )
 #define T1_Load_Field_Table( p, f, o, m, pf )                         \
           (p)->root.funcs.load_field_table( &(p)->root, f, o, m, pf )
 
 
   /********************* Parsing Functions ******************/
 
   FT_LOCAL_DEF( FT_Error )
   t42_parser_init( T42_Parser     parser,
                    FT_Stream      stream,
                    FT_Memory      memory,
                    PSAux_Service  psaux )
   {
     FT_Error  error = T42_Err_Ok;
     FT_Long   size;
 
 
     psaux->ps_parser_funcs->init( &parser->root, 0, 0, memory );
 
     parser->stream    = stream;
     parser->base_len  = 0;
     parser->base_dict = 0;
     parser->in_memory = 0;
 
     /*******************************************************************/
     /*                                                                 */
     /* Here a short summary of what is going on:                       */
     /*                                                                 */
     /*   When creating a new Type 42 parser, we try to locate and load */
     /*   the base dictionary, loading the whole font into memory.      */
     /*                                                                 */
     /*   When `loading' the base dictionary, we only set up pointers   */
     /*   in the case of a memory-based stream.  Otherwise, we allocate */
     /*   and load the base dictionary in it.                           */
     /*                                                                 */
     /*   parser->in_memory is set if we have a memory stream.          */
     /*                                                                 */
 
     if ( FT_STREAM_SEEK( 0L ) ||
          FT_FRAME_ENTER( 17 ) )
       goto Exit;
 
     if ( ft_memcmp( stream->cursor, "%!PS-TrueTypeFont", 17 ) != 0 )
     {
       FT_TRACE2(( "not a Type42 font\n" ));
       error = T42_Err_Unknown_File_Format;
     }
 
     FT_FRAME_EXIT();
 
     if ( error || FT_STREAM_SEEK( 0 ) )
       goto Exit;
 
     size = stream->size;
 
     /* now, try to load `size' bytes of the `base' dictionary we */
     /* found previously                                          */
 
     /* if it is a memory-based resource, set up pointers */
     if ( !stream->read )
     {
       parser->base_dict = (FT_Byte*)stream->base + stream->pos;
       parser->base_len  = size;
       parser->in_memory = 1;
 
       /* check that the `size' field is valid */
       if ( FT_STREAM_SKIP( size ) )
         goto Exit;
     }
     else
     {
       /* read segment in memory */
       if ( FT_ALLOC( parser->base_dict, size )       ||
            FT_STREAM_READ( parser->base_dict, size ) )
         goto Exit;
 
       parser->base_len = size;
     }
 
     parser->root.base   = parser->base_dict;
     parser->root.cursor = parser->base_dict;
     parser->root.limit  = parser->root.cursor + parser->base_len;
 
   Exit:
     if ( error && !parser->in_memory )
       FT_FREE( parser->base_dict );
 
     return error;
   }
 
 
   FT_LOCAL_DEF( void )
   t42_parser_done( T42_Parser  parser )
   {
     FT_Memory  memory = parser->root.memory;
 
 
     /* free the base dictionary only when we have a disk stream */
     if ( !parser->in_memory )
       FT_FREE( parser->base_dict );
 
     parser->root.funcs.done( &parser->root );
   }
 
 
   static int
   t42_is_space( FT_Byte  c )
   {
     return ( c == ' '  || c == '\t'              ||
              c == '\r' || c == '\n' || c == '\f' ||
              c == '\0'                           );
   }
 
 
   static void
   t42_parse_font_matrix( T42_Face    face,
                          T42_Loader  loader )
   {
     T42_Parser  parser = &loader->parser;
     FT_Matrix*  matrix = &face->type1.font_matrix;
     FT_Vector*  offset = &face->type1.font_offset;
     FT_Face     root   = (FT_Face)&face->root;
     FT_Fixed    temp[6];
     FT_Fixed    temp_scale;
 
 
     (void)T1_ToFixedArray( parser, 6, temp, 3 );
 
     temp_scale = FT_ABS( temp[3] );
 
     /* Set Units per EM based on FontMatrix values.  We set the value to */
     /* 1000 / temp_scale, because temp_scale was already multiplied by   */
     /* 1000 (in t1_tofixed, from psobjs.c).                              */
 
     root->units_per_EM = (FT_UShort)( FT_DivFix( 1000 * 0x10000L,
                                                  temp_scale ) >> 16 );
 
     /* we need to scale the values by 1.0/temp_scale */
     if ( temp_scale != 0x10000L )
     {
       temp[0] = FT_DivFix( temp[0], temp_scale );
       temp[1] = FT_DivFix( temp[1], temp_scale );
       temp[2] = FT_DivFix( temp[2], temp_scale );
       temp[4] = FT_DivFix( temp[4], temp_scale );
       temp[5] = FT_DivFix( temp[5], temp_scale );
       temp[3] = 0x10000L;
     }
 
     matrix->xx = temp[0];
     matrix->yx = temp[1];
     matrix->xy = temp[2];
     matrix->yy = temp[3];
 
     /* note that the offsets must be expressed in integer font units */
     offset->x = temp[4] >> 16;
     offset->y = temp[5] >> 16;
   }
 
 
   static void
   t42_parse_encoding( T42_Face    face,
                       T42_Loader  loader )
   {
     T42_Parser  parser = &loader->parser;
     FT_Byte*    cur;
     FT_Byte*    limit  = parser->root.limit;
 
     PSAux_Service  psaux  = (PSAux_Service)face->psaux;
 
 
     T1_Skip_Spaces( parser );
     cur = parser->root.cursor;
     if ( cur >= limit )
     {
       FT_ERROR(( "t42_parse_encoding: out of bounds\n" ));
       parser->root.error = T42_Err_Invalid_File_Format;
       return;
     }
 
     /* if we have a number or `[', the encoding is an array, */
     /* and we must load it now                               */
     if ( ft_isdigit( *cur ) || *cur == '[' )
     {
       T1_Encoding  encode          = &face->type1.encoding;
       FT_UInt      count, n;
       PS_Table     char_table      = &loader->encoding_table;
       FT_Memory    memory          = parser->root.memory;
       FT_Error     error;
       FT_Bool      only_immediates = 0;
 
 
       /* read the number of entries in the encoding; should be 256 */
       if ( *cur == '[' )
       {
         count           = 256;
         only_immediates = 1;
         parser->root.cursor++;
       }
       else
         count = (FT_UInt)T1_ToInt( parser );
 
       T1_Skip_Spaces( parser );
       if ( parser->root.cursor >= limit )
         return;
 
       /* we use a T1_Table to store our charnames */
       loader->num_chars = encode->num_chars = count;
       if ( FT_NEW_ARRAY( encode->char_index, count )     ||
            FT_NEW_ARRAY( encode->char_name,  count )     ||
            FT_SET_ERROR( psaux->ps_table_funcs->init(
                            char_table, count, memory ) ) )
       {
         parser->root.error = error;
         return;
       }
 
       /* We need to `zero' out encoding_table.elements */
       for ( n = 0; n < count; n++ )
       {
         char*  notdef = (char *)".notdef";
 
 
         T1_Add_Table( char_table, n, notdef, 8 );
       }
 
       /* Now we need to read records of the form                */
       /*                                                        */
       /*   ... charcode /charname ...                           */
       /*                                                        */
       /* for each entry in our table.                           */
       /*                                                        */
       /* We simply look for a number followed by an immediate   */
       /* name.  Note that this ignores correctly the sequence   */
       /* that is often seen in type42 fonts:                    */
       /*                                                        */
       /*   0 1 255 { 1 index exch /.notdef put } for dup        */
       /*                                                        */
       /* used to clean the encoding array before anything else. */
       /*                                                        */
       /* Alternatively, if the array is directly given as       */
       /*                                                        */
       /*   /Encoding [ ... ]                                    */
       /*                                                        */
       /* we only read immediates.                               */
 
       n = 0;
       T1_Skip_Spaces( parser );
 
       while ( parser->root.cursor < limit )
       {
         cur = parser->root.cursor;
 
         /* we stop when we encounter `def' or `]' */
         if ( *cur == 'd' && cur + 3 < limit )
         {
           if ( cur[1] == 'e'          &&
                cur[2] == 'f'          &&
                t42_is_space( cur[3] ) )
           {
             FT_TRACE6(( "encoding end\n" ));
             cur += 3;
             break;
           }
         }
         if ( *cur == ']' )
         {
           FT_TRACE6(( "encoding end\n" ));
           cur++;
           break;
         }
 
         /* check whether we have found an entry */
         if ( ft_isdigit( *cur ) || only_immediates )
         {
           FT_Int  charcode;
 
 
           if ( only_immediates )
             charcode = n;
           else
           {
             charcode = (FT_Int)T1_ToInt( parser );
             T1_Skip_Spaces( parser );
           }
 
           cur = parser->root.cursor;
 
           if ( *cur == '/' && cur + 2 < limit && n < count )
           {
             FT_PtrDist  len;
 
 
             cur++;
 
             parser->root.cursor = cur;
             T1_Skip_PS_Token( parser );
             if ( parser->root.error )
               return;
 
             len = parser->root.cursor - cur;
 
             parser->root.error = T1_Add_Table( char_table, charcode,
                                                cur, len + 1 );
             if ( parser->root.error )
               return;
             char_table->elements[charcode][len] = '\0';
 
             n++;
           }
         }
         else
         {
           T1_Skip_PS_Token( parser );
           if ( parser->root.error )
             return;
         }
 
         T1_Skip_Spaces( parser );
       }
 
       face->type1.encoding_type  = T1_ENCODING_TYPE_ARRAY;
       parser->root.cursor        = cur;
     }
 
     /* Otherwise, we should have either `StandardEncoding', */
     /* `ExpertEncoding', or `ISOLatin1Encoding'             */
     else
     {
       if ( cur + 17 < limit                                            &&
            ft_strncmp( (const char*)cur, "StandardEncoding", 16 ) == 0 )
         face->type1.encoding_type = T1_ENCODING_TYPE_STANDARD;
 
       else if ( cur + 15 < limit                                          &&
                 ft_strncmp( (const char*)cur, "ExpertEncoding", 14 ) == 0 )
         face->type1.encoding_type = T1_ENCODING_TYPE_EXPERT;
 
       else if ( cur + 18 < limit                                             &&
                 ft_strncmp( (const char*)cur, "ISOLatin1Encoding", 17 ) == 0 )
         face->type1.encoding_type = T1_ENCODING_TYPE_ISOLATIN1;
 
       else
       {
         FT_ERROR(( "t42_parse_encoding: invalid token\n" ));
         parser->root.error = T42_Err_Invalid_File_Format;
       }
     }
   }
 
 
   typedef enum  T42_Load_Status_
   {
     BEFORE_START,
     BEFORE_TABLE_DIR,
     OTHER_TABLES
 
   } T42_Load_Status;
 
 
   static void
   t42_parse_sfnts( T42_Face    face,
                    T42_Loader  loader )
   {
     T42_Parser  parser = &loader->parser;
     FT_Memory   memory = parser->root.memory;
     FT_Byte*    cur;
     FT_Byte*    limit  = parser->root.limit;
     FT_Error    error;
     FT_Int      num_tables = 0;
     FT_ULong    count, ttf_size = 0;
 
     FT_Long     n, string_size, old_string_size, real_size;
     FT_Byte*    string_buf = NULL;
     FT_Bool     allocated  = 0;
 
     T42_Load_Status  status;
 
 
     /* The format is                                */
     /*                                              */
     /*   /sfnts [ <hexstring> <hexstring> ... ] def */
     /*                                              */
     /* or                                           */
     /*                                              */
     /*   /sfnts [                                   */
     /*      <num_bin_bytes> RD <binary data>        */
     /*      <num_bin_bytes> RD <binary data>        */
     /*      ...                                     */
     /*   ] def                                      */
     /*                                              */
     /* with exactly one space after the `RD' token. */
 
     T1_Skip_Spaces( parser );
 
     if ( parser->root.cursor >= limit || *parser->root.cursor++ != '[' )
     {
       FT_ERROR(( "t42_parse_sfnts: can't find begin of sfnts vector\n" ));
       error = T42_Err_Invalid_File_Format;
       goto Fail;
     }
 
     T1_Skip_Spaces( parser );
     status          = BEFORE_START;
     string_size     = 0;
     old_string_size = 0;
     count           = 0;
 
     while ( parser->root.cursor < limit )
     {
       cur = parser->root.cursor;
 
       if ( *cur == ']' )
       {
         parser->root.cursor++;
         goto Exit;
       }
 
       else if ( *cur == '<' )
       {
         T1_Skip_PS_Token( parser );
         if ( parser->root.error )
           goto Exit;
 
         /* don't include delimiters */
         string_size = (FT_Long)( ( parser->root.cursor - cur - 2 + 1 ) / 2 );
         if ( FT_REALLOC( string_buf, old_string_size, string_size ) )
           goto Fail;
 
         allocated = 1;
 
         parser->root.cursor = cur;
         (void)T1_ToBytes( parser, string_buf, string_size, &real_size, 1 );
         old_string_size = string_size;
         string_size = real_size;
       }
 
       else if ( ft_isdigit( *cur ) )
       {
         if ( allocated )
         {
           FT_ERROR(( "t42_parse_sfnts: "
                      "can't handle mixed binary and hex strings\n" ));
           error = T42_Err_Invalid_File_Format;
           goto Fail;
         }
 
         string_size = T1_ToInt( parser );
+        if ( string_size < 0 )
+        {
+          FT_ERROR(( "t42_parse_sfnts: invalid string size\n" ));
+          error = T42_Err_Invalid_File_Format;
+          goto Fail;
+        }
 
         T1_Skip_PS_Token( parser );             /* `RD' */
         if ( parser->root.error )
           return;
 
         string_buf = parser->root.cursor + 1;   /* one space after `RD' */
 
-        parser->root.cursor += string_size + 1;
-        if ( parser->root.cursor >= limit )
+        if ( limit - parser->root.cursor < string_size )
         {
           FT_ERROR(( "t42_parse_sfnts: too many binary data\n" ));
           error = T42_Err_Invalid_File_Format;
           goto Fail;
         }
+        else
+          parser->root.cursor += string_size + 1;
       }
 
       if ( !string_buf )
       {
         FT_ERROR(( "t42_parse_sfnts: invalid data in sfnts array\n" ));
         error = T42_Err_Invalid_File_Format;
         goto Fail;
       }
 
       /* A string can have a trailing zero byte for padding.  Ignore it. */
       if ( string_buf[string_size - 1] == 0 && ( string_size % 2 == 1 ) )
         string_size--;
 
       if ( !string_size )
       {
         FT_ERROR(( "t42_parse_sfnts: invalid string\n" ));
         error = T42_Err_Invalid_File_Format;
         goto Fail;
       }
 
       for ( n = 0; n < string_size; n++ )
       {
         switch ( status )
         {
         case BEFORE_START:
           /* load offset table, 12 bytes */
           if ( count < 12 )
           {
             face->ttf_data[count++] = string_buf[n];
             continue;
           }
           else
           {
             num_tables = 16 * face->ttf_data[4] + face->ttf_data[5];
             status     = BEFORE_TABLE_DIR;
             ttf_size   = 12 + 16 * num_tables;
 
             if ( FT_REALLOC( face->ttf_data, 12, ttf_size ) )
               goto Fail;
           }
           /* fall through */
 
         case BEFORE_TABLE_DIR:
           /* the offset table is read; read the table directory */
           if ( count < ttf_size )
           {
             face->ttf_data[count++] = string_buf[n];
             continue;
           }
           else
           {
             int       i;
             FT_ULong  len;
 
 
             for ( i = 0; i < num_tables; i++ )
             {
               FT_Byte*  p = face->ttf_data + 12 + 16 * i + 12;
 
 
               len = FT_PEEK_ULONG( p );
 
               /* Pad to a 4-byte boundary length */
               ttf_size += ( len + 3 ) & ~3;
             }
 
             status         = OTHER_TABLES;
             face->ttf_size = ttf_size;
 
             /* there are no more than 256 tables, so no size check here */
             if ( FT_REALLOC( face->ttf_data, 12 + 16 * num_tables,
                              ttf_size + 1 ) )
               goto Fail;
           }
           /* fall through */
 
         case OTHER_TABLES:
           /* all other tables are just copied */
           if ( count >= ttf_size )
           {
             FT_ERROR(( "t42_parse_sfnts: too many binary data\n" ));
             error = T42_Err_Invalid_File_Format;
             goto Fail;
           }
           face->ttf_data[count++] = string_buf[n];
         }
       }
 
       T1_Skip_Spaces( parser );
     }
 
     /* if control reaches this point, the format was not valid */
     error = T42_Err_Invalid_File_Format;
 
   Fail:
     parser->root.error = error;
 
   Exit:
     if ( allocated )
       FT_FREE( string_buf );
   }
 
 
   static void
   t42_parse_charstrings( T42_Face    face,
                          T42_Loader  loader )
   {
     T42_Parser     parser       = &loader->parser;
     PS_Table       code_table   = &loader->charstrings;
     PS_Table       name_table   = &loader->glyph_names;
     PS_Table       swap_table   = &loader->swap_table;
     FT_Memory      memory       = parser->root.memory;
     FT_Error       error;
 
     PSAux_Service  psaux        = (PSAux_Service)face->psaux;
 
     FT_Byte*       cur;
     FT_Byte*       limit        = parser->root.limit;
     FT_UInt        n;
     FT_UInt        notdef_index = 0;
     FT_Byte        notdef_found = 0;
 
 
     T1_Skip_Spaces( parser );
 
     if ( parser->root.cursor >= limit )
     {
       FT_ERROR(( "t42_parse_charstrings: out of bounds\n" ));
       error = T42_Err_Invalid_File_Format;
       goto Fail;
     }
 
     if ( ft_isdigit( *parser->root.cursor ) )
     {
       loader->num_glyphs = (FT_UInt)T1_ToInt( parser );
       if ( parser->root.error )
         return;
     }
     else if ( *parser->root.cursor == '<' )
     {
       /* We have `<< ... >>'.  Count the number of `/' in the dictionary */
       /* to get its size.                                                */
       FT_UInt  count = 0;
 
 
       T1_Skip_PS_Token( parser );
       if ( parser->root.error )
         return;
       T1_Skip_Spaces( parser );
       cur = parser->root.cursor;
 
       while ( parser->root.cursor < limit )
       {
         if ( *parser->root.cursor == '/' )
           count++;
         else if ( *parser->root.cursor == '>' )
         {
           loader->num_glyphs  = count;
           parser->root.cursor = cur;        /* rewind */
           break;
         }
         T1_Skip_PS_Token( parser );
         if ( parser->root.error )
           return;
         T1_Skip_Spaces( parser );
       }
     }
     else
     {
       FT_ERROR(( "t42_parse_charstrings: invalid token\n" ));
       error = T42_Err_Invalid_File_Format;
       goto Fail;
     }
 
     if ( parser->root.cursor >= limit )
     {
       FT_ERROR(( "t42_parse_charstrings: out of bounds\n" ));
       error = T42_Err_Invalid_File_Format;
       goto Fail;
     }
 
     /* initialize tables */
 
     error = psaux->ps_table_funcs->init( code_table,
                                          loader->num_glyphs,
                                          memory );
     if ( error )
       goto Fail;
 
     error = psaux->ps_table_funcs->init( name_table,
                                          loader->num_glyphs,
                                          memory );
     if ( error )
       goto Fail;
 
     /* Initialize table for swapping index notdef_index and */
     /* index 0 names and codes (if necessary).              */
 
     error = psaux->ps_table_funcs->init( swap_table, 4, memory );
     if ( error )
       goto Fail;
 
     n = 0;
 
     for (;;)
     {
       /* The format is simple:                   */
       /*   `/glyphname' + index [+ def]          */
 
       T1_Skip_Spaces( parser );
 
       cur = parser->root.cursor;
       if ( cur >= limit )
         break;
 
       /* We stop when we find an `end' keyword or '>' */
       if ( *cur   == 'e'          &&
            cur + 3 < limit        &&
            cur[1] == 'n'          &&
            cur[2] == 'd'          &&
            t42_is_space( cur[3] ) )
         break;
       if ( *cur == '>' )
         break;
 
       T1_Skip_PS_Token( parser );
       if ( parser->root.error )
         return;
 
       if ( *cur == '/' )
       {
         FT_PtrDist  len;
 
 
         if ( cur + 1 >= limit )
         {
           FT_ERROR(( "t42_parse_charstrings: out of bounds\n" ));
           error = T42_Err_Invalid_File_Format;
           goto Fail;
         }
 
         cur++;                              /* skip `/' */
         len = parser->root.cursor - cur;
 
         error = T1_Add_Table( name_table, n, cur, len + 1 );
         if ( error )
           goto Fail;
 
         /* add a trailing zero to the name table */
         name_table->elements[n][len] = '\0';
 
         /* record index of /.notdef */
         if ( *cur == '.'                                              &&
              ft_strcmp( ".notdef",
                         (const char*)(name_table->elements[n]) ) == 0 )
         {
           notdef_index = n;
           notdef_found = 1;
         }
 
         T1_Skip_Spaces( parser );
 
         cur = parser->root.cursor;
 
         (void)T1_ToInt( parser );
         if ( parser->root.cursor >= limit )
         {
           FT_ERROR(( "t42_parse_charstrings: out of bounds\n" ));
           error = T42_Err_Invalid_File_Format;
           goto Fail;
         }
 
         len = parser->root.cursor - cur;
 
         error = T1_Add_Table( code_table, n, cur, len + 1 );
         if ( error )
           goto Fail;
 
         code_table->elements[n][len] = '\0';
 
         n++;
         if ( n >= loader->num_glyphs )
           break;
       }
     }
 
     loader->num_glyphs = n;
 
     if ( !notdef_found )
     {
       FT_ERROR(( "t42_parse_charstrings: no /.notdef glyph\n" ));
       error = T42_Err_Invalid_File_Format;
       goto Fail;
     }
 
     /* if /.notdef does not occupy index 0, do our magic. */
     if ( ft_strcmp( (const char*)".notdef",
                     (const char*)name_table->elements[0] ) )
     {
       /* Swap glyph in index 0 with /.notdef glyph.  First, add index 0  */
       /* name and code entries to swap_table.  Then place notdef_index   */
       /* name and code entries into swap_table.  Then swap name and code */
       /* entries at indices notdef_index and 0 using values stored in    */
       /* swap_table.                                                     */
 
       /* Index 0 name */
       error = T1_Add_Table( swap_table, 0,
                             name_table->elements[0],
                             name_table->lengths [0] );
       if ( error )
         goto Fail;
 
       /* Index 0 code */
       error = T1_Add_Table( swap_table, 1,
                             code_table->elements[0],
                             code_table->lengths [0] );
       if ( error )
         goto Fail;
 
       /* Index notdef_index name */
       error = T1_Add_Table( swap_table, 2,
                             name_table->elements[notdef_index],
                             name_table->lengths [notdef_index] );
       if ( error )
         goto Fail;
 
       /* Index notdef_index code */
       error = T1_Add_Table( swap_table, 3,
                             code_table->elements[notdef_index],
                             code_table->lengths [notdef_index] );
       if ( error )
         goto Fail;
 
       error = T1_Add_Table( name_table, notdef_index,
                             swap_table->elements[0],
                             swap_table->lengths [0] );
       if ( error )
         goto Fail;
 
       error = T1_Add_Table( code_table, notdef_index,
                             swap_table->elements[1],
                             swap_table->lengths [1] );
       if ( error )
         goto Fail;
 
       error = T1_Add_Table( name_table, 0,
                             swap_table->elements[2],
                             swap_table->lengths [2] );
       if ( error )
         goto Fail;
 
       error = T1_Add_Table( code_table, 0,
                             swap_table->elements[3],
                             swap_table->lengths [3] );
       if ( error )
         goto Fail;
 
     }
 
     return;
 
   Fail:
     parser->root.error = error;
   }
 
 
   static FT_Error
   t42_load_keyword( T42_Face    face,
                     T42_Loader  loader,
                     T1_Field    field )
   {
     FT_Error  error;
     void*     dummy_object;
     void**    objects;
     FT_UInt   max_objects = 0;
 
 
     /* if the keyword has a dedicated callback, call it */
     if ( field->type == T1_FIELD_TYPE_CALLBACK )
     {
       field->reader( (FT_Face)face, loader );
       error = loader->parser.root.error;
       goto Exit;
     }
 
     /* now the keyword is either a simple field or a table of fields; */
     /* we are now going to take care of it                            */
 
     switch ( field->location )
     {
     case T1_FIELD_LOCATION_FONT_INFO:
       dummy_object = &face->type1.font_info;
       break;
 
     case T1_FIELD_LOCATION_FONT_EXTRA:
       dummy_object = &face->type1.font_extra;
       break;
 
     case T1_FIELD_LOCATION_BBOX:
       dummy_object = &face->type1.font_bbox;
       break;
 
     default:
       dummy_object = &face->type1;
     }
 
     objects = &dummy_object;
 
     if ( field->type == T1_FIELD_TYPE_INTEGER_ARRAY ||
          field->type == T1_FIELD_TYPE_FIXED_ARRAY   )
       error = T1_Load_Field_Table( &loader->parser, field,
                                    objects, max_objects, 0 );
     else
       error = T1_Load_Field( &loader->parser, field,
                              objects, max_objects, 0 );
 
    Exit:
     return error;
   }
 
 
   FT_LOCAL_DEF( FT_Error )
   t42_parse_dict( T42_Face    face,
                   T42_Loader  loader,
                   FT_Byte*    base,
                   FT_Long     size )
   {
     T42_Parser  parser     = &loader->parser;
     FT_Byte*    limit;
     FT_Int      n_keywords = (FT_Int)( sizeof ( t42_keywords ) /
                                          sizeof ( t42_keywords[0] ) );
 
 
     parser->root.cursor = base;
     parser->root.limit  = base + size;
     parser->root.error  = T42_Err_Ok;
 
     limit = parser->root.limit;
 
     T1_Skip_Spaces( parser );
 
     while ( parser->root.cursor < limit )
     {
       FT_Byte*  cur;
 
 
       cur = parser->root.cursor;
 
       /* look for `FontDirectory' which causes problems for some fonts */
       if ( *cur == 'F' && cur + 25 < limit                    &&
            ft_strncmp( (char*)cur, "FontDirectory", 13 ) == 0 )
       {
         FT_Byte*  cur2;
 
 
         /* skip the `FontDirectory' keyword */
         T1_Skip_PS_Token( parser );
         T1_Skip_Spaces  ( parser );
         cur = cur2 = parser->root.cursor;
 
         /* look up the `known' keyword */
         while ( cur < limit )
         {
           if ( *cur == 'k' && cur + 5 < limit             &&
                 ft_strncmp( (char*)cur, "known", 5 ) == 0 )
             break;
 
           T1_Skip_PS_Token( parser );
           if ( parser->root.error )
             goto Exit;
           T1_Skip_Spaces  ( parser );
           cur = parser->root.cursor;
         }
 
         if ( cur < limit )
         {
           T1_TokenRec  token;
 
 
           /* skip the `known' keyword and the token following it */
           T1_Skip_PS_Token( parser );
           T1_ToToken( parser, &token );
 
           /* if the last token was an array, skip it! */
           if ( token.type == T1_TOKEN_TYPE_ARRAY )
             cur2 = parser->root.cursor;
         }
         parser->root.cursor = cur2;
       }
 
       /* look for immediates */
       else if ( *cur == '/' && cur + 2 < limit )
       {
         FT_PtrDist  len;
 
 
         cur++;
 
         parser->root.cursor = cur;
         T1_Skip_PS_Token( parser );
         if ( parser->root.error )
           goto Exit;
 
         len = parser->root.cursor - cur;
 
         if ( len > 0 && len < 22 && parser->root.cursor < limit )
         {
           int  i;
 
 
           /* now compare the immediate name to the keyword table */
 
           /* loop through all known keywords */
           for ( i = 0; i < n_keywords; i++ )
           {
             T1_Field  keyword = (T1_Field)&t42_keywords[i];
             FT_Byte   *name   = (FT_Byte*)keyword->ident;
 
 
             if ( !name )
               continue;
 
             if ( cur[0] == name[0]                                  &&
                  len == (FT_PtrDist)ft_strlen( (const char *)name ) &&
                  ft_memcmp( cur, name, len ) == 0                   )
             {
               /* we found it -- run the parsing callback! */
               parser->root.error = t42_load_keyword( face,
                                                      loader,
                                                      keyword );
               if ( parser->root.error )
                 return parser->root.error;
               break;
             }
           }
         }
       }
       else
       {
         T1_Skip_PS_Token( parser );
         if ( parser->root.error )
           goto Exit;
       }
 
       T1_Skip_Spaces( parser );
     }
 
   Exit:
     return parser->root.error;
   }
 
 
   FT_LOCAL_DEF( void )
   t42_loader_init( T42_Loader  loader,
                    T42_Face    face )
   {
     FT_UNUSED( face );
 
     FT_MEM_ZERO( loader, sizeof ( *loader ) );
     loader->num_glyphs = 0;
     loader->num_chars  = 0;
 
     /* initialize the tables -- simply set their `init' field to 0 */
     loader->encoding_table.init = 0;
     loader->charstrings.init    = 0;
     loader->glyph_names.init    = 0;
   }
 
 
   FT_LOCAL_DEF( void )
   t42_loader_done( T42_Loader  loader )
   {
     T42_Parser  parser = &loader->parser;
 
 
     /* finalize tables */
     T1_Release_Table( &loader->encoding_table );
     T1_Release_Table( &loader->charstrings );
     T1_Release_Table( &loader->glyph_names );
     T1_Release_Table( &loader->swap_table );
 
     /* finalize parser */
     t42_parser_done( parser );
   }
 
 
 /* END */
