commit 8627880e07c8345f69ed639325280c7f62a8f894
Author: Dan Williams <dcbw@redhat.com>
Date:   Wed Dec 9 17:42:36 2009 -0800

    editor: prevent any registration of objects on the system bus
    
    D-Bus access-control is name-based; so requests for a specific name
    are allowed/denied based on the rules in /etc/dbus-1/system.d.  But
    apparently apps still get a non-named service on the bus, and if we
    register *any* object even though we don't have a named service,
    dbus and dbus-glib will happily proxy signals.  Since the connection
    editor shouldn't ever expose anything having to do with connections
    on any bus, make sure that's the case.

diff --git a/src/applet.c b/src/applet.c
index 810881b..e174ede 100644
--- a/src/applet.c
+++ b/src/applet.c
@@ -2612,95 +2612,91 @@ static GObject *
 constructor (GType type,
              guint n_props,
              GObjectConstructParam *construct_props)
 {
 	NMApplet *applet;
 	AppletDBusManager *dbus_mgr;
 	GList *server_caps, *iter;
 
 	applet = NM_APPLET (G_OBJECT_CLASS (nma_parent_class)->constructor (type, n_props, construct_props));
 
 	g_set_application_name (_("NetworkManager Applet"));
 	gtk_window_set_default_icon_name (GTK_STOCK_NETWORK);
 
 	applet->glade_file = g_build_filename (GLADEDIR, "applet.glade", NULL);
 	if (!applet->glade_file || !g_file_test (applet->glade_file, G_FILE_TEST_IS_REGULAR)) {
 		GtkWidget *dialog;
 		dialog = applet_warning_dialog_show (_("The NetworkManager Applet could not find some required resources (the glade file was not found)."));
 		gtk_dialog_run (GTK_DIALOG (dialog));
 		goto error;
 	}
 
 	applet->info_dialog_xml = glade_xml_new (applet->glade_file, "info_dialog", NULL);
 	if (!applet->info_dialog_xml)
 		goto error;
 
 	applet->gconf_client = gconf_client_get_default ();
 	if (!applet->gconf_client)
 		goto error;
 
 	/* Load pixmaps and create applet widgets */
 	if (!setup_widgets (applet))
 		goto error;
 	nma_icons_init (applet);
 
 	if (!notify_is_initted ())
 		notify_init ("NetworkManager");
 
 	server_caps = notify_get_server_caps();
 	applet->notify_with_actions = FALSE;
 	for (iter = server_caps; iter; iter = g_list_next (iter)) {
 		if (!strcmp ((const char *) iter->data, NOTIFY_CAPS_ACTIONS_KEY))
 			applet->notify_with_actions = TRUE;
 	}
 
 	g_list_foreach (server_caps, (GFunc) g_free, NULL);
 	g_list_free (server_caps);
 
 	dbus_mgr = applet_dbus_manager_get ();
 	if (dbus_mgr == NULL) {
 		nm_warning ("Couldn't initialize the D-Bus manager.");
 		g_object_unref (applet);
 		return NULL;
 	}
 	g_signal_connect (G_OBJECT (dbus_mgr), "exit-now", G_CALLBACK (exit_cb), applet);
 
 	applet->dbus_settings = (NMDBusSettings *) nm_dbus_settings_system_new (applet_dbus_manager_get_connection (dbus_mgr));
 
-	applet->gconf_settings = nma_gconf_settings_new ();
+	applet->gconf_settings = nma_gconf_settings_new (applet_dbus_manager_get_connection (dbus_mgr));
 	g_signal_connect (applet->gconf_settings, "new-secrets-requested",
 	                  G_CALLBACK (applet_settings_new_secrets_requested_cb),
 	                  applet);
 
-	dbus_g_connection_register_g_object (applet_dbus_manager_get_connection (dbus_mgr),
-	                                     NM_DBUS_PATH_SETTINGS,
-	                                     G_OBJECT (applet->gconf_settings));
-
 	/* Start our DBus service */
 	if (!applet_dbus_manager_start_service (dbus_mgr)) {
 		g_object_unref (applet);
 		return NULL;
 	}
 
 	/* Initialize device classes */
 	applet->wired_class = applet_device_wired_get_class (applet);
 	g_assert (applet->wired_class);
 
 	applet->wifi_class = applet_device_wifi_get_class (applet);
 	g_assert (applet->wifi_class);
 
 	applet->gsm_class = applet_device_gsm_get_class (applet);
 	g_assert (applet->gsm_class);
 
 	applet->cdma_class = applet_device_cdma_get_class (applet);
 	g_assert (applet->cdma_class);
 
 	foo_client_setup (applet);
 
 	/* timeout to update connection timestamps every 5 minutes */
 	applet->update_timestamps_id = g_timeout_add_seconds (300,
 			(GSourceFunc) periodic_update_active_connection_timestamps, applet);
 
 	nm_gconf_set_pre_keyring_callback (applet_pre_keyring_callback, applet);
 
 	return G_OBJECT (applet);
 
diff --git a/src/connection-editor/nm-connection-list.c b/src/connection-editor/nm-connection-list.c
index cd3b252..cd4b375 100644
--- a/src/connection-editor/nm-connection-list.c
+++ b/src/connection-editor/nm-connection-list.c
@@ -1739,66 +1739,66 @@ NMConnectionList *
 nm_connection_list_new (GType def_type)
 {
 	NMConnectionList *list;
 	DBusGConnection *dbus_connection;
 	GError *error = NULL;
 
 	list = g_object_new (NM_TYPE_CONNECTION_LIST, NULL);
 	if (!list)
 		return NULL;
 
 	/* load GUI */
 	list->gui = glade_xml_new (GLADEDIR "/nm-connection-editor.glade", "NMConnectionList", NULL);
 	if (!list->gui) {
 		g_warning ("Could not load Glade file for connection list");
 		goto error;
 	}
 
 	gtk_window_set_default_icon_name ("preferences-system-network");
 
 	list->icon_theme = gtk_icon_theme_get_for_screen (gdk_screen_get_default ());
 
 	/* Load icons */
 	ICON_LOAD(list->wired_icon, "nm-device-wired");
 	ICON_LOAD(list->wireless_icon, "nm-device-wireless");
 	ICON_LOAD(list->wwan_icon, "nm-device-wwan");
 	ICON_LOAD(list->vpn_icon, "nm-vpn-standalone-lock");
 	ICON_LOAD(list->unknown_icon, "nm-no-connection");
 
 	list->client = gconf_client_get_default ();
 	if (!list->client)
 		goto error;
 
 	dbus_connection = dbus_g_bus_get (DBUS_BUS_SYSTEM, &error);
 	if (error) {
 		g_warning ("Could not connect to the system bus: %s", error->message);
 		g_error_free (error);
 		goto error;
 	}
 
 	list->system_settings = nm_dbus_settings_system_new (dbus_connection);
 	dbus_g_connection_unref (dbus_connection);
 	g_signal_connect (list->system_settings, "new-connection",
 				   G_CALLBACK (connection_added),
 				   list);
 
-	list->gconf_settings = nma_gconf_settings_new ();
+	list->gconf_settings = nma_gconf_settings_new (NULL);
 	g_signal_connect (list->gconf_settings, "new-connection",
 				   G_CALLBACK (connection_added),
 				   list);
 
 	add_connection_tabs (list, def_type);
 
 	list->editors = g_hash_table_new_full (g_direct_hash, g_direct_equal, g_object_unref, g_object_unref);
 
 	list->dialog = glade_xml_get_widget (list->gui, "NMConnectionList");
 	if (!list->dialog)
 		goto error;
 	g_signal_connect (G_OBJECT (list->dialog), "response", G_CALLBACK (dialog_response_cb), list);
 
 	if (!vpn_get_plugins (&error)) {
 		g_warning ("%s: failed to load VPN plugins: %s", __func__, error->message);
 		g_error_free (error);
 	}
 
 	return list;
 
diff --git a/src/gconf-helpers/nma-gconf-connection.c b/src/gconf-helpers/nma-gconf-connection.c
index c3c69d4..b7052e6 100644
--- a/src/gconf-helpers/nma-gconf-connection.c
+++ b/src/gconf-helpers/nma-gconf-connection.c
@@ -490,62 +490,49 @@ static GObject *
 constructor (GType type,
 		   guint n_construct_params,
 		   GObjectConstructParam *construct_params)
 {
 	GObject *object;
 	NMAGConfConnectionPrivate *priv;
 	NMConnection *connection;
-	DBusGConnection *bus;
 	GError *error = NULL;
 
 	object = G_OBJECT_CLASS (nma_gconf_connection_parent_class)->constructor (type, n_construct_params, construct_params);
 
 	if (!object)
 		return NULL;
 
 	priv = NMA_GCONF_CONNECTION_GET_PRIVATE (object);
 
 	if (!priv->client) {
 		nm_warning ("GConfClient not provided.");
 		goto err;
 	}
 
 	if (!priv->dir) {
 		nm_warning ("GConf directory not provided.");
 		goto err;
 	}
 
 	connection = nm_exported_connection_get_connection (NM_EXPORTED_CONNECTION (object));
 
 	utils_fill_connection_certs (connection);
 	if (!nm_connection_verify (connection, &error)) {
 		utils_clear_filled_connection_certs (connection);
 		g_warning ("Invalid connection: '%s' / '%s' invalid: %d",
 		           g_type_name (nm_connection_lookup_setting_type_by_quark (error->domain)),
 		           error->message, error->code);
 		g_error_free (error);
 		goto err;
 	}
 	utils_clear_filled_connection_certs (connection);
 
 	fill_vpn_user_name (connection);
 
-	bus = dbus_g_bus_get (DBUS_BUS_SYSTEM, &error);
-	if (!bus) {
-		nm_warning ("Could not get the system bus: %s", error->message);
-		g_error_free (error);
-		goto err;
-	}
-
-	nm_exported_connection_register_object (NM_EXPORTED_CONNECTION (object),
-	                                        NM_CONNECTION_SCOPE_USER,
-	                                        bus);
-	dbus_g_connection_unref (bus);
-
 	return object;
 
  err:
 	g_object_unref (object);
 
 	return NULL;
 }
 
diff --git a/src/gconf-helpers/nma-gconf-settings.c b/src/gconf-helpers/nma-gconf-settings.c
index 895cf59..75bd36d 100644
--- a/src/gconf-helpers/nma-gconf-settings.c
+++ b/src/gconf-helpers/nma-gconf-settings.c
@@ -1,29 +1,30 @@
 /* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
 /* NetworkManager Wireless Applet -- Display wireless access points and allow user control
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  *
  * (C) Copyright 2008 Novell, Inc.
  */
 
 #include <string.h>
 #include <stdio.h>
 #include "nma-gconf-settings.h"
 #include "gconf-helpers.h"
 #include "nma-marshal.h"
 #include "nm-utils.h"
+#include <NetworkManager.h>
 
 G_DEFINE_TYPE (NMAGConfSettings, nma_gconf_settings, NM_TYPE_SETTINGS)
 
@@ -32,10 +33,12 @@ G_DEFINE_TYPE (NMAGConfSettings, nma_gconf_settings, NM_TYPE_SETTINGS)
 typedef struct {
 	GConfClient *client;
 	guint conf_notify_id;
 	GSList *connections;
 	guint read_connections_id;
 	GHashTable *pending_changes;
 
+	DBusGConnection *bus;
+
 	gboolean disposed;
 } NMAGConfSettingsPrivate;
 
@@ -49,9 +52,22 @@ static guint signals[LAST_SIGNAL] = { 0 };
 
 
 NMAGConfSettings *
-nma_gconf_settings_new (void)
+nma_gconf_settings_new (DBusGConnection *bus)
 {
-	return (NMAGConfSettings *) g_object_new (NMA_TYPE_GCONF_SETTINGS, NULL);
+	NMAGConfSettings *self;
+	NMAGConfSettingsPrivate *priv;
+
+	self = (NMAGConfSettings *) g_object_new (NMA_TYPE_GCONF_SETTINGS, NULL);
+	if (!self)
+		return NULL;
+
+	priv = NMA_GCONF_SETTINGS_GET_PRIVATE (self);
+	if (bus) {
+		priv->bus = dbus_g_connection_ref (bus);
+		dbus_g_connection_register_g_object (bus, NM_DBUS_PATH_SETTINGS, G_OBJECT (self));
+	}
+
+	return self;
 }
 
 static void
@@ -90,17 +106,25 @@ static void
 add_connection_real (NMAGConfSettings *self, NMAGConfConnection *connection)
 {
 	NMAGConfSettingsPrivate *priv = NMA_GCONF_SETTINGS_GET_PRIVATE (self);
 
-	if (connection) {
-		priv->connections = g_slist_prepend (priv->connections, connection);
-		g_signal_connect (connection, "new-secrets-requested",
-					   G_CALLBACK (connection_new_secrets_requested_cb),
-					   self);
+	g_return_if_fail (connection != NULL);
+
+	priv->connections = g_slist_prepend (priv->connections, connection);
+	g_signal_connect (connection, "new-secrets-requested",
+				   G_CALLBACK (connection_new_secrets_requested_cb),
+				   self);
 
-		g_signal_connect (connection, "removed", G_CALLBACK (connection_removed), self);
-		nm_settings_signal_new_connection (NM_SETTINGS (self),
-									NM_EXPORTED_CONNECTION (connection));
+	g_signal_connect (connection, "removed", G_CALLBACK (connection_removed), self);
+
+	/* Export the connection over dbus if requested */
+	if (priv->bus) {
+		nm_exported_connection_register_object (NM_EXPORTED_CONNECTION (connection),
+		                                        NM_CONNECTION_SCOPE_USER,
+		                                        priv->bus);
+		dbus_g_connection_unref (priv->bus);
 	}
+
+	nm_settings_signal_new_connection (NM_SETTINGS (self), NM_EXPORTED_CONNECTION (connection));
 }
 
 NMAGConfConnection *
@@ -222,21 +246,24 @@ static void
 read_connections (NMAGConfSettings *settings)
 {
 	NMAGConfSettingsPrivate *priv = NMA_GCONF_SETTINGS_GET_PRIVATE (settings);
 	GSList *dir_list;
 	GSList *iter;
 
 	dir_list = nm_gconf_get_all_connections (priv->client);
 	if (!dir_list)
 		return;
 
 	for (iter = dir_list; iter; iter = iter->next) {
 		char *dir = (char *) iter->data;
+		NMAGConfConnection *connection;
 
-		add_connection_real (settings, nma_gconf_connection_new (priv->client, dir));
+		connection = nma_gconf_connection_new (priv->client, dir);
+		if (connection)
+			add_connection_real (settings, connection);
 		g_free (dir);
 	}
 
 	g_slist_free (dir_list);
 	priv->connections = g_slist_reverse (priv->connections);
 }
 
@@ -282,24 +309,25 @@ static gboolean
 connection_changes_done (gpointer data)
 {
 	ConnectionChangedInfo *info = (ConnectionChangedInfo *) data;
 	NMAGConfSettingsPrivate *priv = NMA_GCONF_SETTINGS_GET_PRIVATE (info->settings);
 	NMAGConfConnection *connection;
 
 	connection = nma_gconf_settings_get_by_path (info->settings, info->path);
 	if (!connection) {
 		/* New connection */
 		connection = nma_gconf_connection_new (priv->client, info->path);
-		add_connection_real (info->settings, connection);
+		if (connection)
+			add_connection_real (info->settings, connection);
 	} else {
 		if (gconf_client_dir_exists (priv->client, info->path, NULL)) {
 			/* Updated connection */
 			if (!nma_gconf_connection_changed (connection))
 				priv->connections = g_slist_remove (priv->connections, connection);
 		}
 	}
 
 	g_hash_table_remove (priv->pending_changes, info->path);
 
 	return FALSE;
 }
 
diff --git a/src/gconf-helpers/nma-gconf-settings.h b/src/gconf-helpers/nma-gconf-settings.h
index 38c4f70..ad69987 100644
--- a/src/gconf-helpers/nma-gconf-settings.h
+++ b/src/gconf-helpers/nma-gconf-settings.h
@@ -53,7 +53,7 @@ typedef struct {
 
 GType nma_gconf_settings_get_type (void);
 
-NMAGConfSettings *nma_gconf_settings_new (void);
+NMAGConfSettings *nma_gconf_settings_new (DBusGConnection *bus);
 
 NMAGConfConnection *nma_gconf_settings_add_connection (NMAGConfSettings *self,
 											NMConnection *connection);
