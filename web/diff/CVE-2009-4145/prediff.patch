   editor: prevent any registration of objects on the system bus
   
   D-Bus access-control is name-based; so requests for a specific name
   are allowed/denied based on the rules in /etc/dbus-1/system.d.  But
   apparently apps still get a non-named service on the bus, and if we
   register *any* object even though we don't have a named service,
   dbus and dbus-glib will happily proxy signals.  Since the connection
   editor shouldn't ever expose anything having to do with connections
   on any bus, make sure that's the case.

	applet->dbus_settings = (NMDBusSettings *) nm_dbus_settings_system_new (applet_dbus_manager_get_connection (dbus_mgr));

	applet->gconf_settings = nma_gconf_settings_new ();
	g_signal_connect (applet->gconf_settings, "new-secrets-requested",
	                  G_CALLBACK (applet_settings_new_secrets_requested_cb),
	                  applet);

	dbus_g_connection_register_g_object (applet_dbus_manager_get_connection (dbus_mgr),
	                                     NM_DBUS_PATH_SETTINGS,
	                                     G_OBJECT (applet->gconf_settings));

	/* Start our DBus service */
	if (!applet_dbus_manager_start_service (dbus_mgr)) {
		g_object_unref (applet);
				   G_CALLBACK (connection_added),
				   list);

	list->gconf_settings = nma_gconf_settings_new ();
	g_signal_connect (list->gconf_settings, "new-connection",
				   G_CALLBACK (connection_added),
				   list);
	GObject *object;
	NMAGConfConnectionPrivate *priv;
	NMConnection *connection;
	DBusGConnection *bus;
	GError *error = NULL;

	object = G_OBJECT_CLASS (nma_gconf_connection_parent_class)->constructor (type, n_construct_params, construct_params);

	fill_vpn_user_name (connection);

	bus = dbus_g_bus_get (DBUS_BUS_SYSTEM, &error);
	if (!bus) {
		nm_warning ("Could not get the system bus: %s", error->message);
		g_error_free (error);
		goto err;
	}

	nm_exported_connection_register_object (NM_EXPORTED_CONNECTION (object),
	                                        NM_CONNECTION_SCOPE_USER,
	                                        bus);
	dbus_g_connection_unref (bus);

	return object;

 err:
#include "gconf-helpers.h"
#include "nma-marshal.h"
#include "nm-utils.h"

G_DEFINE_TYPE (NMAGConfSettings, nma_gconf_settings, NM_TYPE_SETTINGS)

	guint read_connections_id;
	GHashTable *pending_changes;

	gboolean disposed;
} NMAGConfSettingsPrivate;



NMAGConfSettings *
nma_gconf_settings_new (void)
{
	return (NMAGConfSettings *) g_object_new (NMA_TYPE_GCONF_SETTINGS, NULL);
}

static void
{
	NMAGConfSettingsPrivate *priv = NMA_GCONF_SETTINGS_GET_PRIVATE (self);

	if (connection) {
		priv->connections = g_slist_prepend (priv->connections, connection);
		g_signal_connect (connection, "new-secrets-requested",
					   G_CALLBACK (connection_new_secrets_requested_cb),
					   self);

		g_signal_connect (connection, "removed", G_CALLBACK (connection_removed), self);
		nm_settings_signal_new_connection (NM_SETTINGS (self),
									NM_EXPORTED_CONNECTION (connection));
	}
}

NMAGConfConnection *

	for (iter = dir_list; iter; iter = iter->next) {
		char *dir = (char *) iter->data;

		add_connection_real (settings, nma_gconf_connection_new (priv->client, dir));
		g_free (dir);
	}

	if (!connection) {
		/* New connection */
		connection = nma_gconf_connection_new (priv->client, info->path);
		add_connection_real (info->settings, connection);
	} else {
		if (gconf_client_dir_exists (priv->client, info->path, NULL)) {
			/* Updated connection */

GType nma_gconf_settings_get_type (void);

NMAGConfSettings *nma_gconf_settings_new (void);

NMAGConfConnection *nma_gconf_settings_add_connection (NMAGConfSettings *self,
											NMConnection *connection);
