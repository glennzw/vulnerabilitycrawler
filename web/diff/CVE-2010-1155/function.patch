commit 85bbc05b21678e80423815d2ef1dfe26208491ab
Author: coekie <coekie@dbcabf3a-b0e7-0310-adc4-f8d773084564>
Date:   Mon Dec 28 12:15:18 2009 +0000

    Check if an SSL certificate matches the hostname of the server we are connecting to
    
    git-svn-id: http://svn.irssi.org/repos/irssi/trunk@5104 dbcabf3a-b0e7-0310-adc4-f8d773084564

diff --git a/src/core/network-openssl.c b/src/core/network-openssl.c
index 92832ba..5a9c9bc 100644
--- a/src/core/network-openssl.c
+++ b/src/core/network-openssl.c
@@ -1,44 +1,46 @@
 /*
  network-ssl.c : SSL support
 
     Copyright (C) 2002 vjt
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
 
     You should have received a copy of the GNU General Public License along
     with this program; if not, write to the Free Software Foundation, Inc.,
     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
 
 #include "module.h"
 #include "network.h"
 #include "misc.h"
 
 #ifdef HAVE_OPENSSL
 
 #include <openssl/crypto.h>
 #include <openssl/x509.h>
+#include <openssl/x509v3.h>
 #include <openssl/pem.h>
 #include <openssl/ssl.h>
 #include <openssl/err.h>
 
 /* ssl i/o channel object */
 typedef struct
 {
 	GIOChannel pad;
 	gint fd;
 	GIOChannel *giochan;
 	SSL *ssl;
 	SSL_CTX *ctx;
 	unsigned int verify:1;
+	const char *hostname;
 } GIOSSLChannel;
 
 static SSL_CTX *ssl_ctx = NULL;
@@ -53,43 +55,187 @@ static void irssi_ssl_free(GIOChannel *handle)
 	g_free(chan);
 }
 
-static gboolean irssi_ssl_verify(SSL *ssl, SSL_CTX *ctx, X509 *cert)
+/* Checks if the given string has internal NUL characters. */
+static gboolean has_internal_nul(const char* str, int len) {
+	/* Remove trailing nul characters. They would give false alarms */
+	while (len > 0 && str[len-1] == 0)
+		len--;
+	return strlen(str) != len;
+}
+
+/* tls_dns_name - Extract valid DNS name from subjectAltName value */
+static const char *tls_dns_name(const GENERAL_NAME * gn)
+{
+	const char *dnsname;
+
+	/* We expect the OpenSSL library to construct GEN_DNS extension objects as
+	   ASN1_IA5STRING values. Check we got the right union member. */
+	if (ASN1_STRING_type(gn->d.ia5) != V_ASN1_IA5STRING) {
+		g_warning("Invalid ASN1 value type in subjectAltName");
+		return NULL;
+	}
+
+	/* Safe to treat as an ASCII string possibly holding a DNS name */
+	dnsname = (char *) ASN1_STRING_data(gn->d.ia5);
+
+	if (has_internal_nul(dnsname, ASN1_STRING_length(gn->d.ia5))) {
+		g_warning("Internal NUL in subjectAltName");
+		return NULL;
+	}
+
+	return dnsname;
+}
+
+/* tls_text_name - extract certificate property value by name */
+static char *tls_text_name(X509_NAME *name, int nid)
+{
+	int     pos;
+	X509_NAME_ENTRY *entry;
+	ASN1_STRING *entry_str;
+	int     utf8_length;
+	unsigned char *utf8_value;
+	char *result;
+
+	if (name == 0 || (pos = X509_NAME_get_index_by_NID(name, nid, -1)) < 0) {
+		return NULL;
+    }
+
+    entry = X509_NAME_get_entry(name, pos);
+    g_return_val_if_fail(entry != NULL, NULL);
+    entry_str = X509_NAME_ENTRY_get_data(entry);
+    g_return_val_if_fail(entry_str != NULL, NULL);
+
+    /* Convert everything into UTF-8. It's up to OpenSSL to do something
+	   reasonable when converting ASCII formats that contain non-ASCII
+	   content. */
+    if ((utf8_length = ASN1_STRING_to_UTF8(&utf8_value, entry_str)) < 0) {
+    	g_warning("Error decoding ASN.1 type=%d", ASN1_STRING_type(entry_str));
+    	return NULL;
+    }
+
+    if (has_internal_nul((char *)utf8_value, utf8_length)) {
+    	g_warning("NUL character in hostname in certificate");
+    	OPENSSL_free(utf8_value);
+    	return NULL;
+    }
+
+    result = g_strdup((char *) utf8_value);
+	OPENSSL_free(utf8_value);
+	return result;
+}
+
+
+/** check if a hostname in the certificate matches the hostname we used for the connection */
+static gboolean match_hostname(const char *cert_hostname, const char *hostname)
+{
+	const char *hostname_left;
+
+	if (!strcasecmp(cert_hostname, hostname)) { /* exact match */
+		return TRUE;
+	} else if (cert_hostname[0] == '*' && cert_hostname[1] == '.' && cert_hostname[2] != 0) { /* wildcard match */
+		/* The initial '*' matches exactly one hostname component */
+		hostname_left = strchr(hostname, '.');
+		if (hostname_left != NULL && ! strcasecmp(hostname_left + 1, cert_hostname + 2)) {
+			return TRUE;
+		}
+	}
+	return FALSE;
+}
+
+/* based on verify_extract_name from tls_client.c in postfix */
+static gboolean irssi_ssl_verify_hostname(X509 *cert, const char *hostname)
+{
+	int gen_index, gen_count;
+	gboolean matched = FALSE, has_dns_name = FALSE;
+	const char *cert_dns_name;
+	char *cert_subject_cn;
+	const GENERAL_NAME *gn;
+	STACK_OF(GENERAL_NAME) * gens;
+
+	/* Verify the dNSName(s) in the peer certificate against the hostname. */
+	gens = X509_get_ext_d2i(cert, NID_subject_alt_name, 0, 0);
+	if (gens) {
+		gen_count = sk_GENERAL_NAME_num(gens);
+		for (gen_index = 0; gen_index < gen_count && !matched; ++gen_index) {
+			gn = sk_GENERAL_NAME_value(gens, gen_index);
+			if (gn->type != GEN_DNS)
+				continue;
+
+			/* Even if we have an invalid DNS name, we still ultimately
+			   ignore the CommonName, because subjectAltName:DNS is
+			   present (though malformed). */
+			has_dns_name = TRUE;
+			cert_dns_name = tls_dns_name(gn);
+			if (cert_dns_name && *cert_dns_name) {
+				matched = match_hostname(cert_dns_name, hostname);
+			}
+    	}
+
+	    /* Free stack *and* member GENERAL_NAME objects */
+	    sk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free);
+	}
+
+	if (has_dns_name) {
+		if (! matched) {
+			/* The CommonName in the issuer DN is obsolete when SubjectAltName is available. */
+			g_warning("None of the Subject Alt Names in the certificate match hostname '%s'", hostname);
+		}
+		return matched;
+	} else { /* No subjectAltNames, look at CommonName */
+		cert_subject_cn = tls_text_name(X509_get_subject_name(cert), NID_commonName);
+	    if (cert_subject_cn && *cert_subject_cn) {
+	    	matched = match_hostname(cert_subject_cn, hostname);
+	    	if (! matched) {
+				g_warning("SSL certificate common name '%s' doesn't match host name '%s'", cert_subject_cn, hostname);
+	    	}
+	    } else {
+	    	g_warning("No subjectAltNames and no valid common name in certificate");
+	    }
+	    free(cert_subject_cn);
+	}
+
+	return matched;
+}
+
+static gboolean irssi_ssl_verify(SSL *ssl, SSL_CTX *ctx, const char* hostname, X509 *cert)
 {
 	if (SSL_get_verify_result(ssl) != X509_V_OK) {
 		unsigned char md[EVP_MAX_MD_SIZE];
 		unsigned int n;
 		char *str;
 
 		g_warning("Could not verify SSL servers certificate:");
 		if ((str = X509_NAME_oneline(X509_get_subject_name(cert), 0, 0)) == NULL)
 			g_warning("  Could not get subject-name from peer certificate");
 		else {
 			g_warning("  Subject : %s", str);
 			free(str);
 		}
 		if ((str = X509_NAME_oneline(X509_get_issuer_name(cert), 0, 0)) == NULL)
 			g_warning("  Could not get issuer-name from peer certificate");
 		else {
 			g_warning("  Issuer  : %s", str);
 			free(str);
 		}
 		if (! X509_digest(cert, EVP_md5(), md, &n))
 			g_warning("  Could not get fingerprint from peer certificate");
 		else {
 			char hex[] = "0123456789ABCDEF";
 			char fp[EVP_MAX_MD_SIZE*3];
 			if (n < sizeof(fp)) {
 				unsigned int i;
 				for (i = 0; i < n; i++) {
 					fp[i*3+0] = hex[(md[i] >> 4) & 0xF];
 					fp[i*3+1] = hex[(md[i] >> 0) & 0xF];
 					fp[i*3+2] = i == n - 1 ? '\0' : ':';
 				}
 				g_warning("  MD5 Fingerprint : %s", fp);
 			}
 		}
 		return FALSE;
+	} else if (! irssi_ssl_verify_hostname(cert, hostname)){
+		return FALSE;
 	}
 	return TRUE;
 }
 
@@ -241,154 +387,155 @@ static gboolean irssi_ssl_init(void)
 
 }
 
-static GIOChannel *irssi_ssl_get_iochannel(GIOChannel *handle, const char *mycert, const char *mypkey, const char *cafile, const char *capath, gboolean verify)
+static GIOChannel *irssi_ssl_get_iochannel(GIOChannel *handle, const char *hostname, const char *mycert, const char *mypkey, const char *cafile, const char *capath, gboolean verify)
 {
 	GIOSSLChannel *chan;
 	GIOChannel *gchan;
 	int fd;
 	SSL *ssl;
 	SSL_CTX *ctx = NULL;
 
 	g_return_val_if_fail(handle != NULL, NULL);
 
 	if(!ssl_ctx && !irssi_ssl_init())
 		return NULL;
 
 	if(!(fd = g_io_channel_unix_get_fd(handle)))
 		return NULL;
 
 	if (mycert && *mycert) {
 		char *scert = NULL, *spkey = NULL;
 		if ((ctx = SSL_CTX_new(SSLv23_client_method())) == NULL) {
 			g_error("Could not allocate memory for SSL context");
 			return NULL;
 		}
 		scert = convert_home(mycert);
 		if (mypkey && *mypkey)
 			spkey = convert_home(mypkey);
 		if (! SSL_CTX_use_certificate_file(ctx, scert, SSL_FILETYPE_PEM))
 			g_warning("Loading of client certificate '%s' failed", mycert);
 		else if (! SSL_CTX_use_PrivateKey_file(ctx, spkey ? spkey : scert, SSL_FILETYPE_PEM))
 			g_warning("Loading of private key '%s' failed", mypkey ? mypkey : mycert);
 		else if (! SSL_CTX_check_private_key(ctx))
 			g_warning("Private key does not match the certificate");
 		g_free(scert);
 		g_free(spkey);
 	}
 
 	if ((cafile && *cafile) || (capath && *capath)) {
 		char *scafile = NULL;
 		char *scapath = NULL;
 		if (! ctx && (ctx = SSL_CTX_new(SSLv23_client_method())) == NULL) {
 			g_error("Could not allocate memory for SSL context");
 			return NULL;
 		}
 		if (cafile && *cafile)
 			scafile = convert_home(cafile);
 		if (capath && *capath)
 			scapath = convert_home(capath);
 		if (! SSL_CTX_load_verify_locations(ctx, scafile, scapath)) {
 			g_warning("Could not load CA list for verifying SSL server certificate");
 			g_free(scafile);
 			g_free(scapath);
 			SSL_CTX_free(ctx);
 			return NULL;
 		}
 		g_free(scafile);
 		g_free(scapath);
 		verify = TRUE;
 	}
 
 	if (ctx == NULL)
 		ctx = ssl_ctx;
 
 	if(!(ssl = SSL_new(ctx)))
 	{
 		g_warning("Failed to allocate SSL structure");
 		return NULL;
 	}
 
 	if(!SSL_set_fd(ssl, fd))
 	{
 		g_warning("Failed to associate socket to SSL stream");
 		SSL_free(ssl);
 		if (ctx != ssl_ctx)
 			SSL_CTX_free(ctx);
 		return NULL;
 	}
 
 	SSL_set_mode(ssl, SSL_MODE_ENABLE_PARTIAL_WRITE |
 			SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);
 
 	chan = g_new0(GIOSSLChannel, 1);
 	chan->fd = fd;
 	chan->giochan = handle;
 	chan->ssl = ssl;
 	chan->ctx = ctx;
 	chan->verify = verify;
+	chan->hostname = hostname;
 
 	gchan = (GIOChannel *)chan;
 	gchan->funcs = &irssi_ssl_channel_funcs;
 	g_io_channel_init(gchan);
 	gchan->is_readable = gchan->is_writeable = TRUE;
 	gchan->use_buffer = FALSE;
 
 	return gchan;
 }
 
-GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, IPADDR *my_ip, const char *cert, const char *pkey, const char *cafile, const char *capath, gboolean verify)
+GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, const char* hostname, IPADDR *my_ip, const char *cert, const char *pkey, const char *cafile, const char *capath, gboolean verify)
 {
 	GIOChannel *handle, *ssl_handle;
 
 	handle = net_connect_ip(ip, port, my_ip);
 	if (handle == NULL)
 		return NULL;
-	ssl_handle  = irssi_ssl_get_iochannel(handle, cert, pkey, cafile, capath, verify);
+	ssl_handle  = irssi_ssl_get_iochannel(handle, hostname, cert, pkey, cafile, capath, verify);
 	if (ssl_handle == NULL)
 		g_io_channel_unref(handle);
 	return ssl_handle;
 }
 
 int irssi_ssl_handshake(GIOChannel *handle)
 {
 	GIOSSLChannel *chan = (GIOSSLChannel *)handle;
 	int ret, err;
 	X509 *cert;
 	const char *errstr;
 
 	ret = SSL_connect(chan->ssl);
 	if (ret <= 0) {
 		err = SSL_get_error(chan->ssl, ret);
 		switch (err) {
 			case SSL_ERROR_WANT_READ:
 				return 1;
 			case SSL_ERROR_WANT_WRITE:
 				return 3;
 			case SSL_ERROR_ZERO_RETURN:
 				g_warning("SSL handshake failed: %s", "server closed connection");
 				return -1;
 			case SSL_ERROR_SYSCALL:
 				errstr = ERR_reason_error_string(ERR_get_error());
 				if (errstr == NULL && ret == -1)
 					errstr = strerror(errno);
 				g_warning("SSL handshake failed: %s", errstr != NULL ? errstr : "server closed connection unexpectedly");
 				return -1;
 			default:
 				errstr = ERR_reason_error_string(ERR_get_error());
 				g_warning("SSL handshake failed: %s", errstr != NULL ? errstr : "unknown SSL error");
 				return -1;
 		}
 	}
 
 	cert = SSL_get_peer_certificate(chan->ssl);
 	if (cert == NULL) {
 		g_warning("SSL server supplied no certificate");
 		return -1;
 	}
-	ret = !chan->verify || irssi_ssl_verify(chan->ssl, chan->ctx, cert);
+	ret = !chan->verify || irssi_ssl_verify(chan->ssl, chan->ctx, chan->hostname, cert);
 	X509_free(cert);
 	return ret ? 0 : -1;
 }
 
 #else /* HAVE_OPENSSL */
 
diff --git a/src/core/network.h b/src/core/network.h
index 65505ea..8583724 100644
--- a/src/core/network.h
+++ b/src/core/network.h
@@ -47,7 +47,7 @@ int net_ip_compare(IPADDR *ip1, IPADDR *ip2);
 /* Connect to socket */
 GIOChannel *net_connect(const char *addr, int port, IPADDR *my_ip);
 /* Connect to socket with ip address and SSL*/
-GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, IPADDR *my_ip, const char *cert, const char *pkey, const char *cafile, const char *capath, gboolean verify);
+GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, const char* hostname, IPADDR *my_ip, const char *cert, const char *pkey, const char *cafile, const char *capath, gboolean verify);
 int irssi_ssl_handshake(GIOChannel *handle);
 /* Connect to socket with ip address */
 GIOChannel *net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip);
diff --git a/src/core/servers.c b/src/core/servers.c
index d5844e7..017a203 100644
--- a/src/core/servers.c
+++ b/src/core/servers.c
@@ -203,28 +203,28 @@ static void server_connect_callback_init_ssl(SERVER_REC *server, GIOChannel *han
 static void server_real_connect(SERVER_REC *server, IPADDR *ip,
 				const char *unix_socket)
 {
 	GIOChannel *handle;
 	IPADDR *own_ip = NULL;
 	const char *errmsg;
 	char *errmsg2;
 	char ipaddr[MAX_IP_LEN];
         int port;
 
 	g_return_if_fail(ip != NULL || unix_socket != NULL);
 
 	signal_emit("server connecting", 2, server, ip);
 
 	if (server->connrec->no_connect)
 		return;
 
 	if (ip != NULL) {
 		own_ip = ip == NULL ? NULL :
 			(IPADDR_IS_V6(ip) ? server->connrec->own_ip6 :
 			 server->connrec->own_ip4);
 		port = server->connrec->proxy != NULL ?
 			server->connrec->proxy_port : server->connrec->port;
 		handle = server->connrec->use_ssl ?
-			net_connect_ip_ssl(ip, port, own_ip, server->connrec->ssl_cert, server->connrec->ssl_pkey,
+			net_connect_ip_ssl(ip, port, server->connrec->address, own_ip, server->connrec->ssl_cert, server->connrec->ssl_pkey,
 server->connrec->ssl_cafile, server->connrec->ssl_capath, server->connrec->ssl_verify) :
 			net_connect_ip(ip, port, own_ip);
 	} else {
