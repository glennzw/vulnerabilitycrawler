commit 9cc8d78ff33b7a36852b74e64b427489cad44d0e
Author: Simon Budig <simon@gimp.org>
Date:   Tue Nov 17 00:41:39 2009 +0100

    Harden the PSD plugin against integer overflows.
    
    Issues discovered by Stefan Cornelius, Secunia Research, advisory SA37232
    and CVE identifier CVE-2009-3909. Fixes bug #600741.

diff --git a/plug-ins/file-psd/psd-load.c b/plug-ins/file-psd/psd-load.c
index 63f8f01..eeafc360 100644
--- a/plug-ins/file-psd/psd-load.c
+++ b/plug-ins/file-psd/psd-load.c
@@ -233,115 +233,124 @@ static gint
 read_header_block (PSDimage  *img_a,
                    FILE      *f,
                    GError   **error)
 {
   guint16  version;
   gchar    sig[4];
   gchar    buf[6];
 
   if (fread (sig, 4, 1, f) < 1
       || fread (&version, 2, 1, f) < 1
       || fread (buf, 6, 1, f) < 1
       || fread (&img_a->channels, 2, 1, f) < 1
       || fread (&img_a->rows, 4, 1, f) < 1
       || fread (&img_a->columns, 4, 1, f) < 1
       || fread (&img_a->bps, 2, 1, f) < 1
       || fread (&img_a->color_mode, 2, 1, f) < 1)
     {
       psd_set_error (feof (f), errno, error);
       return -1;
     }
   version = GUINT16_FROM_BE (version);
   img_a->channels = GUINT16_FROM_BE (img_a->channels);
   img_a->rows = GUINT32_FROM_BE (img_a->rows);
   img_a->columns = GUINT32_FROM_BE (img_a->columns);
   img_a->bps = GUINT16_FROM_BE (img_a->bps);
   img_a->color_mode = GUINT16_FROM_BE (img_a->color_mode);
 
   IFDBG(1) g_debug ("\n\n\tSig: %.4s\n\tVer: %d\n\tChannels: "
                     "%d\n\tSize: %dx%d\n\tBPS: %d\n\tMode: %d\n",
                     sig, version, img_a->channels,
                     img_a->columns, img_a->rows,
                     img_a->bps, img_a->color_mode);
 
   if (memcmp (sig, "8BPS", 4) != 0)
     {
       g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                   _("Not a valid photoshop document file"));
       return -1;
     }
 
   if (version != 1)
     {
       g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                   _("Unsupported file format version: %d"), version);
       return -1;
     }
 
   if (img_a->channels > MAX_CHANNELS)
     {
       g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                   _("Too many channels in file: %d"), img_a->channels);
       return -1;
     }
 
     /* Photoshop CS (version 8) supports 300000 x 300000, but this
        is currently larger than GIMP_MAX_IMAGE_SIZE */
 
   if (img_a->rows < 1 || img_a->rows > GIMP_MAX_IMAGE_SIZE)
     {
       g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                   _("Unsupported or invalid image height: %d"),
                   img_a->rows);
       return -1;
     }
 
   if (img_a->columns < 1 || img_a->columns > GIMP_MAX_IMAGE_SIZE)
     {
       g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                   _("Unsupported or invalid image width: %d"),
                   img_a->columns);
       return -1;
     }
 
+  /* img_a->rows is sanitized above, so a division by zero is avoided here */
+  if (img_a->columns > G_MAXINT32 / img_a->rows)
+    {
+      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
+                   _("Unsupported or invalid image size: %dx%d"),
+                   img_a->columns, img_a->rows);
+      return -1;
+    }
+
   if (img_a->color_mode != PSD_BITMAP
       && img_a->color_mode != PSD_GRAYSCALE
       && img_a->color_mode != PSD_INDEXED
       && img_a->color_mode != PSD_RGB
       && img_a->color_mode != PSD_DUOTONE)
     {
       g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                    _("Unsupported color mode: %s"),
                    get_psd_color_mode_name (img_a->color_mode));
       return -1;
     }
 
   /* Warnings for format conversions */
   switch (img_a->bps)
     {
       case 16:
         IFDBG(3) g_debug ("16 Bit Data");
         if (CONVERSION_WARNINGS)
           g_message (_("Warning:\n"
                        "The image you are loading has 16 bits per channel. GIMP "
                        "can only handle 8 bit, so it will be converted for you. "
                        "Information will be lost because of this conversion."));
         break;
 
       case 8:
         IFDBG(3) g_debug ("8 Bit Data");
         break;
 
       case 1:
         IFDBG(3) g_debug ("1 Bit Data");
         break;
 
       default:
         g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                     _("Unsupported bit depth: %d"), img_a->bps);
         return -1;
         break;
     }
 
   return 0;
 }
 
@@ -457,371 +466,411 @@ static PSDlayer **
 read_layer_block (PSDimage  *img_a,
                   FILE      *f,
                   GError   **error)
 {
   PSDlayer **lyr_a;
   guint32    block_len;
   guint32    block_end;
   guint32    block_rem;
   gint32     read_len;
   gint32     write_len;
   gint       lidx;                  /* Layer index */
   gint       cidx;                  /* Channel index */
 
   if (fread (&block_len, 4, 1, f) < 1)
     {
       psd_set_error (feof (f), errno, error);
       img_a->num_layers = -1;
       return NULL;
     }
   img_a->mask_layer_len = GUINT32_FROM_BE (block_len);
 
   IFDBG(1) g_debug ("Layer and mask block size = %d", img_a->mask_layer_len);
 
   img_a->transparency = FALSE;
   img_a->layer_data_len = 0;
 
   if (!img_a->mask_layer_len)
     {
       img_a->num_layers = 0;
       return NULL;
     }
   else
     {
       img_a->mask_layer_start = ftell (f);
       block_end = img_a->mask_layer_start + img_a->mask_layer_len;
 
       /* Get number of layers */
       if (fread (&block_len, 4, 1, f) < 1
           || fread (&img_a->num_layers, 2, 1, f) < 1)
         {
           psd_set_error (feof (f), errno, error);
           img_a->num_layers = -1;
           return NULL;
         }
       img_a->num_layers = GINT16_FROM_BE (img_a->num_layers);
       IFDBG(2) g_debug ("Number of layers: %d", img_a->num_layers);
 
       if (img_a->num_layers < 0)
         {
           img_a->transparency = TRUE;
           img_a->num_layers = -img_a->num_layers;
         }
 
       if (img_a->num_layers)
         {
           /* Read layer records */
           PSDlayerres           res_a;
 
           /* Create pointer array for the layer records */
           lyr_a = g_new (PSDlayer *, img_a->num_layers);
           for (lidx = 0; lidx < img_a->num_layers; ++lidx)
             {
               /* Allocate layer record */
               lyr_a[lidx] = (PSDlayer *) g_malloc (sizeof (PSDlayer) );
 
               /* Initialise record */
               lyr_a[lidx]->drop = FALSE;
               lyr_a[lidx]->id = 0;
 
               if (fread (&lyr_a[lidx]->top, 4, 1, f) < 1
                   || fread (&lyr_a[lidx]->left, 4, 1, f) < 1
                   || fread (&lyr_a[lidx]->bottom, 4, 1, f) < 1
                   || fread (&lyr_a[lidx]->right, 4, 1, f) < 1
                   || fread (&lyr_a[lidx]->num_channels, 2, 1, f) < 1)
                 {
                   psd_set_error (feof (f), errno, error);
                   return NULL;
                 }
               lyr_a[lidx]->top = GINT32_FROM_BE (lyr_a[lidx]->top);
               lyr_a[lidx]->left = GINT32_FROM_BE (lyr_a[lidx]->left);
               lyr_a[lidx]->bottom = GINT32_FROM_BE (lyr_a[lidx]->bottom);
               lyr_a[lidx]->right = GINT32_FROM_BE (lyr_a[lidx]->right);
               lyr_a[lidx]->num_channels = GUINT16_FROM_BE (lyr_a[lidx]->num_channels);
 
               if (lyr_a[lidx]->num_channels > MAX_CHANNELS)
                 {
                   g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                               _("Too many channels in layer: %d"),
                               lyr_a[lidx]->num_channels);
                   return NULL;
                 }
-              if (lyr_a[lidx]->bottom - lyr_a[lidx]->top > GIMP_MAX_IMAGE_SIZE)
+              if (lyr_a[lidx]->bottom < lyr_a[lidx]->top ||
+                  lyr_a[lidx]->bottom - lyr_a[lidx]->top > GIMP_MAX_IMAGE_SIZE)
                 {
                   g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                               _("Unsupported or invalid layer height: %d"),
                               lyr_a[lidx]->bottom - lyr_a[lidx]->top);
                   return NULL;
                 }
-              if (lyr_a[lidx]->right - lyr_a[lidx]->left > GIMP_MAX_IMAGE_SIZE)
+              if (lyr_a[lidx]->right < lyr_a[lidx]->left ||
+                  lyr_a[lidx]->right - lyr_a[lidx]->left > GIMP_MAX_IMAGE_SIZE)
                 {
                   g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                               _("Unsupported or invalid layer width: %d"),
                               lyr_a[lidx]->right - lyr_a[lidx]->left);
                   return NULL;
                 }
 
+              if ((lyr_a[lidx]->right - lyr_a[lidx]->left) >
+                  G_MAXINT32 / MAX (lyr_a[lidx]->bottom - lyr_a[lidx]->top, 1))
+                {
+                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
+                               _("Unsupported or invalid layer size: %dx%d"),
+                               lyr_a[lidx]->right - lyr_a[lidx]->left,
+                               lyr_a[lidx]->bottom - lyr_a[lidx]->top);
+                  return NULL;
+                }
+
               IFDBG(2) g_debug ("Layer %d, Coords %d %d %d %d, channels %d, ",
                                  lidx, lyr_a[lidx]->left, lyr_a[lidx]->top,
                                  lyr_a[lidx]->right, lyr_a[lidx]->bottom,
                                  lyr_a[lidx]->num_channels);
 
               lyr_a[lidx]->chn_info = g_new (ChannelLengthInfo, lyr_a[lidx]->num_channels);
               for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)
                 {
                   if (fread (&lyr_a[lidx]->chn_info[cidx].channel_id, 2, 1, f) < 1
                       || fread (&lyr_a[lidx]->chn_info[cidx].data_len, 4, 1, f) < 1)
                     {
                       psd_set_error (feof (f), errno, error);
                       return NULL;
                     }
                   lyr_a[lidx]->chn_info[cidx].channel_id =
                     GINT16_FROM_BE (lyr_a[lidx]->chn_info[cidx].channel_id);
                   lyr_a[lidx]->chn_info[cidx].data_len =
                     GUINT32_FROM_BE (lyr_a[lidx]->chn_info[cidx].data_len);
                   img_a->layer_data_len += lyr_a[lidx]->chn_info[cidx].data_len;
                   IFDBG(3) g_debug ("Channel ID %d, data len %d",
                                      lyr_a[lidx]->chn_info[cidx].channel_id,
                                      lyr_a[lidx]->chn_info[cidx].data_len);
                 }
 
               if (fread (lyr_a[lidx]->mode_key, 4, 1, f) < 1
                   || fread (lyr_a[lidx]->blend_mode, 4, 1, f) < 1
                   || fread (&lyr_a[lidx]->opacity, 1, 1, f) < 1
                   || fread (&lyr_a[lidx]->clipping, 1, 1, f) < 1
                   || fread (&lyr_a[lidx]->flags, 1, 1, f) < 1
                   || fread (&lyr_a[lidx]->filler, 1, 1, f) < 1
                   || fread (&lyr_a[lidx]->extra_len, 4, 1, f) < 1)
                 {
                   psd_set_error (feof (f), errno, error);
                   return NULL;
                 }
               if (memcmp (lyr_a[lidx]->mode_key, "8BIM", 4) != 0)
                 {
                   IFDBG(1) g_debug ("Incorrect layer mode signature %.4s",
                                     lyr_a[lidx]->mode_key);
                   g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                               _("The file is corrupt!"));
                   return NULL;
                 }
 
               lyr_a[lidx]->layer_flags.trans_prot = lyr_a[lidx]->flags & 1 ? TRUE : FALSE;
               lyr_a[lidx]->layer_flags.visible = lyr_a[lidx]->flags & 2 ? FALSE : TRUE;
               if (lyr_a[lidx]->flags & 8)
                 lyr_a[lidx]->layer_flags.irrelevant = lyr_a[lidx]->flags & 16 ? TRUE : FALSE;
               else
                 lyr_a[lidx]->layer_flags.irrelevant = FALSE;
 
               lyr_a[lidx]->extra_len = GUINT32_FROM_BE (lyr_a[lidx]->extra_len);
               block_rem = lyr_a[lidx]->extra_len;
               IFDBG(2) g_debug ("\n\tLayer mode sig: %.4s\n\tBlend mode: %.4s\n\t"
                                 "Opacity: %d\n\tClipping: %d\n\tExtra data len: %d\n\t"
                                 "Alpha lock: %d\n\tVisible: %d\n\tIrrelevant: %d",
                                     lyr_a[lidx]->mode_key,
                                     lyr_a[lidx]->blend_mode,
                                     lyr_a[lidx]->opacity,
                                     lyr_a[lidx]->clipping,
                                     lyr_a[lidx]->extra_len,
                                     lyr_a[lidx]->layer_flags.trans_prot,
                                     lyr_a[lidx]->layer_flags.visible,
                                     lyr_a[lidx]->layer_flags.irrelevant);
               IFDBG(3) g_debug ("Remaining length %d", block_rem);
 
               /* Layer mask data */
               if (fread (&block_len, 4, 1, f) < 1)
                 {
                   psd_set_error (feof (f), errno, error);
                   return NULL;
                 }
               block_len = GUINT32_FROM_BE (block_len);
               block_rem -= (block_len + 4);
               IFDBG(3) g_debug ("Remaining length %d", block_rem);
 
               lyr_a[lidx]->layer_mask_extra.top = 0;
               lyr_a[lidx]->layer_mask_extra.left = 0;
               lyr_a[lidx]->layer_mask_extra.bottom = 0;
               lyr_a[lidx]->layer_mask_extra.right = 0;
               lyr_a[lidx]->layer_mask.top = 0;
               lyr_a[lidx]->layer_mask.left = 0;
               lyr_a[lidx]->layer_mask.bottom = 0;
               lyr_a[lidx]->layer_mask.right = 0;
               lyr_a[lidx]->layer_mask.def_color = 0;
               lyr_a[lidx]->layer_mask.extra_def_color = 0;
               lyr_a[lidx]->layer_mask.mask_flags.relative_pos = FALSE;
               lyr_a[lidx]->layer_mask.mask_flags.disabled = FALSE;
               lyr_a[lidx]->layer_mask.mask_flags.invert = FALSE;
 
               switch (block_len)
                 {
                   case 0:
                     break;
 
                   case 20:
                     if (fread (&lyr_a[lidx]->layer_mask.top, 4, 1, f) < 1
                         || fread (&lyr_a[lidx]->layer_mask.left, 4, 1, f) < 1
                         || fread (&lyr_a[lidx]->layer_mask.bottom, 4, 1, f) < 1
                         || fread (&lyr_a[lidx]->layer_mask.right, 4, 1, f) < 1
                         || fread (&lyr_a[lidx]->layer_mask.def_color, 1, 1, f) < 1
                         || fread (&lyr_a[lidx]->layer_mask.flags, 1, 1, f) < 1
                         || fread (&lyr_a[lidx]->layer_mask.extra_def_color, 1, 1, f) < 1
                         || fread (&lyr_a[lidx]->layer_mask.extra_flags, 1, 1, f) < 1)
                       {
                         psd_set_error (feof (f), errno, error);
                         return NULL;
                       }
                     lyr_a[lidx]->layer_mask.top =
                       GINT32_FROM_BE (lyr_a[lidx]->layer_mask.top);
                     lyr_a[lidx]->layer_mask.left =
                       GINT32_FROM_BE (lyr_a[lidx]->layer_mask.left);
                     lyr_a[lidx]->layer_mask.bottom =
                       GINT32_FROM_BE (lyr_a[lidx]->layer_mask.bottom);
                     lyr_a[lidx]->layer_mask.right =
                       GINT32_FROM_BE (lyr_a[lidx]->layer_mask.right);
                     lyr_a[lidx]->layer_mask.mask_flags.relative_pos =
                       lyr_a[lidx]->layer_mask.flags & 1 ? TRUE : FALSE;
                     lyr_a[lidx]->layer_mask.mask_flags.disabled =
                       lyr_a[lidx]->layer_mask.flags & 2 ? TRUE : FALSE;
                     lyr_a[lidx]->layer_mask.mask_flags.invert =
                       lyr_a[lidx]->layer_mask.flags & 4 ? TRUE : FALSE;
                     break;
                   case 36: /* If we have a 36 byte mask record assume second data set is correct */
                     if (fread (&lyr_a[lidx]->layer_mask_extra.top, 4, 1, f) < 1
                         || fread (&lyr_a[lidx]->layer_mask_extra.left, 4, 1, f) < 1
                         || fread (&lyr_a[lidx]->layer_mask_extra.bottom, 4, 1, f) < 1
                         || fread (&lyr_a[lidx]->layer_mask_extra.right, 4, 1, f) < 1
                         || fread (&lyr_a[lidx]->layer_mask.extra_def_color, 1, 1, f) < 1
                         || fread (&lyr_a[lidx]->layer_mask.extra_flags, 1, 1, f) < 1
                         || fread (&lyr_a[lidx]->layer_mask.def_color, 1, 1, f) < 1
                         || fread (&lyr_a[lidx]->layer_mask.flags, 1, 1, f) < 1
                         || fread (&lyr_a[lidx]->layer_mask.top, 4, 1, f) < 1
                         || fread (&lyr_a[lidx]->layer_mask.left, 4, 1, f) < 1
                         || fread (&lyr_a[lidx]->layer_mask.bottom, 4, 1, f) < 1
                         || fread (&lyr_a[lidx]->layer_mask.right, 4, 1, f) < 1)
                       {
                         psd_set_error (feof (f), errno, error);
                         return NULL;
                       }
                     lyr_a[lidx]->layer_mask_extra.top =
                       GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.top);
                     lyr_a[lidx]->layer_mask_extra.left =
                       GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.left);
                     lyr_a[lidx]->layer_mask_extra.bottom =
                       GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.bottom);
                     lyr_a[lidx]->layer_mask_extra.right =
                       GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.right);
                     lyr_a[lidx]->layer_mask.top =
                       GINT32_FROM_BE (lyr_a[lidx]->layer_mask.top);
                     lyr_a[lidx]->layer_mask.left =
                       GINT32_FROM_BE (lyr_a[lidx]->layer_mask.left);
                     lyr_a[lidx]->layer_mask.bottom =
                       GINT32_FROM_BE (lyr_a[lidx]->layer_mask.bottom);
                     lyr_a[lidx]->layer_mask.right =
                       GINT32_FROM_BE (lyr_a[lidx]->layer_mask.right);
                     lyr_a[lidx]->layer_mask.mask_flags.relative_pos =
                       lyr_a[lidx]->layer_mask.flags & 1 ? TRUE : FALSE;
                     lyr_a[lidx]->layer_mask.mask_flags.disabled =
                       lyr_a[lidx]->layer_mask.flags & 2 ? TRUE : FALSE;
                     lyr_a[lidx]->layer_mask.mask_flags.invert =
                       lyr_a[lidx]->layer_mask.flags & 4 ? TRUE : FALSE;
                     break;
 
                   default:
                     IFDBG(1) g_debug ("Unknown layer mask record size ... skipping");
                     if (fseek (f, block_len, SEEK_CUR) < 0)
                       {
                         psd_set_error (feof (f), errno, error);
                         return NULL;
                       }
                 }
 
+              /* sanity checks */
+              if (lyr_a[lidx]->layer_mask.bottom < lyr_a[lidx]->layer_mask.top ||
+                  lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top > GIMP_MAX_IMAGE_SIZE)
+                {
+                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
+                               _("Unsupported or invalid layer mask height: %d"),
+                               lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top);
+                  return NULL;
+                }
+              if (lyr_a[lidx]->layer_mask.right < lyr_a[lidx]->layer_mask.left ||
+                  lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left > GIMP_MAX_IMAGE_SIZE)
+                {
+                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
+                               _("Unsupported or invalid layer mask width: %d"),
+                               lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left);
+                  return NULL;
+                }
+
+              if ((lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left) >
+                  G_MAXINT32 / MAX (lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top, 1))
+                {
+                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
+                               _("Unsupported or invalid layer mask size: %dx%d"),
+                               lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left,
+                               lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top);
+                  return NULL;
+                }
+
               IFDBG(2) g_debug ("Layer mask coords %d %d %d %d, Rel pos %d",
                                 lyr_a[lidx]->layer_mask.left,
                                 lyr_a[lidx]->layer_mask.top,
                                 lyr_a[lidx]->layer_mask.right,
                                 lyr_a[lidx]->layer_mask.bottom,
                                 lyr_a[lidx]->layer_mask.mask_flags.relative_pos);
 
               IFDBG(3) g_debug ("Default mask color, %d, %d",
                                 lyr_a[lidx]->layer_mask.def_color,
                                 lyr_a[lidx]->layer_mask.extra_def_color);
 
               /* Layer blending ranges */           /* FIXME  */
               if (fread (&block_len, 4, 1, f) < 1)
                 {
                   psd_set_error (feof (f), errno, error);
                   return NULL;
                 }
               block_len = GUINT32_FROM_BE (block_len);
               block_rem -= (block_len + 4);
               IFDBG(3) g_debug ("Remaining length %d", block_rem);
               if (block_len > 0)
                 {
                   if (fseek (f, block_len, SEEK_CUR) < 0)
                     {
                       psd_set_error (feof (f), errno, error);
                       return NULL;
                     }
                 }
 
               lyr_a[lidx]->name = fread_pascal_string (&read_len, &write_len,
                                                        4, f, error);
               if (*error)
                 return NULL;
               block_rem -= read_len;
               IFDBG(3) g_debug ("Remaining length %d", block_rem);
 
               /* Adjustment layer info */           /* FIXME */
 
               while (block_rem > 7)
                 {
                   if (get_layer_resource_header (&res_a, f, error) < 0)
                     return NULL;
                   block_rem -= 12;
 
                   if (res_a.data_len > block_rem)
                     {
                       IFDBG(1) g_debug ("Unexpected end of layer resource data");
                       g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                                   _("The file is corrupt!"));
                       return NULL;
                     }
 
                   if (load_layer_resource (&res_a, lyr_a[lidx], f, error) < 0)
                     return NULL;
                   block_rem -= res_a.data_len;
                 }
               if (block_rem > 0)
                 {
                   if (fseek (f, block_rem, SEEK_CUR) < 0)
                     {
                       psd_set_error (feof (f), errno, error);
                       return NULL;
                     }
                 }
             }
 
           img_a->layer_data_start = ftell(f);
           if (fseek (f, img_a->layer_data_len, SEEK_CUR) < 0)
             {
               psd_set_error (feof (f), errno, error);
               return NULL;
             }
 
           IFDBG(1) g_debug ("Layer image data block size %d",
                              img_a->layer_data_len);
         }
       else
         lyr_a = NULL;
 
       /* Read global layer mask record */       /* FIXME */
 
       /* Skip to end of block */
       if (fseek (f, block_end, SEEK_SET) < 0)
         {
           psd_set_error (feof (f), errno, error);
           return NULL;
         }
     }
 
   return lyr_a;
 }
 
@@ -956,419 +1005,419 @@ static gint
 add_layers (const gint32  image_id,
             PSDimage     *img_a,
             PSDlayer    **lyr_a,
             FILE         *f,
             GError      **error)
 {
   PSDchannel          **lyr_chn;
   guchar               *pixels;
   guint16               alpha_chn;
   guint16               user_mask_chn;
   guint16               layer_channels;
   guint16               channel_idx[MAX_CHANNELS];
   guint16              *rle_pack_len;
   gint32                l_x;                   /* Layer x */
   gint32                l_y;                   /* Layer y */
   gint32                l_w;                   /* Layer width */
   gint32                l_h;                   /* Layer height */
   gint32                lm_x;                  /* Layer mask x */
   gint32                lm_y;                  /* Layer mask y */
   gint32                lm_w;                  /* Layer mask width */
   gint32                lm_h;                  /* Layer mask height */
   gint32                layer_size;
   gint32                layer_id = -1;
   gint32                mask_id = -1;
   gint                  lidx;                  /* Layer index */
   gint                  cidx;                  /* Channel index */
   gint                  rowi;                  /* Row index */
   gint                  coli;                  /* Column index */
   gint                  i;
   gboolean              alpha;
   gboolean              user_mask;
   gboolean              empty;
   gboolean              empty_mask;
   GimpDrawable         *drawable;
   GimpPixelRgn          pixel_rgn;
   GimpImageType         image_type;
   GimpLayerModeEffects  layer_mode;
 
 
   IFDBG(2) g_debug ("Number of layers: %d", img_a->num_layers);
 
   if (img_a->num_layers == 0)
     {
       IFDBG(2) g_debug ("No layers to process");
       return 0;
     }
 
   /* Layered image - Photoshop 3 style */
   if (fseek (f, img_a->layer_data_start, SEEK_SET) < 0)
     {
       psd_set_error (feof (f), errno, error);
       return -1;
     }
 
   for (lidx = 0; lidx < img_a->num_layers; ++lidx)
     {
       IFDBG(2) g_debug ("Process Layer No %d.", lidx);
 
       if (lyr_a[lidx]->drop)
         {
           IFDBG(2) g_debug ("Drop layer %d", lidx);
 
           /* Step past layer data */
           for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)
             {
               if (fseek (f, lyr_a[lidx]->chn_info[cidx].data_len, SEEK_CUR) < 0)
                 {
                   psd_set_error (feof (f), errno, error);
                   return -1;
                 }
             }
           g_free (lyr_a[lidx]->chn_info);
           g_free (lyr_a[lidx]->name);
         }
 
       else
         {
           /* Empty layer */
           if (lyr_a[lidx]->bottom - lyr_a[lidx]->top == 0
               || lyr_a[lidx]->right - lyr_a[lidx]->left == 0)
               empty = TRUE;
           else
               empty = FALSE;
 
           /* Empty mask */
           if (lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top == 0
               || lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left == 0)
               empty_mask = TRUE;
           else
               empty_mask = FALSE;
 
           IFDBG(3) g_debug ("Empty mask %d, size %d %d", empty_mask,
                             lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top,
                             lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left);
 
           /* Load layer channel data */
           IFDBG(2) g_debug ("Number of channels: %d", lyr_a[lidx]->num_channels);
           /* Create pointer array for the channel records */
           lyr_chn = g_new (PSDchannel *, lyr_a[lidx]->num_channels);
           for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)
             {
               guint16 comp_mode = PSD_COMP_RAW;
 
               /* Allocate channel record */
               lyr_chn[cidx] = g_malloc (sizeof (PSDchannel) );
 
               lyr_chn[cidx]->id = lyr_a[lidx]->chn_info[cidx].channel_id;
               lyr_chn[cidx]->rows = lyr_a[lidx]->bottom - lyr_a[lidx]->top;
               lyr_chn[cidx]->columns = lyr_a[lidx]->right - lyr_a[lidx]->left;
 
               if (lyr_chn[cidx]->id == PSD_CHANNEL_MASK)
                 {
                   /* Works around a bug in panotools psd files where the layer mask
                      size is given as 0 but data exists. Set mask size to layer size.
                   */
                   if (empty_mask && lyr_a[lidx]->chn_info[cidx].data_len - 2 > 0)
                     {
                       empty_mask = FALSE;
                       if (lyr_a[lidx]->layer_mask.top == lyr_a[lidx]->layer_mask.bottom)
                         {
                           lyr_a[lidx]->layer_mask.top = lyr_a[lidx]->top;
                           lyr_a[lidx]->layer_mask.bottom = lyr_a[lidx]->bottom;
                         }
                       if (lyr_a[lidx]->layer_mask.right == lyr_a[lidx]->layer_mask.left)
                         {
                           lyr_a[lidx]->layer_mask.right = lyr_a[lidx]->right;
                           lyr_a[lidx]->layer_mask.left = lyr_a[lidx]->left;
                         }
                     }
                   lyr_chn[cidx]->rows = (lyr_a[lidx]->layer_mask.bottom -
                                         lyr_a[lidx]->layer_mask.top);
                   lyr_chn[cidx]->columns = (lyr_a[lidx]->layer_mask.right -
                                            lyr_a[lidx]->layer_mask.left);
                 }
 
               IFDBG(3) g_debug ("Channel id %d, %dx%d",
                                 lyr_chn[cidx]->id,
                                 lyr_chn[cidx]->columns,
                                 lyr_chn[cidx]->rows);
 
               /* Only read channel data if there is any channel
                * data. Note that the channel data can contain a
                * compression method but no actual data.
                */
               if (lyr_a[lidx]->chn_info[cidx].data_len >= COMP_MODE_SIZE)
                 {
                   if (fread (&comp_mode, COMP_MODE_SIZE, 1, f) < 1)
                     {
                       psd_set_error (feof (f), errno, error);
                       return -1;
                     }
                   comp_mode = GUINT16_FROM_BE (comp_mode);
                   IFDBG(3) g_debug ("Compression mode: %d", comp_mode);
                 }
               if (lyr_a[lidx]->chn_info[cidx].data_len > COMP_MODE_SIZE)
                 {
                   switch (comp_mode)
                     {
                       case PSD_COMP_RAW:        /* Planar raw data */
                         IFDBG(3) g_debug ("Raw data length: %d",
                                           lyr_a[lidx]->chn_info[cidx].data_len - 2);
                         if (read_channel_data (lyr_chn[cidx], img_a->bps,
                             PSD_COMP_RAW, NULL, f, error) < 1)
                           return -1;
                         break;
 
                       case PSD_COMP_RLE:        /* Packbits */
                         IFDBG(3) g_debug ("RLE channel length %d, RLE length data: %d, "
                                           "RLE data block: %d",
                                           lyr_a[lidx]->chn_info[cidx].data_len - 2,
                                           lyr_chn[cidx]->rows * 2,
                                           (lyr_a[lidx]->chn_info[cidx].data_len - 2 -
                                            lyr_chn[cidx]->rows * 2));
                         rle_pack_len = g_malloc (lyr_chn[cidx]->rows * 2);
                         for (rowi = 0; rowi < lyr_chn[cidx]->rows; ++rowi)
                           {
                             if (fread (&rle_pack_len[rowi], 2, 1, f) < 1)
                               {
                                 psd_set_error (feof (f), errno, error);
                                 return -1;
                               }
-                                rle_pack_len[rowi] = GUINT16_FROM_BE (rle_pack_len[rowi]);
+                            rle_pack_len[rowi] = GUINT16_FROM_BE (rle_pack_len[rowi]);
                           }
 
                         IFDBG(3) g_debug ("RLE decode - data");
                         if (read_channel_data (lyr_chn[cidx], img_a->bps,
                             PSD_COMP_RLE, rle_pack_len, f, error) < 1)
                           return -1;
 
                         g_free (rle_pack_len);
                         break;
 
                       case PSD_COMP_ZIP:                 /* ? */
                       case PSD_COMP_ZIP_PRED:
                       default:
                         g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                                     _("Unsupported compression mode: %d"), comp_mode);
                         return -1;
                         break;
                     }
                 }
             }
           g_free (lyr_a[lidx]->chn_info);
 
           /* Draw layer */
 
           alpha = FALSE;
           alpha_chn = -1;
           user_mask = FALSE;
           user_mask_chn = -1;
           layer_channels = 0;
           l_x = 0;
           l_y = 0;
           l_w = img_a->columns;
           l_h = img_a->rows;
 
           IFDBG(3) g_debug ("Re-hash channel indices");
           for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)
             {
               if (lyr_chn[cidx]->id == PSD_CHANNEL_MASK)
                 {
                   user_mask = TRUE;
                   user_mask_chn = cidx;
                 }
               else if (lyr_chn[cidx]->id == PSD_CHANNEL_ALPHA)
                 {
                   alpha = TRUE;
                   alpha_chn = cidx;
                 }
               else
                 {
                   channel_idx[layer_channels] = cidx;   /* Assumes in sane order */
                   layer_channels++;                     /* RGB, Lab, CMYK etc.   */
                 }
             }
           if (alpha)
             {
               channel_idx[layer_channels] = alpha_chn;
               layer_channels++;
             }
 
           if (empty)
             {
               IFDBG(2) g_debug ("Create blank layer");
               image_type = get_gimp_image_type (img_a->base_type, TRUE);
               layer_id = gimp_layer_new (image_id, lyr_a[lidx]->name,
                                          img_a->columns, img_a->rows,
                                          image_type, 0, GIMP_NORMAL_MODE);
               g_free (lyr_a[lidx]->name);
               gimp_image_add_layer (image_id, layer_id, -1);
               drawable = gimp_drawable_get (layer_id);
               gimp_drawable_fill (drawable->drawable_id, GIMP_TRANSPARENT_FILL);
               gimp_drawable_set_visible (drawable->drawable_id, lyr_a[lidx]->layer_flags.visible);
               if (lyr_a[lidx]->id)
                 gimp_drawable_set_tattoo (drawable->drawable_id, lyr_a[lidx]->id);
               if (lyr_a[lidx]->layer_flags.irrelevant)
                 gimp_drawable_set_visible (drawable->drawable_id, FALSE);
               gimp_drawable_flush (drawable);
               gimp_drawable_detach (drawable);
             }
           else
             {
               l_x = lyr_a[lidx]->left;
               l_y = lyr_a[lidx]->top;
               l_w = lyr_a[lidx]->right - lyr_a[lidx]->left;
               l_h = lyr_a[lidx]->bottom - lyr_a[lidx]->top;
 
               IFDBG(3) g_debug ("Draw layer");
               image_type = get_gimp_image_type (img_a->base_type, alpha);
               IFDBG(3) g_debug ("Layer type %d", image_type);
               layer_size = l_w * l_h;
               pixels = g_malloc (layer_size * layer_channels);
               for (cidx = 0; cidx < layer_channels; ++cidx)
                 {
                   IFDBG(3) g_debug ("Start channel %d", channel_idx[cidx]);
                   for (i = 0; i < layer_size; ++i)
                     pixels[(i * layer_channels) + cidx] = lyr_chn[channel_idx[cidx]]->data[i];
                   g_free (lyr_chn[channel_idx[cidx]]->data);
                 }
 
               layer_mode = psd_to_gimp_blend_mode (lyr_a[lidx]->blend_mode);
               layer_id = gimp_layer_new (image_id, lyr_a[lidx]->name, l_w, l_h,
                                          image_type, lyr_a[lidx]->opacity * 100 / 255,
                                          layer_mode);
               IFDBG(3) g_debug ("Layer tattoo: %d", layer_id);
               g_free (lyr_a[lidx]->name);
               gimp_image_add_layer (image_id, layer_id, -1);
               gimp_layer_set_offsets (layer_id, l_x, l_y);
               gimp_layer_set_lock_alpha  (layer_id, lyr_a[lidx]->layer_flags.trans_prot);
               drawable = gimp_drawable_get (layer_id);
               gimp_pixel_rgn_init (&pixel_rgn, drawable, 0, 0,
                                    drawable->width, drawable->height, TRUE, FALSE);
               gimp_pixel_rgn_set_rect (&pixel_rgn, pixels,
                                        0, 0, drawable->width, drawable->height);
               gimp_drawable_set_visible (drawable->drawable_id, lyr_a[lidx]->layer_flags.visible);
               if (lyr_a[lidx]->id)
                 gimp_drawable_set_tattoo (drawable->drawable_id, lyr_a[lidx]->id);
               gimp_drawable_flush (drawable);
               gimp_drawable_detach (drawable);
               g_free (pixels);
             }
 
           /* Layer mask */
           if (user_mask)
             {
               if (empty_mask)
                 {
                   IFDBG(3) g_debug ("Create empty mask");
                   if (lyr_a[lidx]->layer_mask.def_color == 255)
                     mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_WHITE_MASK);
                   else
                     mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_BLACK_MASK);
                   gimp_layer_add_mask (layer_id, mask_id);
                   gimp_layer_set_apply_mask (layer_id,
                     ! lyr_a[lidx]->layer_mask.mask_flags.disabled);
                 }
               else
                 {
                   /* Load layer mask data */
                   if (lyr_a[lidx]->layer_mask.mask_flags.relative_pos)
                     {
                       lm_x = lyr_a[lidx]->layer_mask.left;
                       lm_y = lyr_a[lidx]->layer_mask.top;
                       lm_w = lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left;
                       lm_h = lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top;
                     }
                   else
                     {
                       lm_x = lyr_a[lidx]->layer_mask.left - l_x;
                       lm_y = lyr_a[lidx]->layer_mask.top - l_y;
                       lm_w = lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left;
                       lm_h = lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top;
                     }
                   IFDBG(3) g_debug ("Mask channel index %d", user_mask_chn);
                   IFDBG(3) g_debug ("Relative pos %d",
                                     lyr_a[lidx]->layer_mask.mask_flags.relative_pos);
                   layer_size = lm_w * lm_h;
                   pixels = g_malloc (layer_size);
                   IFDBG(3) g_debug ("Allocate Pixels %d", layer_size);
                   /* Crop mask at layer boundry */
                   IFDBG(3) g_debug ("Original Mask %d %d %d %d", lm_x, lm_y, lm_w, lm_h);
                   if (lm_x < 0
                       || lm_y < 0
                       || lm_w + lm_x > l_w
                       || lm_h + lm_y > l_h)
                     {
                       if (CONVERSION_WARNINGS)
                         g_message ("Warning\n"
                                    "The layer mask is partly outside the "
                                    "layer boundary. The mask will be "
                                    "cropped which may result in data loss.");
                       i = 0;
                       for (rowi = 0; rowi < lm_h; ++rowi)
                         {
                           if (rowi + lm_y >= 0 && rowi + lm_y < l_h)
                             {
                               for (coli = 0; coli < lm_w; ++coli)
                                 {
                                   if (coli + lm_x >= 0 && coli + lm_x < l_w)
                                     {
                                       pixels[i] =
                                         lyr_chn[user_mask_chn]->data[(rowi * lm_w) + coli];
                                       i++;
                                     }
                                 }
                             }
                         }
                       if (lm_x < 0)
                         {
                           lm_w += lm_x;
                           lm_x = 0;
                         }
                       if (lm_y < 0)
                         {
                           lm_h += lm_y;
                           lm_y = 0;
                         }
                       if (lm_w + lm_x > l_w)
                         lm_w = l_w - lm_x;
                       if (lm_h + lm_y > l_h)
                         lm_h = l_h - lm_y;
                     }
                   else
                     memcpy (pixels, lyr_chn[user_mask_chn]->data, layer_size);
                   g_free (lyr_chn[user_mask_chn]->data);
                   /* Draw layer mask data */
                   IFDBG(3) g_debug ("Layer %d %d %d %d", l_x, l_y, l_w, l_h);
                   IFDBG(3) g_debug ("Mask %d %d %d %d", lm_x, lm_y, lm_w, lm_h);
 
                   if (lyr_a[lidx]->layer_mask.def_color == 255)
                     mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_WHITE_MASK);
                   else
                     mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_BLACK_MASK);
 
                   IFDBG(3) g_debug ("New layer mask %d", mask_id);
                   gimp_layer_add_mask (layer_id, mask_id);
                   drawable = gimp_drawable_get (mask_id);
                   gimp_pixel_rgn_init (&pixel_rgn, drawable, 0 , 0,
                                        drawable->width, drawable->height, TRUE, FALSE);
                   gimp_pixel_rgn_set_rect (&pixel_rgn, pixels, lm_x, lm_y, lm_w, lm_h);
                   gimp_drawable_flush (drawable);
                   gimp_drawable_detach (drawable);
                   gimp_layer_set_apply_mask (layer_id,
                     ! lyr_a[lidx]->layer_mask.mask_flags.disabled);
                   g_free (pixels);
                 }
             }
           for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)
             if (lyr_chn[cidx])
               g_free (lyr_chn[cidx]);
           g_free (lyr_chn);
         }
       g_free (lyr_a[lidx]);
     }
   g_free (lyr_a);
 
   return 0;
 }
 
@@ -1743,81 +1792,91 @@ static gint
 read_channel_data (PSDchannel     *channel,
                    const guint16   bps,
                    const guint16   compression,
                    const guint16  *rle_pack_len,
                    FILE           *f,
                    GError        **error)
 {
   gchar    *raw_data;
   gchar    *src;
   gchar    *dst;
   guint32   readline_len;
   gint      i;
 
   if (bps == 1)
     readline_len = ((channel->columns + 7) >> 3);
   else
     readline_len = (channel->columns * bps >> 3);
 
   IFDBG(3) g_debug ("raw data size %d x %d = %d", readline_len,
                     channel->rows, readline_len * channel->rows);
+
+  /* sanity check, int overflow check (avoid divisions by zero) */
+  if ((channel->rows == 0) || (channel->columns == 0) ||
+      (channel->rows > G_MAXINT32 / channel->columns / MAX (bps >> 3, 1)))
+    {
+      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
+                   _("Unsupported or invalid channel size"));
+      return -1;
+    }
+
   raw_data = g_malloc (readline_len * channel->rows);
   switch (compression)
     {
       case PSD_COMP_RAW:
         if (fread (raw_data, readline_len, channel->rows, f) < 1)
           {
             psd_set_error (feof (f), errno, error);
             return -1;
           }
         break;
 
       case PSD_COMP_RLE:
         for (i = 0; i < channel->rows; ++i)
           {
             src = g_malloc (rle_pack_len[i]);
             dst = g_malloc (readline_len);
 /*      FIXME check for over-run
             if (ftell (f) + rle_pack_len[i] > block_end)
               {
                 psd_set_error (TRUE, errno, error);
                 return -1;
               }
 */
             if (fread (src, rle_pack_len[i], 1, f) < 1)
               {
                 psd_set_error (feof (f), errno, error);
                 return -1;
               }
             /* FIXME check for errors returned from decode packbits */
             decode_packbits (src, dst, rle_pack_len[i], readline_len);
             g_free (src);
             memcpy (raw_data + i * readline_len, dst, readline_len);
             g_free (dst);
           }
         break;
     }
 
   /* Convert channel data to GIMP format */
   switch (bps)
     {
       case 16:
         channel->data = (gchar *) g_malloc (channel->rows * channel->columns);
         convert_16_bit (raw_data, channel->data, (channel->rows * channel->columns) << 1);
         break;
 
       case 8:
         channel->data = (gchar *) g_malloc (channel->rows * channel->columns);
         memcpy (channel->data, raw_data, (channel->rows * channel->columns));
         break;
 
       case 1:
         channel->data = (gchar *) g_malloc (channel->rows * channel->columns);
         convert_1_bit (raw_data, channel->data, channel->rows, channel->columns);
         break;
     }
 
   g_free (raw_data);
 
   return 1;
 }
 
