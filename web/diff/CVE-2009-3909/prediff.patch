   Harden the PSD plugin against integer overflows.
   
   Issues discovered by Stefan Cornelius, Secunia Research, advisory SA37232
   and CVE identifier CVE-2009-3909. Fixes bug #600741.
      return -1;
    }

  if (img_a->color_mode != PSD_BITMAP
      && img_a->color_mode != PSD_GRAYSCALE
      && img_a->color_mode != PSD_INDEXED
                              lyr_a[lidx]->num_channels);
                  return NULL;
                }
              if (lyr_a[lidx]->bottom - lyr_a[lidx]->top > GIMP_MAX_IMAGE_SIZE)
                {
                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                              _("Unsupported or invalid layer height: %d"),
                              lyr_a[lidx]->bottom - lyr_a[lidx]->top);
                  return NULL;
                }
              if (lyr_a[lidx]->right - lyr_a[lidx]->left > GIMP_MAX_IMAGE_SIZE)
                {
                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                              _("Unsupported or invalid layer width: %d"),
                  return NULL;
                }

              IFDBG(2) g_debug ("Layer %d, Coords %d %d %d %d, channels %d, ",
                                 lidx, lyr_a[lidx]->left, lyr_a[lidx]->top,
                                 lyr_a[lidx]->right, lyr_a[lidx]->bottom,
                      }
                }

              IFDBG(2) g_debug ("Layer mask coords %d %d %d %d, Rel pos %d",
                                lyr_a[lidx]->layer_mask.left,
                                lyr_a[lidx]->layer_mask.top,
                                psd_set_error (feof (f), errno, error);
                                return -1;
                              }
                                rle_pack_len[rowi] = GUINT16_FROM_BE (rle_pack_len[rowi]);
                          }

                        IFDBG(3) g_debug ("RLE decode - data");

  IFDBG(3) g_debug ("raw data size %d x %d = %d", readline_len,
                    channel->rows, readline_len * channel->rows);
  raw_data = g_malloc (readline_len * channel->rows);
  switch (compression)
    {
