commit 822191a2fa1584a29c3224ab328507adcaeac1ab
Author: Andrey Mirkin <amirkin@openvz.org>
Date:   Wed Dec 6 20:31:35 2006 -0800

    [PATCH] skip data conversion in compat_sys_mount when data_page is NULL
    
    OpenVZ Linux kernel team has found a problem with mounting in compat mode.
    
    Simple command "mount -t smbfs ..." on Fedora Core 5 distro in 32-bit mode
    leads to oops:
    
      Unable to handle kernel NULL pointer dereference at 0000000000000000 RIP: compat_sys_mount+0xd6/0x290
      Process mount (pid: 14656, veid=300, threadinfo ffff810034d30000, task ffff810034c86bc0)
      Call Trace: ia32_sysret+0x0/0xa
    
    The problem is that data_page pointer can be NULL, so we should skip data
    conversion in this case.
    
    Signed-off-by: Andrey Mirkin <amirkin@openvz.org>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/compat.c b/fs/compat.c
index 06dad66..7aef541 100644
--- a/fs/compat.c
+++ b/fs/compat.c
@@ -845,61 +845,61 @@ static int do_nfs4_super_data_conv(void *raw_data)
 asmlinkage long compat_sys_mount(char __user * dev_name, char __user * dir_name,
 				 char __user * type, unsigned long flags,
 				 void __user * data)
 {
 	unsigned long type_page;
 	unsigned long data_page;
 	unsigned long dev_page;
 	char *dir_page;
 	int retval;
 
 	retval = copy_mount_options (type, &type_page);
 	if (retval < 0)
 		goto out;
 
 	dir_page = getname(dir_name);
 	retval = PTR_ERR(dir_page);
 	if (IS_ERR(dir_page))
 		goto out1;
 
 	retval = copy_mount_options (dev_name, &dev_page);
 	if (retval < 0)
 		goto out2;
 
 	retval = copy_mount_options (data, &data_page);
 	if (retval < 0)
 		goto out3;
 
 	retval = -EINVAL;
 
-	if (type_page) {
+	if (type_page && data_page) {
 		if (!strcmp((char *)type_page, SMBFS_NAME)) {
 			do_smb_super_data_conv((void *)data_page);
 		} else if (!strcmp((char *)type_page, NCPFS_NAME)) {
 			do_ncp_super_data_conv((void *)data_page);
 		} else if (!strcmp((char *)type_page, NFS4_NAME)) {
 			if (do_nfs4_super_data_conv((void *) data_page))
 				goto out4;
 		}
 	}
 
 	lock_kernel();
 	retval = do_mount((char*)dev_page, dir_page, (char*)type_page,
 			flags, (void*)data_page);
 	unlock_kernel();
 
  out4:
 	free_page(data_page);
  out3:
 	free_page(dev_page);
  out2:
 	putname(dir_page);
  out1:
 	free_page(type_page);
  out:
 	return retval;
 }
 
 #define NAME_OFFSET(de) ((int) ((de)->d_name - (char __user *) (de)))
 #define COMPAT_ROUND_UP(x) (((x)+sizeof(compat_long_t)-1) & \
 				~(sizeof(compat_long_t)-1))
 
