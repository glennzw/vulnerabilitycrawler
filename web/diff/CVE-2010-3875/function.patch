commit fe10ae53384e48c51996941b7720ee16995cbcb7
Author: Vasiliy Kulikov <segooon@gmail.com>
Date:   Wed Nov 10 10:14:33 2010 -0800

    net: ax25: fix information leak to userland
    
    Sometimes ax25_getname() doesn't initialize all members of fsa_digipeater
    field of fsa struct, also the struct has padding bytes between
    sax25_call and sax25_ndigis fields.  This structure is then copied to
    userland.  It leads to leaking of contents of kernel stack memory.
    
    Signed-off-by: Vasiliy Kulikov <segooon@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/ax25/af_ax25.c b/net/ax25/af_ax25.c
index 26eaebf..bb86d29 100644
--- a/net/ax25/af_ax25.c
+++ b/net/ax25/af_ax25.c
@@ -1386,42 +1386,42 @@ out:
 static int ax25_getname(struct socket *sock, struct sockaddr *uaddr,
 	int *uaddr_len, int peer)
 {
 	struct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)uaddr;
 	struct sock *sk = sock->sk;
 	unsigned char ndigi, i;
 	ax25_cb *ax25;
 	int err = 0;
 
+	memset(fsa, 0, sizeof(fsa));
 	lock_sock(sk);
 	ax25 = ax25_sk(sk);
 
 	if (peer != 0) {
 		if (sk->sk_state != TCP_ESTABLISHED) {
 			err = -ENOTCONN;
 			goto out;
 		}
 
 		fsa->fsa_ax25.sax25_family = AF_AX25;
 		fsa->fsa_ax25.sax25_call   = ax25->dest_addr;
-		fsa->fsa_ax25.sax25_ndigis = 0;
 
 		if (ax25->digipeat != NULL) {
 			ndigi = ax25->digipeat->ndigi;
 			fsa->fsa_ax25.sax25_ndigis = ndigi;
 			for (i = 0; i < ndigi; i++)
 				fsa->fsa_digipeater[i] =
 						ax25->digipeat->calls[i];
 		}
 	} else {
 		fsa->fsa_ax25.sax25_family = AF_AX25;
 		fsa->fsa_ax25.sax25_call   = ax25->source_addr;
 		fsa->fsa_ax25.sax25_ndigis = 1;
 		if (ax25->ax25_dev != NULL) {
 			memcpy(&fsa->fsa_digipeater[0],
 			       ax25->ax25_dev->dev->dev_addr, AX25_ADDR_LEN);
 		} else {
 			fsa->fsa_digipeater[0] = null_ax25_address;
 		}
 	}
 	*uaddr_len = sizeof (struct full_sockaddr_ax25);
 
