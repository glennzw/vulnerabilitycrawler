commit 7873ca4e4401f0ecd8868bf1543113467e6bae61
Author: Krishna Gudipati <kgudipat@brocade.com>
Date:   Fri May 21 14:39:45 2010 -0700

    [SCSI] bfa: fix system crash when reading sysfs fc_host statistics
    
    The port data structure related to fc_host statistics collection is
    not initialized. This causes system crash when reading the fc_host
    statistics. The fix is to initialize port structure during driver
    attach.
    
    Signed-off-by: Krishna Gudipati <kgudipat@brocade.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/bfa/bfa_core.c b/drivers/scsi/bfa/bfa_core.c
index 0c08e18..3a7b3f8 100644
--- a/drivers/scsi/bfa/bfa_core.c
+++ b/drivers/scsi/bfa/bfa_core.c
@@ -69,49 +69,70 @@ void
 bfa_cfg_get_meminfo(struct bfa_iocfc_cfg_s *cfg, struct bfa_meminfo_s *meminfo)
 {
 	int             i;
 	u32        km_len = 0, dm_len = 0;
 
 	bfa_assert((cfg != NULL) && (meminfo != NULL));
 
 	bfa_os_memset((void *)meminfo, 0, sizeof(struct bfa_meminfo_s));
 	meminfo->meminfo[BFA_MEM_TYPE_KVA - 1].mem_type =
 		BFA_MEM_TYPE_KVA;
 	meminfo->meminfo[BFA_MEM_TYPE_DMA - 1].mem_type =
 		BFA_MEM_TYPE_DMA;
 
 	bfa_iocfc_meminfo(cfg, &km_len, &dm_len);
 
 	for (i = 0; hal_mods[i]; i++)
 		hal_mods[i]->meminfo(cfg, &km_len, &dm_len);
 
+	dm_len += bfa_port_meminfo();
 
 	meminfo->meminfo[BFA_MEM_TYPE_KVA - 1].mem_len = km_len;
 	meminfo->meminfo[BFA_MEM_TYPE_DMA - 1].mem_len = dm_len;
 }
 
+static void
+bfa_com_port_attach(struct bfa_s *bfa, struct bfa_meminfo_s *mi)
+{
+	struct bfa_port_s       *port = &bfa->modules.port;
+	uint32_t                dm_len;
+	uint8_t                 *dm_kva;
+	uint64_t                dm_pa;
+
+	dm_len = bfa_port_meminfo();
+	dm_kva = bfa_meminfo_dma_virt(mi);
+	dm_pa  = bfa_meminfo_dma_phys(mi);
+
+	memset(port, 0, sizeof(struct bfa_port_s));
+	bfa_port_attach(port, &bfa->ioc, bfa, bfa->trcmod, bfa->logm);
+	bfa_port_mem_claim(port, dm_kva, dm_pa);
+
+	bfa_meminfo_dma_virt(mi) = dm_kva + dm_len;
+	bfa_meminfo_dma_phys(mi) = dm_pa + dm_len;
+}
+
 /**
  * Use this function to do attach the driver instance with the BFA
  * library. This function will not trigger any HW initialization
  * process (which will be done in bfa_init() call)
  *
  * This call will fail, if the cap is out of range compared to
  * pre-defined values within the BFA library
  *
  * @param[out]	bfa	Pointer to bfa_t.
  * @param[in]	bfad 	Opaque handle back to the driver's IOC structure
  * @param[in]	cfg	Pointer to bfa_ioc_cfg_t. Should be same structure
  * 			that was used in bfa_cfg_get_meminfo().
  * @param[in] 	meminfo Pointer to bfa_meminfo_t. The driver should
  * 			use the bfa_cfg_get_meminfo() call to
  * 			find the memory blocks required, allocate the
  * 			required memory and provide the starting addresses.
  * @param[in] 	pcidev	pointer to struct bfa_pcidev_s
  *
  * @return
  * void
  *
  * Special Considerations:
  *
  * @note
  *
  */
@@ -119,39 +140,40 @@ void
 bfa_attach(struct bfa_s *bfa, void *bfad, struct bfa_iocfc_cfg_s *cfg,
 	       struct bfa_meminfo_s *meminfo, struct bfa_pcidev_s *pcidev)
 {
 	int             i;
 	struct bfa_mem_elem_s *melem;
 
 	bfa->fcs = BFA_FALSE;
 
 	bfa_assert((cfg != NULL) && (meminfo != NULL));
 
 	/**
 	 * initialize all memory pointers for iterative allocation
 	 */
 	for (i = 0; i < BFA_MEM_TYPE_MAX; i++) {
 		melem = meminfo->meminfo + i;
 		melem->kva_curp = melem->kva;
 		melem->dma_curp = melem->dma;
 	}
 
 	bfa_iocfc_attach(bfa, bfad, cfg, meminfo, pcidev);
 
 	for (i = 0; hal_mods[i]; i++)
 		hal_mods[i]->attach(bfa, bfad, cfg, meminfo, pcidev);
 
+	bfa_com_port_attach(bfa, meminfo);
 }
 
 /**
  * Use this function to delete a BFA IOC. IOC should be stopped (by
  * calling bfa_stop()) before this function call.
  *
  * @param[in] bfa - pointer to bfa_t.
  *
  * @return
  * void
  *
  * Special Considerations:
  *
  * @note
  */
