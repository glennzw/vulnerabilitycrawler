commit 586a944ddd4d03e66dea1093306147594748037a
Author: Aaron Patterson <aaron.patterson@gmail.com>
Date:   Tue Aug 16 15:17:49 2011 -0700

    Tags with invalid names should also be stripped in order to prevent
    XSS attacks.  Thanks Sascha Depold for the report.

diff --git a/actionpack/lib/action_controller/vendor/html-scanner/html/node.rb b/actionpack/lib/action_controller/vendor/html-scanner/html/node.rb
index 22b3243..4e1f016 100644
--- a/actionpack/lib/action_controller/vendor/html-scanner/html/node.rb
+++ b/actionpack/lib/action_controller/vendor/html-scanner/html/node.rb
@@ -3,529 +3,529 @@ require 'strscan'
 module HTML #:nodoc:
 
   class Conditions < Hash #:nodoc:
     def initialize(hash)
       super()
       hash = { :content => hash } unless Hash === hash
       hash = keys_to_symbols(hash)
       hash.each do |k,v|
         case k
           when :tag, :content then
             # keys are valid, and require no further processing
           when :attributes then
             hash[k] = keys_to_strings(v)
           when :parent, :child, :ancestor, :descendant, :sibling, :before,
                   :after
             hash[k] = Conditions.new(v)
           when :children
             hash[k] = v = keys_to_symbols(v)
             v.each do |key,value|
               case key
                 when :count, :greater_than, :less_than
                   # keys are valid, and require no further processing
                 when :only
                   v[key] = Conditions.new(value)
                 else
                   raise "illegal key #{key.inspect} => #{value.inspect}"
               end
             end
           else
             raise "illegal key #{k.inspect} => #{v.inspect}"
         end
       end
       update hash
     end
 
     private
 
       def keys_to_strings(hash)
         Hash[hash.keys.map {|k| [k.to_s, hash[k]]}]
       end
 
       def keys_to_symbols(hash)
         Hash[hash.keys.map do |k|
           raise "illegal key #{k.inspect}" unless k.respond_to?(:to_sym)
           [k.to_sym, hash[k]]
         end]
       end
   end
 
   # The base class of all nodes, textual and otherwise, in an HTML document.
   class Node #:nodoc:
     # The array of children of this node. Not all nodes have children.
     attr_reader :children
 
     # The parent node of this node. All nodes have a parent, except for the
     # root node.
     attr_reader :parent
 
     # The line number of the input where this node was begun
     attr_reader :line
 
     # The byte position in the input where this node was begun
     attr_reader :position
 
     # Create a new node as a child of the given parent.
     def initialize(parent, line=0, pos=0)
       @parent = parent
       @children = []
       @line, @position = line, pos
     end
 
     # Return a textual representation of the node.
     def to_s
       @children.join()
     end
 
     # Return false (subclasses must override this to provide specific matching
     # behavior.) +conditions+ may be of any type.
     def match(conditions)
       false
     end
 
     # Search the children of this node for the first node for which #find
     # returns non +nil+. Returns the result of the #find call that succeeded.
     def find(conditions)
       conditions = validate_conditions(conditions)
       @children.each do |child|
         node = child.find(conditions)
         return node if node
       end
       nil
     end
 
     # Search for all nodes that match the given conditions, and return them
     # as an array.
     def find_all(conditions)
       conditions = validate_conditions(conditions)
 
       matches = []
       matches << self if match(conditions)
       @children.each do |child|
         matches.concat child.find_all(conditions)
       end
       matches
     end
 
     # Returns +false+. Subclasses may override this if they define a kind of
     # tag.
     def tag?
       false
     end
 
     def validate_conditions(conditions)
       Conditions === conditions ? conditions : Conditions.new(conditions)
     end
 
     def ==(node)
       return false unless self.class == node.class && children.size == node.children.size
 
       equivalent = true
 
       children.size.times do |i|
         equivalent &&= children[i] == node.children[i]
       end
 
       equivalent
     end
 
     class <<self
       def parse(parent, line, pos, content, strict=true)
         if content !~ /^<\S/
           Text.new(parent, line, pos, content)
         else
           scanner = StringScanner.new(content)
 
           unless scanner.skip(/</)
             if strict
               raise "expected <"
             else
               return Text.new(parent, line, pos, content)
             end
           end
 
           if scanner.skip(/!\[CDATA\[/)
             unless scanner.skip_until(/\]\]>/)
               if strict
                 raise "expected ]]> (got #{scanner.rest.inspect} for #{content})"
               else
                 scanner.skip_until(/\Z/)
               end
             end
 
             return CDATA.new(parent, line, pos, scanner.pre_match.gsub(/<!\[CDATA\[/, ''))
           end
 
           closing = ( scanner.scan(/\//) ? :close : nil )
-          return Text.new(parent, line, pos, content) unless name = scanner.scan(/[\w:-]+/)
+          return Text.new(parent, line, pos, content) unless name = scanner.scan(/[^\s!>\/]+/)
           name.downcase!
 
           unless closing
             scanner.skip(/\s*/)
             attributes = {}
             while attr = scanner.scan(/[-\w:]+/)
               value = true
               if scanner.scan(/\s*=\s*/)
                 if delim = scanner.scan(/['"]/)
                   value = ""
                   while text = scanner.scan(/[^#{delim}\\]+|./)
                     case text
                       when "\\" then
                         value << text
                         break if scanner.eos?
                         value << scanner.getch
                       when delim
                         break
                       else value << text
                     end
                   end
                 else
                   value = scanner.scan(/[^\s>\/]+/)
                 end
               end
               attributes[attr.downcase] = value
               scanner.skip(/\s*/)
             end
 
             closing = ( scanner.scan(/\//) ? :self : nil )
           end
 
           unless scanner.scan(/\s*>/)
             if strict
               raise "expected > (got #{scanner.rest.inspect} for #{content}, #{attributes.inspect})"
             else
               # throw away all text until we find what we're looking for
               scanner.skip_until(/>/) or scanner.terminate
             end
           end
 
           Tag.new(parent, line, pos, name, attributes, closing)
         end
       end
     end
   end
 
   # A node that represents text, rather than markup.
   class Text < Node #:nodoc:
 
     attr_reader :content
 
     # Creates a new text node as a child of the given parent, with the given
     # content.
     def initialize(parent, line, pos, content)
       super(parent, line, pos)
       @content = content
     end
 
     # Returns the content of this node.
     def to_s
       @content
     end
 
     # Returns +self+ if this node meets the given conditions. Text nodes support
     # conditions of the following kinds:
     #
     # * if +conditions+ is a string, it must be a substring of the node's
     #   content
     # * if +conditions+ is a regular expression, it must match the node's
     #   content
     # * if +conditions+ is a hash, it must contain a <tt>:content</tt> key that
     #   is either a string or a regexp, and which is interpreted as described
     #   above.
     def find(conditions)
       match(conditions) && self
     end
 
     # Returns non-+nil+ if this node meets the given conditions, or +nil+
     # otherwise. See the discussion of #find for the valid conditions.
     def match(conditions)
       case conditions
         when String
           @content == conditions
         when Regexp
           @content =~ conditions
         when Hash
           conditions = validate_conditions(conditions)
 
           # Text nodes only have :content, :parent, :ancestor
           unless (conditions.keys - [:content, :parent, :ancestor]).empty?
             return false
           end
 
           match(conditions[:content])
         else
           nil
       end
     end
 
     def ==(node)
       return false unless super
       content == node.content
     end
   end
 
   # A CDATA node is simply a text node with a specialized way of displaying
   # itself.
   class CDATA < Text #:nodoc:
     def to_s
       "<![CDATA[#{super}]]>"
     end
   end
 
   # A Tag is any node that represents markup. It may be an opening tag, a
   # closing tag, or a self-closing tag. It has a name, and may have a hash of
   # attributes.
   class Tag < Node #:nodoc:
 
     # Either +nil+, <tt>:close</tt>, or <tt>:self</tt>
     attr_reader :closing
 
     # Either +nil+, or a hash of attributes for this node.
     attr_reader :attributes
 
     # The name of this tag.
     attr_reader :name
 
     # Create a new node as a child of the given parent, using the given content
     # to describe the node. It will be parsed and the node name, attributes and
     # closing status extracted.
     def initialize(parent, line, pos, name, attributes, closing)
       super(parent, line, pos)
       @name = name
       @attributes = attributes
       @closing = closing
     end
 
     # A convenience for obtaining an attribute of the node. Returns +nil+ if
     # the node has no attributes.
     def [](attr)
       @attributes ? @attributes[attr] : nil
     end
 
     # Returns non-+nil+ if this tag can contain child nodes.
     def childless?(xml = false)
       return false if xml && @closing.nil?
       !@closing.nil? ||
         @name =~ /^(img|br|hr|link|meta|area|base|basefont|
                     col|frame|input|isindex|param)$/ox
     end
 
     # Returns a textual representation of the node
     def to_s
       if @closing == :close
         "</#{@name}>"
       else
         s = "<#{@name}"
         @attributes.each do |k,v|
           s << " #{k}"
           s << "=\"#{v}\"" if String === v
         end
         s << " /" if @closing == :self
         s << ">"
         @children.each { |child| s << child.to_s }
         s << "</#{@name}>" if @closing != :self && !@children.empty?
         s
       end
     end
 
     # If either the node or any of its children meet the given conditions, the
     # matching node is returned. Otherwise, +nil+ is returned. (See the
     # description of the valid conditions in the +match+ method.)
     def find(conditions)
       match(conditions) && self || super
     end
 
     # Returns +true+, indicating that this node represents an HTML tag.
     def tag?
       true
     end
 
     # Returns +true+ if the node meets any of the given conditions. The
     # +conditions+ parameter must be a hash of any of the following keys
     # (all are optional):
     #
     # * <tt>:tag</tt>: the node name must match the corresponding value
     # * <tt>:attributes</tt>: a hash. The node's values must match the
     #   corresponding values in the hash.
     # * <tt>:parent</tt>: a hash. The node's parent must match the
     #   corresponding hash.
     # * <tt>:child</tt>: a hash. At least one of the node's immediate children
     #   must meet the criteria described by the hash.
     # * <tt>:ancestor</tt>: a hash. At least one of the node's ancestors must
     #   meet the criteria described by the hash.
     # * <tt>:descendant</tt>: a hash. At least one of the node's descendants
     #   must meet the criteria described by the hash.
     # * <tt>:sibling</tt>: a hash. At least one of the node's siblings must
     #   meet the criteria described by the hash.
     # * <tt>:after</tt>: a hash. The node must be after any sibling meeting
     #   the criteria described by the hash, and at least one sibling must match.
     # * <tt>:before</tt>: a hash. The node must be before any sibling meeting
     #   the criteria described by the hash, and at least one sibling must match.
     # * <tt>:children</tt>: a hash, for counting children of a node. Accepts the
     #   keys:
     # ** <tt>:count</tt>: either a number or a range which must equal (or
     #    include) the number of children that match.
     # ** <tt>:less_than</tt>: the number of matching children must be less than
     #    this number.
     # ** <tt>:greater_than</tt>: the number of matching children must be
     #    greater than this number.
     # ** <tt>:only</tt>: another hash consisting of the keys to use
     #    to match on the children, and only matching children will be
     #    counted.
     #
     # Conditions are matched using the following algorithm:
     #
     # * if the condition is a string, it must be a substring of the value.
     # * if the condition is a regexp, it must match the value.
     # * if the condition is a number, the value must match number.to_s.
     # * if the condition is +true+, the value must not be +nil+.
     # * if the condition is +false+ or +nil+, the value must be +nil+.
     #
     # Usage:
     #
     #   # test if the node is a "span" tag
     #   node.match :tag => "span"
     #
     #   # test if the node's parent is a "div"
     #   node.match :parent => { :tag => "div" }
     #
     #   # test if any of the node's ancestors are "table" tags
     #   node.match :ancestor => { :tag => "table" }
     #
     #   # test if any of the node's immediate children are "em" tags
     #   node.match :child => { :tag => "em" }
     #
     #   # test if any of the node's descendants are "strong" tags
     #   node.match :descendant => { :tag => "strong" }
     #
     #   # test if the node has between 2 and 4 span tags as immediate children
     #   node.match :children => { :count => 2..4, :only => { :tag => "span" } }
     #
     #   # get funky: test to see if the node is a "div", has a "ul" ancestor
     #   # and an "li" parent (with "class" = "enum"), and whether or not it has
     #   # a "span" descendant that contains # text matching /hello world/:
     #   node.match :tag => "div",
     #              :ancestor => { :tag => "ul" },
     #              :parent => { :tag => "li",
     #                           :attributes => { :class => "enum" } },
     #              :descendant => { :tag => "span",
     #                               :child => /hello world/ }
     def match(conditions)
       conditions = validate_conditions(conditions)
       # check content of child nodes
       if conditions[:content]
         if children.empty?
           return false unless match_condition("", conditions[:content])
         else
           return false unless children.find { |child| child.match(conditions[:content]) }
         end
       end
 
       # test the name
       return false unless match_condition(@name, conditions[:tag]) if conditions[:tag]
 
       # test attributes
       (conditions[:attributes] || {}).each do |key, value|
         return false unless match_condition(self[key], value)
       end
 
       # test parent
       return false unless parent.match(conditions[:parent]) if conditions[:parent]
 
       # test children
       return false unless children.find { |child| child.match(conditions[:child]) } if conditions[:child]
 
       # test ancestors
       if conditions[:ancestor]
         return false unless catch :found do
           p = self
           throw :found, true if p.match(conditions[:ancestor]) while p = p.parent
         end
       end
 
       # test descendants
       if conditions[:descendant]
         return false unless children.find do |child|
           # test the child
           child.match(conditions[:descendant]) ||
           # test the child's descendants
           child.match(:descendant => conditions[:descendant])
         end
       end
 
       # count children
       if opts = conditions[:children]
         matches = children.select do |c|
           (c.kind_of?(HTML::Tag) and (c.closing == :self or ! c.childless?))
         end
 
         matches = matches.select { |c| c.match(opts[:only]) } if opts[:only]
         opts.each do |key, value|
           next if key == :only
           case key
             when :count
               if Integer === value
                 return false if matches.length != value
               else
                 return false unless value.include?(matches.length)
               end
             when :less_than
               return false unless matches.length < value
             when :greater_than
               return false unless matches.length > value
             else raise "unknown count condition #{key}"
           end
         end
       end
 
       # test siblings
       if conditions[:sibling] || conditions[:before] || conditions[:after]
         siblings = parent ? parent.children : []
         self_index = siblings.index(self)
 
         if conditions[:sibling]
           return false unless siblings.detect do |s|
             s != self && s.match(conditions[:sibling])
           end
         end
 
         if conditions[:before]
           return false unless siblings[self_index+1..-1].detect do |s|
             s != self && s.match(conditions[:before])
           end
         end
 
         if conditions[:after]
           return false unless siblings[0,self_index].detect do |s|
             s != self && s.match(conditions[:after])
           end
         end
       end
 
       true
     end
 
     def ==(node)
       return false unless super
       return false unless closing == node.closing && self.name == node.name
       attributes == node.attributes
     end
 
     private
       # Match the given value to the given condition.
       def match_condition(value, condition)
         case condition
           when String
             value && value == condition
           when Regexp
             value && value.match(condition)
           when Numeric
             value == condition.to_s
           when true
             !value.nil?
           when false, nil
             value.nil?
           else
             false
         end
       end
   end
diff --git a/actionpack/test/template/html-scanner/sanitizer_test.rb b/actionpack/test/template/html-scanner/sanitizer_test.rb
index 678cb9e..62ad6be 100644
--- a/actionpack/test/template/html-scanner/sanitizer_test.rb
+++ b/actionpack/test/template/html-scanner/sanitizer_test.rb
@@ -3,269 +3,276 @@ require 'abstract_unit'
 class SanitizerTest < ActionController::TestCase
   def setup
     @sanitizer = nil # used by assert_sanitizer
   end
 
+  def test_strip_tags_with_quote
+    sanitizer = HTML::FullSanitizer.new
+    string    = '<" <img src="trollface.gif" onload="alert(1)"> hi'
+
+    assert_equal ' hi', sanitizer.sanitize(string)
+  end
+
   def test_strip_tags
     sanitizer = HTML::FullSanitizer.new
     assert_equal("<<<bad html", sanitizer.sanitize("<<<bad html"))
     assert_equal("<<", sanitizer.sanitize("<<<bad html>"))
     assert_equal("Dont touch me", sanitizer.sanitize("Dont touch me"))
     assert_equal("This is a test.", sanitizer.sanitize("<p>This <u>is<u> a <a href='test.html'><strong>test</strong></a>.</p>"))
     assert_equal("Weirdos", sanitizer.sanitize("Wei<<a>a onclick='alert(document.cookie);'</a>/>rdos"))
     assert_equal("This is a test.", sanitizer.sanitize("This is a test."))
     assert_equal(
     %{This is a test.\n\n\nIt no longer contains any HTML.\n}, sanitizer.sanitize(
     %{<title>This is <b>a <a href="" target="_blank">test</a></b>.</title>\n\n<!-- it has a comment -->\n\n<p>It no <b>longer <strong>contains <em>any <strike>HTML</strike></em>.</strong></b></p>\n}))
     assert_equal "This has a  here.", sanitizer.sanitize("This has a <!-- comment --> here.")
     assert_equal "This has a  here.", sanitizer.sanitize("This has a <![CDATA[<section>]]> here.")
     assert_equal "This has an unclosed ", sanitizer.sanitize("This has an unclosed <![CDATA[<section>]] here...")
     [nil, '', '   '].each { |blank| assert_equal blank, sanitizer.sanitize(blank) }
     assert_nothing_raised { sanitizer.sanitize("This is a frozen string with no tags".freeze) }
   end
 
   def test_strip_links
     sanitizer = HTML::LinkSanitizer.new
     assert_equal "Dont touch me", sanitizer.sanitize("Dont touch me")
     assert_equal "on my mind\nall day long", sanitizer.sanitize("<a href='almost'>on my mind</a>\n<A href='almost'>all day long</A>")
     assert_equal "0wn3d", sanitizer.sanitize("<a href='http://www.rubyonrails.com/'><a href='http://www.rubyonrails.com/' onlclick='steal()'>0wn3d</a></a>")
     assert_equal "Magic", sanitizer.sanitize("<a href='http://www.rubyonrails.com/'>Mag<a href='http://www.ruby-lang.org/'>ic")
     assert_equal "FrrFox", sanitizer.sanitize("<href onlclick='steal()'>FrrFox</a></href>")
     assert_equal "My mind\nall <b>day</b> long", sanitizer.sanitize("<a href='almost'>My mind</a>\n<A href='almost'>all <b>day</b> long</A>")
     assert_equal "all <b>day</b> long", sanitizer.sanitize("<<a>a href='hello'>all <b>day</b> long<</A>/a>")
 
     assert_equal "<a<a", sanitizer.sanitize("<a<a")
   end
 
   def test_sanitize_form
     assert_sanitized "<form action=\"/foo/bar\" method=\"post\"><input></form>", ''
   end
 
   def test_sanitize_plaintext
     raw = "<plaintext><span>foo</span></plaintext>"
     assert_sanitized raw, "<span>foo</span>"
   end
 
   def test_sanitize_script
     assert_sanitized "a b c<script language=\"Javascript\">blah blah blah</script>d e f", "a b cd e f"
   end
 
   # TODO: Clean up
   def test_sanitize_js_handlers
     raw = %{onthis="do that" <a href="#" onclick="hello" name="foo" onbogus="remove me">hello</a>}
     assert_sanitized raw, %{onthis="do that" <a name="foo" href="#">hello</a>}
   end
 
   def test_sanitize_javascript_href
     raw = %{href="javascript:bang" <a href="javascript:bang" name="hello">foo</a>, <span href="javascript:bang">bar</span>}
     assert_sanitized raw, %{href="javascript:bang" <a name="hello">foo</a>, <span>bar</span>}
   end
 
   def test_sanitize_image_src
     raw = %{src="javascript:bang" <img src="javascript:bang" width="5">foo</img>, <span src="javascript:bang">bar</span>}
     assert_sanitized raw, %{src="javascript:bang" <img width="5">foo</img>, <span>bar</span>}
   end
 
   HTML::WhiteListSanitizer.allowed_tags.each do |tag_name|
     define_method "test_should_allow_#{tag_name}_tag" do
       assert_sanitized "start <#{tag_name} title=\"1\" onclick=\"foo\">foo <bad>bar</bad> baz</#{tag_name}> end", %(start <#{tag_name} title="1">foo bar baz</#{tag_name}> end)
     end
   end
 
   def test_should_allow_anchors
     assert_sanitized %(<a href="foo" onclick="bar"><script>baz</script></a>), %(<a href="foo"></a>)
   end
 
   # RFC 3986, sec 4.2
   def test_allow_colons_in_path_component
     assert_sanitized("<a href=\"./this:that\">foo</a>")
   end
 
   %w(src width height alt).each do |img_attr|
     define_method "test_should_allow_image_#{img_attr}_attribute" do
       assert_sanitized %(<img #{img_attr}="foo" onclick="bar" />), %(<img #{img_attr}="foo" />)
     end
   end
 
   def test_should_handle_non_html
     assert_sanitized 'abc'
   end
 
   def test_should_handle_blank_text
     assert_sanitized nil
     assert_sanitized ''
   end
 
   def test_should_allow_custom_tags
     text = "<u>foo</u>"
     sanitizer = HTML::WhiteListSanitizer.new
     assert_equal(text, sanitizer.sanitize(text, :tags => %w(u)))
   end
 
   def test_should_allow_only_custom_tags
     text = "<u>foo</u> with <i>bar</i>"
     sanitizer = HTML::WhiteListSanitizer.new
     assert_equal("<u>foo</u> with bar", sanitizer.sanitize(text, :tags => %w(u)))
   end
 
   def test_should_allow_custom_tags_with_attributes
     text = %(<blockquote cite="http://example.com/">foo</blockquote>)
     sanitizer = HTML::WhiteListSanitizer.new
     assert_equal(text, sanitizer.sanitize(text))
   end
 
   def test_should_allow_custom_tags_with_custom_attributes
     text = %(<blockquote foo="bar">Lorem ipsum</blockquote>)
     sanitizer = HTML::WhiteListSanitizer.new
     assert_equal(text, sanitizer.sanitize(text, :attributes => ['foo']))
   end
 
   [%w(img src), %w(a href)].each do |(tag, attr)|
     define_method "test_should_strip_#{attr}_attribute_in_#{tag}_with_bad_protocols" do
       assert_sanitized %(<#{tag} #{attr}="javascript:bang" title="1">boo</#{tag}>), %(<#{tag} title="1">boo</#{tag}>)
     end
   end
 
   def test_should_flag_bad_protocols
     sanitizer = HTML::WhiteListSanitizer.new
     %w(about chrome data disk hcp help javascript livescript lynxcgi lynxexec ms-help ms-its mhtml mocha opera res resource shell vbscript view-source vnd.ms.radio wysiwyg).each do |proto|
       assert sanitizer.send(:contains_bad_protocols?, 'src', "#{proto}://bad")
     end
   end
   
   def test_should_accept_good_protocols_ignoring_case
     sanitizer = HTML::WhiteListSanitizer.new
     HTML::WhiteListSanitizer.allowed_protocols.each do |proto|
       assert !sanitizer.send(:contains_bad_protocols?, 'src', "#{proto.capitalize}://good")
     end
   end
 
   def test_should_accept_good_protocols
     sanitizer = HTML::WhiteListSanitizer.new
     HTML::WhiteListSanitizer.allowed_protocols.each do |proto|
       assert !sanitizer.send(:contains_bad_protocols?, 'src', "#{proto}://good")
     end
   end
 
   def test_should_reject_hex_codes_in_protocol
     assert_sanitized %(<a href="&#37;6A&#37;61&#37;76&#37;61&#37;73&#37;63&#37;72&#37;69&#37;70&#37;74&#37;3A&#37;61&#37;6C&#37;65&#37;72&#37;74&#37;28&#37;22&#37;58&#37;53&#37;53&#37;22&#37;29">1</a>), "<a>1</a>"
     assert @sanitizer.send(:contains_bad_protocols?, 'src', "%6A%61%76%61%73%63%72%69%70%74%3A%61%6C%65%72%74%28%22%58%53%53%22%29")
   end
 
   def test_should_block_script_tag
     assert_sanitized %(<SCRIPT\nSRC=http://ha.ckers.org/xss.js></SCRIPT>), ""
   end
 
   [%(<IMG SRC="javascript:alert('XSS');">),
    %(<IMG SRC=javascript:alert('XSS')>),
    %(<IMG SRC=JaVaScRiPt:alert('XSS')>),
    %(<IMG """><SCRIPT>alert("XSS")</SCRIPT>">),
    %(<IMG SRC=javascript:alert(&quot;XSS&quot;)>),
    %(<IMG SRC=javascript:alert(String.fromCharCode(88,83,83))>),
    %(<IMG SRC=&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;>),
    %(<IMG SRC=&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041>),
    %(<IMG SRC=&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&#x27&#x58&#x53&#x53&#x27&#x29>),
    %(<IMG SRC="jav\tascript:alert('XSS');">),
    %(<IMG SRC="jav&#x09;ascript:alert('XSS');">),
    %(<IMG SRC="jav&#x0A;ascript:alert('XSS');">),
    %(<IMG SRC="jav&#x0D;ascript:alert('XSS');">),
    %(<IMG SRC=" &#14;  javascript:alert('XSS');">),
    %(<IMG SRC=`javascript:alert("RSnake says, 'XSS'")`>)].each_with_index do |img_hack, i|
     define_method "test_should_not_fall_for_xss_image_hack_#{i+1}" do
       assert_sanitized img_hack, "<img>"
     end
   end
 
   def test_should_sanitize_tag_broken_up_by_null
     assert_sanitized %(<SCR\0IPT>alert(\"XSS\")</SCR\0IPT>), "alert(\"XSS\")"
   end
 
   def test_should_sanitize_invalid_script_tag
     assert_sanitized %(<SCRIPT/XSS SRC="http://ha.ckers.org/xss.js"></SCRIPT>), ""
   end
 
   def test_should_sanitize_script_tag_with_multiple_open_brackets
     assert_sanitized %(<<SCRIPT>alert("XSS");//<</SCRIPT>), "&lt;"
     assert_sanitized %(<iframe src=http://ha.ckers.org/scriptlet.html\n<a), %(&lt;a)
   end
 
   def test_should_sanitize_unclosed_script
     assert_sanitized %(<SCRIPT SRC=http://ha.ckers.org/xss.js?<B>), "<b>"
   end
 
   def test_should_sanitize_half_open_scripts
     assert_sanitized %(<IMG SRC="javascript:alert('XSS')"), "<img>"
   end
 
   def test_should_not_fall_for_ridiculous_hack
     img_hack = %(<IMG\nSRC\n=\n"\nj\na\nv\na\ns\nc\nr\ni\np\nt\n:\na\nl\ne\nr\nt\n(\n'\nX\nS\nS\n'\n)\n"\n>)
     assert_sanitized img_hack, "<img>"
   end
 
   # TODO: Clean up
   def test_should_sanitize_attributes
     assert_sanitized %(<SPAN title="'><script>alert()</script>">blah</SPAN>), %(<span title="'&gt;&lt;script&gt;alert()&lt;/script&gt;">blah</span>)
   end
 
   def test_should_sanitize_illegal_style_properties
     raw      = %(display:block; position:absolute; left:0; top:0; width:100%; height:100%; z-index:1; background-color:black; background-image:url(http://www.ragingplatypus.com/i/cam-full.jpg); background-x:center; background-y:center; background-repeat:repeat;)
     expected = %(display: block; width: 100%; height: 100%; background-color: black; background-image: ; background-x: center; background-y: center;)
     assert_equal expected, sanitize_css(raw)
   end
 
   def test_should_sanitize_with_trailing_space
     raw = "display:block; "
     expected = "display: block;"
     assert_equal expected, sanitize_css(raw)
   end
 
   def test_should_sanitize_xul_style_attributes
     raw = %(-moz-binding:url('http://ha.ckers.org/xssmoz.xml#xss'))
     assert_equal '', sanitize_css(raw)
   end
 
   def test_should_sanitize_invalid_tag_names
     assert_sanitized(%(a b c<script/XSS src="http://ha.ckers.org/xss.js"></script>d e f), "a b cd e f")
   end
 
   def test_should_sanitize_non_alpha_and_non_digit_characters_in_tags
     assert_sanitized('<a onclick!#$%&()*~+-_.,:;?@[/|\]^`=alert("XSS")>foo</a>', "<a>foo</a>")
   end
 
   def test_should_sanitize_invalid_tag_names_in_single_tags
     assert_sanitized('<img/src="http://ha.ckers.org/xss.js"/>', "<img />")
   end
 
   def test_should_sanitize_img_dynsrc_lowsrc
     assert_sanitized(%(<img lowsrc="javascript:alert('XSS')" />), "<img />")
   end
 
   def test_should_sanitize_div_background_image_unicode_encoded
     raw = %(background-image:\0075\0072\006C\0028'\006a\0061\0076\0061\0073\0063\0072\0069\0070\0074\003a\0061\006c\0065\0072\0074\0028.1027\0058.1053\0053\0027\0029'\0029)
     assert_equal '', sanitize_css(raw)
   end
 
   def test_should_sanitize_div_style_expression
     raw = %(width: expression(alert('XSS'));)
     assert_equal '', sanitize_css(raw)
   end
 
   def test_should_sanitize_img_vbscript
     assert_sanitized %(<img src='vbscript:msgbox("XSS")' />), '<img />'
   end
 
   def test_should_sanitize_cdata_section
     assert_sanitized "<![CDATA[<span>section</span>]]>", "&lt;![CDATA[&lt;span>section&lt;/span>]]>"
   end
 
   def test_should_sanitize_unterminated_cdata_section
     assert_sanitized "<![CDATA[<span>neverending...", "&lt;![CDATA[&lt;span>neverending...]]>"
   end
 
   def test_should_not_mangle_urls_with_ampersand
      assert_sanitized %{<a href=\"http://www.domain.com?var1=1&amp;var2=2\">my link</a>}
   end
 
   def test_should_sanitize_neverending_attribute
     assert_sanitized "<span class=\"\\", "<span class=\"\\\">"
   end
 
