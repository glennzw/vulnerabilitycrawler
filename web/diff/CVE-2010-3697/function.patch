commit ff94dd35673bba1476594299d31ce8293b8bd223
Author: Alan T. DeKok <aland@freeradius.org>
Date:   Wed Jun 30 21:58:27 2010 +0200

    Do not delete "old" requests until they are free.
    
    If the request is in the queue for 30+ seconds, do NOT delete it.
    Instead, mark it as "STOP PROCESSING", and do "wait_for_child_to_die",
    which waits for a child thread to pick it up, and acknowledge that it's
    done.  Once it's marked done, we can finally clean it up.
    
    This may be the underlying issue behind bug #35

diff --git a/src/main/event.c b/src/main/event.c
index e3b32a8..6ed7847 100644
--- a/src/main/event.c
+++ b/src/main/event.c
@@ -477,46 +477,47 @@ static void wait_for_proxy_id_to_expire(void *ctx)
 static void wait_for_child_to_die(void *ctx)
 {
 	REQUEST *request = ctx;
 
 	rad_assert(request->magic == REQUEST_MAGIC);
+	remove_from_request_hash(request);
 
 	/*
 	 *	If it's still queued (waiting for a thread to pick it
 	 *	up) OR, it's running AND there's still a child thread
 	 *	handling it, THEN delay some more.
 	 */
 	if ((request->child_state == REQUEST_QUEUED) ||
 	    ((request->child_state == REQUEST_RUNNING) &&
 	     (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0))) {
 
 		/*
-		 *	Cap delay at five minutes.
+		 *	Cap delay at max_request_time
 		 */
-		if (request->delay < (USEC * 60 * 5)) {
+		if (request->delay < (USEC * request->root->max_request_time)) {
 			request->delay += (request->delay >> 1);
 			radlog(L_INFO, "WARNING: Child is hung for request %u in component %s module %s.",
 			       request->number, request->component, request->module);
 		} else {
-			RDEBUG2("Child is still stuck for request %u",
+			request->delay = USEC * request->root->max_request_time;
+			RDEBUG2("WARNING: Child is still stuck for request %u",
 				request->number);
 		}
 		tv_add(&request->when, request->delay);
 
 		INSERT_EVENT(wait_for_child_to_die, request);
 		return;
 	}
 
 	RDEBUG2("Child is finally responsive for request %u", request->number);
-	remove_from_request_hash(request);
 
 #ifdef WITH_PROXY
 	if (request->proxy) {
 		wait_for_proxy_id_to_expire(request);
 		return;
 	}
 #endif
 
 	ev_request_free(&request);
 }
 #endif
 
@@ -1115,173 +1116,174 @@ static void no_response_to_proxied_request(void *ctx)
 static void wait_a_bit(void *ctx)
 {
 	struct timeval when;
 	REQUEST *request = ctx;
 	fr_event_callback_t callback = NULL;
 
 	rad_assert(request->magic == REQUEST_MAGIC);
 
 #ifdef WITH_COA
 	/*
 	 *	The CoA request is a new (internally generated)
 	 *	request, created in a child thread.  We therefore need
 	 *	some way to tie its events back into the main event
 	 *	handler.
 	 */
 	if (request->coa && !request->coa->proxy_reply &&
 	    request->coa->next_callback) {
 		request->coa->when = request->coa->next_when;
 		INSERT_EVENT(request->coa->next_callback, request->coa);
 		request->coa->next_callback = NULL;
 		request->coa->parent = NULL;
 		request->coa = NULL;
 	}
 #endif
 
 	switch (request->child_state) {
 	case REQUEST_QUEUED:
 	case REQUEST_RUNNING:
+		/*
+		 *	If we're not thread-capable, OR we're capable,
+		 *	but have been told to run without threads,
+		 *	complain when the requests is queued for a
+		 *	thread, or running in a child thread.
+		 */
+#ifdef HAVE_PTHREAD_H
+		if (!have_children)
+#endif
+		{
+			rad_assert("We do not have threads, but the request is marked as queued or running in a child thread" == NULL);
+			break;
+		}
+
+#ifdef HAVE_PTHREAD_H
+		/*
+		 *	If we have threads, wait for the child thread
+		 *	to stop.
+		 */
 		when = request->received;
 		when.tv_sec += request->root->max_request_time;
 
 		/*
 		 *	Normally called from the event loop with the
 		 *	proper event loop time.  Otherwise, called from
 		 *	post proxy fail handler, which sets "now", and
 		 *	this call won't re-set it, because we're not
 		 *	in the event loop.
 		 */
 		fr_event_now(el, &now);
 
 		/*
 		 *	Request still has more time.  Continue
 		 *	waiting.
 		 */
-		if (timercmp(&now, &when, <) ||
-		    ((request->listener->type == RAD_LISTEN_DETAIL) &&
-		     (request->child_state == REQUEST_QUEUED))) {
+		if (timercmp(&now, &when, <)) {
 			if (request->delay < (USEC / 10)) {
 				request->delay = USEC / 10;
 			}
 			request->delay += request->delay >> 1;
 
-#ifdef WITH_DETAIL
 			/*
-			 *	Cap wait at some sane value for detail
-			 *	files.
+			 *	Cap delays at something reasonable.
 			 */
-			if ((request->listener->type == RAD_LISTEN_DETAIL) &&
-			    (request->delay > (request->root->max_request_time * USEC))) {
+			if (request->delay > (request->root->max_request_time * USEC)) {
 				request->delay = request->root->max_request_time * USEC;
 			}
-#endif
 
 			request->when = now;
 			tv_add(&request->when, request->delay);
 			callback = wait_a_bit;
 			break;
 		}
 
-#if defined(HAVE_PTHREAD_H)
+		request->master_state = REQUEST_STOP_PROCESSING;
+
 		/*
 		 *	A child thread MAY still be running on the
 		 *	request.  Ask the thread to stop working on
 		 *	the request.
 		 */
 		if (have_children &&
 		    (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0)) {
-			request->master_state = REQUEST_STOP_PROCESSING;
-
 			radlog(L_ERR, "WARNING: Unresponsive child for request %u, in module %s component %s",
 			       request->number,
 			       request->module ? request->module : "<server core>",
 			       request->component ? request->component : "<server core>");
-			
-			request->delay = USEC / 4;
-			tv_add(&request->when, request->delay);
-			callback = wait_for_child_to_die;
-			break;
 		}
+			
+		request->delay = USEC;
+		tv_add(&request->when, request->delay);
+		callback = wait_for_child_to_die;
+		break;
 #endif
 
 		/*
-		 *	Else no child thread is processing the
-		 *	request.  We probably should have just marked
-		 *	the request as 'done' elsewhere, like in the
-		 *	post-proxy-fail handler.  But doing that would
-		 *	involve checking for max_request_time in
-		 *	multiple places, so this may be simplest.
-		 */
-		request->child_state = REQUEST_DONE;
-		/* FALL-THROUGH */
-
-		/*
 		 *	Mark the request as no longer running,
 		 *	and clean it up.
 		 */
 	case REQUEST_DONE:
 #ifdef HAVE_PTHREAD_H
 		request->child_pid = NO_SUCH_CHILD_PID;
 #endif
 
 #ifdef WITH_COA
 		/*
 		 *	This is a CoA request.  It's been divorced
 		 *	from everything else, so we clean it up now.
 		 */
 		if (!request->in_request_hash &&
 		    request->proxy &&
 		    (request->packet->code != request->proxy->code) &&
 		    ((request->proxy->code == PW_COA_REQUEST) ||
 		     (request->proxy->code == PW_DISCONNECT_REQUEST))) {
 			/*
 			 *	FIXME: Do CoA MIBs
 			 */
 			ev_request_free(&request);
 			return;
 		}
 #endif
 		request_stats_final(request);
 		cleanup_delay(request);
 		return;
 
 	case REQUEST_REJECT_DELAY:
 	case REQUEST_CLEANUP_DELAY:
 #ifdef HAVE_PTHREAD_H
 		request->child_pid = NO_SUCH_CHILD_PID;
 #endif
 		request_stats_final(request);
 
 	case REQUEST_PROXIED:
 		rad_assert(request->next_callback != NULL);
 		rad_assert(request->next_callback != wait_a_bit);
 
 		request->when = request->next_when;
 		callback = request->next_callback;
 		request->next_callback = NULL;
 		break;
 
 	default:
 		rad_panic("Internal sanity check failure");
 		return;
 	}
 
 	/*
 	 *	Something major went wrong.  Discard the request, and
 	 *	keep running.
 	 *
 	 *	FIXME: No idea why this happens or how to fix it...
 	 *	It seems to happen *only* when requests are proxied,
 	 *	and where the home server doesn't respond.  So it looks
 	 *	like a race condition above, but it happens in debug
 	 *	mode, with no threads...
 	 */
 	if (!callback) {
 		RDEBUG("WARNING: Internal sanity check failed in event handler for request %u: Discarding the request!", request->number);
 		ev_request_free(&request);
 		return;
 	}
 
 	INSERT_EVENT(callback, request);
 }
 
 #ifdef WITH_COA
