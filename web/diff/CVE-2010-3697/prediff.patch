   Do not delete "old" requests until they are free.
   
   If the request is in the queue for 30+ seconds, do NOT delete it.
   Instead, mark it as "STOP PROCESSING", and do "wait_for_child_to_die",
   which waits for a child thread to pick it up, and acknowledge that it's
   done.  Once it's marked done, we can finally clean it up.
   
   This may be the underlying issue behind bug #35
	REQUEST *request = ctx;

	rad_assert(request->magic == REQUEST_MAGIC);

	/*
	 *	If it's still queued (waiting for a thread to pick it
	     (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0))) {

		/*
		 *	Cap delay at five minutes.
		 */
		if (request->delay < (USEC * 60 * 5)) {
			request->delay += (request->delay >> 1);
			radlog(L_INFO, "WARNING: Child is hung for request %u in component %s module %s.",
			       request->number, request->component, request->module);
		} else {
			RDEBUG2("Child is still stuck for request %u",
				request->number);
		}
		tv_add(&request->when, request->delay);
	}

	RDEBUG2("Child is finally responsive for request %u", request->number);
	remove_from_request_hash(request);

#ifdef WITH_PROXY
	if (request->proxy) {
	switch (request->child_state) {
	case REQUEST_QUEUED:
	case REQUEST_RUNNING:
		when = request->received;
		when.tv_sec += request->root->max_request_time;

		 *	Request still has more time.  Continue
		 *	waiting.
		 */
		if (timercmp(&now, &when, <) ||
		    ((request->listener->type == RAD_LISTEN_DETAIL) &&
		     (request->child_state == REQUEST_QUEUED))) {
			if (request->delay < (USEC / 10)) {
				request->delay = USEC / 10;
			}
			request->delay += request->delay >> 1;

#ifdef WITH_DETAIL
			/*
			 *	Cap wait at some sane value for detail
			 *	files.
			 */
			if ((request->listener->type == RAD_LISTEN_DETAIL) &&
			    (request->delay > (request->root->max_request_time * USEC))) {
				request->delay = request->root->max_request_time * USEC;
			}
#endif

			request->when = now;
			tv_add(&request->when, request->delay);
			break;
		}

#if defined(HAVE_PTHREAD_H)
		/*
		 *	A child thread MAY still be running on the
		 *	request.  Ask the thread to stop working on
		 */
		if (have_children &&
		    (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0)) {
			request->master_state = REQUEST_STOP_PROCESSING;

			radlog(L_ERR, "WARNING: Unresponsive child for request %u, in module %s component %s",
			       request->number,
			       request->module ? request->module : "<server core>",
			       request->component ? request->component : "<server core>");
			
			request->delay = USEC / 4;
			tv_add(&request->when, request->delay);
			callback = wait_for_child_to_die;
			break;
		}
#endif

		/*
		 *	Else no child thread is processing the
		 *	request.  We probably should have just marked
		 *	the request as 'done' elsewhere, like in the
		 *	post-proxy-fail handler.  But doing that would
		 *	involve checking for max_request_time in
		 *	multiple places, so this may be simplest.
		 */
		request->child_state = REQUEST_DONE;
		/* FALL-THROUGH */

		/*
		 *	Mark the request as no longer running,
		 *	and clean it up.
		 */
