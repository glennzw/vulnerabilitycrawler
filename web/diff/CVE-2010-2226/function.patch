commit 1817176a86352f65210139d4c794ad2d19fc6b63
Author: Dan Rosenberg <dan.j.rosenberg@gmail.com>
Date:   Thu Jun 24 12:07:47 2010 +1000

    xfs: prevent swapext from operating on write-only files
    
    This patch prevents user "foo" from using the SWAPEXT ioctl to swap
    a write-only file owned by user "bar" into a file owned by "foo" and
    subsequently reading it.  It does so by checking that the file
    descriptors passed to the ioctl are also opened for reading.
    
    Signed-off-by: Dan Rosenberg <dan.j.rosenberg@gmail.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/fs/xfs/xfs_dfrag.c b/fs/xfs/xfs_dfrag.c
index 5bba29a..7f159d2 100644
--- a/fs/xfs/xfs_dfrag.c
+++ b/fs/xfs/xfs_dfrag.c
@@ -58,85 +58,88 @@ int
 xfs_swapext(
 	xfs_swapext_t	*sxp)
 {
 	xfs_inode_t     *ip, *tip;
 	struct file	*file, *tmp_file;
 	int		error = 0;
 
 	/* Pull information for the target fd */
 	file = fget((int)sxp->sx_fdtarget);
 	if (!file) {
 		error = XFS_ERROR(EINVAL);
 		goto out;
 	}
 
-	if (!(file->f_mode & FMODE_WRITE) || (file->f_flags & O_APPEND)) {
+	if (!(file->f_mode & FMODE_WRITE) ||
+	    !(file->f_mode & FMODE_READ) ||
+	    (file->f_flags & O_APPEND)) {
 		error = XFS_ERROR(EBADF);
 		goto out_put_file;
 	}
 
 	tmp_file = fget((int)sxp->sx_fdtmp);
 	if (!tmp_file) {
 		error = XFS_ERROR(EINVAL);
 		goto out_put_file;
 	}
 
 	if (!(tmp_file->f_mode & FMODE_WRITE) ||
+	    !(tmp_file->f_mode & FMODE_READ) ||
 	    (tmp_file->f_flags & O_APPEND)) {
 		error = XFS_ERROR(EBADF);
 		goto out_put_tmp_file;
 	}
 
 	if (IS_SWAPFILE(file->f_path.dentry->d_inode) ||
 	    IS_SWAPFILE(tmp_file->f_path.dentry->d_inode)) {
 		error = XFS_ERROR(EINVAL);
 		goto out_put_tmp_file;
 	}
 
 	ip = XFS_I(file->f_path.dentry->d_inode);
 	tip = XFS_I(tmp_file->f_path.dentry->d_inode);
 
 	if (ip->i_mount != tip->i_mount) {
 		error = XFS_ERROR(EINVAL);
 		goto out_put_tmp_file;
 	}
 
 	if (ip->i_ino == tip->i_ino) {
 		error = XFS_ERROR(EINVAL);
 		goto out_put_tmp_file;
 	}
 
 	if (XFS_FORCED_SHUTDOWN(ip->i_mount)) {
 		error = XFS_ERROR(EIO);
 		goto out_put_tmp_file;
 	}
 
 	error = xfs_swap_extents(ip, tip, sxp);
 
  out_put_tmp_file:
 	fput(tmp_file);
  out_put_file:
 	fput(file);
  out:
 	return error;
 }
 
 /*
  * We need to check that the format of the data fork in the temporary inode is
  * valid for the target inode before doing the swap. This is not a problem with
  * attr1 because of the fixed fork offset, but attr2 has a dynamically sized
  * data fork depending on the space the attribute fork is taking so we can get
  * invalid formats on the target inode.
  *
  * E.g. target has space for 7 extents in extent format, temp inode only has
  * space for 6.  If we defragment down to 7 extents, then the tmp format is a
  * btree, but when swapped it needs to be in extent format. Hence we can't just
  * blindly swap data forks on attr2 filesystems.
  *
  * Note that we check the swap in both directions so that we don't end up with
  * a corrupt temporary inode, either.
  *
  * Note that fixing the way xfs_fsr sets up the attribute fork in the source
  * inode will prevent this situation from occurring, so all we do here is
  * reject and log the attempt. basically we are putting the responsibility on
  * userspace to get this right.
  */
