commit 5c58ceff103d8a654f24769bb1baaf84a841b0cc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 25 09:12:43 2009 -0700

    tty: make sure to flush any pending work when halting the ldisc
    
    When I rewrote tty ldisc code to use proper reference counts (commits
    65b770468e98 and cbe9352fa08f) in order to avoid a race with hangup, the
    test-program that Eric Biederman used to trigger the original problem
    seems to have exposed another long-standing bug: the hangup code did the
    'tty_ldisc_halt()' to stop any buffer flushing activity, but unlike the
    other call sites it never actually flushed any pending work.
    
    As a result, if you get just the right timing, the pending work may be
    just about to execute (ie the timer has already triggered and thus
    cancel_delayed_work() was a no-op), when we then re-initialize the ldisc
    from under it.
    
    That, in turn, results in various random problems, usually seen as a
    NULL pointer dereference in run_timer_softirq() or a BUG() in
    worker_thread (but it can be almost anything).
    
    Fix it by adding the required 'flush_scheduled_work()' after doing the
    tty_ldisc_halt() (this also requires us to move the ldisc halt to before
    taking the ldisc mutex in order to avoid a deadlock with the workqueue
    executing do_tty_hangup, which requires the mutex).
    
    The locking should be cleaned up one day (the requirement to do this
    outside the ldisc_mutex is very annoying, and weakens the lock), but
    that's a larger and separate undertaking.
    
    Reported-by: Eric W. Biederman <ebiederm@xmission.com>
    Tested-by: Xiaotian Feng <xtfeng@gmail.com>
    Tested-by: Yanmin Zhang <yanmin_zhang@linux.intel.com>
    Tested-by: Dave Young <hidave.darkstar@gmail.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/char/tty_ldisc.c b/drivers/char/tty_ldisc.c
index 1733d34..e48af9f 100644
--- a/drivers/char/tty_ldisc.c
+++ b/drivers/char/tty_ldisc.c
@@ -475,41 +475,42 @@ static void tty_ldisc_close(struct tty_struct *tty, struct tty_ldisc *ld)
 static void tty_ldisc_restore(struct tty_struct *tty, struct tty_ldisc *old)
 {
 	char buf[64];
 	struct tty_ldisc *new_ldisc;
 	int r;
 
 	/* There is an outstanding reference here so this is safe */
 	old = tty_ldisc_get(old->ops->num);
 	WARN_ON(IS_ERR(old));
 	tty_ldisc_assign(tty, old);
 	tty_set_termios_ldisc(tty, old->ops->num);
 	if (tty_ldisc_open(tty, old) < 0) {
 		tty_ldisc_put(old);
 		/* This driver is always present */
 		new_ldisc = tty_ldisc_get(N_TTY);
 		if (IS_ERR(new_ldisc))
 			panic("n_tty: get");
 		tty_ldisc_assign(tty, new_ldisc);
 		tty_set_termios_ldisc(tty, N_TTY);
 		r = tty_ldisc_open(tty, new_ldisc);
 		if (r < 0)
 			panic("Couldn't open N_TTY ldisc for "
 			      "%s --- error %d.",
 			      tty_name(tty, buf), r);
 	}
 }
 
 /**
  *	tty_ldisc_halt		-	shut down the line discipline
  *	@tty: tty device
  *
  *	Shut down the line discipline and work queue for this tty device.
  *	The TTY_LDISC flag being cleared ensures no further references can
  *	be obtained while the delayed work queue halt ensures that no more
  *	data is fed to the ldisc.
  *
- *	In order to wait for any existing references to complete see
- *	tty_ldisc_wait_idle.
+ *	You need to do a 'flush_scheduled_work()' (outside the ldisc_mutex)
+ *	in order to make sure any currently executing ldisc work is also
+ *	flushed.
  */
 
 static int tty_ldisc_halt(struct tty_struct *tty)
@@ -723,61 +724,64 @@ static void tty_ldisc_reinit(struct tty_struct *tty)
 void tty_ldisc_hangup(struct tty_struct *tty)
 {
 	struct tty_ldisc *ld;
 
 	/*
 	 * FIXME! What are the locking issues here? This may me overdoing
 	 * things... This question is especially important now that we've
 	 * removed the irqlock.
 	 */
 	ld = tty_ldisc_ref(tty);
 	if (ld != NULL) {
 		/* We may have no line discipline at this point */
 		if (ld->ops->flush_buffer)
 			ld->ops->flush_buffer(tty);
 		tty_driver_flush_buffer(tty);
 		if ((test_bit(TTY_DO_WRITE_WAKEUP, &tty->flags)) &&
 		    ld->ops->write_wakeup)
 			ld->ops->write_wakeup(tty);
 		if (ld->ops->hangup)
 			ld->ops->hangup(tty);
 		tty_ldisc_deref(ld);
 	}
 	/*
 	 * FIXME: Once we trust the LDISC code better we can wait here for
 	 * ldisc completion and fix the driver call race
 	 */
 	wake_up_interruptible_poll(&tty->write_wait, POLLOUT);
 	wake_up_interruptible_poll(&tty->read_wait, POLLIN);
 	/*
 	 * Shutdown the current line discipline, and reset it to
 	 * N_TTY.
 	 */
 	if (tty->driver->flags & TTY_DRIVER_RESET_TERMIOS) {
+		/* Make sure the old ldisc is quiescent */
+		tty_ldisc_halt(tty);
+		flush_scheduled_work();
+
 		/* Avoid racing set_ldisc or tty_ldisc_release */
 		mutex_lock(&tty->ldisc_mutex);
 		if (tty->ldisc) {	/* Not yet closed */
 			/* Switch back to N_TTY */
-			tty_ldisc_halt(tty);
 			tty_ldisc_reinit(tty);
 			/* At this point we have a closed ldisc and we want to
 			   reopen it. We could defer this to the next open but
 			   it means auditing a lot of other paths so this is
 			   a FIXME */
 			WARN_ON(tty_ldisc_open(tty, tty->ldisc));
 			tty_ldisc_enable(tty);
 		}
 		mutex_unlock(&tty->ldisc_mutex);
 		tty_reset_termios(tty);
 	}
 }
 
 /**
  *	tty_ldisc_setup			-	open line discipline
  *	@tty: tty being shut down
  *	@o_tty: pair tty for pty/tty pairs
  *
  *	Called during the initial open of a tty/pty pair in order to set up the
  *	line disciplines and bind them to the tty. This has no locking issues
  *	as the device isn't yet active.
  */
 
